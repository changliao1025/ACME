module unicon

! ---------------------------------------------------------- !
!                                                            !
!                 UNIFIED CONVECTION SCHEME                  !
!                                                            !
!                         ( UNICON )                         !
!                                                            ! 
!                        Developed By                        ! 
!                                                            !
!            Sungsu Park, AMP/CGD/NCAR, Boulder.             !
!                                                            !
!                         Aug.2010.                          !
!                                                            !
!  I hope my scheme can provide many people with happiness.  ! 
!  However,                                                  ! 
!                                                            !
!                      <<< WARNING >>>                       ! 
!                                                            !
!            No one is allowed to use this UNICON            !
!  without an explicit personal permission from Sungsu Park  !
!         until it is released as a open source code         !
!                 as a part of CAM6/CESM2.                   !
!                                                            !
! ---------------------------------------------------------- !

use shr_kind_mod,    only : r8 => shr_kind_r8, i4 => shr_kind_i4
use cam_history,     only : outfld, phys_decomp
use shr_spfn_mod,    only : erfc => shr_spfn_erfc
use time_manager,    only : get_nstep
use cam_abortutils,      only : endrun
use cam_logfile,     only : iulog
use constituents,    only : qmin, cnst_get_type_byind, cnst_get_ind, cnst_name
use wv_saturation,   only : qsat, findsp
#ifdef MODAL_AERO
! use modal_aero_data, only : ntot_amode, numptr_amode, nspec_amode, lmassptr_amode
use modal_aero_data
#endif

implicit none
private
save

public :: &
   unicon_init,       &
   compute_unicon,    &
   positive_moisture, &
   positive_tracer

real(r8) :: xlv       !  Latent heat of vaporization
real(r8) :: xlf       !  Latent heat of fusion
real(r8) :: xls       !  Latent heat of sublimation
real(r8) :: cp        !  Specific heat of dry air
real(r8) :: zvir      !  rh2o/rair - 1
real(r8) :: r         !  Gas constant for dry air
real(r8) :: g         !  Gravitational constant
real(r8) :: ep2       !  Mol wgt water vapor / Mol wgt dry air [ Rv = r(=Rd)/ep2 ] 
real(r8) :: p00       !  Reference pressure for exner function
real(r8) :: rovcp     !  R/cp

! -------------------------- !
!                            !
! Define Dynamic Parameters  !
!                            !
! -------------------------- !

! ---------------------------------- !
! 3 key parameters : au_base, Ro, mu !
! ---------------------------------- !

integer,  parameter :: nseg               =  1           !  Number of updraft segments [ # ]
integer,  parameter :: inorm              =  2           !  Either 1 ( force 'au_base' is preserved ) or 2 (force 'cmfu_base' is preserved) for various nseg. 
! integer,  parameter :: iprpback           =  1         !  Either 1 ( backward differencing ) or 0 ( centered differencing ) or -1 ( previous semi-analytical ) 
!                                                        !  or    -2 ( correct full analytical ) only in 'evap_prep_dn'.  
integer,  parameter :: iprd_prep          =  0           !  '-1' : Forward  Numerical,  '0' : Centered  Numerical, '1' : Backward  Numerical, '-5' : Forward Analytical
                                                         !  Mar.08.2015: The option of 'positive 5' is wrong and should not be used, because it does not account of the new in-cumulus condensate
                                                         !               generated by upward motion in the computation of precipitation production within convective updraft.
                                                         !               Recommened to use 'iprd_prep = 1' for numerical stability and consistency with 'ievp_prep = 1'.
integer,  parameter :: ievp_prep          =  0           !  '-1' : Forward  Numerical,  '0' : Centered  Numerical, '1' : Backward  Numerical
                                                         !  Mar.08.2015: Recommended to use 'ievp_prep = 1' for numerical stability as in Part II UNICON paper.
integer,  parameter :: nacc               =  1           !  Number of accretion iterations [ # ]. Can be any integer n_icc >=1. 
integer,  parameter :: niter              =  1           !  Number of whole iterations [ # ]. Should be 1 or 2.
!ainteger,  parameter :: itendency          =  0         !  If 0 ( 1 ), choose NUMerical ( ANAlytical ) tendencies for final output. Must use NUMerical ( 0 ) tendencies.
logical,  parameter :: dbsort_con         = .false.      !  If .true. (.false.), do continuous (discontinuous) downdraft buoyancy sorting. .false. is the previous default.
                                                         !  This is applied only for downdraft buoyancy sorting, not the buoyancy sorting of convective updraft that generates
                                                         !  the mixing downdraft. That is, the generation (or source) of mixing downdraft is still done by using 
                                                         !  previous default method using 'ithv_minE, mu_mix, offset_minE' specified in the below parameter sentences.
integer,  parameter :: ithv_minE          =  1           !  If 1 ( -1 ), do buoynacy sorting ( both updraft and downdraft ) using 'thv_minE' ( thvl_minE ).
real(r8), parameter :: mu_mix             =  0.5_r8      !  Minimum downdraft = 0 <= mu <= 1 = Maximum Downdraft. Due to the displacement of interface, it may be set to 1. 
                                                         !  In order to deepen PBL, we should use the largest value 1.  
                                                         !  For mixing        downdraft.
real(r8), parameter :: mu_top             =  0.5_r8      !  For top           downdraft. 
real(r8), parameter :: mu_area            =  0.5_r8      !  For area-velocity downdraft.

real(r8), parameter :: offset_minE        =  0._r8       !  Final 'thv_minE = thv_minE from mu + offset_minE'. Same for thvl_minE. [K]. Set 'offset_minE < 0' to reduce downdraft.

real(r8), parameter :: epsz_dn            =  1.5e-4_r8   !  Lateral entrainment rate of downdraft [ 1 / z ]. 5.e-5 = R:1000 [m], 1.e-4 = R:500 [m], 2.e-4 = R:250 [m]. 
real(r8), parameter :: delz_dn            =  1.5e-4_r8   !  Lateral  derainment rate of downdraft [ 1 / z ]. 5.e-4 = R:100  [m], 1.e-3 = R:50  [m], 2.e-3 = R:25  [m]. 
                                                         !  Jul.10.2011. These two are very impportant in controlling the properties of detrained airs at surface.
                                                         !  From ARM95, too small ( even 5.e-4 ) value produced too dry and cold detrained airs at surface. It seems that 
                                                         !  I should at least use 1.e-3.

real(r8), parameter :: eps_wk             =  0.e-5_r8    !  Lateral entrainment rate from non-wake to     wake area within PBL [ 1 / s ] 
real(r8), parameter :: del_wk             =  0.e-5_r8    !  Lateral  derainment rate from     wake to non-wake area within PBL [ 1 / s ]. 2.32e-4 is 3hr when awk_PBL = 0.5.
                                                         !  Previous study used 0.
                                                         !  This is valid only for below 'int_del_wk = 0'.


!og
!og
integer,  parameter :: i_budget_coldpool  =  6           !  If 0 (1, 2), use budget-inconsistent A068j ( budget consistent with M^j_U=0, budget consistent with M^j_G=0 ) cold pool formula.
                                                         !  If 3, use clevely approximately budget consistent modified from '0' option ( ** This '3' is the best ** ) 
                                                         !  If 4, budget-inconsistent A068j but with M^j_G=0 ( ** This is for sensitivity simulation for writing paper ).
                                                         !  If 5, use clevely approximately budget consistent method with with M^j_G=0 ( ** This '5' is the another best ** ) 
                                                         !  If 6, use clevely approximately, budget consistent, raw cold pool formula modified from '3' option ( ** This '6' is the best ** ) 
integer,  parameter :: i_energy_coldpool  =  1           !  If 2 (1, 0), use the full energy-consistent (partially consistent, previous default) cold pool formula.
real(r8), parameter :: eps_wk0            =  0.e-5_r8    !  Lateral entrainment rate from non-wake to     wake area within PBL [ 1 / s ]. Used only when i_energy_coldpool  =  1. 
real(r8), parameter :: del_wk0            =  0.e-5_r8    !  Lateral  derainment rate from     wake to non-wake area within PBL [ 1 / s ]. Used only when i_energy_coldpool  =  1. 
                                                         !  This must be positive to generate organized flow. 
                                                         !   5 hr = 5.56e-5,  6 hr = 4.63e-5,  7 hr = 3.97e-5,  8 hr = 3.47e-5,  9 hr = 3.09e-5, 10 hr = 2.78e-5,
                                                         !  15 hr = 1.85e-5, 20 hr = 1.39e-5, 1 day = 1.16e-5
real(r8), parameter :: b1                 =  15.0_r8     !  Multiplication factor for decorrelation time scale of meso-scale TKE. No unit.
                                                         !  This 'b1' is used only when 'i_energy_coldpool = 2' is chosen. 
!og
!og


integer, parameter  :: int_del_wk         =  0           !  If 1 (0), use internally computed 'del_wk_eff = c_del_wk * tmp1 * awk_PBL * cmf_u(kpblhm)' (specified del_wk above ), 
                                                         !  But above eps_wk is still used in any cases. 
                                                         !  Note that '0 <= c_del_wk <= 1' which is specified below. 
                                                         !  Hopely, this will have an impact to retard the diurnal cycle of convective precipitation over land.
       							 !  CAUTION : Since analytical integration is performed, not only 'del_wk_eff' but also the
       			                                 !  format of 'taui,_orgforce' should be changed together. Thus, below option of 'int_del_wk .eq. 1'
       		                                         !  is incomplete at this stage. This should be refined later.

real(r8), parameter :: c_del_wk           =  0._r8       !  When 'int_del_wk = 1' above, 'del_wk_eff = c_del_wk * tmp1 * awk_PBL * cmf_u(kpblhm)'. 
                                                         !  Note that '0 <= c_del_wk <= 1'.
                                                         !  This is valid only when int_del_wk = 1.

integer,  parameter :: icudist_tail       =  0           !  If 0 ( 1 ), use whole ( tail ) distribution for cumulus updrafts. 
                                                         !  0 : Good to simulate CIN stabilizing effect. 1 : Simulate only strong updrafts and so conceptually attractable.
                                                         !  But '1' also produces negative updraft buoyancy near cloud base. If 1, we may need to use larger Ro if sigmaR = 0.
                                                         !  In general, '1' produces non-better results, such as not to good and unstable u,v profile. Thus, recommended to use 0.
                                                         !  Feb.08.2013. I should always choose 'icudist_tail = 0' because 'inorm = 2' is only supported for icudist_tail = 0.
 
! real(r8), parameter :: au_base_min        =  0.05_r8   !  Updraft fractional area at the launching interface [ 0 - 0.5 ] when org = 0. 
! real(r8), parameter :: au_base_max        =  0.05_r8   !  Updraft fractional area at the launching interface [ 0 - 0.5 ] when org = 1.
!                                                        !  May.17.2011. In order to decrease CLDLOW in deep convective area, I may need to use 'au_base_max = 0.1' instead of
!                                                        !               'au_base_max=au_base_min'.
!                                                        !  Aug.31.2011. From the geometric point of view of wake parameterization, it seems to be reasonable to reduce 'au_base_max' when
!                                                        !               convective organization is increased, since the horizontal area occuplied by 'non-wake' ( note that convective updraft
!                                                        !               can grow only in the non-wake area ) is likely to decrease when cuorg increases. This should be implemented.
!                                                        !  Sep.07.2011. In order to be fully compatible with the true organization concept, 
!                                                        !               we may need to use the same value for au_base_min = au_base_max. 
!                                                        !  Sep.10.2011. For full compatibility with the definition of 'cuorg', it seems to be clear that 
!                                                        !               we should use au_base_min = au_base_max.  

real(r8), parameter :: au_base_min_ocn    =  0.04_r8     !  Updraft fractional area at the launching interface [ 0 - 0.5 ] when org = 0. 
real(r8), parameter :: au_base_max_ocn    =  0.04_r8     !  Updraft fractional area at the launching interface [ 0 - 0.5 ] when org = 1.
real(r8), parameter :: au_base_min_lnd    =  0.025_r8    !  Updraft fractional area at the launching interface [ 0 - 0.5 ] when org = 0. 
real(r8), parameter :: au_base_max_lnd    =  0.025_r8    !  Updraft fractional area at the launching interface [ 0 - 0.5 ] when org = 1.

integer,  parameter :: iau_base_ocn       =  1           !  If '0', use above 'au_base_min,au_base_max' in computing au_base.
                                                         !  If '1', use above 'au_base = au_base_min * ( 1._r8 - cuorg * awk_PBL_max )'. In this case only above au_base_min is used.
                                                         !  Aug.03.2012. In association with the internal computation of 'cdelta_s,cdelta_w', it is definitely reasonable to use
                                                         !               iau_base_ocn = 1 instead of 0.
integer,  parameter :: iau_base_lnd       =  1           !  If '0', use above 'au_base_min,au_base_max' in computing au_base.
                                                         !  If '1', use above 'au_base = au_base_min * ( 1._r8 - cuorg * awk_PBL_max )'. In this case only above au_base_min is used.
                                                         !  Aug.03.2012. In association with the internal computation of 'cdelta_s,cdelta_w', it is definitely reasonable to use
                                                         !               iau_base_lnd = 1 instead of 0.
! integer,  parameter :: iau_base           =  0         !  If '0', use above 'au_base_min,au_base_max' in computing au_base.
!                                                        !  If '1', use above 'au_base = au_base_min * ( 1._r8 - cuorg * awk_PBL_max )'. In this case only above au_base_min is used.

! real(r8), parameter :: au_base            =  0.05_r8   !  Updraft fractional area at the launching interface [ 0 - 0.5 ]. If cudist_tail = 0 ( 1 ), au_base = 0.1 ( 0.05 ) is good. 
!                                                        !  Choose among [ 0.01, 0.05, 0.06, 0.07, 0.08, 0.09, 0.10, 0.20, 0.30, 0.40, 0.50 ]. If need other value, add table within the program.

real(r8), parameter :: cadj_area_ocn      = 5._r8        !  The multiplication factor of 'au_base_min_ocn' : overturning adjustment associated with convective organization occurs
                                                         !  over the 'cadj_area_ocn * au_base_ocn'. It must be '1 <= cadj_area_ocn <= ( 1. / au_base_min_ocn )'.
                                                         !  If cadj_area_ocn = ( 1. / au_base_min_ocn ), overturning adjustment occurs in 'a_U' as in the original formulation.
                                                         !  Dec.19.2012. Previous use of cdelta_s_ocn = 4 is equivalent to using cadj_area_ocn = 5 if au_base_min_ocn = 0.05.
                                                         !  Apr.05.2012. If this is set to be too small (e.g., 1 or 2), the model crashes as expected.
real(r8), parameter :: cadj_area_lnd      = 5._r8        !  The multiplication factor of 'au_base_min_lnd' : overturning adjustment associated with convective organization occurs
                                                         !  over the 'cadj_area_lnd * au_base_lnd'. It must be '1 <= cadj_area_lnd <= ( 1. / au_base_min_lnd )'.
                                                         !  If cadj_area_ocn = ( 1. / au_base_min_lnd ), overturning adjustment occurs in 'a_U' as in the original formulation.
                                                         !  Dec.19.2012. Previous use of cdelta_s_lnd = 8 is equivalent to using cadj_area_lnd = 5 if au_base_min_lnd = 0.025.
                                                         !  Apr.05.2012. If this is set to be too small (e.g., 1 or 2), the model crashes as expected.
! real(r8), parameter :: cdelta_s_ocn       =  4._r8     !  Inhomogeneity parameter within 'a_U' for updraft perturbation induced by organization for conservative scslars. [ no ]. 0 <= cdelta_s.
!                                                        !  Default is 1. Valid only when above 'i_persrc = 1'. Over ocean.
!                                                        !  Aug.20.2012. From TOGAII, this value over ocean should be smaller than over land.   
! real(r8), parameter :: cdelta_w_ocn       =  1._r8     !  Inhomogeneity parameter within 'a_U' for updraft perturbation induced by organization for vertical velocity. [ no ]. 0 <= cdelta_w.
!                                                        !  Default is 1. Valid only when above 'i_persrc = 1'. Over ocean.
! real(r8), parameter :: cdelta_s_lnd       =  8._r8     !  Inhomogeneity parameter within 'a_U' for updraft perturbation induced by organization for conservative scslars. [ no ]. 0 <= cdelta_s.
!                                                        !  Default is 1. Valid only when above 'i_persrc = 1'. Over land.
!                                                        !  Aug.20.2012. From ARM97, this value over ocean should be larger than over ocean. 
! real(r8), parameter :: cdelta_w_lnd       =  1._r8     !  Inhomogeneity parameter within 'a_U' for updraft perturbation induced by organization for vertical velocity. [ no ]. 0 <= cdelta_w.
!                                                        !  Default is 1. Valid only when above 'i_persrc = 1'. Over land.

integer,  parameter :: icridis            =  1           !  If '1', use internal 'cridis = rlc * cush', but if '0', use specified 'cridis = cridis_in'.
                                                         !  In order to impose positive feedback as in uwshcu, recommend to use '1'  with the corresponding setting of 'rlc'.
                                                         !  Mar.11.2011. Since we are using multiple plume, 'cush' is meaningless and so good to use 'icridis = 0'
real(r8), parameter :: rlc                =  0.15_r8     !  Critical distance for updraft buoyancy sorting [ 0 - 1 ]. Critical distance = rlc * cush. 
                                                         !  Active only when icridis = 1. If rlc = -1._r8, use 'cridis  =  dz_m'.
                                                         !  May.16.2011. From BOMEX L30/L80, this 'rlc = -1' was clearly shown to be the source of resolution sensitivity.
                                                         !               Especially, when 'cuorg' was very small non-zero, this 'rlc = -1' showed very strange sensitivity
                                                         !               in the BOMEX L80 simulation.  
                                                         !               Thus, I MUST NOT USE 'rlc = -1.' in any case. 
                                                         !               However, in order to impose a positive feedback from shallow to deep convection ( i.e., less mixing
                                                         !               for deep convective cases ), it is good not to use 'cridis_in = 1.e8' but to use 'icridis = 1' and
                                                         !               'rlc = 0.1' etc. Thus, from May.16.2011 today, I must use 'icridis = 1 & rlc = 0.1 etc'.   
real(r8), parameter :: cridis_in          =  1.e8_r8     !  Critical distance for updraft buoyancy sorting [ m ]. Default was 1.e8. 
                                                         !  Active only when icridis = 0.
!ginteger,  parameter :: icridis_negbuoy    =  0         !  If '1' ( '0' ), specifically do ( not ) set 'cridis = 1.e8' [ m ] if updraft buoyancy is negative.
!g                                                       !  This is a parameter independent of the above 'cridis'. 
!g                                                       !  Feb.06.2013. As of today, always use icridis_negbuoy = 0 since this is more physical and remove the option.  

integer,  parameter :: i_downloading      =  0           !  If '1' ( '0' ), include ( exclude ) precipitating-condensate-loading in computing the buoyancy of convective downdraft.
                                                         !  This will help to increase downdraft vertical velocity.
                                                         !  Oct.27.2011. Restored to zero following the '016' case. 
real(r8), parameter :: vfall_rain         =  1.e1_r8     !  Fall speed of rain droplet [ m/s ]. This is used for computing (1) rain mixing ratio and (2) evaporation time scale
                                                         !  of convective rain within environment in each layer for computing tkePBLorgEV.
real(r8), parameter :: vfall_snow         =  1.e1_r8     !  Fall speed of snow droplet [ m/s ]. This is used for computing (2) snow mixing ratio and (2) evaporation time scale
                                                         !  of convective snow within environment in each layer for computing tkePBLorgEV.   

!breal(r8), parameter :: csig_w             =  2._r8     !  Additional 'csig_w   * sigma_w'   when cuorg = 1. [ no ]. 0 <= csig_w
!breal(r8), parameter :: csig_qt            =  1._r8     !  Additional 'csig_qt  * sigma_qt'  when cuorg = 1. [ no ]. 0 <= csig_qt 
!breal(r8), parameter :: csig_thl           =  1._r8     !  Additional 'csig_thl * sigma_thl' when cuorg = 1. [ no ]. 0 <= csig_thl

!binteger,  parameter :: i_persrc           =  1         !  If 1 (2,3), use explicit analytical ( Cathy's empirical, '016' ) formula to perturbe source air properties by organization.
                                                         !  I want to treat this purely with the different values of initial plume radius.
                                                         !  Sep.15.2011. Must choose '1' for using the perfect heterogeneity model within PBL.
                                                         !  Feb.06.2013. As of today, always choose i_persrc = 1 and remove this option. 

real(r8), parameter :: prepminPBLH_org    =  0.0_r8      !  Minimum precipitation flux at the PBL top height interface required for initiating convective organization [ mm/day ].
                                                         !  This corresponds to 'individual' updraft segment, not the whole mean of various updrafts.
                                                         !  This should be carefully defined not to be sensitive to the choice of 'nseg'.
                                                         !  In order to completely remove the sensitivity to nseg, this should be set to zero in principle.
                                                         !  Setting this value to be positive (regardless of how small it is) will result in the sensitivity to nseg. 
                                                         !  Feb.06.2013. Now, without having sensitivity to nseg, we can use small positive value for this with one line modification
                                                         !               in the main program. See the main program part with 'prepminPBLH_org'. 

logical,  parameter :: iorg_adv           = .true.       !  If .true. (.false.), advect (do not advect) horizontal heterogeneity information associated with organization.

logical,  parameter :: orgfeedback_off    = .false.      !  If .true. (.false.), turn-off (turn-on) convective organization. Default is .false.
                                                         !  This switch with 'false' is used for doing sensitivity simulation without convective organization feedback.

! real(r8), parameter :: con_org_tke        =  1.e0_r8   !  Coefficient converting 'downdraft + evaporation TKE' into sigma_w^2 [ no unit ]. Used only with i_persrc = 1.
! real(r8), parameter :: con_org_thl        =  1.e0_r8   !  Coefficient scaling organized thl perturbation within PBL into source air perturbation [ no unit ]. Used only with i_persrc = 1.
! real(r8), parameter :: con_org_qt         =  1.e0_r8   !  Coefficient scaling organized qt  perturbation within PBL into source air perturbation [ no unit ]. Used only with i_persrc = 1.

!cinteger,  parameter :: i_diagorg          =  1         !  If 1 ( 0 ), use diagnostically-computed ( prognostically-computed ) organization parameter.
                                                         !  Below 3 variables ( tau_org, cc1_org, cc2_org ) are valid only when i_diagorg = 0.
                                                         !  Sep.15.2011. Must choose '1' for using the perfect heterogeneity model within the PBL.
                                                         !  Feb.06.2013. As of today, always choose i_diagorg = 1 and remove this option.

real(r8), parameter :: norm_sgh           =  1.e3_r8     !  Normalization height for computing 'a_oro = sgh30 / norm_sgh' [ m ]
real(r8), parameter :: a_oro_max          =  0._r8       !  Maximally allowed forbidden area by surface orography [ fraction ]
                                                         !  Set this to be zero if I want to turn-off the orographic effect.
real(r8), parameter :: awk_PBL_min        =  0.05_r8     !  Minimum wake area used only for computing 'eps_wk_eff,del_wk_eff' to allow initial development of wake [fraction] > 0.
                                                         !  This should be set to be positive in order to allow wake development for a given set of non-zero 'eps_wk,del_wk'.
                                                         !  If we set 'eps_wk = del_wk = 0' in the parameter sentence, this does not do anything. 
                                                         !  Sep.16.2011. This should be appropriately set such that it prevents the development of weak wake but allows 
                                                         !               the development of reasonably strong wake. By doing this, we may be able to simulate diurnal cycle
                                                         !               very well - my impression is that we can control diurnal cycle by appropriately chosing 
                                                         !                   (1) 'awk_PBL_min', 
                                                         !                   (2) 'delta_thv_wc' 
                                                         !                   (3) 'sigmaR_min_lnd', 'sigmaR_max_lnd',  
                                                         !                   (4) 'au_base_max' , 'au_base_max'
                                                         !                   (5) 'iorg_detrain'
                                                         !               If awk_PBL = 0.05 ( 0.1, 0.5 ), then 'awk_PBL / ( 1 - awk_ PBL )' = 21, 11, 4. 
real(r8), parameter :: cdrag              =  1.0e-3_r8   !  Surface drag coefficient for computing damping time scale of wake within PBL [ no unit ]
                                                         !  Sep.16.2011. Since this should also reflect the neglected dffect of small entrainment flux at the PBL top
                                                         !               in the wake area due to enhanced stratification at the PBL top, we should use smaller value
                                                         !               than the typical allowed value of ~ 1.5e-3.
real(r8), parameter :: delta_thv_wc       = -0.2_r8      !  Critical thv difference between 'wake' and 'grid-mean' averaged over the PBL in order to be identified as the 'wake'. 
                                                         !  Must be negative value. [ K ]. This is a general wake selection parameter.
                                                         !  The 'wake' with thv offset less than this value ( e.g., -0.05 K ) will be identified as 'non-wake'. 
                                                         !  Sep.12.2011. Currently '-0.01' produces the best results. The '-0.05' produced too small 'cuorg' and unreasonably
                                                         !               large wake spreading velocity. Thus, let's use '-0.01'. 
real(r8), parameter :: kw_omega           =  1.414_r8    !  Control 'sigma_w = kw_omega * sqrt(tke_omega)'.
                                                         !  Sep.22.2011. Use 0.82 assuming isotropic meso-scale turbulence similar to kw.
real(r8), parameter :: kstar              =  0.08_r8     !  Compute tke_omega = kstar * tke_omega_max. In principle, 0 < kstar < 1.
                                                         !  By setting zero, we can turn-off density current parameterization on delta_w_PBL, i.e., delta_w_PBL = 0.
                                                         !  Oct.27.2011. Set to the kstar = 1 instead of 0.5.
                                                         !  Aug.03.2012. In association with the internally computed 'cdelta_s,cdelta_w', I can use more 
                                                         !               reasonably smaller values ( 0.05, 0.1 or 0.2 ) for kstar.  
! real(r8), parameter :: wake_ratio         =  2.0_r8    !  The ratio of area fraction between non-wake area and wake areas ( = ( 1 - aw ) / aw ) [ no unit ]. 
!                                                        !  This controls vertical velocity perturbation of convective updraft at surface due to convective organization.
!                                                        !  Aug.31.2011. Potentially and conceptually, wake_ratio may be related with cuorg since we can approximate aw = cuorg in geometrically.
!                                                        !               This aspect can be explored later.
!                                                        !  Sep.07.2011. Now this wake_ratio is fully internally computed.

!dreal(r8), parameter :: cc1_org            =  2.e0_r8   !  Coefficient of organization forcing 1. Originally 2._r8.
!dreal(r8), parameter :: cc2_org            =  0._r8     !  Coefficient of organization forcing 2
!dreal(r8), parameter :: cc3_org            =  0._r8     !  Coefficient of organization forcing 3
!dreal(r8), parameter :: w0_org             =  0.5_r8    !  Master velocity scale for convective organization [ m / s ] 

! real(r8), parameter :: tau_org            =  10800._r8 !  Damping ( e-folding ) time scale of convective organization [ sec ] 
! real(r8), parameter :: cc0_org            =  5._r8     !  Conversion constant for time-scale of convective organization : tau_org = cc0_org * ( pblh / w_org ). 
!                                                        !  Same role as b1 = 5.8 in the CAM5 moist PBL scheme [ no unit ]
!dreal(r8), parameter :: ASRG               =  0._r8     !  Control the modification of downdraft properties at surface during horizontal displacement. 
                                                         !  Aspect Ratio of convective gust front within PBL. 
                                                         !  1 < ASRG ~ horizontal scale of convective downdraft (~pblh) / vertical scale of gust front within pblh < 10. No unit.

!dreal(r8), parameter :: b1                 =  5.8_r8    !  Multiplication factor for decorrelation time scale of meso-scale TKE. No unit.

!dreal(r8), parameter :: a_d_sfcTKEorg      =  0.025_r8  !  Norminal downdraft fractional area at surface to compute localized TKE by convective organization at sfc. [ 0 <  < 1 ]. I used 0.01.

! integer,  parameter :: iorgforce          =  3         !  Choose 'orgforce' : from '1' to '8'. The best default is '3'.   
!                                                        !  This is valid only when i_diagorg = 0.
!einteger,  parameter :: iorg_src           =  0         !  If '1'('0'), use (not use) the detrained downdraft airs from previous time step as the updraft source air properties.
                                                         !  Sep.15.2011. Must be set to '0' to use the perfect heterogeneity PBL model. 
                                                         !  Feb.06.2013. As of today, always use iorg_src = 0 and remove this and related options.
integer,  parameter :: iorg_ent           =  1           !  If '1', use the detrained airs from previous time step as part of environmental airs for lateral mixing.
                                                         !  If '0', use the mean environmental airs at the current time step for lateral mixing.
integer,  parameter :: iorg_detrain       =  1           !  Choose the detrained airs that will be used for organized entrainment at the next time step. Default was 1.
                                                         !  This switch is active only when the above 'iorg_ent = 1'.
                                                         !  '1' : Detrained Updraft + Detrained Downdraft
                                                         !  '2' : Detrained Updraft
                                                         !  '3' : Detrained Downdraft
                                                         !  '4' : Updraft
                                                         !  '5' : Detrained Updraft + Detrained Downdraft + Updraft
                                                         !  '6' : Detrained Updraft +                       Updraft
                                                         !  '7' : Detrained Downdraft +                     Updraft

! integer,  parameter :: i_detrain          =  0         !  If '0' : Convectively detrained air contains mixing environmental airs (previous old). This cause inconsistency between 
!                                                        !           flux-convergence and subsidence-detrainment formula. No. I should use 'i_detrain = 0'.
!                                                        !  If '1' : Convectively detrained air is defined only using convective updraft (not with mixing environmental air) and 
!                                                        !           convective downdraft airs. 
!                                                        !           This impose a full constency between 'flux-convergence' and 'subsidence-detrainment' formula.
!                                                        !           It is highly recommended to use '1'. No. I should use 'i_detrain = 0'. 

!ereal(r8), parameter :: fac_org_src        =  0._r8     !  Scale factor for computing 'org_src = cuorg * fac_org_src'. After this, we impose limits [0,1] on org_src.
                                                         !  Active only when iorg_src = '1'.
real(r8), parameter :: fac_org_ent        =  1._r8       !  Scale factor for computing 'org_ent = cuorg * fac_org_ent'. After this, we impose limits [0,1] on org_ent.
                                                         !  Active only when iorg_ent = '1'.
real(r8), parameter :: fac_org_rad        =  1._r8       !  Scale factor for computing 'org_rad = cuorg * fac_org_rad'. After this, we impose limits [0,1] on org_rad.

real(r8), parameter :: orp                =  1._r8       !  Power for the plume radius associated with organization. 0 < orp.
                                                         !  If orp = 1 (0.5, 2), R is a linear (square root, square) function of organization. In order to reduce SWCF over the
                                                         !  Panama, I strongly recommend to use 'orp' smaller than 1, e.g., 0.5. 
                                                         !  Apr.01.2013. If 'orp = -1', use 'sinusoidal' function.
! Aug.15.2011. I added a functionality to specify different values over the ocean and land. This is designed to simulate strongly organized
!              convective activity over the land ( and so diurnal cycle ) where simulated organization is usually much smaller than the
!              organization over the ocean. Note that 'oce-ice' are grouped into the same category. 

real(r8), parameter :: Ro_min_ocn         =  100._r8     !  Minimum intercept updraft plume radius at surface at alpha = 0 [ m ]
                                                         !  This is a default value when org_Rad = 0. 
                                                         !  May.21.2011 : We may use slightly a large value in future.
real(r8), parameter :: Ro_max_ocn         = 4000._r8     !  Maximum intercept updraft plume radius at surface at alpha = 0 [ m ]
                                                         !  This is a default value when org_Rad = 1.
                                                         !  May.21.2011 : We may use slightly a large value in future.
real(r8), parameter :: sigmaR_min_ocn     =   50._r8     !  Standard deviation of updraft plume radius ( -infinity < alpha < infinity ) at surface [ m ]
                                                         !  This is a default value when org_Rad = 0.
                                                         !  May.21.2011 : We may use slightly a large value in future.
real(r8), parameter :: sigmaR_max_ocn     =   50._r8     !  Standard deviation of updraft plume radius ( -infinity < alpha < infinity ) at surface [ m ]
                                                         !  This is a default value when org_Rad = 1.

real(r8), parameter :: Ro_min_lnd         =  100._r8     !  Minimum intercept updraft plume radius at surface at alpha = 0 [ m ]
                                                         !  This is a default value when org_Rad = 0. 
                                                         !  May.21.2011 : We may use slightly a large value in future.
real(r8), parameter :: Ro_max_lnd         =10000._r8     !  Maximum intercept updraft plume radius at surface at alpha = 0 [ m ]
                                                         !  This is a default value when org_Rad = 1.
                                                         !  May.21.2011 : We may use slightly a large value in future.
real(r8), parameter :: sigmaR_min_lnd     =   50._r8     !  Standard deviation of updraft plume radius ( -infinity < alpha < infinity ) at surface [ m ]
                                                         !  This is a default value when org_Rad = 0.
                                                         !  May.21.2011 : We may use slightly a large value in future.
real(r8), parameter :: sigmaR_max_lnd     =   50._r8     !  Standard deviation of updraft plume radius ( -infinity < alpha < infinity ) at surface [ m ]
                                                         !  This is a default value when org_Rad = 1.
                                                         !  Aug.15.2011. Only this parameter is doubled compared to the ocean to compensate for the
                                                         !               relative small value of convective organization over the land. 

real(r8), parameter :: Ro_eps0            =  25._r8      !  Minimum updraft plume for computing mixing rate eps0 [ m ]. Originally 10 [ m ].
                                                         !  Aug.15.2011. Originally 10 but relaxed to 100 following 008a.
!?real(r8), parameter :: eta1               =  1.0_r8    !  Factor controlling 'precipitation residence time * ovc(a_p,a_d)/a_d' ( [ 0 (zero) - 1 (maximum residence) ]
real(r8), parameter :: eta2               =  0.17_r8     !  Frac. of convective precipitation evaporated within downdraft (=ovc(a_p,a_d)/a_p) [ 0 (zero) - 1 (whole precipitation flux) ]
                                                         !  In order to allow evaporation within environment, good to use eta2 < 1. Recommend to use eta2 = 0.5 if specified.
                                                         !  Feb.08.2013. Since precipitation area is not necessarily coinciding with downdraft area (=ovc(a_p,a_d)/a_p), this value
                                                         !               should be smaller than 1. For example, eta2 = 0.5 seems to be more reasonable choice that 0.99.   
                                                         !  Apr.05.2013. Larger 'eta2' reduce MJO noise but increases PREH2O.
!?integer,  parameter :: i_ovp              =  1         !  If '1', use explicit macrophysics vertical overlap structure as a function of vertical wind shear ( with 'zscale_evap' below )
                                                         !  If '0', use simplified maximum-minimum overlap parameter ( with 'beta1' below )
                                                         !  Feb.06.2013. As of today, I will only use i_ovp = 1 and remove the option.   
!oreal(r8), parameter :: zscale_evap        =  1.e3_r8   !  E-folding length scale of convective precipitation by overall evaporation used for vertical overlap of convective updraft [ m ]
                                                         !  Valid only when 'i_ovp = 1' is chosen.                            
                                                         !  Feb.06.2013. Since I will only use i_ovp = 1, this is not necessary any more. 
                                                         !  Feb.10.2013. Still need this until exaplcit macrophysical structure is resolved in future by using individual precipitation segments.
!?real(r8), parameter :: beta1              =  1.0_r8    !  Tilting parameter of convective updraft plume with height [ 0 (minimum tilting) - 1 (maximum tilting) ]
                                                         !  Valid only when 'i_ovp = 0' is chosen.                             
                                                         !  This control overlappings between 'precipitation area' and 'updraft area'.
real(r8), parameter :: beta2              =  1.0_r8      !  Tilting parameter of convective updraft plume with height [ 0 (minimum tilting) - 1 (maximum tilting) ]
                                                         !  This control overlappings between 'evaporation ( or precipitation ) area' and 'wake area'.
                                                         !  Sep.13.2011. In principle, we can ( should ) set 'beta1 = beta2' since the same physical process is 
                                                         !               controlling both 'beta1' and 'beta2'.
                                                         !               In future, we can set this as a function of low-level wind shear.
                                                         !  Apr.25.2012. This is nothing to do with the choice of 'i_ovp' above. Only 'beta1' is related to 'i_ovp = 0'.

real(r8), parameter :: beta2_st           =  0.0_r8      !  Same as the above 'beta2' but for the stratiform precipitation part.
                                                         !  Aug.08.2013. Overlapping parameter between 'stratiform evaporation area' and 'cold-pool area'
                                                         !               0 (random overpap) <= beta2_st <= 1 (maximum overlap)

real(r8), parameter :: sigma_wo           =  0.0_r8      !  Background value as 'sigma_w = sigma_wo + kw * sqrt(tkes)'. Should be small positive value. > 0.
                                                         !  Oct.16.2011. This is designed to improve the timing of diurnal cycle of precipitation. 
                                                         !               For obtaining the desirable effect, this should be accompanied by the use of smaller kw.    


! Nov.18.2013. Comment-out below 4 lines since we are using internally computed 'kw_internal'.
real(r8), parameter :: kw_min_ocn         =  0.4_r8      !  Control 'sigma_w = sigma_wo + kw * sqrt(tkes)' when org = 0 over ocean.
real(r8), parameter :: kw_max_ocn         =  0.4_r8      !  Control 'sigma_w = sigma_wo + kw * sqrt(tke1)' when org = 1 over ocean.
real(r8), parameter :: kw_min_lnd         =  0.4_r8      !  Control 'sigma_w = sigma_wo + kw * sqrt(tkes)' when org = 0 over land.
real(r8), parameter :: kw_max_lnd         =  0.4_r8      !  Control 'sigma_w = sigma_wo + kw * sqrt(tke1)' when org = 1 over land.

! real(r8), parameter :: kw_min             =  0.3_r8    !  Control 'sigma_w = sigma_wo + kw * sqrt(tkes)' when org = 0. Previous 0.82.
!                                                        !  Aug.15.2011. Originally 0.3 but increased to 0.8165 assuming symmetric turbulences similar to 008a.
! real(r8), parameter :: kw_max             =  0.3_r8    !  Control 'sigma_w = sigma_wo + kw * sqrt(tke1)' when org = 1. Previous 0.82.
!                                                        !  May.16.2011. Increasing 'kw_max' ( this also automatically includes decreasing 'sigma_thl, sigma_qt',sigma_u,sigma_v' )
!                                                        !               helps to decrease CLDLOW in the deep convective regime, but concurrent reduction of 'sigma_qt' is not desirable.
!                                                        !               This, in order to obtain the two effects of 'increased kw' and 'increased sigma_qt', I additionally added
!                                                        !               'kw_org' and 'sigma_qt_org' as explained below.
!                                                        !  Aug.15.2011. Originally 0.3 but increased to 0.8165 assuming symmetric turbulences similar to 008a.   
!                                                        !  Aug.31.2011. From the geometric point of view of wake parameterization, it seems to be reasonable to set 'kw_max=kw_min' since the 
!                                                        !               expected effects of reducing kx_max ( i.e, reduce updraft mass flux at surface ) can be more reasonably obtained by
!                                                        !               reducing au_base_max. This should be implemented.
!                                                        !               Reducing 'kw_max' compared to 'kw_min' does not make any physical sence. 
!                                                        !               In addition, reduction of 'kw_max' will increase 'sigme_thl(qt.u.v)' which is
!                                                        !               likely to be unreasonable double counting since by introducing 'delta_thv(qt,u,v,w,tr)_PBL', we already obtained the
!                                                        !               desirable change of conservative scalars at surface. Thus, we must set kw_max = kw_min. 
!                                                        !  May.17.2012. Define separately over land and ocean, similar to sigmaR.
!                                                        !               However, conceptually this kw is only for non-organized flow, so that 'min' and 'max'
!                                                        !               separation is meaningless. However, let's keep diverse functionality for the time being and clean later. 
!                                                        !               These new definitions are defined separately above.                      

! real(r8), parameter :: kw                 =  0.82_r8   !  Control 'sigma_w = sigma_wo + kw * sqrt(tke1)' or 'sigma_w = sigma_wo + kw(=0.2) * wstar2' [ no unit ]
!                                                        !  When 'sigma_w = kw * sqrt(tke1)' is used, kw = 'sqrt(2/5)=0.6325', 'sqrt(2/3)=0.8165', and '1' are
!                                                        !  the 3 possible choices we can make. The sqrt(2/3) assumes symmetric turbulences.
!                                                        !  In this case, theoretical maximum value of kw = sqrt(2) = 1.4142.  
!                                                        !  Mar.11.2011. I included an option not to use 'kw' anymore - it is fully internally computed now !.
!                                                        !  TOGAII suggests that we should use large value ( ~ '1' when tke1 is used ) for smooth simulation.

real(r8), parameter :: PGFc_up            =  0.9_r8      !  Effect of horizontal PGF on the vertical change of   updraft horizonal momentum [ 0 - 1 ]
real(r8), parameter :: PGFc_dn            =  0.9_r8      !  Effect of horizontal PGF on the vertical change of downdraft horizonal momentum [ 0 - 1 ]

!hinteger,  parameter :: microcu            =  1         !  If '0' ( '1', '2' ), use uwshcu ( 'centered uwshcu+ZM combination', 'sub-stepped uwshcu+ZM combination' ) microphysics.
                                                         !  On Jun.13.2012, microcu = 2 is not stable, producing weird results. 
integer,  parameter :: mclimit            =  1           !  If '1' ( '0' ), impose (not impose ) 'ql + qi > criqc' at the top interface after precipitation fall-out.
                                                         !  This is only valid when microcu = 1 above.
!hinteger,  parameter :: nsub_dia           =  2         !  Nomber of sub-stepping for updraft convective microphysics designed to reduce sensitivity to vertical resolution ( >= 1 ). 
                                                         !  This is valid only when 'microcu = 2' is chosen. 
                                                         !  Note that I have not implemented sub-stepping for evaporation within downdraft due to the expected 
                                                         !  increase of computation time ( 2*k downdraft for each convective updraft ) but it can be implemented in future.


real(r8), parameter :: caer               =  0.18_r8     !  Wet scavenging efficiency of aerosols within convective updraft [ no unit or fraction ] ( 0 < caer < 1 ).
 
! real(r8), parameter :: criqc              =  9.0e-4_r8 !  Critical in-cumulus LWC for the formation of precipitation [ kg / kg ]. UWShCu used 7.e-4.    
!                                                        !  Active when microcu = 0 or 1
real(r8), parameter :: criqc_lnd          =  6.0e-4_r8   !  Critical in-cumulus LWC for the formation of precipitation over land  [ kg / kg ]. UWShCu used 7.e-4.    
                                                         !  Active when microcu = 0 or 1
                                                         !  Apr.11.2012. Land-Sea contrast is added to consider aerosol effects. 
                                                         !  From ARM97, this value over land is definitely smaller than over ocean. 
real(r8), parameter :: criqc_ocn          =  6.0e-4_r8   !  Critical in-cumulus LWC for the formation of precipitation over ocean [ kg / kg ]. UWShCu used 7.e-4.    
                                                         !  Active when microcu = 0 or 1
                                                         !  Apr.11.2012. Land-Sea contrast is added to consider aerosol effects. 
                                                         !  From TOGAII, this value over ocean is definitely larger than over land. 
real(r8), parameter :: c0_ac_lnd          =  2.0e-3_r8   !  Auto-conversion efficiency of cloud liquid ( ice ) to rain ( snow ) over land.  Unit is [1/m].
                                                         !  In CAM5.1, c0_ac = 0.0059 ( LAND ) and 0.0450 ( OCEAN ) in unit of [1/m].   
real(r8), parameter :: c0_ac_ocn          =  4.0e-3_r8   !  Auto-conversion efficiency of cloud liquid ( ice ) to rain ( snow ) over ocean. Unit is [1/m].
                                                         !  In CAM5.1, c0_ac = 0.0059 ( LAND ) and 0.0450 ( OCEAN ) in unit of [1/m]. 

! real(r8), parameter :: kevp_rain_dn       =  2.e-5_r8  !  Evaporation efficiency of rain flux within downdraft [ ( kg m^-2 s^-1 )^(-1/2) s^-1 ]. UWShCu used 1.e-6.
! real(r8), parameter :: kevp_snow_dn       =  2.e-5_r8  !  Evaporation efficiency of snow flux within downdraft [ ( kg m^-2 s^-1 )^(-1/2) s^-1 ]. UWShCu used 1.e-6.
!                                                        !  Jul.12.2011. Test using ARM95 showed that this 'kevp_rain = 2.e-5' only produced downdraft RH of 
!                                                        !  only around of 70-80 % even when epsz_dn = delz_dn = 5.e-3. In order to increase positive moisture
!                                                        !  perturbations of detrained downdraft airs at surface, I should increase this a lot from 2.e-5.
!                                                        !  The use of '2.e-4' nearly maintained the desired saturation state ( 90-100% RH ) of convective downdraft.

! real(r8), parameter :: kevp_rain          =  2.e-5_r8  !  Evaporation efficiency of rain flux within environment [ ( kg m^-2 s^-1 )^(-1/2) s^-1 ]. UWShCu used 1.e-6.
! real(r8), parameter :: kevp_snow          =  2.e-5_r8  !  Evaporation efficiency of snow flux within environment [ ( kg m^-2 s^-1 )^(-1/2) s^-1 ]. UWShCu used 1.e-6.

real(r8), parameter :: kevp_rain_dn_lnd   =  3.0e-5_r8   !  Evaporation efficiency of rain flux within downdraft over land [ ( kg m^-2 s^-1 )^(-1/2) s^-1 ]. UWShCu used 1.e-6.
real(r8), parameter :: kevp_snow_dn_lnd   =  3.0e-5_r8   !  Evaporation efficiency of snow flux within downdraft over land [ ( kg m^-2 s^-1 )^(-1/2) s^-1 ]. UWShCu used 1.e-6.
real(r8), parameter :: kevp_rain_lnd      =  3.0e-5_r8   !  Evaporation efficiency of rain flux within environment over land [ ( kg m^-2 s^-1 )^(-1/2) s^-1 ]. UWShCu used 1.e-6.
real(r8), parameter :: kevp_snow_lnd      =  3.0e-5_r8   !  Evaporation efficiency of snow flux within environment over land [ ( kg m^-2 s^-1 )^(-1/2) s^-1 ]. UWShCu used 1.e-6.

real(r8), parameter :: kevp_rain_dn_ocn   =  3.0e-5_r8   !  Evaporation efficiency of rain flux within downdraft over ocean [ ( kg m^-2 s^-1 )^(-1/2) s^-1 ]. UWShCu used 1.e-6.
real(r8), parameter :: kevp_snow_dn_ocn   =  3.0e-5_r8   !  Evaporation efficiency of snow flux within downdraft over ocean [ ( kg m^-2 s^-1 )^(-1/2) s^-1 ]. UWShCu used 1.e-6.
real(r8), parameter :: kevp_rain_ocn      =  3.0e-5_r8   !  Evaporation efficiency of rain flux within environment over ocean [ ( kg m^-2 s^-1 )^(-1/2) s^-1 ]. UWShCu used 1.e-6.
real(r8), parameter :: kevp_snow_ocn      =  3.0e-5_r8   !  Evaporation efficiency of snow flux within environment over ocean [ ( kg m^-2 s^-1 )^(-1/2) s^-1 ]. UWShCu used 1.e-6.

real(r8), parameter :: c0                 =  0.2_r8      !  For fractional mixing rate of eps0 when inverse-R formula is used [ no unit ]
integer,  parameter :: i_eps0             =  1           !  Parameter for eps0 : 
                                                         !    '0' : The original ramped eps0 as a function of ql_u + qi_u. 
                                                         !    '1' : Evaporative enhancement of mixing as a function of 'ql_u + qi_u' and 'rh_eg'.
                                                         !    '2' : The full eps0 = c0 / R / eeps following laboratory experiment.
real(r8), parameter :: cevpeps0           =  1.0_r8      !  Evaporative enhancement of mixing. This is valid if i_eps0 = 0 or 1 [ no unit ] 
                                                         !  If 'i_eps0 = 0' : 1 /  3 /  5 (  1 maybe optimum )
                                                         !  If 'i_eps0 = 1' : 5 / 10 / 15 ( 10 maybe optimum )  

! real(r8), parameter :: qc_c0              =  3.e-4_r8  !  Ramping in-cumulus LWC+IWC for fractional mixing rate of eps0 when inverse-R formula is used [ kg/kg ]
!                                                        !  This is valid only when 'i_eps0 = 0'.
                                                         !  Mar.30.2012. Not used any more.  

! real(r8), parameter :: cm                 =  7.0_r8    !  For fractional mixing rate of eps0 when UW formula is used [ no unit ]

integer,  parameter :: i_dnmixing         =  0           !  If '0' ( '1', '2', '3' ), convective downdraft is mixed with mean environmental air ( 
                                                         ! '1' : detrained airs at the previous time step, 
                                                         ! '2' : updraft at the same current time step, 
                                                         ! '3' : below PBL top, mix with 'wake' airs but above PBL top, mix with
                                                         !  the same mixing environmental airs as convective updraft ). 
                                                         !  Aug.31.2011. In association with wake parameterization, I added '3' option. 
                                                         !               However, it does not consider the amount of available mixing environmental
                                                         !               airs and 'wake' airs in computation. This is approximation but 
                                                         !               this '3' is probably the most realistic approach even though it involves
                                                         !               an inevitable approximation. 
                                                         !  Nov.15.2011. In addition, only some downdrafts falls into wake area. Thus, it is good to
                                                         !               use i_dnmixing = 0.
                                                         !  Sep.15.2011. Recommend to use '0', i.e., mean environmental airs for convective downdraft as opposed to convective updraft.

!?integer,  parameter :: i_evpdown          =  0         !  If '0' ( '1' ), use 'numerical discrete evaporation' ( 'analytical continuous evaporation' ) within convective downdraft.  
                                                         !  Apr.18.2012. In order to prevent generation of LWC at the base interface by over-evaporation of precipitation,
                                                         !               I should use i_evpdown = 0 until the option of i_evpdown = 1 is fully stabilized.  
                                                         !  Jun.13.2012. Now 'i_evpdown = 1' is fully stablized and we should use this option.
                                                         !  Feb.06.2013. As of today, I will always use i_evpdown = 0, so that remove this option.
!pinteger,  parameter :: idt_evpd           =  1         !  If '0' ( '1', '2' ), use 'dt_evpd = dt' ( 'dt_evpd = dz / max( 0.5_r8 * ( w_db_ori + w_dt ), wdmin )', 'dt_evpd = dz / wd_evpd ) 
                                                         !  as evaporation time scale within convective downdraft. We must choose appropriate one for (1)
                                                         !  reducing the sensitivity to vertical resolution, and (2) obtaining reasonable deep convective
                                                         !  activity with reasonable diurnal cycle of convective precipitation. 
                                                         !  May.22.2011. Comparing with diabatic forcing for convective updraft and from the criteria of
                                                         !               resolution-insensitive 'S_d(thl),S_d(qt)', it is definitely clear that
                                                         !               I must use 'idt_evpd = 1' in order to remove the sensitivity to vertical resolution. 
                                                         !  Sep.15.2011. strongly recommend to use '1' for full conceptual-physical consistency.
                                                         !  Apr.10.2012. Add 'idt_evpd = 2' option.
                                                         !  Jun.13.2012. This is valid only when i_evpdown = 0.  

!xreal(r8), parameter :: wd_evpd            =  0.5_r8    !  Downdraft vertical velocity for computing evaporation of precipitation within convective downdraft.
                                                         !  This is valid only when idt_evpd = 2 is chosen above.
                                                         !  Jun.13.2012. This is valid only when i_evpdown = 0.  
                                                         !  Mar.17.2013. Activate this and evaporation within downdraft is done by this not by computed w_db.
                                                         !               This is because small value of internally computed 'wd' was the model sensitivity to vertical resolution.

real(r8), parameter :: rbuoy_min          =  0.33_r8     !  Minimum Buoyancy coefficient [ no unit ]. Default was 0.37.
                                                         !  Aug.18.2011. Originally it was 0.33 but restored to 0.37 based on my previous LES analysis. 
real(r8), parameter :: rbuoy_max          =  1.00_r8     !  Maximum Buoyancy coefficient [ no unit ]. Default was 0.37.
                                                         !  Aug.18.2011. Originally it was 1 but restored to the value of 0.37 same as rbuoy_min. 
                                                         !  This is for enhancing vertical velocity perturbation when org is developed, so that deep convection is well developed.
                                                         !  It might be important to use the same value for rbuoy_min and rbuoy_max to obtain the effect of reasonable org.     
real(r8), parameter :: rdrag              =  2.0_r8      !  Drag coefficient [ no unit ]
real(r8), parameter :: rjet               =  0.0_r8      !  Jet coefficient associated with detrainment [ 0 - 1, no unit ]. 0 : No jet effect, 1 : Maximum jet effect. 
! real(r8), parameter :: R_buomin           =  500._r8   !  Updraft plume radius when rbuoy = rbuoy_min [ m ]. Simply set as 'R_buomin = Ro_min ( = Ro_max ) + 2*sigmaR_max' [ m ].
!                                                        !  Aug.21.2011. By using 'rbuoy_min = rbuoy_max', this parameter does not do anything. This is good since I remove 
!                                                        !  one uncertain parameter.  
! real(r8), parameter :: R_buomax           =  0._r8     !  Updraft plume radius when rbuoy = rbuoy_max [ m ]. Simply set as 'R_buomax = Ro_min ( = Ro_max ) + 2*sigmaR_min' [ m ].
!                                                        !  May.21.2011 : We may use slightly a large value in future in consistent with Ro_min, Ro_max, sigmaR_min.
!                                                        !  Aug.21.2011. By using 'rbuoy_min = rbuoy_max', this parameter does not do anything. This is good since I remove 
!                                                        !  one uncertain parameter.  
!                                                        !  Oct.17.2011. Increase from 100 to 200 in order to handle the case of large Ro_min = 200.
real(r8), parameter :: R_buo              = 200._r8      !  Scaling updraft plume radius where 0 < a(R)=0.5786 <=1.
                                                         !  Mar.27.2012. This is added on this day.
real(r8), parameter :: xc_min             =  0._r8       !  Minimum critical mixing fraction from the buoyancy sorting. 
                                                         !  Oct.16.2011. This must be set to be a very small positive value when i_eps0 = 1 is chosen. 1.e-3_r8. [ 0-1 ].
                                                         !  Aug.18.2011. Originally it was 0.15 but is reduced down to 0.1. In principle, I can use any positive value even small.
real(r8), parameter :: xc_max             =  1._r8       !  Maximum critical mixing fraction from the buoyancy sorting. Default = 1 [ 0-1 ].
                                                         !  Aug.18.2011. Originally 0.85 but restored to 1.0 to remove any unclear limitation.

! real(r8), parameter :: droprad_liq_LZ     =  10.e-6_r8 !  Effectie droplet radius of detrained liquid at  low level below 700 hPa. [ m ]  
! real(r8), parameter :: droprad_liq_HZ     =   8.e-6_r8 !  Effectie droplet radius of detrained liquid at high level above 400 hPa. [ m ] 
! real(r8), parameter :: droprad_ice_LZ     =  50.e-6_r8 !  Effectie droplet radius of detrained    ice at  low level below 700 hPa. [ m ]
! real(r8), parameter :: droprad_ice_HZ     =  25.e-6_r8 !  Effectie droplet radius of detrained    ice at high level above 400 hPa. [ m ]

real(r8), parameter :: droprad_liq_lnd     =   6.e-6_r8   !  Effectie droplet radius of detrained liquid [ m ]  
real(r8), parameter :: droprad_ice_lnd     =  50.e-6_r8   !  Effectie droplet radius of detrained    ice [ m ]

real(r8), parameter :: droprad_rain_lnd    =   6.e-6_r8   !  Effectie droplet radius of rain [ m ]  
real(r8), parameter :: droprad_snow_lnd    =  50.e-6_r8   !  Effectie droplet radius of snow [ m ]

real(r8), parameter :: droprad_liq_ocn     =   9.e-6_r8   !  Effectie droplet radius of detrained liquid [ m ]  
real(r8), parameter :: droprad_ice_ocn     =  50.e-6_r8   !  Effectie droplet radius of detrained    ice [ m ]

real(r8), parameter :: droprad_rain_ocn    =   9.e-6_r8   !  Effectie droplet radius of rain [ m ]  
real(r8), parameter :: droprad_snow_ocn    =  50.e-6_r8   !  Effectie droplet radius of snow [ m ]

real(r8), parameter :: density_liq        =  997._r8     !  Density of cloud liquid droplets [ kg/m3 ]  
real(r8), parameter :: density_ice        =  500._r8     !  Density of cloud ice    crystals [ kg/m3 ]

real(r8), parameter :: density_rain       =  1000._r8    !  Density of rain [ kg/m3 ]  
real(r8), parameter :: density_snow       =  250._r8     !  Density of snow [ kg/m3 ]

! real(r8), parameter :: fmix_max           =  2._r8     !  Upper limit of fmix for convective updraft and downdraft. Positive equal or larger than 1 [ no unit ]
                                                         !  Aug.18.2011. Originally, this was 2. By using one additional limiting coonstraint on eps0(m), this
                                                         !  parameter is hopely likely to be unnecessary. So, I increased this limit to 2.e8 which virtually does 
                                                         !  not do anything in the actual model computation.
                                                         !  Oct.27.2011. Restored to the oririnal value to prevent any unreasonable model behavior. This may be
                                                         !               the source of model crash due to unreasonable aerosol for some global CAM5 cases.   
                                                         !  Jan.31.2013. This 'fmix_max' is not used any more if we choose 'exp_cmf = 1' with a new treatment
                                                         !               of constraining 'eps0(m), eps_dn, del_dn' made on this day. 
! real(r8), parameter :: fmix_frac          =  2.3026_r8 !  The maximum fraction of total amount of environmental airs involved in the updraft buoyancy sorting 
                                                         !  during dt compared to dp0(k) in each layer [ 0 - 1].
                                                         !  By imposing this constraint, the above 'fmix_max' seems not be necessary anymore.
                                                         !  Note that instead of using 0.9, I am using 0.5 to impose a more strict constraint mimicking original 
                                                         !  fmix_max = 2 effect also. 
                                                         !  Aug.14.2012. This value should be set close to 1 (e.g., 0.9) not 0.5 in order to ensure the use of physically computed eps0(m)
                                                         !  with a minimal correction. It is set to 0.9.
                                                         !  Jan.30.2013. With a new formulation on this day, this fmix_frac is set to ln(10) = 2.3026, which forces
                                                         !               ' 0.1 < Mu(p+dp)/Mu(p), Md(p+dp)/Md(p) < 10.0 '                                               
                                                         !               between any two level than convective updraft/downdraft move.                                              

                                                         !  Nov.18.2013. Still crash with a new energy-conserving cold pool formula with del_wk0 = (10 hr)^(-1) and b1 = 10.
                                                         !               So, add and change to ln(5) = 1.6094, ln(3) = 1.0986, ln(2) = 0.6931. 
real(r8), parameter :: epsz0_max          =  0.05_r8     !  Maximum effective mixing rate allowed: (M(p+dp)/M(p)-1)/dp = (exp(eps0*dp)-1)/dp <= (epsz0_max/rho/g) [1/m].
                                                         !  Note that this has a unit of [1/m] not [1/Pa] since I should use 'densitiy' in the main body.                    
                                                         !  This is added on Nov.18.2013, replacing the above fmix_frac.
                                                         !  This value is computed by using the following formula of 
                                                         !             epsz0_max [1/m] ~ 0.5 / Ro_minimum [m] 
                                                         !  This may be potentially associated with 'Ro_eps0' but let's use 'epsz0_max' separately.   
                                                         !  This is consistently applied both for convective updraft and downdraft, preventing the mass flux from 
                                                         !  hugely increasing during vertical displacement in any layer.
integer,  parameter :: exp_cmf            =  1           !  If 1 (2,3), do original exponential ( simplified linear, combination ) computation of vertical variation of cmf_u and cmf_d.
                                                         !  If this is set to 2, above 'fmix_max, fmix_frac' are not used.
                                                         !  This linear option is critical important in the coarse resolution simulation to prevent unreasonably large
                                                         !  exponential growth of mass flux and so model crash. This inevitably induces inconsistency with the 
                                                         !  corresponding computation of 'thl,qt,u,v,q' and 'w' (so that affect vertical evolution of plume radius R),
                                                         !  but in order to use physically reasonable single 'eps0' in all the vertical prognostic equations with stable state,
                                                         !  the use of this linear option is very important. 
                                                         !  Jan.30.2013. With a new formulation on this day on imposing 'eps0(m), eps_dn, del_dn' with fmix_frac = ln(10) = 2.3026, 
                                                         !               I 'must' use exp_cmf = 1 ( full physical exponential function ) for full physical consistency of the model.
                                                         !  Feb.06.2013. Always choose 'exp_cmf = 1' and removes this option.
real(r8), parameter :: alpha_max          =  2._r8       !  Upper limit of mixing parameter of updraft mass flux PDF [ no unit ]
real(r8), parameter :: cmfmin             =  1.e-5_r8    !  Minimum updraft mass flux for identification as the non-detached updraft at the top interface [ kg / s / m^2 ]

real(r8), parameter :: au_max             =  1.e-1_r8    !  Maximum   updraft fractional area [ no unit ]
real(r8), parameter :: wumin              =  1.e-1_r8    !  Minimum   updraft vertical velocity > 0 [ m / s ]
real(r8), parameter :: wumax              =  20._r8      !  Maximum   updraft vertical velocity > 0 [ m / s ]

!?integer,  parameter :: i_snowmlt          =  0         !  If 0 ( 1 ), melt snow before ( after ) evaporation within downdraft. The default '0' does not allow
                                                         !  direct evaporation of snow within downdraft and environment ( that is, the melted snow will be evaporated ), 
                                                         !  while '1' can generate non-zero precipitation flux at surface even though temperature is large. 
                                                         !  Strongly recommend to use '0' for full physical consistency.
                                                         !  Sep.07.2011. In addition, computation of overlapping area ( am_p_wk ) between 'precipitation area' and 'wake area'
                                                         !               is made based on the assumption that i_snowmlt = 0. Thus, strongly recommend to use 'i_snowmlt = 0'.  
                                                         !  Sep.12.2011. Needless to say, I must use 'i_snowmlt = 0' not '1'.
!?integer,  parameter :: ifinad_evpenv      =  0         !  If 0 ( 1 ), assume downdraft fractional area is zero ( non-zero ) in computing evap. of prep. within environment.
                                                         !  However, downdraft detrainment associated with 'ad_max, wdmax' are functional regardless of ifinad_evpenv. 
                                                         !  When this is '0', set 'ad_max = 1.e8, wdmax = 1.e8' in order not to disrupt downdraft dynamics.
                                                         !  When this is '1', set 'ad_max = 0.2, wdmin = 0.5, wdmax = 10' in order not to minimize downdraft dynamics. 

!?integer,  parameter :: i_dnconon          =  0         !  If 1 ( 0 ), turn-on ( off ) the below area ( ad_max ) and vertical velocity ( wdmax ) constraint on downdraft. 
                                                         !  This '0' setting is designed to save computation time.
real(r8), parameter :: ad_max             =  1.e8_r8     !  Maximum downdraft fractional area [ no unit ]. This should be set to infinity for conceptually reasonable performance.
real(r8), parameter :: wdmin              =  1.e-1_r8    !  Minimum downdraft vertical velocity > 0 [ m / s ]. This also influences evaporation within downdraft. May increase to 0.3.
real(r8), parameter :: wdmax              =  1.e8_r8     !  Maximum downdraft vertical velocity > 0 [ m / s ]. This should be set to infinity for conceptually reasonable performance.

real(r8), parameter :: nonzero            =  1.e-20_r8   !  Non-zero minimal positive constant [ no unit ]
real(r8), parameter :: unity              =  0.9999_r8   !  Constant close to 1 but smaller than 1 [ no unit ]
real(r8), parameter :: tmax_fice          =  263.15_r8   !  Temperature where ice starts to be formed [ K ]. Apr.3.2011 : I should do sensitivity simulation on this.
real(r8), parameter :: tmin_fice          =  233.15_r8   !  Temperature where ice fraction becomes 1  [ K ]
real(r8), parameter :: thv_ref            =  300._r8     !  Reference virtual potential temperature for buoyancy computation [ K ]

!ice integer,  parameter :: ipartition_fice    =  0      !  If 0 ( 1 ), ice fraction among the "mixture" between updraft and environment is 
!ice                                                     !  a function of temperature ( an explicit average of updraft and environmental ice fractions ).
!ice                                                     !  All previous codes used '0' but it is recommended to use '1' since '1' is more physically realistic.


!pinteger,  parameter :: ipartition         =  1         !  If 1 ( 0 ), do ( not ) partition the tendency in the lowest model layer into all the layers within the PBL both up/downdrafts.
                                                         !  This helps to deepen PBL in the HR ( e.g., L80 ) simulation. But we can choose 0 for conceptual clarity.
                                                         !  Sep.12.2011. In order to guarantee non-distroted correct computation of surface flux in the following surface flux
                                                         !               computation routine in CAM5 with colum-integrated energy conservation, I absolutely recommend to use 
                                                         !               ipartition = 1, not 0. That is, partition negative surface flux into the whole convective layers after
                                                         !               depositing reconstructed surface flux into the lowest model layer.
                                                         !  Sep.15.2011. It turns out that 'ipartition=0' produces very nice best MJO in '031h2' while the same simulations
                                                         !               with 'ipartition=1' degraded MJO in '031h3'. Even though 'ipartition=1' helps to reduce PREH20 
                                                         !               ( 27.3 from 27.6 ), it is not much. Thus, let's use 'ipartition = 0' for simulating MJO. 
                                                         !               It means that I don't do any arbitrary correction, which is good.
                                                         !  Mar.19.2014. As of today, this 'ipartition = 1' must be always used, since I added non-zero
                                                         !               convective fluxes at surface not only for updraft and also for downdraft.
                                                         !               Instead of 'ipartition' option, I should use below 'iopt_partition' option from today.
!pinteger,  parameter :: iopt_partition     =  1         !  If 1 ( 2 ),  Partition convective fluxes at the surface into the entire cumulus (PBL) layers.
                                                         !  Mar.19.2014. previous default was 1, but '2' seems to be also OK.
                                                         !               Note that 'kpblhm >= 1' and 'iopt_partition = 2' might be more conceptually
                                                         !               consistent with the cold-pool formulation.                        
                                                         !  Mar.19.2014. I checked that 'iopt_partition = 2' hugely degrades the diurnal cycle.
                                                         !               Thus, I must use '1', which partitions all over the cumulus layer.          

integer,  parameter :: iup_par            =  4           !  Partitioning of convective surface updraft flux into other layers
                                                         !  1 : Lowest Layer, or equivalently, No Partitioning
                                                         !  2 : Minimum of 'PBL Top' and 'Cumulus Top' 
                                                         !  3 : PBL Layers ( this degrades diurnal cycle )
                                                         !  4 : Cumulus Layers ( ** the best option ** )
                                                         !  5 : Entire Layers
                                                         !  Added on Mar.20.2014 as the most general functionality.

integer,  parameter :: idn_par            =  1           !  Partitioning of convective surface downdraft flux into other layers
                                                         !  1 : Lowest Layer, or equivalently, No Partitioning
                                                         !  2 : Minimum of 'PBL Top' and 'Cumulus Top' ( ** the best option both for cold-pool and plumes in stable env. ** )  
                                                         !  3 : PBL Layers
                                                         !  4 : Cumulus Layers
                                                         !  5 : Entire Layers
                                                         !  Added on Mar.20.2014 as the most general functionality.

! integer,  parameter :: ibogtopd           =  1         !  Computation of downdraft buoyancy at the top interface. 0 : Original Simplest, 1 : More Advanced. 
!                                                        !  No need to choose 0, so always choose 1.
! integer,  parameter :: idias_off          =  0         !  If 1 ( 0 ), turn-off ( on ) evap. of precip. and PGF in all downdrafts in the source layer. 
!                                                        !  Recommend to use 0 since it is more conceptually reasonable and physically continuous.
integer,  parameter :: islope_on_thlqttr  =  1           !  If 1 ( 0 ), turn-on ( off ) environmental profile reconstruction of 'thl, qt and tracers' in each layer. 
                                                         !  Strongly recommend to use 0 to obtain stable results and prevent unreasonable reversal of environmental buoyancy at the interface.
                                                         !  In the CAM5, simulation with '1' cuases model crash due to FINSDP_SINGLE in unicon.F90 --> But the cause was not due to this. 
                                                         !  Apr.03.2011 : I should do sensitivity test on this using BOMEX.
                                                         !  Sep.11.2011 : For full consistency with symmetric turbulence transport scheme, I must use 'islope_on_thlqttr = 1 ( not 0 )'
                                                         !                without no question in this asymmetric turbulence transport scheme.
integer,  parameter :: islope_on_uv       =  1           !  If 1 ( 0 ), turn-on ( off ) environmental profile reconstruction of 'u,v' in each layer. 
                                                         !  Recommend to use 0 to reasonably treat diabatic 'PGFc' effect similar to UW. 
                                                         !  Apr.03.2011 : I must use '1' for treating PGFc effect.
                                                         !  Sep.11.2011 : For full consistency with symmetric turbulence transport scheme, I must use 'islope_on_uv = 1 ( not 0 )'
                                                         !                without no question in this asymmetric turbulence transport scheme.
integer,  parameter :: iflux_env          =  1           !  Use the UW ( 0 ) or Park's reconstructed environmental profile ( 1 ) for flux computation.
                                                         !  Recommend to always use 1 since it is conceptually reasonable.
                                                         !  Sep.11.2011. For full conceptual consistency and consistent performance, I must absolutely use 'iflux_env = 1'.
integer,  parameter :: kiss               =  0           !  Launching interface : 0 ( 'surface' ) or 1 ( next interface ). In order to reduce model sensitivity to the thickness of 
                                                         !  the lowest layer, recommend to choose 0, which should be accompanied by sigfac = 1.
                                                         !  Sep.11.2011. For full conceptual consistency and coherence with 'ipartition = 1' choice above, 
                                                         !               I must absolutely use 'kiss = 0'.  
real(r8), parameter :: sigfac             =  1.0_r8      !  Reduction of surface flux from the surface to the next interface [ 0-1 ]
                                                         !  When kiss = 0, should be 1 but when kiss = 1, choose any reasonable value between [ 0 - 1 ].
                                                         !  Sep.11.2011. Needless to say, I must use 'sigfac = 1._r8' since I will always use kiss = 0.
!dreal(r8), parameter :: org_memory_time    =  10800._r8 !  Time scale over which convective plume carries time memory [ sec ]
                                                         !  It is good to set this one idential to the 'tau_org'.

contains
  
subroutine unicon_init(xlv_in, cp_in, xlf_in, zvir_in, r_in, g_in, ep2_in)

   real(r8), intent(in) :: xlv_in     !  Latent heat of vaporization
   real(r8), intent(in) :: xlf_in     !  Latent heat of fusion
   real(r8), intent(in) :: cp_in      !  Specific heat of dry air
   real(r8), intent(in) :: zvir_in    !  rh2o/rair - 1
   real(r8), intent(in) :: r_in       !  Gas constant for dry air
   real(r8), intent(in) :: g_in       !  Gravitational constant
   real(r8), intent(in) :: ep2_in     !  Mol wgt water vapor / Mol wgt dry air 

   xlv   = xlv_in
   xlf   = xlf_in
   xls   = xlv + xlf
   cp    = cp_in
   zvir  = zvir_in
   r     = r_in
   g     = g_in
   ep2   = ep2_in
   p00   = 1.e5_r8
   rovcp = r/cp

end subroutine unicon_init

!==================================================================================================

subroutine compute_unicon( mix            , mkx           , iend          , ncnst         , mit           , dt            , &
                           ps0_in         , zs0_in        , p0_in         , z0_in         , dp0_in        , dpdry0_in     , &
                           t0_in          , s0_in         , qv0_in        , ql0_in        , qi0_in        , tr0_in        , & 
                           u0_in          , v0_in         , ast0_in       , tke0_in       , bprod0_in     ,                 &
                           ipbl_in        , kpblh_in      , pblh_in       , wstar_in      , tkes_in       , went_in       , &
                           qflx_in        , shflx_in      , taux_in       , tauy_in       , aflx_in       ,                 & 
                           ocnfrac_in     , landfrac_in   , icefrac_in    , sgh_in        , sgh30_in      ,                 &
                           am_evp_st_in   , evprain_st_in , evpsnow_st_in ,                                                 &
                           cush_inout     , cushavg_inout , cuorg_inout   ,                                                 &
                           awk_PBL_inout                  , delta_thl_PBL_inout           , delta_qt_PBL_inout            , & 
                           delta_u_PBL_inout              , delta_v_PBL_inout             , delta_tr_PBL_inout            , &
!d                         cu_prep_inout  , cu_cmfu_inout , cu_cmfd_inout ,                                                 &
!d                         cu_tkePBLorg_inout             , cu_cmfPBLorg_inout            , cu_thlPBLorg_inout            , &
!d                         cu_qtPBLorg_inout              , cu_uPBLorg_inout              , cu_vPBLorg_inout              , &
                           cu_cmfum_inout , cu_cmfr_inout , cu_thlr_inout , cu_qtr_inout  , cu_ur_inout   , cu_vr_inout   , &
                           cu_qlr_inout   , cu_qir_inout  , cu_trr_inout  ,                                                 &
                           cu_cmfrd_inout , cu_thlrd_inout, cu_qtrd_inout , cu_urd_inout  , cu_vrd_inout  ,                 &
                           cu_qlrd_inout  , cu_qird_inout , cu_trrd_inout ,                                                 &
                           am_u_out       , qlm_u_out     , qim_u_out     ,                                                 &
                           am_d_out       , qlm_d_out     , qim_d_out     ,                                                 &
                           cmf_u_out      , slflx_out     , qtflx_out     ,                                                 & 
                           qvten_out      , qlten_out     , qiten_out     , trten_out     ,                                 &
                           sten_out       , uten_out      , vten_out      ,                                                 &
                           qrten_out      , qsten_out     ,                                                                 & 
                           rqc_l_out      , rqc_i_out     , rqc_out       , rnc_l_out     , rnc_i_out     ,                 &
                           rliq_out       , rice_out      , precip_out    , snow_out      , evapc_out     ,                 &
                           cnt_out        , cnb_out       , cmf_det_out   , ql_det_out    , qi_det_out    ,                 &
                           lchnk )

   !---------------------------------------------------!
   !                                                   ! 
   !     The Unified Convection Scheme - UNICON        !
   !     Developed by Sungsu Park                      !
   !     For detailed description, See JAS.2014.Nov.   !
   !     Copyright is owned by Sungsu Park             !
   !                                                   !
   !---------------------------------------------------!
 
   use cam_history,     only : outfld
   use time_manager,    only : get_nstep
   implicit none 

   ! --------------------------- !
   ! Main Input-Output variables !
   ! --------------------------- !

   integer , intent(in)    :: lchnk
   integer , intent(in)    :: mix                                  !  Number of columns
   integer , intent(in)    :: iend                                 !  Number of columns 
   integer , intent(in)    :: mkx                                  !  k = 1 : Lowest layer, k = mkx : Top layer
   integer , intent(in)    :: ncnst                                !  Number of tracers
   integer , intent(in)    :: mit                                  !  Number of previous time steps saved for convective organization  
   real(r8), intent(in)    :: dt                                   !  Time step in seconds: 2*delta_t [s]

   real(r8), intent(in)    :: ps0_in(mix,0:mkx)                    !  Environmental pressure at the interface [Pa]
   real(r8), intent(in)    :: zs0_in(mix,0:mkx)                    !  Environmental height   at the interface [m]
   real(r8), intent(in)    :: p0_in(mix,mkx)                       !  Environmental pressure at the mid-point [m]
   real(r8), intent(in)    :: z0_in(mix,mkx)                       !  Environmental height   at the mid-point [m]
   real(r8), intent(in)    :: dp0_in(mix,mkx)                      !  Environmental layer pressure thickness  [Pa] > 0
   real(r8), intent(in)    :: dpdry0_in(mix,mkx)                   !  Environmental layer dry pressure thickness  [Pa] > 0
   real(r8), intent(in)    :: u0_in(mix,mkx)                       !  Environmental zonal wind [m/s]
   real(r8), intent(in)    :: v0_in(mix,mkx)                       !  Environmental meridional wind [m/s]
   real(r8), intent(in)    :: qv0_in(mix,mkx)                      !  Environmental water  vapor specific humidity [kg/kg]
   real(r8), intent(in)    :: ql0_in(mix,mkx)                      !  Environmental liquid water specific humidity [kg/kg]
   real(r8), intent(in)    :: qi0_in(mix,mkx)                      !  Environmental ice          specific humidity [kg/kg]
   real(r8), intent(in)    :: tr0_in(mix,mkx,ncnst)                !  Environmental tracers [ #/kg, kg/kg ]
   real(r8), intent(in)    :: t0_in(mix,mkx)                       !  Environmental temperature [K]
   real(r8), intent(in)    :: s0_in(mix,mkx)                       !  Environmental dry static energy [J/kg]
   real(r8), intent(in)    :: ast0_in(mix,mkx)                     !  Stratiform fractional area at the layer mid-point [ fraction ]
   real(r8), intent(in)    :: tke0_in(mix,0:mkx)                   !  TKE at the interface [ m2/s2 ]
   real(r8), intent(in)    :: bprod0_in(mix,0:mkx)                 !  Buoyancy production at the interface [ m2/s3 ]

   integer(i4), intent(in) :: ipbl_in(mix)                         !  If 1(0), PBL is CL(STL)
   integer(i4), intent(in) :: kpblh_in(mix)                        !  Layer index with PBL top in it or at the base interface
   real(r8), intent(in)    :: pblh_in(mix)                         !  PBL top height [ m ]
   real(r8), intent(in)    :: wstar_in(mix)                        !  Turbulent convective velocity scale within PBL [ m/s ]
   real(r8), intent(in)    :: tkes_in(mix)                         !  Turbulent kinetic energy at surface directly from the UW PBL scheme [ m/s ]
   real(r8), intent(in)    :: went_in(mix)                         !  Entrainment rate at the PBL top interface directly from the UW PBL scheme [ m/s ]
   real(r8), intent(in)    :: qflx_in(mix)                         !  Upward water vapor flux into atmosphere at surface [ kg/m2/s ]
   real(r8), intent(in)    :: shflx_in(mix)                        !  Upward sensible heat flux into atmosphere at surface [ J/m2/s ]
   real(r8), intent(in)    :: taux_in(mix)                         !  Upward zonal      wind stress into atmosphere at surface [ kg m/s /m2/s ] 
   real(r8), intent(in)    :: tauy_in(mix)                         !  Upward meridional wind stress into atmosphere at surface [ kg m/s /m2/s ] 
   real(r8), intent(in)    :: aflx_in(mix,ncnst)                   !  Upward tracer fluxes          into atmosphere at surface [ #/m2/s, kg/m2/s ]

   real(r8), intent(in)    :: ocnfrac_in(mix)                      !  Ocean Fraction [ fraction ]
   real(r8), intent(in)    :: landfrac_in(mix)                     !  Land  Fraction [ fraction ]    
   real(r8), intent(in)    :: icefrac_in(mix)                      !  Ice   Fraction [ fraction ]

   real(r8), intent(in)    :: sgh_in(mix)                          !  Standard deviation of subgrid topographic height [ meter ] 
   real(r8), intent(in)    :: sgh30_in(mix)                        !  Standard deviation of subgrid topographic height at 30 s horizontal area [ meter ] 
                                                                   !  This 'sgh30' ( not sgh ) is used for the parameterization of tms. 
   ! Aug.08.2013. Evaporation of stratiform precipitation
   real(r8), intent(in)    :: am_evp_st_in(mix,mkx)                !  Evaporation area of stratiform precipitation [fraction]
   real(r8), intent(in)    :: evprain_st_in(mix,mkx)               !  Grid-mean evaporation rate of stratiform rain [kg/kg/s] >= 0.
   real(r8), intent(in)    :: evpsnow_st_in(mix,mkx)               !  Grid-mean evaporation rate of stratiform snow [kg/kg/s] >= 0.

   real(r8), intent(inout) :: cush_inout(mix)                      !  Cumulus top height [ m ]
   real(r8), intent(inout) :: cushavg_inout(mix)                   !  Mean cumulus top height weighted by updraft masss flux at surface [ m ]
   real(r8), intent(inout) :: cuorg_inout(mix)                     !  Covective organization parameter [ 0-1 ]
   real(r8), intent(inout) :: awk_PBL_inout(mix)                   !  Wake area within PBL [ 0 - 1 ]
   real(r8), intent(inout) :: delta_thl_PBL_inout(mix)             !  Difference of thl between off-wake region and grid-mean value averaged over the PBL [ K ]
   real(r8), intent(inout) :: delta_qt_PBL_inout(mix)              !  Difference of qt  between off-wake region and grid-mean value averaged over the PBL [ kg/kg ]
   real(r8), intent(inout) :: delta_u_PBL_inout(mix)               !  Difference of u   between off-wake region and grid-mean value averaged over the PBL [ m/s ]
   real(r8), intent(inout) :: delta_v_PBL_inout(mix)               !  Difference of v   between off-wake region and grid-mean value averaged over the PBL [ m/s ]
   ! real(r8), intent(inout) :: delta_thv_PBL_inout(mix)           !  Difference of thv between off-wake region and grid-mean value averaged over the PBL [ K ]
   real(r8), intent(inout) :: delta_tr_PBL_inout(mix,ncnst)        !  Difference of tr  between off-wake region and grid-mean value averaged over the PBL [ kg/kg, #/kg ]

!d  real(r8), intent(inout) :: cu_prep_inout(mix,mit)              !  Precipitation flux memory at surface [ kg/s/m2 ] 
!d                                                                 !  mit = 1 : The most recent time step, mit : The oldest time step.
!d  real(r8), intent(inout) :: cu_cmfu_inout(mix,mit)              !  Convective   updraft flux at surface [ kg/s/m2 ] 
!d                                                                 !  mit = 1 : The most recent time step, mit : The oldest time step.
!d  real(r8), intent(inout) :: cu_cmfd_inout(mix,mit)              !  Convective downdraft flux at surface [ kg/s/m2 ] 
!d                                                                 !  mit = 1 : The most recent time step, mit : The oldest time step.
!d  real(r8), intent(inout) :: cu_tkePBLorg_inout(mix,mit)         !  Organized TKE memory averaged over PBL [ m2/s2 ] 
!d                                                                 !  mit = 1 : The most recent time step, mit : The oldest time step.
!d  real(r8), intent(inout) :: cu_cmfPBLorg_inout(mix,mit)         !  Organized cmfd memory averaged over PBL [ kg/m2/s ] 
!d                                                                 !  mit = 1 : The most recent time step, mit : The oldest time step.
!d  real(r8), intent(inout) :: cu_thlPBLorg_inout(mix,mit)         !  Organized thl anomaly memory averaged over PBL [ K ] 
!d                                                                 !  mit = 1 : The most recent time step, mit : The oldest time step.
!d  real(r8), intent(inout) :: cu_qtPBLorg_inout(mix,mit)          !  Organized qt  anomaly memory averaged over PBL [ kg/kg ] 
!d                                                                 !  mit = 1 : The most recent time step, mit : The oldest time step.
!d  real(r8), intent(inout) :: cu_uPBLorg_inout(mix,mit)           !  Organized u   anomaly memory averaged over PBL [ m/s ] 
!d                                                                 !  mit = 1 : The most recent time step, mit : The oldest time step.
!d  real(r8), intent(inout) :: cu_vPBLorg_inout(mix,mit)           !  Organized v   anomaly memory averaged over PBL [ m/s ] 
!d                                                                 !  mit = 1 : The most recent time step, mit : The oldest time step.

   real(r8), intent(inout) :: cu_cmfum_inout(mix,mkx)              !  The amount of mass involved in the updraft buoyancy sorting at the previous time step [ kg/s/m2 ]
   real(r8), intent(inout) :: cu_cmfr_inout(mix,mkx)               !  The amount of detrained mass from convective updraft and downdraft at the previous time step [ kg/s/m2 ]
   real(r8), intent(inout) :: cu_thlr_inout(mix,mkx)               !  Mass-flux weighted mean 'thl' of detrained mass from convective updraft and downdraft at the previous time step [ K ]
   real(r8), intent(inout) :: cu_qtr_inout(mix,mkx)                !  Mass-flux weighted mean 'qt'  of detrained mass from convective updraft and downdraft at the previous time step [ kg/kg ]
   real(r8), intent(inout) :: cu_ur_inout(mix,mkx)                 !  Mass-flux weighted mean 'u'   of detrained mass from convective updraft and downdraft at the previous time step [ m/s ]
   real(r8), intent(inout) :: cu_vr_inout(mix,mkx)                 !  Mass-flux weighted mean 'v'   of detrained mass from convective updraft and downdraft at the previous time step [ m/s ]
   real(r8), intent(inout) :: cu_qlr_inout(mix,mkx)                !  Mass-flux weighted mean 'ql'  of detrained mass from convective updraft and downdraft at the previous time step [ kg/kg ]
   real(r8), intent(inout) :: cu_qir_inout(mix,mkx)                !  Mass-flux weighted mean 'qi'  of detrained mass from convective updraft and downdraft at the previous time step [ kg/kg ]
   real(r8), intent(inout) :: cu_trr_inout(mix,mkx,ncnst)          !  Mass-flux weighted mean 'tr'  of detrained mass from convective updraft and downdraft at the previous time step [ kg/kg ]

   real(r8)                :: cu_thvr_inout(mix,mkx)               !  Mass-flux weighted mean 'thv' of detrained mass from convective updraft and downdraft at the previous time step [ K ]
   real(r8)                :: cu_rhr_inout(mix,mkx)                !  Mass-flux weighted mean 'rh'  of detrained mass from convective updraft and downdraft at the previous time step [ ratio ]

   real(r8), intent(inout) :: cu_cmfrd_inout(mix,mkx)              !  The amount of detrained mass from convective downdraft at the previous time step [ kg/s/m2 ]
   real(r8), intent(inout) :: cu_thlrd_inout(mix,mkx)              !  Mass-flux weighted mean 'thl' of detrained mass from convective downdraft at the previous time step [ K ]
   real(r8), intent(inout) :: cu_qtrd_inout(mix,mkx)               !  Mass-flux weighted mean 'qt'  of detrained mass from convective downdraft at the previous time step [ kg/kg ]
   real(r8), intent(inout) :: cu_urd_inout(mix,mkx)                !  Mass-flux weighted mean 'u'   of detrained mass from convective downdraft at the previous time step [ m/s ]
   real(r8), intent(inout) :: cu_vrd_inout(mix,mkx)                !  Mass-flux weighted mean 'v'   of detrained mass from convective downdraft at the previous time step [ m/s ]
   real(r8), intent(inout) :: cu_qlrd_inout(mix,mkx)               !  Mass-flux weighted mean 'ql'  of detrained mass from convective downdraft at the previous time step [ kg/kg ]
   real(r8), intent(inout) :: cu_qird_inout(mix,mkx)               !  Mass-flux weighted mean 'qi'  of detrained mass from convective downdraft at the previous time step [ kg/kg ]
   real(r8), intent(inout) :: cu_trrd_inout(mix,mkx,ncnst)         !  Mass-flux weighted mean 'tr'  of detrained mass from convective downdraft at the previous time step [ kg/kg ]

   ! Formal output variables

   real(r8), intent(out)   :: am_u_out(mix,mkx)                    !  Updraft fractional area [ fraction ] 
   real(r8), intent(out)   :: qlm_u_out(mix,mkx)                   !  Area-weighted in-cloud LWC within updraft fractional area [ kg / kg ]
   real(r8), intent(out)   :: qim_u_out(mix,mkx)                   !  Area-weighted in-cloud IWC within updraft fractional area [ kg / kg ]

   real(r8), intent(out)   :: am_d_out(mix,mkx)                    !  Downdraft fractional area [ fraction ] 
   real(r8), intent(out)   :: qlm_d_out(mix,mkx)                   !  Area-weighted in-cloud LWC within downdraft fractional area [ kg / kg ]
   real(r8), intent(out)   :: qim_d_out(mix,mkx)                   !  Area-weighted in-cloud IWC within downdraft fractional area [ kg / kg ]

   real(r8), intent(out)   :: cmf_u_out(mix,0:mkx)                 !  Upward convective mass flux at the interface [ kg / s / m2 ]
   real(r8), intent(out)   :: slflx_out(mix,0:mkx)                 !  Net upward convective flux of liquid static energy [ J / s / m2 ]
   real(r8), intent(out)   :: qtflx_out(mix,0:mkx)                 !  Net upward convective flux of total specific humidity [ kg / s / m2 ]
 
   real(r8), intent(out)   :: qvten_out(mix,mkx)                   !  Tendency of water vapor specific humidity [ kg / kg / s ]
   real(r8), intent(out)   :: qlten_out(mix,mkx)                   !  Tendency of liquid water mixing ratio [ kg / kg / s ]
   real(r8), intent(out)   :: qiten_out(mix,mkx)                   !  Tendency of ice mixing ratio [ kg / kg / s ]
   real(r8), intent(out)   :: sten_out(mix,mkx)                    !  Tendency of dry static energy [ J / kg / s ]
   real(r8), intent(out)   :: uten_out(mix,mkx)                    !  Tendency of zonal wind [ m / s / s ]
   real(r8), intent(out)   :: vten_out(mix,mkx)                    !  Tendency of meridional wind [ m / s / s ]
   real(r8), intent(out)   :: trten_out(mix,mkx,ncnst)             !  Tendency of tracers [ # / kg / s, kg / kg / s ]

   real(r8), intent(out)   :: qrten_out(mix,mkx)                   !  Production rate of rain by lateral expels of cumulus condensate [kg/kg/s]
   real(r8), intent(out)   :: qsten_out(mix,mkx)                   !  Production rate of snow by lateral expels of cumulus condensate [kg/kg/s]
   real(r8), intent(out)   :: precip_out(mix)                      !  Precipitation flux at surface in flux unit [ m / s ]
   real(r8), intent(out)   :: snow_out(mix)                        !  Snow flux at surface in flux unit [ m / s ]
   real(r8), intent(out)   :: evapc_out(mix,mkx)                   !  Evaporation rate of convective precipitation within environment [ kg/kg/s ]

   real(r8), intent(out)   :: rqc_out(mix,mkx)                     ! Production rate of raw detrained LWC+IWC  [kg/kg/s] > 0
   real(r8), intent(out)   :: rqc_l_out(mix,mkx)                   ! Production rate of raw detrained LWC      [kg/kg/s] > 0
   real(r8), intent(out)   :: rqc_i_out(mix,mkx)                   ! Production rate of raw detrained IWC      [kg/kg/s] > 0
   real(r8), intent(out)   :: rliq_out(mix)                        ! Vertical integral of 'rqc_out'   in flux unit [m/s]
   real(r8), intent(out)   :: rice_out(mix)                        ! Vertical integral of 'rqc_l_out' in flux unit [m/s]
   real(r8), intent(out)   :: rnc_l_out(mix,mkx)                   ! Production rate of raw detrained droplet number of cloud liquid droplets [#/kg/s] > 0
   real(r8), intent(out)   :: rnc_i_out(mix,mkx)                   ! Production rate of raw detrained droplet number of cloud    ice droplets [#/kg/s] > 0

   real(r8), intent(out)   :: cnt_out(mix)                         ! Cloud top  interface index ( ki = kpen )
   real(r8), intent(out)   :: cnb_out(mix)                         ! Cloud base interface index ( ki = krel-1 )

   real(r8), intent(out)   :: cmf_det_out(mix,mkx)                 ! Detrained mass flux only from convective updraft (not from environmental air) and downdraft [ kg / s / m2 ] 
   real(r8), intent(out)   :: ql_det_out(mix,mkx)                  ! Detrained LWC without mixing with the environment ( flux-convergence & subsidence-detrainment consistent ) [ kg / kg ]
   real(r8), intent(out)   :: qi_det_out(mix,mkx)                  ! Detrained LWC without mixing with the environment ( flux-convergence & subsidence-detrainment consistent ) [ kg / kg ]

   ! ------------------------- ! 
   ! Internal output variables !
   ! ------------------------- !

   real(r8)                :: cmf_out(mix,0:mkx)                   !  Net upward convective mass flux at the interface [kg/s/m2]
   real(r8)                :: uflx_out(mix,0:mkx)                  !  Net upward convective flux of zonal momentum [m/s/s/m2]
   real(r8)                :: vflx_out(mix,0:mkx)                  !  Net upward convective flux of meridional momentum [m/s/s/m2]

   real(r8)                :: slflx_u_out(mix,0:mkx)               !  Upward convective flux of liquid static energy [J/s/m2]
   real(r8)                :: qtflx_u_out(mix,0:mkx)               !  Upward convective flux of total specific humidity [kg/s/m2]
   real(r8)                :: uflx_u_out(mix,0:mkx)                !  Upward convective flux of zonal momentum [kg m/s/s/m2]
   real(r8)                :: vflx_u_out(mix,0:mkx)                !  Upward convective flux of meridional momentum [kg m/s/s/m2]

   real(r8)                :: cmf_d_out(mix,0:mkx)                 !  Downward convective mass flux at the interface [kg/s/m2]
   real(r8)                :: slflx_d_out(mix,0:mkx)               !  Downward convective flux of liquid static energy [J/s/m2]
   real(r8)                :: qtflx_d_out(mix,0:mkx)               !  Downward convective flux of total specific humidity [kg/s/m2]
   real(r8)                :: uflx_d_out(mix,0:mkx)                !  Downward convective flux of zonal momentum [kg m/s/s/m2]
   real(r8)                :: vflx_d_out(mix,0:mkx)                !  Downward convective flux of meridional momentum [kg m/s/s/m2]

!d  real(r8)                :: slflx_d_org_out(mix,0:mkx)           !  Downward convective flux of liquid static energy [J/s/m2]
!d  real(r8)                :: qtflx_d_org_out(mix,0:mkx)           !  Downward convective flux of total specific humidity [kg/s/m2]

   real(r8)                :: thl_orgforce_out(mix)                !  Total organization forcing generating thl difference between 'non-wake' and 'grid-mean' areas [ K / s ] 
   real(r8)                :: qt_orgforce_out(mix)                 !  Total organization forcing generating qt  difference between 'non-wake' and 'grid-mean' areas [ kg / kg / s ]
   real(r8)                :: u_orgforce_out(mix)                  !  Total organization forcing generating u   difference between 'non-wake' and 'grid-mean' areas [ m / s / s ]
   real(r8)                :: v_orgforce_out(mix)                  !  Total organization forcing generating v   difference between 'non-wake' and 'grid-mean' areas [ m / s / s ]
  ! real(r8)                :: thv_orgforce_out(mix)                !  Total organization forcing generating thv difference between 'non-wake' and 'grid-mean' areas [ K / s ]
   real(r8)                :: tr_orgforce_out(mix,ncnst)           !  Total organization forcing generating thv difference between 'non-wake' and 'grid-mean' areas [ kg / kg / s or # / kg / s ]
   real(r8)                :: awk_orgforce_out(mix)                !  Total organization forcing generating 'wake area' ( a_wk ) [ 1 / s ] 

   ! Below block is for detailed diagnostic output

   real(r8)                :: flxrain_out(mix,0:mkx)                  
   real(r8)                :: flxsnow_out(mix,0:mkx)                  

   real(r8)                :: thl_orgforce_flx_out(mix)            !  PBL top flux-related forcing for organized difference between 'off-wake' and 'grid-mean' thl [ K / s ]
   real(r8)                :: qt_orgforce_flx_out(mix)             !  PBL top flux-related forcing for organized difference between 'off-wake' and 'grid-mean' qt [ kg / kg / s ]
   real(r8)                :: u_orgforce_flx_out(mix)              !  PBL top flux-related forcing for organized difference between 'off-wake' and 'grid-mean' u [ m / s / s ]
   real(r8)                :: v_orgforce_flx_out(mix)              !  PBL top flux-related forcing for organized difference between 'off-wake' and 'grid-mean' v [ m / s / s ]
   real(r8)                :: tr_orgforce_flx_out(mix,ncnst)       !  PBL top flux-related forcing for organized difference between 'off-wake' and 'grid-mean' tracers [ kg / kg / s or # / kg /s]
   real(r8)                :: awk_orgforce_flx_out(mix)            !  PBL top flux-related forcing for wake area [ 1 / s ]

   real(r8)                :: thl_orgforce_und_out(mix)            !  Up-and-Down diabatic forcing for organized difference between 'off-wake' and 'grid-mean' thl [ K / s ]
   real(r8)                :: qt_orgforce_und_out(mix)             !  Up-and-Down diabatic forcing for organized difference between 'off-wake' and 'grid-mean' qt [ kg / kg / s ]
   real(r8)                :: u_orgforce_und_out(mix)              !  Up-and-Down diabatic forcing for organized difference between 'off-wake' and 'grid-mean' u [ m / s / s ]
   real(r8)                :: v_orgforce_und_out(mix)              !  Up-and-Down diabatic forcing for organized difference between 'off-wake' and 'grid-mean' v [ m / s / s ]
   real(r8)                :: tr_orgforce_und_out(mix,ncnst)       !  Up-and-Down diabatic forcing for organized difference between 'off-wake' and 'grid-mean' tracers [ kg / kg / s or # / kg /s]
   real(r8)                :: awk_orgforce_mix_out(mix)            !  Lateral-Mixing       forcing for wake area [ 1 / s ]

   real(r8)                :: thl_orgforce_env_out(mix)            !  Environment diabatic forcing for organized difference between 'off-wake' and 'grid-mean' thl [ K / s ]
   real(r8)                :: qt_orgforce_env_out(mix)             !  Environment diabatic forcing for organized difference between 'off-wake' and 'grid-mean' qt [ kg / kg / s ]
   real(r8)                :: u_orgforce_env_out(mix)              !  Environment diabatic forcing for organized difference between 'off-wake' and 'grid-mean' u [ m / s / s ]
   real(r8)                :: v_orgforce_env_out(mix)              !  Environment diabatic forcing for organized difference between 'off-wake' and 'grid-mean' v [ m / s / s ]
   real(r8)                :: tr_orgforce_env_out(mix,ncnst)       !  Environment diabatic forcing for organized difference between 'off-wake' and 'grid-mean' tracers [ kg / kg / s or # / kg /s]
   real(r8)                :: cmf_d_org_pblh_out(mix)              !  Organization-inducing downdraft mass flux at the PBL top interface [ kg / m^2 / s ] 

   ! Above block is for detailed diagnostic output
       
   real(r8)                :: taui_thl_out(mix)                    !  Inverse of damping time scale of the difference between 'off-wake' and 'grid-mean' thl [ 1 / s ]
   real(r8)                :: taui_qt_out(mix)                     !  Inverse of damping time scale of the difference between 'off-wake' and 'grid-mean' qt [ 1 / s ]
   real(r8)                :: taui_u_out(mix)                      !  Inverse of damping time scale of the difference between 'off-wake' and 'grid-mean' u [ 1 / s ]
   real(r8)                :: taui_v_out(mix)                      !  Inverse of damping time scale of the difference between 'off-wake' and 'grid-mean' v [ 1 / s ]
  ! real(r8)                :: taui_thv_out(mix)                    !  Inverse of damping time scale of the difference between 'off-wake' and 'grid-mean' thv [ 1 / s ]
   real(r8)                :: taui_tr_out(mix,ncnst)               !  Inverse of damping time scale of the difference between 'off-wake' and 'grid-mean' tracers [ 1 / s ]
   real(r8)                :: taui_awk_out(mix)                    !  Inverse of damping time scale of the wake area [ 1 / s ]


!og
   real(r8)                :: del_org_out(mix)                     !  Detrainment rate of the cold pool [ 1 / s ]
   real(r8)                :: del0_org_out(mix)                    !  Effective detrainment rate of the cold pool [ 1 / s ]
!og

   real(r8)                :: slten_u_out(mix,mkx)      
   real(r8)                :: qtten_u_out(mix,mkx)      
   real(r8)                :: uten_u_out(mix,mkx)       
   real(r8)                :: vten_u_out(mix,mkx)       
   real(r8)                :: sten_u_out(mix,mkx)       
   real(r8)                :: qvten_u_out(mix,mkx)      
   real(r8)                :: qlten_u_out(mix,mkx)      
   real(r8)                :: qiten_u_out(mix,mkx)      
   real(r8)                :: trten_u_out(mix,mkx,ncnst)      

   real(r8)                :: slten_d_out(mix,mkx)      
   real(r8)                :: qtten_d_out(mix,mkx)      
   real(r8)                :: uten_d_out(mix,mkx)       
   real(r8)                :: vten_d_out(mix,mkx)       
   real(r8)                :: sten_d_out(mix,mkx)       
   real(r8)                :: qvten_d_out(mix,mkx)      
   real(r8)                :: qlten_d_out(mix,mkx)      
   real(r8)                :: qiten_d_out(mix,mkx)      
   real(r8)                :: trten_d_out(mix,mkx,ncnst)      

   real(r8)                :: slten_evp_out(mix,mkx)    
   real(r8)                :: qtten_evp_out(mix,mkx)    
   real(r8)                :: uten_evp_out(mix,mkx)     
   real(r8)                :: vten_evp_out(mix,mkx)     
   real(r8)                :: sten_evp_out(mix,mkx)     
   real(r8)                :: qvten_evp_out(mix,mkx)    
   real(r8)                :: qlten_evp_out(mix,mkx)    
   real(r8)                :: qiten_evp_out(mix,mkx)    
   real(r8)                :: trten_evp_out(mix,mkx,ncnst)      
   real(r8)                :: trten_wdep_out(mix,mkx,ncnst)      

   real(r8)                :: slten_dis_out(mix,mkx)    
   real(r8)                :: qtten_dis_out(mix,mkx)    
   real(r8)                :: uten_dis_out(mix,mkx)     
   real(r8)                :: vten_dis_out(mix,mkx)     
   real(r8)                :: sten_dis_out(mix,mkx)     
   real(r8)                :: qvten_dis_out(mix,mkx)    
   real(r8)                :: qlten_dis_out(mix,mkx)    
   real(r8)                :: qiten_dis_out(mix,mkx)    
   real(r8)                :: trten_dis_out(mix,mkx,ncnst)      

   real(r8)                :: qlten_sub_out(mix,mkx)    
   real(r8)                :: qiten_sub_out(mix,mkx)    

   real(r8)                :: qlten_det_out(mix,mkx)    
   real(r8)                :: qiten_det_out(mix,mkx)    

   real(r8)                :: thl_u_out(mix,0:mkx)                 !  Mass-flux weighted updraft thl [ K ]
   real(r8)                :: qt_u_out(mix,0:mkx)                  !  Mass-flux weighted updraft qt [ kg / kg ]
   real(r8)                :: u_u_out(mix,0:mkx)                   !  Mass-flux weighted updraft u [ m / s ]
   real(r8)                :: v_u_out(mix,0:mkx)                   !  Mass-flux weighted updraft v [ m / s ]
   real(r8)                :: w_u_out(mix,0:mkx)                   !  Mass-flux weighted updraft w [ m / s ]
   real(r8)                :: ql_u_out(mix,0:mkx)                  !  Mass-flux weighted updraft in-cumulus ql [ kg / kg ]
   real(r8)                :: qi_u_out(mix,0:mkx)                  !  Mass-flux weighted updraft in-cumulus qi [ kg / kg ]
   real(r8)                :: tr_u_out(mix,0:mkx,ncnst)            !  Mass-flux weighted updraft tr [ # / kg, kg / kg ]
   real(r8)                :: wa_u_out(mix,0:mkx)                  !  Area weighted updraft w [ m / s ]
   real(r8)                :: qla_u_out(mix,0:mkx)                 !  Area weighted updraft in-cumulus ql [ kg / kg ]
   real(r8)                :: qia_u_out(mix,0:mkx)                 !  Area weighted updraft in-cumulus qi [ kg / kg ]
   real(r8)                :: a_u_out(mix,0:mkx)                   !  Updraft fractional area [ fraction ]
   real(r8)                :: rad_u_out(mix,0:mkx)                 !  Number weighted effective radius of updraft plumes [ m ]
   real(r8)                :: num_u_out(mix,0:mkx)                 !  Number concentration of updraft plumes [ # / m^2 ]
   real(r8)                :: gamw_u_out(mix,0:mkx)                !  Ratio of 'w_u_out / wa_u_out' [ no ]
   real(r8)                :: thva_u_out(mix,0:mkx)                !  Area weighted updraft thv [ K ]

   real(r8)                :: a_p_out(mix,0:mkx)                   !  Convective precipitation area [ fraction ]
   real(r8)                :: am_evp_out(mix,mkx)                  !  Convective evaporation area [ fraction ]
   real(r8)                :: am_pu_out(mix,mkx)                   !  Overlapping area between convective precipitation and saturated updraft [ fraction ]
   real(r8)                :: x_p_out(mix,0:mkx)                   !  Zonal displacement of the precipitation area from the surface [ m ]
   real(r8)                :: y_p_out(mix,0:mkx)                   !  Meridional displacement of the precipitation area from the surface [ m ]
   real(r8)                :: x_um_out(mix,mkx)                    !  Zonal displacement of the updraft area from the surface [ m ]
   real(r8)                :: y_um_out(mix,mkx)                    !  Meridional displacement of the updraft area from the surface [ m ]

   real(r8)                :: thl_d_out(mix,0:mkx)                 !  Mass-flux weighted downdraft thl [ K ]
   real(r8)                :: qt_d_out(mix,0:mkx)                  !  Mass-flux weighted downdraft qt [ kg / kg ]
   real(r8)                :: u_d_out(mix,0:mkx)                   !  Mass-flux weighted downdraft u [ m / s ]
   real(r8)                :: v_d_out(mix,0:mkx)                   !  Mass-flux weighted downdraft v [ m / s ]
   real(r8)                :: w_d_out(mix,0:mkx)                   !  Mass-flux weighted downdraft w [ m / s ]
   real(r8)                :: ql_d_out(mix,0:mkx)                  !  Mass-flux weighted downdraft in-cumulus ql [ kg / kg ]
   real(r8)                :: qi_d_out(mix,0:mkx)                  !  Mass-flux weighted downdraft in-cumulus qi [ kg / kg ]
   real(r8)                :: tr_d_out(mix,0:mkx,ncnst)            !  Mass-flux weighted downdraft tr [ # / kg, kg / kg ]
   real(r8)                :: wa_d_out(mix,0:mkx)                  !  Area weighted downdraft w [ m / s ]
   real(r8)                :: qla_d_out(mix,0:mkx)                 !  Area weighted downdraft in-cumulus ql [ kg / kg ]
   real(r8)                :: qia_d_out(mix,0:mkx)                 !  Area weighted downdraft in-cumulus qi [ kg / kg ]
   real(r8)                :: a_d_out(mix,0:mkx)                   !  Downdraft fractional area [ fraction ]

   real(r8)                :: thl_u_msfc_out(mix,0:mkx,nseg,niter)       !  Updraft             thl at the interface for each original updraft segment [ K ].
   real(r8)                :: qt_u_msfc_out(mix,0:mkx,nseg,niter)        !  Updraft              qt at the interface for each original updraft segment [ kg / kg ].
   real(r8)                :: u_u_msfc_out(mix,0:mkx,nseg,niter)         !  Updraft               u at the interface for each original updraft segment [ m / s ].
   real(r8)                :: v_u_msfc_out(mix,0:mkx,nseg,niter)         !  Updraft               v at the interface for each original updraft segment [ m / s ].
   real(r8)                :: w_u_msfc_out(mix,0:mkx,nseg,niter)         !  Updraft               w at the interface for each original updraft segment [ m / s ].
   real(r8)                :: ql_u_msfc_out(mix,0:mkx,nseg,niter)        !  Updraft              ql at the interface for each original updraft segment [ kg / kg ].
   real(r8)                :: qi_u_msfc_out(mix,0:mkx,nseg,niter)        !  Updraft              qi at the interface for each original updraft segment [ kg / kg ].
   real(r8)                :: tr_u_msfc_out(mix,0:mkx,nseg,ncnst,niter)  !  Updraft              tr at the interface for each original updraft segment [ # / kg, kg / kg ].
   real(r8)                :: cmf_u_msfc_out(mix,0:mkx,nseg,niter)       !  Updraft             cmf at the interface for each original updraft segment [ kg / s / m^2 ].
   real(r8)                :: a_u_msfc_out(mix,0:mkx,nseg,niter)         !  Updraft               a at the interface for each original updraft segment [ fraction ].
   real(r8)                :: num_u_msfc_out(mix,0:mkx,nseg,niter)       !  Updraft             num at the interface for each original updraft segment [ # / m^2 ].
   real(r8)                :: rad_u_msfc_out(mix,0:mkx,nseg,niter)       !  Updraft             rad at the interface for each original updraft segment [ m ].

   real(r8)                :: eps0_u_msfc_out(mix,0:mkx,nseg,niter)      !  Updraft            eps0 at the interface for each original updraft segment [ 1 / Pa ].
   real(r8)                :: eps_u_msfc_out(mix,0:mkx,nseg,niter)       !  Updraft             eps at the interface for each original updraft segment [ 1 / Pa ].
   real(r8)                :: del_u_msfc_out(mix,0:mkx,nseg,niter)       !  Updraft             del at the interface for each original updraft segment [ 1 / Pa ].
   real(r8)                :: eeps_u_msfc_out(mix,0:mkx,nseg,niter)      !  Updraft            eeps at the interface for each original updraft segment [ no ].
   real(r8)                :: ddel_u_msfc_out(mix,0:mkx,nseg,niter)      !  Updraft            ddel at the interface for each original updraft segment [ no ].
   real(r8)                :: xc_u_msfc_out(mix,0:mkx,nseg,niter)        !  Updraft              xc at the interface for each original updraft segment [ no ].
   real(r8)                :: xs_u_msfc_out(mix,0:mkx,nseg,niter)        !  Updraft              xs at the interface for each original updraft segment [ no ].
   real(r8)                :: xemin_u_msfc_out(mix,0:mkx,nseg,niter)     !  Updraft           xemin at the interface for each original updraft segment [ no ].
   real(r8)                :: xemax_u_msfc_out(mix,0:mkx,nseg,niter)     !  Updraft           xemax at the interface for each original updraft segment [ no ].
   real(r8)                :: cridis_u_msfc_out(mix,0:mkx,nseg,niter)    !  Updraft          cridis at the interface for each original updraft segment [ m ].
   real(r8)                :: thvcuenv_u_msfc_out(mix,0:mkx,nseg,niter)  !  Updraft        thvcuenv at the interface for each original updraft segment [ K ].
   real(r8)                :: thvegenv_u_msfc_out(mix,0:mkx,nseg,niter)  !  Updraft        thvegenv at the interface for each original updraft segment [ K ].
   real(r8)                :: thvxsenv_u_msfc_out(mix,0:mkx,nseg,niter)  !  Updraft        thvxsenv at the interface for each original updraft segment [ K ].
   real(r8)                :: fmix_u_msfc_out(mix,0:mkx,nseg,niter)      !  Updraft            fmix at the interface for each original updraft segment [ no ].
   real(r8)                :: cmfumix_u_msfc_out(mix,0:mkx,nseg,niter)   !  Updraft         cmfumix at the interface for each original updraft segment [ kg / s / m^2 ].

   real(r8)                :: thl_d_msfc_out(mix,0:mkx,nseg,niter)       !  Mass-flux weighted  mean downdraft      thl at the interface for each original updraft segment [ K ].
   real(r8)                :: qt_d_msfc_out(mix,0:mkx,nseg,niter)        !  Mass-flux weighted  mean downdraft       qt at the interface for each original updraft segment [ kg / kg ].
   real(r8)                :: u_d_msfc_out(mix,0:mkx,nseg,niter)         !  Mass-flux weighted  mean downdraft        u at the interface for each original updraft segment [ m / s ].
   real(r8)                :: v_d_msfc_out(mix,0:mkx,nseg,niter)         !  Mass-flux weighted  mean downdraft        v at the interface for each original updraft segment [ m / s ].
   real(r8)                :: w_d_msfc_out(mix,0:mkx,nseg,niter)         !  Mass-flux weighted  mean downdraft        w at the interface for each original updraft segment [ m / s ].
   real(r8)                :: ql_d_msfc_out(mix,0:mkx,nseg,niter)        !  Mass-flux weighted  mean downdraft       ql at the interface for each original updraft segment [ kg / kg ].
   real(r8)                :: qi_d_msfc_out(mix,0:mkx,nseg,niter)        !  Mass-flux weighted  mean downdraft       qi at the interface for each original updraft segment [ kg / kg ].
   real(r8)                :: tr_d_msfc_out(mix,0:mkx,nseg,ncnst,niter)  !  Mass-flux weighted  mean downdraft       tr at the interface for each original updraft segment [ # / kg, kg / kg ].
   real(r8)                :: wa_d_msfc_out(mix,0:mkx,nseg,niter)        !  Area-weighted       mean downdraft        w at the interface for each original updraft segment [ m / s ].
   real(r8)                :: qla_d_msfc_out(mix,0:mkx,nseg,niter)       !  Area-weighted       mean downdraft       ql at the interface for each original updraft segment [ kg / kg ].
   real(r8)                :: qia_d_msfc_out(mix,0:mkx,nseg,niter)       !  Area-weighted       mean downdraft       qi at the interface for each original updraft segment [ kg / kg ].
   real(r8)                :: cmf_d_msfc_out(mix,0:mkx,nseg,niter)       !  Net                      downdraft      cmf at the interface for each original updraft segment [ kg / s / m^2 ].
   real(r8)                :: a_d_msfc_out(mix,0:mkx,nseg,niter)         !  Net                      downdraft        a at the interface for each original updraft segment [ fraction ].

   integer                 :: ktop_msfc_out(mix,nseg,niter)              !  The top layer index of individual original updraft segment defined at surface [ no ]
   real(r8)                :: ptop_msfc_out(mix,nseg,niter)              !  Updraft top height  of individual original updraft segment defined at surface [ Pa ]
   real(r8)                :: ztop_msfc_out(mix,nseg,niter)              !  Updraft top height  of individual original updraft segment defined at surface [ m ]

   real(r8)                :: thv_b_out(mix,0:mkx) 
   real(r8)                :: thv_t_out(mix,0:mkx) 
   real(r8)                :: thv_mt_out(mix,0:mkx) 
   real(r8)                :: thv_min_out(mix,0:mkx) 

!a  real(r8)                :: CFL_out(mix,mkx) 

   ! --------------------------- !
   ! Exit condition and limiters !
   ! --------------------------- !

!f  real(r8)  exit_Cu(mix)                        

   ! ----------------------------------------------------------- ! 
   ! One-dimensional local variables defined at each grid column !
   ! k = 0   : Surface interface                                 !
   ! k = 1   : Lowest layer                                      !
   ! k = mkx : Top layer                                         !
   ! ----------------------------------------------------------- !

   ! --------------- !
   ! Input variables !
   ! --------------- !

   real(r8)    ps0(0:mkx)                       !  Environmental pressure at the interface [Pa]
   real(r8)    zs0(0:mkx)                       !  Environmental height   at the interface [m]
   real(r8)    p0(mkx)                          !  Environmental pressure at the mid-point [Pa]
   real(r8)    z0(mkx)                          !  Environmental height   at the mid-point [m]
   real(r8)    dp0(mkx)                         !  Environmental layer pressure thickness  [Pa] ( > 0 )
   real(r8)    dpdry0(mkx)                      !  Environmental layer dry pressure thickness  [Pa] ( > 0 )

   real(r8)    u0(mkx)                          !  Environmental zonal wind [m/s]
   real(r8)    v0(mkx)                          !  Environmental meridional wind [m/s]
   real(r8)    qv0(mkx)                         !  Environmental water vapor specific humidity [kg/kg]
   real(r8)    ql0(mkx)                         !  Environmental liquid water mixing ratio [kg/kg]
   real(r8)    qi0(mkx)                         !  Environmental ice mixing ratio [kg/kg]
   real(r8)    tr0(mkx,ncnst)                   !  Environmental tracers [ #/kg, kg/kg ]
   real(r8)    t0(mkx)                          !  Environmental temperature [K]
   real(r8)    s0(mkx)                          !  Environmental dry static energy [J/kg]

   real(r8)    ast0(mkx)                        !  Stratiform fractional area at the layer mid-point [ fraction ]
   real(r8)    tke0(0:mkx)                      !  TKE [ m2/s2 ]
   real(r8)    bprod0(0:mkx)                    !  Buoyancy production [ m2/s3 ]

   ! -------------------------------------------------------- !
   ! Environmental variables derived from the input variables !
   ! -------------------------------------------------------- !

   real(r8)    dptr0(mkx,ncnst)                 !  Environmental layer pressure thickness for each dry or moist tracers [Pa] ( > 0 )
   real(r8)    dz0(mkx)                         !  Environmental layer thickness  [m] ( > 0 )
   real(r8)    dzs0(0:mkx)                      !  Environmental interfacial layer thickness  [m] ( > 0 )
   real(r8)    dps0(0:mkx)                      !  Environmental interfacial layer pressure thickness  [Pa] ( > 0 )

   real(r8)    qt0(mkx)                         !  Environmental total specific humidity [kg/kg]
   real(r8)    thl0(mkx)                        !  Environmental liquid potential temperature [K]
   real(r8)    thvl0(mkx)                       !  Environmental liquid virtual potential temperature [K]
   real(r8)    thv0(mkx)                        !  Environmental virtual potential temperature [K]
   real(r8)    rh0(mkx)                         !  Environmental mean rh [fraction]
   real(r8)    ssqt0(mkx)                       !  Vertical gradient of qt0 [kg/kg/Pa]
   real(r8)    ssthl0(mkx)                      !  Vertical gradient of thl0 [K/Pa]
   real(r8)    ssu0(mkx)                        !  Vertical gradient of u0 [m/s/Pa]
   real(r8)    ssv0(mkx)                        !  Vertical gradient of v0 [m/s/Pa]
   real(r8)    u_grd0(mkx)                      !  Vertical gradient of u0 for computing PGFc effect [m/s/Pa]
   real(r8)    v_grd0(mkx)                      !  Vertical gradient of v0 for computing PGFc effect [m/s/Pa]
   real(r8)    rho0(mkx)                        !  Environmental density [kg/m3]

   real(r8)    thl0bot(mkx)                     !  Environmental thl at the bottom interface [K]
   real(r8)    thl0top(mkx)                     !  Environmental thl at the top interface [K]
   real(r8)    qt0bot(mkx)                      !  Environmental qt at the bottom interface [kg/kg]
   real(r8)    qt0top(mkx)                      !  Environmental qt at the top interface [kg/kg]
   real(r8)    u0bot(mkx)                       !  Environmental u at the bottom interface [m/s]
   real(r8)    u0top(mkx)                       !  Environmental u at the top interface [m/s]
   real(r8)    v0bot(mkx)                       !  Environmental v at the bottom interface [m/s]
   real(r8)    v0top(mkx)                       !  Environmental v at the top interface [m/s]
   real(r8)    thv0bot(mkx)                     !  Environmental virtual potential temperature at the bottom interface [K]
   real(r8)    thv0top(mkx)                     !  Environmental virtual potential temperature at the top interface [K]
   real(r8)    thvl0bot(mkx)                    !  Environmental thvl at the bottom interface [K]
   real(r8)    thvl0top(mkx)                    !  Environmental thvl at the top interface [K]
   real(r8)    ql0bot(mkx)                      !  Environmental ql at the bottom interface [kg/kg]
   real(r8)    ql0top(mkx)                      !  Environmental ql at the top interface [kg/kg]
   real(r8)    qi0bot(mkx)                      !  Environmental qi at the bottom interface [kg/kg]
   real(r8)    qi0top(mkx)                      !  Environmental qi at the top interface [kg/kg]
   real(r8)    tr0bot(mkx,ncnst)                !  Environmental tracer at the bottom interface [#/kg, kg/kg]
   real(r8)    tr0top(mkx,ncnst)                !  Environmental tracer at the top    interface [#/kg, kg/kg]
   real(r8)    rho0bot(mkx)                     !  Environmental density at the bottom interface [kg/m3]
   real(r8)    rho0top(mkx)                     !  Environmental density at the top interface [kg/m3]
   real(r8)    rh0bot(mkx)                      !  Environmental RH at the bottom interface [0-1]
   real(r8)    rh0top(mkx)                      !  Environmental RH at the top interface [0-1]
   real(r8)    exn0(mkx)                        !  Exner function at the mid-points
   real(r8)    exns0(0:mkx)                     !  Exner function at the interfaces
   real(r8)    ssthv0(mkx)                      !  Vertical gradient of thv0  [K/Pa]
   real(r8)    ssthvl0(mkx)                     !  Vertical gradient of thvl0 [K/Pa]
   real(r8)    ssql0(mkx)                       !  Vertical gradient of ql0   [kg/kg/Pa]
   real(r8)    ssqi0(mkx)                       !  Vertical gradient of qi0   [kg/kg/Pa]
   real(r8)    sstr0(mkx,ncnst)                 !  Vertical gradient of environmental tracers [ #/kg/Pa, kg/kg/Pa ]

   ! ----------------- !
   ! Cumulus variables !
   ! ----------------- !

   real(r8)    flxrain(0:mkx)                   !  Grid-mean convective rain flux after evaporation within downdraft and environment [kg/m2/s]
   real(r8)    flxsnow(0:mkx)                   !  Grid-mean convective snow flux after evaporation within downdraft and environment [kg/m2/s]
   real(r8)    flxtrrs(0:mkx,ncnst)             !  Grid-mean convective tracer flux after evaporation within downdraft and environment [kg(#)/m2/s]

   real(r8)    flxrain_msfc(0:mkx,nseg)         !  Grid-mean convective rain flux after evaporation within downdraft and environment for each original updraft segment [kg/m2/s]
   real(r8)    flxsnow_msfc(0:mkx,nseg)         !  Grid-mean convective snow flux after evaporation within downdraft and environment for each original updraft segment [kg/m2/s]
   real(r8)    flxtrrs_msfc(0:mkx,nseg,ncnst)   !  Grid-mean convective tracer flux after evaporation within downdraft and environment for each original updraft segment [kg(#)/m2/s]

!?  real(r8)    flxrain_prevp(0:mkx)             !  Grid-mean convective rain flux before evaporation within downdraft/environment [kg/m2/s]
!?  real(r8)    flxsnow_prevp(0:mkx)             !  Grid-mean convective snow flux before evaporation within downdraft/environment [kg/m2/s]
!?  real(r8)    flxtrrs_prevp(0:mkx,ncnst)       !  Grid-mean convective tracer flux before evaporation within downdraft/environment [kg(#)/m2/s]

!?  real(r8)    flxrain_prevp_msfc(0:mkx,nseg)   !  Grid-mean convective rain flux before evaporation within downdraft/environment for each original updraft segment [kg/m2/s]
!?  real(r8)    flxsnow_prevp_msfc(0:mkx,nseg)   !  Grid-mean convective snow flux before evaporation within downdraft/environment for each original updraft segment [kg/m2/s]
!?  real(r8)    flxtrrs_prevp_msfc(0:mkx,nseg,ncnst)   !  Grid-mean convective tracer flux before evaporation within downdraft/environment for each original updraft segment [kg(#)/m2/s]

!?  real(r8)    flxrain_ava(0:mkx)               !  Grid-mean convective rain flux after evaporation within downdraft [kg/m2/s]
!?  real(r8)    flxsnow_ava(0:mkx)               !  Grid-mean convective snow flux after evaporation within downdraft [kg/m2/s]
!?  real(r8)    flxtrrs_ava(0:mkx,ncnst)         !  Grid-mean convective tracer flux after evaporation within downdraft [kg(#)/m2/s]

!?  real(r8)    flxrain_ava_msfc(0:mkx,nseg)     !  Grid-mean convective rain flux after evaporation within downdraft for each original updraft segment [kg/m2/s]
!?  real(r8)    flxsnow_ava_msfc(0:mkx,nseg)     !  Grid-mean convective snow flux after evaporation within downdraft for each original updraft segment [kg/m2/s]
!?  real(r8)    flxtrrs_ava_msfc(0:mkx,nseg,ncnst)     !  Grid-mean convective tracer flux after evaporation within downdraft for each original updraft segment [kg(#)/m2/s]

!?  real(r8)    flxrain_aftdn(0:mkx)             !  Grid-mean convective rain flux before evaporation within downdraft/environment [kg/m2/s]
!?  real(r8)    flxsnow_aftdn(0:mkx)             !  Grid-mean convective snow flux before evaporation within downdraft/environment [kg/m2/s]
!?  real(r8)    flxtrrs_aftdn(0:mkx,ncnst)       !  Grid-mean convective tracer flux before evaporation within downdraft/environment [kg(#)/m2/s]

   real(r8)    cmf_u_mix(mkx)                   !  Total amount of updraft mass flux involved in the buoyancy sorting [kg/m2/s]
   real(r8)    cmf_r(mkx)                       !  Total amount of detrained mass into the environment mass [kg/m2/s]
   real(r8)    thl_r(mkx)                       !  Mass flux weighted conservative scalar of detrained airs  
   real(r8)    qt_r(mkx)                        !  Same as above
   real(r8)    u_r(mkx)                         !  Same as above
   real(r8)    v_r(mkx)                         !  Same as above
   real(r8)    ql_r(mkx)                        !  Same as above
   real(r8)    qi_r(mkx)                        !  Same as above
   real(r8)    tr_r(mkx,ncnst)                  !  Same as above

   ! ------------------------------------------------------------------------------------------------------------------------ !
   ! Below '2' variables are same as the above, but only consider the detrained component purely from the convective updraft, !
   ! not from the environmental airs involved in the mixing. This approach is very important because this approach is         !
   ! fully consistently connecting the 'flux-convergence formula' to the 'subsidence-detrainment form' particularly           !
   ! for the budget of cloud condensate. This approach will be directly used for simulating the effect of convective          !
   ! detrainment on the critical relative humidity in the stratiform macrophysics. In addition, this approach may be          !
   ! used for defining the mixing environmental air, instead of the above approach.                                           !
   ! ------------------------------------------------------------------------------------------------------------------------ !  

   real(r8)    cmf_r2(mkx)                     
   real(r8)    thl_r2(mkx)                     
   real(r8)    qt_r2(mkx)                      
   real(r8)    u_r2(mkx)                       
   real(r8)    v_r2(mkx)                       
   real(r8)    ql_r2(mkx)                      
   real(r8)    qi_r2(mkx)                      
   real(r8)    tr_r2(mkx,ncnst)                

  ! real(r8)    cmf_u_mix_org(mkx)               !  Same as above 
  ! real(r8)    cmf_r_org(mkx)                   !  Same as above
  ! real(r8)    thl_r_org(mkx)                   !  Same as above
  ! real(r8)    qt_r_org(mkx)                    !  Same as above
  ! real(r8)    u_r_org(mkx)                     !  Same as above
  ! real(r8)    v_r_org(mkx)                     !  Same as above
  ! real(r8)    ql_r_org(mkx)                    !  Same as above
  ! real(r8)    qi_r_org(mkx)                    !  Same as above
  ! real(r8)    tr_r_org(mkx,ncnst)              !  Same as above

  ! real(r8)    eta1_a(mkx)                      !  'a_pd / am_d' computed at the end of the first iteration, iter = 1.
  ! real(r8)    eta2_a(mkx)                      !  'a_pd /  a_p' computed at the end of the first iteration, iter = 1. 

   real(r8)    cmf_u(0:mkx)                     !  Total updraft mass flux at the model interface [ kg / m2 / s ] 
   real(r8)    w_u(0:mkx)                       !  Mass-flux weighted updraft vertical velocity [ m / s ]
   real(r8)    wa_u(0:mkx)                      !  Area weighted updraft vertical velocity [ m / s ]
   real(r8)    a_u(0:mkx)                       !  Physical updraft fractional area [ fraction ]
   real(r8)    num_u(0:mkx)                     !  Number density of updraft plumes [ # / m^2 ]
   real(r8)    rad_u(0:mkx)                     !  Physical mean effective radius of updraft plumes [ m ] 
   real(r8)    gamw_u(0:mkx)                    !  The ratio of 'mass-flux weighted' and 'area weighted' updraft vertical velocity. [ ratio ] >= 1.
   real(r8)    thl_u(0:mkx)                     !  Mass-flux weighted updraft liquid potential temperature [ K ]
   real(r8)    qt_u(0:mkx)                      !  Mass-flux weighted updraft total specific humidity [ kg / kg ]
   real(r8)    u_u(0:mkx)                       !  Mass-flux weighted updraft zonal velocity [ m / s ]
   real(r8)    v_u(0:mkx)                       !  Mass-flux weighted updraft meridional velocity [ m / s ]
   real(r8)    ql_u(0:mkx)                      !  Mass-flux weighted in-cloud LWC     within convective   updraft [ kg / kg ]
   real(r8)    qi_u(0:mkx)                      !  Mass-flux weighted in-cloud IWC     within convective   updraft [ kg / kg ]
   real(r8)    qla_u(0:mkx)                     !  Area weighted in-cloud LWC within convective   updraft [ kg / kg ]
   real(r8)    qia_u(0:mkx)                     !  Area weighted in-cloud IWC within convective   updraft [ kg / kg ] 
   real(r8)    tr_u(0:mkx,ncnst)                !  Mass-flux weighted in-cloud tracers within convective   updraft [ # / kg, kg / kg ] 
   real(r8)    thva_u(0:mkx)                    !  Area weighted thv within updraft [ K ]

   real(r8)    cmf_u_dia(mkx)                   !  Total updraft mass flux at individual cloud tops [ kg / m2 / s ] 
   real(r8)    evp_thll_u(mkx)                  !  Mass-flux weighted diabatic change of updraft 'thl' at each cloud top due to evaporation of rain [ K ] <= 0.
   real(r8)    evp_qtl_u(mkx)                   !  Mass-flux weighted diabatic change of updraft 'qt'  at each cloud top due to evaporation of rain [ kg / kg ] >= 0.
   real(r8)    evp_thli_u(mkx)                  !  Mass-flux weighted diabatic change of updraft 'thl' at each cloud top due to evaporation of snow [ K ] <= 0.
   real(r8)    evp_qti_u(mkx)                   !  Mass-flux weighted diabatic change of updraft 'qt'  at each cloud top due to evaporation of snow [ kg / kg ] >= 0.
   real(r8)    evp_tr_u(mkx,ncnst)              !  Mass-flux weighted diabatic change of updraft  tracer  at each cloud top due to evaporation of rain + snow [ # / kg, kg / kg ]
   real(r8)    prep_thll_u(mkx)                 !  Mass-flux weighted diabatic change of updraft 'thl' at each cloud top due to production  of rain [ K ] >= 0.
   real(r8)    prep_qtl_u(mkx)                  !  Mass-flux weighted diabatic change of updraft 'qt'  at each cloud top due to production  of rain [ kg / kg ] <= 0.
   real(r8)    prep_thli_u(mkx)                 !  Mass-flux weighted diabatic change of updraft 'thl' at each cloud top due to production  of snow [ K ] >= 0.
   real(r8)    prep_qti_u(mkx)                  !  Mass-flux weighted diabatic change of updraft 'qt'  at each cloud top due to production  of snow [ kg / kg ] <= 0.
   real(r8)    prep_tr_u(mkx,ncnst)             !  Mass-flux weighted diabatic change of updraft  tracer  at each cloud top due to production  of rain + snow [ # / kg, kg / kg ]
   real(r8)    eff_ql_u(mkx)                    !  Mass-flux weighted diabatic change of updraft 'ql'  at each cloud top due to effective diabatic forcing on cloud condensate [ kg / kg ]
   real(r8)    eff_qi_u(mkx)                    !  Mass-flux weighted diabatic change of updraft 'qi'  at each cloud top due to effective diabatic forcing on cloud condensate [ kg / kg ]
   real(r8)    eff_tr_u(mkx,ncnst)              !  Mass-flux weighted diabatic change of updraft  tracer  at each cloud top due to effective diabatic forcing on the tracer [ # / kg, kg / kg ]
   real(r8)    PGF_u_u(mkx)                     !  Mass-flux weighted diabatic change of updraft 'u'   at each cloud top due to horizontal PGF forcing [ m / s ]
   real(r8)    PGF_v_u(mkx)                     !  Mass-flux weighted diabatic change of updraft 'v'   at each cloud top due to horizontal PGF forcing [ m / s ]
!   real(r8)    wdep_tr_u(mkx,ncnst)             !  Mass-flux weighted diabatic change of updraft  tracer  at each cloud top due to wet deposition of in-cumulus aerosols 
!                                                !            including both the cloud-borne and interstitial aerosols within cumulus updraft [ # / kg, kg / kg ]
                                                 !  Feb.06.2013. This is unnecessary since wet deposition of aerosols within cumulus updraft (both interstitial and cloud-borne)
                                                 !               will be treated as a part of prep_tr_u.           

   real(r8)    f_srcd(mkx)                      !  Total source of downdraft generated from the updraft. f_srcd(k) = f_dd(k) + f_dud(k) + f_nud(k). [ ratio ] >= 0. 
   real(r8)    thl_srcd(mkx)                    !  Mass-flux weighted thl of net sources of downdraft [ K ]
   real(r8)    qt_srcd(mkx)                     !  Mass-flux weighted qt  of net sources of downdraft [ kg / kg ]
   real(r8)    u_srcd(mkx)                      !  Mass-flux weighted u   of net sources of downdraft [ m / s ]
   real(r8)    v_srcd(mkx)                      !  Mass-flux weighted v   of net sources of downdraft [ m / s ]
   real(r8)    tr_srcd(mkx,ncnst)               !  Mass-flux weighted tracer  of net sources of downdraft [ # / kg, kg / kg ]
   real(r8)    ql_srcd(mkx)                     !  Mass-flux weighted ql  of net sources of downdraft [ kg / kg ]
   real(r8)    qi_srcd(mkx)                     !  Mass-flux weighted qi  of net sources of downdraft [ kg / kg ]

   real(r8)    f_srcds(mkx,nseg,3)              !  Total source of downdraft generated from the updraft. f_srcd(k) = f_dd(k) + f_dud(k) + f_nud(k). [ ratio ] >= 0. 
   real(r8)    thl_srcds(mkx,nseg,3)            !  The thl of net sources of downdraft [ K ]
   real(r8)    qt_srcds(mkx,nseg,3)             !  The qt  of net sources of downdraft [ kg / kg ]
   real(r8)    u_srcds(mkx,nseg,3)              !  The u   of net sources of downdraft [ m / s ]
   real(r8)    v_srcds(mkx,nseg,3)              !  The v   of net sources of downdraft [ m / s ]
   real(r8)    tr_srcds(mkx,nseg,3,ncnst)       !  The tracer of net sources of downdraft [ # / kg, kg / kg ]
   real(r8)    ql_srcds(mkx,nseg,3)             !  The ql  of net sources of downdraft [ kg / kg ]
   real(r8)    qi_srcds(mkx,nseg,3)             !  The qi  of net sources of downdraft [ kg / kg ]

   real(r8)    f_srcr(mkx)                      !  Total source of remained airs generated from the updraft. f_srcr(k) = f_dr(k) + f_dur(k) + f_nur(k). [ ratio ] >= 0. 
   real(r8)    thl_srcr(mkx)                    !  Mass-flux weighted thl of net sources of remained airs [ K ]
   real(r8)    qt_srcr(mkx)                     !  Mass-flux weighted qt  of net sources of remained airs [ kg / kg ]
   real(r8)    u_srcr(mkx)                      !  Mass-flux weighted u   of net sources of remained airs [ m / s ]
   real(r8)    v_srcr(mkx)                      !  Mass-flux weighted v   of net sources of remained airs [ m / s ]
   real(r8)    tr_srcr(mkx,ncnst)               !  Mass-flux weighted tracer  of net sources of remained airs [ # / kg, kg / kg ]
   real(r8)    ql_srcr(mkx)                     !  Mass-flux weighted ql  of net sources of remained airs [ kg / kg ]
   real(r8)    qi_srcr(mkx)                     !  Mass-flux weighted qi  of net sources of remained airs [ kg / kg ]

   real(r8)    f_srcr2(mkx)                     
   real(r8)    thl_srcr2(mkx)                   
   real(r8)    qt_srcr2(mkx)                    
   real(r8)    u_srcr2(mkx)                     
   real(r8)    v_srcr2(mkx)                     
   real(r8)    tr_srcr2(mkx,ncnst)              
   real(r8)    ql_srcr2(mkx)                    
   real(r8)    qi_srcr2(mkx)                    

   real(r8)    f_srcrs(mkx,nseg,3)              !  Total source of remained airs generated from the updraft. f_srcr(k) = f_dr(k) + f_dur(k) + f_nur(k). [ ratio ] >= 0. 
   real(r8)    thl_srcrs(mkx,nseg,3)            !  The thl of net sources of remained airs [ K ]
   real(r8)    qt_srcrs(mkx,nseg,3)             !  The qt  of net sources of remained airs [ kg / kg ]
   real(r8)    u_srcrs(mkx,nseg,3)              !  The u   of net sources of remained airs [ m / s ]
   real(r8)    v_srcrs(mkx,nseg,3)              !  The v   of net sources of remained airs [ m / s ]
   real(r8)    tr_srcrs(mkx,nseg,3,ncnst)       !  The tracer  of net sources of remained airs [ # / kg , kg / kg ]
   real(r8)    ql_srcrs(mkx,nseg,3)             !  The ql  of net sources of remained airs [ kg / kg ]
   real(r8)    qi_srcrs(mkx,nseg,3)             !  The qi  of net sources of remained airs [ kg / kg ]

   real(r8)    f_srcrs2(mkx,nseg,3)            
   real(r8)    thl_srcrs2(mkx,nseg,3)          
   real(r8)    qt_srcrs2(mkx,nseg,3)           
   real(r8)    u_srcrs2(mkx,nseg,3)            
   real(r8)    v_srcrs2(mkx,nseg,3)            
   real(r8)    tr_srcrs2(mkx,nseg,3,ncnst)     
   real(r8)    ql_srcrs2(mkx,nseg,3)           
   real(r8)    qi_srcrs2(mkx,nseg,3)           

   integer     kdtd(mkx,nseg,3)                 !  The detrained layer index of convective downdraft that was generated in the 'k' layer from
                                                !  the 'm' (not msfc) updraft segment with a type of 'ids'. Not used in the new evaporation code with 'i_dnconon .eq. 1'. 

   real(r8)    cmf_ru(mkx)                      !  f_srcr(mkx) * cmf_u(km) [ kg / m^2 / s ]
   real(r8)    thl_ru(mkx)                      !  = thl_srcr(mkx)
   real(r8)    qt_ru(mkx)                       !  = qt_srcr(mkx)
   real(r8)    u_ru(mkx)                        !  = u_srcr(mkx)
   real(r8)    v_ru(mkx)                        !  = v_srcr(mkx)
   real(r8)    ql_ru(mkx)                       !  = ql_srcr(mkx)
   real(r8)    qi_ru(mkx)                       !  = qi_srcr(mkx)
   real(r8)    tr_ru(mkx,ncnst)                 !  = tr_srcr(mkx,ncnst)

   real(r8)    cmf_ru2(mkx)                     
   real(r8)    thl_ru2(mkx)                     
   real(r8)    qt_ru2(mkx)                      
   real(r8)    u_ru2(mkx)                       
   real(r8)    v_ru2(mkx)                       
   real(r8)    ql_ru2(mkx)                      
   real(r8)    qi_ru2(mkx)                      
   real(r8)    tr_ru2(mkx,ncnst)                

   real(r8)    cmf_ad(0:mkx,mkx,nseg,3)         !  Downdraft mass flux at the model interface     originated from the downdraft sources of the 'k' layer [ kg / m^2 / s ] >= 0.
   real(r8)    w_ad(0:mkx,mkx,nseg,3)           !  Mass-flux weighted downdraft vertical velocity originated from the downdraft sources of the 'k' layer [ m / s ]
   real(r8)    a_ad(0:mkx,mkx,nseg,3)           !  Physical downdraft fractional area             originated from the downdraft sources of the 'k' layer [ fraction ]
   real(r8)    thl_ad(0:mkx,mkx,nseg,3)         !  Mass-flux weighted downdraft thl               originated from the downdraft sources of the 'k' layer [ K ]
   real(r8)    qt_ad(0:mkx,mkx,nseg,3)          !  Mass-flux weighted downdraft qt                originated from the downdraft sources of the 'k' layer [ kg / kg ]
   real(r8)    u_ad(0:mkx,mkx,nseg,3)           !  Mass-flux weighted downdraft u                 originated from the downdraft sources of the 'k' layer [ m / s ]
   real(r8)    v_ad(0:mkx,mkx,nseg,3)           !  Mass-flux weighted downdraft v                 originated from the downdraft sources of the 'k' layer [ m / s ]
   real(r8)    ql_ad(0:mkx,mkx,nseg,3)          !  Mass-flux weighted downdraft ql                originated from the downdraft sources of the 'k' layer [ kg / kg ]
   real(r8)    qi_ad(0:mkx,mkx,nseg,3)          !  Mass-flux weighted downdraft qi                originated from the downdraft sources of the 'k' layer [ kg / kg ]
   real(r8)    tr_ad(0:mkx,mkx,nseg,3,ncnst)    !  Mass-flux weighted downdraft tracer            originated from the downdraft sources of the 'k' layer [ # / kg, kg / kg ]

   real(r8)    dpad(mkx,mkx,nseg,3)              

   real(r8)    cmf_d(0:mkx)                     !  Total downdraft mass flux at the model interface [ kg / m^2 / s ] >= 0.
   real(r8)    w_d(0:mkx)                       !  Mass-flux weighted downdraft vertical velocity   [ m / s ]
   real(r8)    wa_d(0:mkx)                      !  Area weighted downdraft vertical velocity        [ m / s ]
   real(r8)    a_d(0:mkx)                       !  Physical downdraft fractional area               [ fraction ]
   real(r8)    thl_d(0:mkx)                     !  Mass-flux weighted downdraft thl                 [ K ]
   real(r8)    qt_d(0:mkx)                      !  Mass-flux weighted downdraft qt                  [ kg / kg ]
   real(r8)    u_d(0:mkx)                       !  Mass-flux weighted downdraft u                   [ m / s ]
   real(r8)    v_d(0:mkx)                       !  Mass-flux weighted downdraft v                   [ m / s ]
   real(r8)    ql_d(0:mkx)                      !  Mass-flux weighted in-cloud LWC     within convective downdraft [ kg / kg ]
   real(r8)    qi_d(0:mkx)                      !  Mass-flux weighted in-cloud IWC     within convective downdraft [ kg / kg ] 
   real(r8)    qla_d(0:mkx)                     !  Area weighted in-cloud LWC within convective downdraft [ kg / kg ]
   real(r8)    qia_d(0:mkx)                     !  Area weighted in-cloud IWC within convective downdraft [ kg / kg ] 
   real(r8)    tr_d(0:mkx,ncnst)                !  Mass-flux weighted downdraft tracer              [ # / kg, kg / kg ]

!d  real(r8)    cmf_d_org(0:mkx)                 !  Total downdraft mass flux at the model interface [ kg / m^2 / s ] >= 0.
!d  real(r8)    thl_d_org(0:mkx)                 !  Mass-flux weighted downdraft thl                 [ K ]
!d  real(r8)    qt_d_org(0:mkx)                  !  Mass-flux weighted downdraft qt                  [ kg / kg ]

   real(r8)    cmf_ar(mkx,mkx,nseg,3)           !  The mass flux of detrained airs into environment from the downdraft originated from the downdraft sources of the 'k' layer [ kg / m^2 / s ] >= 0.
   real(r8)    thl_ar(mkx,mkx,nseg,3)           !  Mass-flux weighted thl of detrained airs         from the downdraft originated from the downdraft sources of the 'k' layer [ K ]
   real(r8)    qt_ar(mkx,mkx,nseg,3)            !  Mass-flux weighted qt  of detrained airs         from the downdraft originated from the downdraft sources of the 'k' layer [ kg / kg ]
   real(r8)    u_ar(mkx,mkx,nseg,3)             !  Mass-flux weighted u   of detrained airs         from the downdraft originated from the downdraft sources of the 'k' layer [ m / s ]
   real(r8)    v_ar(mkx,mkx,nseg,3)             !  Mass-flux weighted v   of detrained airs         from the downdraft originated from the downdraft sources of the 'k' layer [ m / s ]
   real(r8)    tr_ar(mkx,mkx,nseg,3,ncnst)      !  Mass-flux weighted tracer  of detrained airs     from the downdraft originated from the downdraft sources of the 'k' layer [ # / kg, kg / kg ]
   real(r8)    ql_ar(mkx,mkx,nseg,3)            !  Mass-flux weighted ql  of detrained airs         from the downdraft originated from the downdraft sources of the 'k' layer [ kg / kg ]
   real(r8)    qi_ar(mkx,mkx,nseg,3)            !  Mass-flux weighted qi  of detrained airs         from the downdraft originated from the downdraft sources of the 'k' layer [ kg / kg ]

   real(r8)    cmf_rd(mkx)                      !  The mass flux of detrained airs into environment from the downdraft [ kg / m^2 / s ] >= 0.
   real(r8)    thl_rd(mkx)                      !  Mass-flux weighted thl     of detrained airs     from the downdraft [ K ]
   real(r8)    qt_rd(mkx)                       !  Mass-flux weighted qt      of detrained airs     from the downdraft [ kg / kg ]
   real(r8)    u_rd(mkx)                        !  Mass-flux weighted u       of detrained airs     from the downdraft [ m / s ]
   real(r8)    v_rd(mkx)                        !  Mass-flux weighted v       of detrained airs     from the downdraft [ m / s ]
   real(r8)    ql_rd(mkx)                       !  Mass-flux weighted ql      of detrained airs     from the downdraft [ kg / kg ]
   real(r8)    qi_rd(mkx)                       !  Mass-flux weighted qi      of detrained airs     from the downdraft [ kg / kg ]
   real(r8)    tr_rd(mkx,ncnst)                 !  Mass-flux weighted tracer  of detrained airs     from the downdraft [ # / kg, kg / kg ]

   real(r8)    cmf_ad_dia(mkx,mkx,nseg,3)       !  Downdraft mass flux at each downdraft base in each layer originated from the downdraft sources of the 'k' layer [ kg / m2 / s ] >= 0. 
   real(r8)    evp_thll_ad(mkx,mkx,nseg,3)      !  Diabatic change of downdraft 'thl'   at each downdraft base due to evaporation of rain [ K ] <= 0.
   real(r8)    evp_qtl_ad(mkx,mkx,nseg,3)       !  Diabatic change of downdraft 'qt'    at each downdraft base due to evaporation of rain [ kg / kg ] >= 0.
   real(r8)    evp_thli_ad(mkx,mkx,nseg,3)      !  Diabatic change of downdraft 'thl'   at each downdraft base due to evaporation of snow [ K ] <= 0.
   real(r8)    evp_qti_ad(mkx,mkx,nseg,3)       !  Diabatic change of downdraft 'qt'    at each downdraft base due to evaporation of snow [ kg / kg ] >= 0.
   real(r8)    evp_tr_ad(mkx,mkx,nseg,3,ncnst)  !  Diabatic change of downdraft  tracer at each downdraft base due to evaporation of rain + snow [ kg / kg ]
   real(r8)    prep_thll_ad(mkx,mkx,nseg,3)     !  Diabatic change of downdraft 'thl'   at each downdraft base due to production  of rain [ K ] >= 0.
   real(r8)    prep_qtl_ad(mkx,mkx,nseg,3)      !  Diabatic change of downdraft 'qt'    at each downdraft base due to production  of rain [ kg / kg ] <= 0.
   real(r8)    prep_thli_ad(mkx,mkx,nseg,3)     !  Diabatic change of downdraft 'thl'   at each downdraft base due to production  of snow [ K ] >= 0.
   real(r8)    prep_qti_ad(mkx,mkx,nseg,3)      !  Diabatic change of downdraft 'qt'    at each downdraft base due to production  of snow [ kg / kg ] <= 0.
   real(r8)    prep_tr_ad(mkx,mkx,nseg,3,ncnst) !  Diabatic change of downdraft  tracer at each downdraft base due to production  of rain + snow [ # / kg, kg / kg ]
   real(r8)    eff_ql_ad(mkx,mkx,nseg,3)        !  Diabatic change of downdraft 'ql'    at each downdraft base due to effective diabatic forcing on cloud condensate [ kg / kg ]
   real(r8)    eff_qi_ad(mkx,mkx,nseg,3)        !  Diabatic change of downdraft 'qi'    at each downdraft base due to effective diabatic forcing on cloud condensate [ kg / kg ]
   real(r8)    eff_tr_ad(mkx,mkx,nseg,3,ncnst)  !  Diabatic change of downdraft  tracer at each downdraft base due to effective diabatic forcing on tracer [ # / kg, kg / kg ]
   real(r8)    PGF_u_ad(mkx,mkx,nseg,3)         !  Diabatic change of downdraft 'u'     at each downdraft base due to horizontal PGF forcing [ m / s ]
   real(r8)    PGF_v_ad(mkx,mkx,nseg,3)         !  Diabatic change of downdraft 'v'     at each downdraft base due to horizontal PGF forcing [ m / s ]
   real(r8)    wdep_tr_ad(mkx,mkx,nseg,3,ncnst) !  Diabatic change of downdraft  tracer at each downdraft base due to wet deposition of aerosols within downdraft
                                                !                     including both the cloud-borne and interstitial aerosols within convective downdraft [ # / kg, kg / kg ]

   real(r8)    cmf_d_dia(mkx)                   !  Total downdraft mass flux at the downdraft base in each layer [ kg / m2 / s ] >= 0. 
   real(r8)    evp_thll_d(mkx)                  !  Mass-flux weighted diabatic change of downdraft 'thl'   at the downdraft base due to evaporation of rain [ K ] <= 0.
   real(r8)    evp_qtl_d(mkx)                   !  Mass-flux weighted diabatic change of downdraft 'qt'    at the downdraft base due to evaporation of rain [ kg / kg ] >= 0.
   real(r8)    evp_thli_d(mkx)                  !  Mass-flux weighted diabatic change of downdraft 'thl'   at the downdraft base due to evaporation of snow [ K ] <= 0.
   real(r8)    evp_qti_d(mkx)                   !  Mass-flux weighted diabatic change of downdraft 'qt'    at the downdraft base due to evaporation of snow [ kg / kg ] >= 0.
   real(r8)    evp_tr_d(mkx,ncnst)              !  Mass-flux weighted diabatic change of downdraft  tracer at the downdraft base due to evaporation of rain + snow [ # / kg, kg / kg ]
   real(r8)    prep_thll_d(mkx)                 !  Mass-flux weighted diabatic change of downdraft 'thl'   at the downdraft base due to production  of rain [ K ] >= 0.
   real(r8)    prep_qtl_d(mkx)                  !  Mass-flux weighted diabatic change of downdraft 'qt'    at the downdraft base due to production  of rain [ kg / kg ] <= 0.
   real(r8)    prep_thli_d(mkx)                 !  Mass-flux weighted diabatic change of downdraft 'thl'   at the downdraft base due to production  of snow [ K ] >= 0.
   real(r8)    prep_qti_d(mkx)                  !  Mass-flux weighted diabatic change of downdraft 'qt'    at the downdraft base due to production  of snow [ kg / kg ] <= 0.
   real(r8)    prep_tr_d(mkx,ncnst)             !  Mass-flux weighted diabatic change of downdraft  tracer at the downdraft base due to production  of rain + snow [ kg / kg ]
   real(r8)    eff_ql_d(mkx)                    !  Mass-flux weighted diabatic change of downdraft 'ql'    at the downdraft base due to effective diabatic forcing on cloud condensate [ kg / kg ]
   real(r8)    eff_qi_d(mkx)                    !  Mass-flux weighted diabatic change of downdraft 'qi'    at the downdraft base due to effective diabatic forcing on cloud condensate [ kg / kg ]
   real(r8)    eff_tr_d(mkx,ncnst)              !  Mass-flux weighted diabatic change of downdraft  tracer at the downdraft base due to effective diabatic forcing on tracer [ # / kg, kg / kg ]
   real(r8)    PGF_u_d(mkx)                     !  Mass-flux weighted diabatic change of downdraft 'u'     at the downdraft base due to horizontal PGF forcing [ m / s ]
   real(r8)    PGF_v_d(mkx)                     !  Mass-flux weighted diabatic change of downdraft 'v'     at the downdraft base due to horizontal PGF forcing [ m / s ]
!   real(r8)    wdep_tr_d(mkx,ncnst)             !  Mass-flux weighted diabatic change of downdraft  tracer at the downdraft base due to wet deposition within downdraft
                                                 !                     including both the cloud-borne and interstitial aerosols within convective downdraft [ # / kg, kg / kg ]
                                                 !  Feb.06.2013. I don't need this 'wdep_tr_d' since wet deposition of aerosols (both cloud-borne and interstitial) within 
                                                 !               convective downdraft will be treated as a part of 'prep_tr_d' in future.

   real(r8)    qlten_sub(mkx)                   !  Environmental tendency of ql due to compensating subsidence / upwelling [ kg / kg / s ]
   real(r8)    qiten_sub(mkx)                   !  Environmental tendency of qi due to compensating subsidence / upwelling [ kg / kg / s ] 

   real(r8)    rqc_l(mkx)                       !  Environmental tendency of ql      due to raw detrainment of updraft ( sum of 'cmf_dur(k)' and 'cmf_nur(k)' ) [ kg / kg / s ]
   real(r8)    rqc_i(mkx)                       !  Environmental tendency of qi      due to raw detrainment of updraft ( sum of 'cmf_dur(k)' and 'cmf_nur(k)' ) [ kg / kg / s ]
   real(r8)    rqc(mkx)                         !  Environmental tendency of ql + qi due to raw detrainment of updraft ( sum of 'cmf_dur(k)' and 'cmf_nur(k)' ) [ kg / kg / s ]
   real(r8)    rnc_l(mkx)                       !  Environmental tendency of nl      due to raw detrainment of updraft ( sum of 'cmf_dur(k)' and 'cmf_nur(k)' ) [  # / kg / s ]
   real(r8)    rnc_i(mkx)                       !  Environmental tendency of ni      due to raw detrainment of updraft ( sum of 'cmf_dur(k)' and 'cmf_nur(k)' ) [  # / kg / s ]

   real(r8)    qlten_det(mkx)                   !  Environmental tendency of ql      due to all detrainment of updraft and downdraft [ kg / kg / s ]
   real(r8)    qiten_det(mkx)                   !  Environmental tendency of qi      due to all detrainment of updraft and downdraft [ kg / kg / s ]

   real(r8)    am_u_msfc(mkx,nseg)              !  Updraft       fractional area at the layer mid-point for each original updraft segment [ fraction ].
   real(r8)    am_d_msfc(mkx,nseg)              !  Downdraft     fractional area at the layer mid-point for each original updraft segment [ fraction ].

   real(r8)    am_u(mkx)                        !  Updraft       fractional area at the layer mid-point [ fraction ]. 0 <= am_u(mkx) <= au_max <= 1.  
   real(r8)    am_d(mkx)                        !  Downdraft     fractional area at the layer mid-point [ fraction ]. 0 <= am_d(mkx) <= ad_max <= 1.  
   real(r8)    am_e(mkx)                        !  Environmental fractional area at the layer mid-point [ fraction ]. 0 <= am_e(mkx) <= 1.

   real(r8)    qlm_u_msfc(mkx,nseg)             !  Updraft LWC at the layer mid-point for each original updraft segment [ kg / kg ].
   real(r8)    qim_u_msfc(mkx,nseg)             !  Updraft IWC at the layer mid-point for each original updraft segment [ kg / kg ].
   real(r8)    thlm_u_msfc(mkx,nseg)            !  Updraft thl at the layer mid-point for each original updraft segment [ K ].
   real(r8)    qtm_u_msfc(mkx,nseg)             !  Updraft qt  at the layer mid-point for each original updraft segment [ kg / kg ].
   real(r8)    um_u_msfc(mkx,nseg)              !  Updraft u   at the layer mid-point for each original updraft segment [ m / s ].
   real(r8)    vm_u_msfc(mkx,nseg)              !  Updraft v   at the layer mid-point for each original updraft segment [ m / s ].
   real(r8)    trm_u_msfc(mkx,nseg,ncnst)       !  Updraft tr  at the layer mid-point for each original updraft segment [ kg / kg or # / kg ].
   
   real(r8)    qlm_u(mkx)                       !  Area-weighted updraft LWC at the layer mid-point [ kg / kg ].
   real(r8)    qim_u(mkx)                       !  Area-weighted updraft IWC at the layer mid-point [ kg / kg ].
   real(r8)    thlm_u(mkx)                      !  Area-weighted updraft thl at the layer mid-point [ K ].
   real(r8)    qtm_u(mkx)                       !  Area-weighted updraft qt  at the layer mid-point [ kg / kg ].
   real(r8)    um_u(mkx)                        !  Area-weighted updraft u   at the layer mid-point [ m / s ].
   real(r8)    vm_u(mkx)                        !  Area-weighted updraft v   at the layer mid-point [ m / s ].
   real(r8)    trm_u(mkx,ncnst)                 !  Area-weighted updraft tr  at the layer mid-point [ kg / kg or # / kg ].

   real(r8)    qlm_d_msfc(mkx,nseg)             !  Downdraft LWC at the layer mid-point for each original updraft segment [ kg / kg ].
   real(r8)    qim_d_msfc(mkx,nseg)             !  Downdraft IWC at the layer mid-point for each original updraft segment [ kg / kg ].

   real(r8)    qlm_d(mkx)                       !  Area-weighted downdraft LWC at the layer mid-point [ kg / kg ].
   real(r8)    qim_d(mkx)                       !  Area-weighted downdraft IWC at the layer mid-point [ kg / kg ].

   real(r8)    am_s(mkx)                        !  Stratiform    fractional area at the layer mid-point [ fraction ]. 0 <= am_s(mkx) <= 1.
   real(r8)    am_r(mkx)                        !  Clear-sky     fractional area at the layer mid-point [ fraction ]. 0 <= am_r(mkx)=1-am_u(mkx)-am_s(mkx)<= 1.  
   real(r8)    am_up(mkx)                       !  Precipitating updraft fractional area at the layer mid-point [ fraction ]. 0 <= am_up(mkx) <= am_u(mkx) <= 1.  
   real(r8)    am_us(mkx)                       !  Saturated     updraft fractional area at the layer mid-point [ fraction ]. 0 <= am_us(mkx) <= am_u(mkx) <= 1.  

   real(r8)    am_up_msfc(mkx,nseg)             !  Precipitating updraft fractional area at the layer mid-point for each original updraft segment [ fraction ].
   real(r8)    am_us_msfc(mkx,nseg)             !  Saturated     updraft fractional area at the layer mid-point for each original updraft segment [ fraction ].

   real(r8)    a_p(0:mkx)                       !  Physical convective precipitation area at the interface [ fraction ]
   real(r8)    a_p_msfc(0:mkx,nseg)             !  Physical convective precipitation area at the interface for each original updraft segment [ fraction ]
   real(r8)    a_pu                             !  Overlapping area between convective precipitation area at the top interface and   updraft area at the layer mid-point [ fraction ]
   real(r8)    a_pd                             !  Overlapping area between convective precipitation area at the top interface and downdraft area at the layer mid-point [ fraction ]
   real(r8)    a_ps                             !  Overlapping area between convective precipitation area at the top interface and   stratus area at the layer mid-point [ fraction ]
   real(r8)    a_pr                             !  Overlapping area between convective precipitation area at the top interface and     clear area at the layer mid-point [ fraction ]
   real(r8)    a_evp                            !  Fractional area where evaporation of precipitation occurs. 
   real(r8)    a_ovp                            ! 
   real(r8)    am_evp_msfc(mkx,nseg)            !  Same as 'a_evp' but into array variables.
   real(r8)    am_pu_msfc(mkx,nseg)
   real(r8)    am_pd_msfc(mkx,nseg)
   real(r8)    am_pr_msfc(mkx,nseg)
   real(r8)    am_ps_msfc(mkx,nseg)
   real(r8)    am_evp(mkx)         
   real(r8)    am_pu(mkx)
   real(r8)    am_pd(mkx)
   real(r8)    am_pr(mkx)
   real(r8)    am_ps(mkx)

   real(r8)    cmf_det(mkx)                     ! Detrained mass flux only from convective updraft (not from environmental air) and downdraft [ kg / s / m2 ] 
   real(r8)    ql_det(mkx)                      ! Detrained LWC without mixing with the environment ( flux-convergence & subsidence-detrainment consistent ) [ kg / kg ]
   real(r8)    qi_det(mkx)                      ! Detrained LWC without mixing with the environment ( flux-convergence & subsidence-detrainment consistent ) [ kg / kg ]

!?  real(r8)    a_p_prevp(0:mkx)                 !  Non-physical convective precipitation area at the interface before evaporation within downdraft and env. [ fraction ]
!?  real(r8)    a_p_prevp_msfc(0:mkx,nseg)       !  Non-physical convective precipitation area at the interface before evaporation within downdraft and env. for each original updraft segment.

  ! real(r8)    awk_PBL                          !  Fractional area of wake [ 0 - 1 ]
  ! real(r8)    anw_PBL                          !  Fractional area of non-wake. 'anw_PBL = 1 - awk_PBL' [ 0 - 1 ]
   real(r8)    am_evp_nw                        !  Overlapping area between 'evaporation area' and 'non-wake area' [ 0 - 1 ]
   real(r8)    am_p_nw                          !  Overlapping area between 'precipitation area' and 'non-wake area' [ 0 - 1 ]
   real(r8)    am_evp_wk                        !  Overlapping area between 'evaporation area' and 'wake area' [ 0 - 1 ]
   real(r8)    am_p_wk                          !  Overlapping area between 'precipitation area' and 'wake area' [ 0 - 1 ]

   ! Aug.08.2013. Add stratiform part
   real(r8)    am_evp_nw_st                     !  Overlapping area between 'stratiform evaporation area' and 'non-wake area' [ 0 - 1 ]
   real(r8)    tmp2_st
   real(r8)    am_evp_st(mkx)
   real(r8)    evprain_st(mkx)
   real(r8)    evpsnow_st(mkx) 

   ! ---------------------------------------------------------------------- !
   ! Individual Updraft Segment Variables at 'msfc' index at each interface !
   ! ---------------------------------------------------------------------- !

   real(r8)    thl_u_msfc(0:mkx,nseg)           !  Updraft             thl at the interface for each original updraft segment [ K ].
   real(r8)    qt_u_msfc(0:mkx,nseg)            !  Updraft              qt at the interface for each original updraft segment [ kg / kg ].
   real(r8)    u_u_msfc(0:mkx,nseg)             !  Updraft               u at the interface for each original updraft segment [ m / s ].
   real(r8)    v_u_msfc(0:mkx,nseg)             !  Updraft               v at the interface for each original updraft segment [ m / s ].
   real(r8)    w_u_msfc(0:mkx,nseg)             !  Updraft               w at the interface for each original updraft segment [ m / s ].
   real(r8)    ql_u_msfc(0:mkx,nseg)            !  Updraft              ql at the interface for each original updraft segment [ kg / kg ].
   real(r8)    qi_u_msfc(0:mkx,nseg)            !  Updraft              qi at the interface for each original updraft segment [ kg / kg ].
   real(r8)    tr_u_msfc(0:mkx,nseg,ncnst)      !  Updraft              tr at the interface for each original updraft segment [ # / kg, kg / kg ].
   real(r8)    cmf_u_msfc(0:mkx,nseg)           !  Updraft             cmf at the interface for each original updraft segment [ kg / s / m^2 ].
   real(r8)    a_u_msfc(0:mkx,nseg)             !  Updraft               a at the interface for each original updraft segment [ fraction ].
   real(r8)    num_u_msfc(0:mkx,nseg)           !  Updraft             num at the interface for each original updraft segment [ # / m^2 ].
   real(r8)    rad_u_msfc(0:mkx,nseg)           !  Updraft             rad at the interface for each original updraft segment [ m ].

   real(r8)    eps0_u_msfc(0:mkx,nseg)          !  Updraft            eps0 at the interface for each original updraft segment [ 1 / Pa ].
   real(r8)    eps_u_msfc(0:mkx,nseg)           !  Updraft             eps at the interface for each original updraft segment [ 1 / Pa ].
   real(r8)    del_u_msfc(0:mkx,nseg)           !  Updraft             del at the interface for each original updraft segment [ 1 / Pa ].
   real(r8)    eeps_u_msfc(0:mkx,nseg)          !  Updraft            eeps at the interface for each original updraft segment [ no ].
   real(r8)    ddel_u_msfc(0:mkx,nseg)          !  Updraft            ddel at the interface for each original updraft segment [ no ].
   real(r8)    xc_u_msfc(0:mkx,nseg)            !  Updraft              xc at the interface for each original updraft segment [ no ].
   real(r8)    xs_u_msfc(0:mkx,nseg)            !  Updraft              xs at the interface for each original updraft segment [ no ].
   real(r8)    xemin_u_msfc(0:mkx,nseg)         !  Updraft           xemin at the interface for each original updraft segment [ no ].
   real(r8)    xemax_u_msfc(0:mkx,nseg)         !  Updraft           xemax at the interface for each original updraft segment [ no ].
   real(r8)    cridis_u_msfc(0:mkx,nseg)        !  Updraft          cridis at the interface for each original updraft segment [ m ].
   real(r8)    thvcuenv_u_msfc(0:mkx,nseg)      !  Updraft        thvcuenv at the interface for each original updraft segment [ K ].
   real(r8)    thvegenv_u_msfc(0:mkx,nseg)      !  Updraft        thvegenv at the interface for each original updraft segment [ K ].
   real(r8)    thvxsenv_u_msfc(0:mkx,nseg)      !  Updraft        thvxsenv at the interface for each original updraft segment [ K ].
   real(r8)    fmix_u_msfc(0:mkx,nseg)          !  Updraft            fmix at the interface for each original updraft segment [ no ].
   real(r8)    cmfumix_u_msfc(0:mkx,nseg)       !  Updraft         cmfumix at the interface for each original updraft segment [ kg / s / m^2 ]

   ! ------------------------------------------ !
   ! Variables associated with vertical overlap !
   ! ------------------------------------------ !

   real(r8)    x_um_msfc(mkx,nseg)              !  Location ( x ) of convective updraft at the layer mid-point relative to the convective updraft at surface [ m ]
   real(r8)    y_um_msfc(mkx,nseg)              !  Location ( y ) of convective updraft at the layer mid-point relative to the convective updraft at surface [ m ]
   real(r8)    x_p_msfc(0:mkx,nseg)             !  Location ( x ) of convective precipitation area at the interface relative to the convective updraft at surface [ m ]
   real(r8)    y_p_msfc(0:mkx,nseg)             !  Location ( y ) of convective precipitation area at the interface relative to the convective updraft at surface [ m ]

   ! -------------------------------------------------------------------------------------------------------- !
   ! Individual Mean Downdraft variables for each Updraft Segment Variables at 'msfc' index at each interface !
   ! -------------------------------------------------------------------------------------------------------- !

   real(r8)    thl_d_msfc(0:mkx,nseg)           !  Mass-flux weighted  mean downdraft      thl at the interface for each original updraft segment [ K ].
   real(r8)    qt_d_msfc(0:mkx,nseg)            !  Mass-flux weighted  mean downdraft       qt at the interface for each original updraft segment [ kg / kg ].
   real(r8)    u_d_msfc(0:mkx,nseg)             !  Mass-flux weighted  mean downdraft        u at the interface for each original updraft segment [ m / s ].
   real(r8)    v_d_msfc(0:mkx,nseg)             !  Mass-flux weighted  mean downdraft        v at the interface for each original updraft segment [ m / s ].
   real(r8)    w_d_msfc(0:mkx,nseg)             !  Mass-flux weighted  mean downdraft        w at the interface for each original updraft segment [ m / s ].
   real(r8)    ql_d_msfc(0:mkx,nseg)            !  Mass-flux weighted  mean downdraft       ql at the interface for each original updraft segment [ kg / kg ].
   real(r8)    qi_d_msfc(0:mkx,nseg)            !  Mass-flux weighted  mean downdraft       qi at the interface for each original updraft segment [ kg / kg ].
   real(r8)    tr_d_msfc(0:mkx,nseg,ncnst)      !  Mass-flux weighted  mean downdraft       tr at the interface for each original updraft segment [ # / kg, kg / kg ].
   real(r8)    wa_d_msfc(0:mkx,nseg)            !  Area-weighted       mean downdraft        w at the interface for each original updraft segment [ m / s ].
   real(r8)    qla_d_msfc(0:mkx,nseg)           !  Area-weighted       mean downdraft       ql at the interface for each original updraft segment [ kg / kg ].
   real(r8)    qia_d_msfc(0:mkx,nseg)           !  Area-weighted       mean downdraft       qi at the interface for each original updraft segment [ kg / kg ].
   real(r8)    cmf_d_msfc(0:mkx,nseg)           !  Net                      downdraft      cmf at the interface for each original updraft segment [ kg / s / m^2 ].
   real(r8)    a_d_msfc(0:mkx,nseg)             !  Net                      downdraft        a at the interface for each original updraft segment [ fraction ].

   ! ------------------------- !
   ! Updraft Segment Variables !
   ! ------------------------- !

   real(r8)    ytop(nseg)                       !  If 1 ( 0 ), updraft segment does ( not ) reach to the top interface [ no unit ]        
   real(r8)    ybot(nseg)                       !  If 1 ( 0 ), updraft segment does ( not ) convert into the downdraft [ no unit ]
   real(r8)    xc_tmp(nseg)                     !  Critical   mixing fraction for buoyancy sorting [ fraction ]  0 <= xc <= 1.
   real(r8)    xc(nseg)                         !  Critical   mixing fraction for buoyancy sorting [ fraction ]  0 <= xc <= 1.
   real(r8)    xs(nseg)                         !  Saturation mixing fraction for buoyancy sorting [ fraction ]  0 <= xs <= 1.
   real(r8)    eeps(nseg)                       !  Non-dimensional fractional entrainment rate [ no unit ]
   real(r8)    ddel(nseg)                       !  Non-dimensional fractional detrainment rate [ no unit ]
   real(r8)    eps(nseg)                        !  Fractional entrainment rate [ 1 / Pa ]
   real(r8)    del(nseg)                        !  Fractional detrainment rate [ 1 / Pa ]
   real(r8)    eps0(nseg)                       !  Fractional mixing rate [ 1 / Pa ]
   real(r8)    eps0org(nseg)                    !  Fractional mixing rate [ 1 / Pa ]
   real(r8)    xe_min(nseg)                     !  Minimum mixing fraction for conversion into downdraft [ fraction ]
   real(r8)    xe_max(nseg)                     !  Maximum mixing fraction for conversion into downdraft [ fraction ]
   real(r8)    dpa(nseg)                        !  Vertical distance that updraft segment can rise in each layer [ Pa ]. 0 <= dp <= dp0.
   real(r8)    dza(nseg)                        !  Vertical distance that updraft segment can rise in each layer [ m ].  0 <= dz <= dz0.
   real(r8)    ptop(nseg)                       !  Updraft top height [ Pa ]
   real(r8)    ztop(nseg)                       !  Updraft top height [ m ]
   real(r8)    ptops(mkx,nseg)                  !  Updraft top height for each segment in each layer [ Pa ]
   real(r8)    ztops(mkx,nseg)                  !  Updraft top height for each segment in each layer [ m ]
   integer     m_from_msfc(mkx,nseg)            !  Get 'm' index from 'msfc' index in each layer that updraft reaches [ no unit ]
   integer     msfc_from_m(mkx,nseg)            !  Get 'msfc' index from 'm' index in each layer that updraft reaches [ no unit ]
   integer     ktop_msfc(nseg)                  !  The top layer index of individual original updraft segment defined at surface [ no ]
   real(r8)    ptop_msfc(nseg)                  !  Updraft top height  of individual original updraft segment defined at surface [ Pa ]
   real(r8)    ztop_msfc(nseg)                  !  Updraft top height  of individual original updraft segment defined at surface [ m ]
   real(r8)    fmix(nseg)                       !  When multiplied by cmf_au(m), it becomes the amount of updraft mass involved in the buoyancy sorting mixing [ no unit ]
   real(r8)    f_wu(nseg)                       !  For updraft vertical velocity constraint [ no unit ]
   real(r8)    fmixd                            !  Same as 'fmix' but for downdraft.

   real(r8)    alpha(nseg)                      !  Mixing fraction within updraft at the k = 1 interface [ no unit ]
   real(r8)    Pmu(nseg)                        !  Normalized PDF of updraft mass flux            at the k = 1 interface [ 1 / d_alpha ]
   real(r8)    Pau(nseg)                        !  Normalized PDF of updraft fractional area      at the k = 1 interface [ 1 / d_alpha ]
   real(r8)    Pnu(nseg)                        !  Normalized PDF of updraft number concentration at the k = 1 interface [ 1 / d_alpha ]
   real(r8)    rnorm_a                          !  Area normalization constant to force the sum of updraft fraction area at surface to be the specified 'au_base' in all cases.
   real(r8)    rnorm_m                          !  Area normalization constant to force the sum of non-organized updraft mass flux at surface to be the specified 'cmfu_base' in all cases.
   real(r8)    cmfu_base                        !  Physical analytical non-organized updraft mass flux at surface for a given 'au_base'.

   real(r8)    cmf_au(nseg)                     !  Updraft mass flux            at the base interface [ kg / s / m^2 ]
   real(r8)    thl_au(nseg)                     !  Updraft thl                  at the base interface [ K ]
   real(r8)    qt_au(nseg)                      !  Updraft qt                   at the base interface [ kg / kg ] 
   real(r8)    u_au(nseg)                       !  Updraft u                    at the base interface [ m / s ]
   real(r8)    v_au(nseg)                       !  Updraft v                    at the base interface [ m / s ]
   real(r8)    w_au(nseg)                       !  Updraft vertical velocity    at the base interface [ m / s ]
   real(r8)    ql_au(nseg)                      !  Updraft ql                   at the base interface [ kg / kg ]
   real(r8)    qi_au(nseg)                      !  Updraft qi                   at the base interface [ kg / kg ]
   real(r8)    tr_au(nseg,ncnst)                !  Updraft tracers              at the base interface [ # / kg, kg / kg ]
   real(r8)    a_au(nseg)                       !  Updraft fractional area      at the base interface [ fraction ]
   real(r8)    num_au(nseg)                     !  Updraft number concentration at the base interface [ # / m^2 ]
   real(r8)    rad_au(nseg)                     !  Updraft radius               at the base interface [ m ]
   real(r8)    thv_au(nseg)                     !  Updraft thv                  at the base interface [ K ]
   real(r8)    S_b_ql_au(nseg)                  !  Updraft rain production rate at the base interface [ kg / kg / Pa ]
   real(r8)    S_b_qi_au(nseg)                  !  Updraft snow production rate at the base interface [ kg / kg / Pa ]
!ice   real(r8)    frac_ice_au(nseg)                !  Updraft ice fraction among total updraft condensate after all 'CEF + Mixing + Precipitation Fall Out' [ fraction ]

   real(r8)    cmf_aut(nseg)                    !  Updraft mass flux            at the cloud top or top interface [ kg / s / m^2 ]
   real(r8)    thl_aut(nseg)                    !  Updraft thl                  at the cloud top or top interface [ K ]
   real(r8)    qt_aut(nseg)                     !  Updraft qt                   at the cloud top or top interface [ kg / kg ] 
   real(r8)    u_aut(nseg)                      !  Updraft u                    at the cloud top or top interface [ m / s ]
   real(r8)    v_aut(nseg)                      !  Updraft v                    at the cloud top or top interface [ m / s ]
   real(r8)    w_aut(nseg)                      !  Updraft vertical velocity    at the cloud top or top interface [ m / s ]
   real(r8)    ql_aut(nseg)                     !  Updraft ql                   at the cloud top or top interface [ kg / kg ]
   real(r8)    qi_aut(nseg)                     !  Updraft qi                   at the cloud top or top interface [ kg / kg ]
   real(r8)    a_aut(nseg)                      !  Updraft fractional area      at the cloud top or top interface [ fraction ]
   real(r8)    num_aut(nseg)                    !  Updraft number concentration at the cloud top or top interface [ # / m^2 ]
   real(r8)    rad_aut(nseg)                    !  Updraft radius               at the cloud top or top interface [ m ]
   real(r8)    tr_aut(nseg,ncnst)               !  Updraft tracer               at the cloud top or top interface [ # / kg, kg / kg ] 
   real(r8)    thv_aut(nseg)                    !  Updraft thv                  at the cloud top or top interface [ K ]
   real(r8)    S_t_ql_au(nseg)                  !  Updraft rain production rate at the cloud top or top interface [ kg / kg / Pa ]
   real(r8)    S_t_qi_au(nseg)                  !  Updraft snow production rate at the cloud top or top interface [ kg / kg / Pa ]
!ice   real(r8)    frac_ice_aut(nseg)               !  Updraft ice fraction among total updraft condensate after all 'CEF + Mixing + Precipitation Fall Out' [ fraction ]

   real(r8)    evp_thll_au(nseg)                !  Diabatic change of updraft 'thl' at each cloud top due to evaporation of rain [ K ] <= 0.
   real(r8)    evp_qtl_au(nseg)                 !  Diabatic change of updraft 'qt'  at each cloud top due to evaporation of rain [ kg / kg ] >= 0.
   real(r8)    evp_thli_au(nseg)                !  Diabatic change of updraft 'thl' at each cloud top due to evaporation of snow [ K ] <= 0.
   real(r8)    evp_qti_au(nseg)                 !  Diabatic change of updraft 'qt'  at each cloud top due to evaporation of snow [ kg / kg ] >= 0.
   real(r8)    evp_tr_au(nseg,ncnst)            !  Diabatic change of updraft  tracer  at each cloud top due to evaporation of rain + snow [ # / kg, kg / kg ]
   real(r8)    prep_thll_au(nseg)               !  Diabatic change of updraft 'thl' at each cloud top due to production  of rain [ K ] >= 0.
   real(r8)    prep_qtl_au(nseg)                !  Diabatic change of updraft 'qt'  at each cloud top due to production  of rain [ kg / kg ] <= 0.
   real(r8)    prep_thli_au(nseg)               !  Diabatic change of updraft 'thl' at each cloud top due to production  of snow [ K ] >= 0.
   real(r8)    prep_qti_au(nseg)                !  Diabatic change of updraft 'qt'  at each cloud top due to production  of snow [ kg / kg ] <= 0.
   real(r8)    prep_tr_au(nseg,ncnst)           !  Diabatic change of updraft  tracer  at each cloud top due to production  of rain + snow [ # / kg, kg / kg ]
   real(r8)    eff_ql_au(nseg)                  !  Diabatic change of updraft 'ql'  at each cloud top due to effective diabatic forcing on cloud condensate [ K ] >= 0.
   real(r8)    eff_qi_au(nseg)                  !  Diabatic change of updraft 'qi'  at each cloud top due to effective diabatic forcing on cloud condensate [ kg / kg ] 
   real(r8)    eff_tr_au(nseg,ncnst)            !  Diabatic change of updraft  tracer at each cloud top due to effective diabatic forcing on tracer [ # / kg, kg / kg ] 
   real(r8)    PGF_u_au(nseg)                   !  Diabatic change of updraft 'u'   at each cloud top due to horizontal PGF forcing [ m / s ]
   real(r8)    PGF_v_au(nseg)                   !  Diabatic change of updraft 'v'   at each cloud top due to horizontal PGF forcing [ m / s ]
!   real(r8)    wdep_tr_au(nseg,ncnst)           !  Diabatic change of updraft  tracer  at each cloud top due to wet deposition of within convective updraft
                                                 !                     including both the cloud-borne and interstitial aerosols [ # / kg, kg / kg ]
                                                 !  Feb.06.2013. This 'wdep_tr_au' is not necessary since wet deposition of aerosols within updraft (both interstitial and cloud-borne)
                                                 !               will be computed as a part of prep_tr_au.

   ! ---------------------------------------------------------------------------------------------------------------------------------------------- !
   ! Variables to compute effective diabatic forcings ( condensation-evaporation-freezing ) on cloud condensate and tracers and PGF on uv momentum. !
   ! ---------------------------------------------------------------------------------------------------------------------------------------------- !
    
   real(r8)    ql_aut_adi, ql_aut_dii, ql_aut_dif
   real(r8)    qi_aut_adi, qi_aut_dii, qi_aut_dif
   real(r8)    eff_ql
   real(r8)    eff_qi
   real(r8)    eff_tr(ncnst)
   real(r8)    u_aut_adi
   real(r8)    v_aut_adi

   ! ----------------------------------------------------------------------------- !
   ! Variables associated with the treatment of entrainment dilution of downdraft. !
   ! ----------------------------------------------------------------------------- !

   real(r8)    eps_dn, del_dn
   real(r8)    ql_db_adi, qi_db_adi, qv_db_adi, qv_db_adi_evp
   real(r8)    u_db_adi ,  v_db_adi
   real(r8)    ql_dt, qi_dt, qv_dt, qs_dt, th_dt 
   real(r8)    ql_db, qi_db, qv_db, qs_db, th_db
   real(r8)    wd2
   
   ! --------------------------------------------------------------------------------- !
   ! Variables related to the evaporation of precipitation within convective downdraft !
   ! --------------------------------------------------------------------------------- !

   real(r8)    evplflux                         !  Evaporation + Production of rain within downdraft in each layer [kg/s/m^2]
   real(r8)    evpiflux                         !  Evaporation + Production of snow within downdraft in each layer [kg/s/m^2]
   real(r8)    evptrflux(ncnst)                 !  Evaporation + Production + Wet Deposition of tracers within downdraft in each layer [kg(#)/s/m^2]
   real(r8)    fevp, fevp0, fevp1, fevp2        !  Measure whether there is enough amount of precipitation flux for evaporation within downdraft. 0 <= [no unit] <= 1.
   real(r8)    fevp1_t_rate, fevp2_t_rate       !  Evaporation rate of precipitation within downdraft at the  top interface [(kg/kg)/Pa] >= 0.
   real(r8)    fevp1_b_rate, fevp2_b_rate       !  Evaporation rate of precipitation within downdraft at the base interface [(kg/kg)/Pa] >= 0.
   real(r8)    fevp1_rate, fevp2_rate           !  Evaporation rate of precipitation within downdraft within the layer      [(kg/kg)/Pa] >= 0.

   ! ------------------------ !
   ! Turbulent flux variables !
   ! ------------------------ !

   real(r8)    slflx_u(0:mkx)                   !  Convective updraft liquid static energy flux [J/s/m2]
   real(r8)    qtflx_u(0:mkx)                   !  Convective updraft total water flux [kg/s/m2]
   real(r8)    uflx_u(0:mkx)                    !  Convective updraft zonal momentum flux [kg m/s/s/m2]
   real(r8)    vflx_u(0:mkx)                    !  Convective updraft meridional momentum flux [kg m/s/s/m2]
   real(r8)    qlflx_u(0:mkx)                   !  Convective updraft ql flux [kg/s/m2]
   real(r8)    qiflx_u(0:mkx)                   !  Convective updraft qi flux [kg/s/m2]
   real(r8)    trflx_u(0:mkx,ncnst)             !  Convective updraft tracer flux [ #/s/m2, kg/s/m2 ]

   real(r8)    slflx_d(0:mkx)                   !  Convective downdraft liquid static energy flux [J/s/m2]
   real(r8)    qtflx_d(0:mkx)                   !  Convective downdraft total water flux [kg/s/m2]
   real(r8)    uflx_d(0:mkx)                    !  Convective downdraft zonal momentum flux [kg m/s/s/m2]
   real(r8)    vflx_d(0:mkx)                    !  Convective downdraft meridional momentum flux [kg m/s/s/m2]
   real(r8)    qlflx_d(0:mkx)                   !  Convective downdraft ql flux [kg/s/m2]
   real(r8)    qiflx_d(0:mkx)                   !  Convective downdraft qi flux [kg/s/m2]
   real(r8)    trflx_d(0:mkx,ncnst)             !  Convective downdraft tracer flux [ #/s/m2, kg/s/m2 ]

   real(r8)    uflx(0:mkx)                      !  Reconstructed convective zonal momentum flux [kg m/s/s/m2]
   real(r8)    vflx(0:mkx)                      !  Reconstructed convective meridional momentum flux [kg m/s/s/m2]

!d  real(r8)    slflx_d_org(0:mkx)               !  Convective downdraft liquid static energy flux [J/s/m2]
!d  real(r8)    qtflx_d_org(0:mkx)               !  Convective downdraft total water flux [kg/s/m2]

   real(r8)    thlflx_d_org_pblh                !  Adiabatic organization forcing. Convective downdraft flux of thl at the PBL top [kg*K/s/m2]
   real(r8)    qtflx_d_org_pblh                 !  Adiabatic organization forcing. Convective downdraft flux of qt  at the PBL top [kg*(kg/kg)/s/m2]
   real(r8)    uflx_d_org_pblh                  !  Adiabatic organization forcing. Convective downdraft flux of u   at the PBL top [kg*(m/s)/s/m2]
   real(r8)    vflx_d_org_pblh                  !  Adiabatic organization forcing. Convective downdraft flux of v   at the PBL top [kg*(m/s)/s/m2]
   ! real(r8)    thvflx_d_org_pblh                !  Adiabatic organization forcing. Convective downdraft flux of thv at the PBL top [kg*K/s/m2]
   real(r8)    trflx_d_org_pblh(ncnst)          !  Adiabatic organization forcing. Convective downdraft flux of tr  at the PBL top [kg*(kg/kg)/s/m2, kg*(#/kg)/s/m2]

   real(r8)    cmf_d_org_pblh                   !  Organization-inducing downdraft mass flux at the PBL top interface [kg/s/m2]               
   real(r8)    thl_d_org_pblh                
   real(r8)    qt_d_org_pblh                
   real(r8)    u_d_org_pblh                 
   real(r8)    v_d_org_pblh                 
   real(r8)    tr_d_org_pblh(ncnst)         

   real(r8)    thl_dia_d_org                    !  Diabatic organization forcing of thl      within convective downdraft [ K / s ]
   real(r8)    qt_dia_d_org                     !  Diabatic organization forcing of qt       within convective downdraft [ kg / kg / s ]
   real(r8)    tr_dia_d_org(ncnst)              !  Diabatic organization forcing of tracers  within convective downdraft [ kg / kg / s  or # / kg / s ]

   real(r8)    thl_dia_und_org                  !  Diabatic organization forcing of thl      within convective updraft and downdraft [ K / s ]
   real(r8)    qt_dia_und_org                   !  Diabatic organization forcing of qt       within convective updraft and downdraft [ kg / kg / s ]
   real(r8)    tr_dia_und_org(ncnst)            !  Diabatic organization forcing of tracers  within convective updraft and downdraft [ kg / kg / s  or # / kg / s ]

   real(r8)    thl_dia_env_org                  !  Diabatic organization forcing of thl      within environment [ K / s ]
   real(r8)    qt_dia_env_org                   !  Diabatic organization forcing of qt       within environment [ kg / kg / s ]
   real(r8)    tr_dia_env_org(ncnst)            !  Diabatic organization forcing of tracers  within environment [ kg / kg / s  or # / kg / s ]

 ! May.1.2014. Below '_d_orgU' and '_u_org' variables are added for 'budget consistent coldpool' treatment (i_budget_coldpool = 1,2 ).

   real(r8)    thlflx_d_orgU_pblh               !  Adiabatic organization forcing. Convective downdraft flux of thl at the PBL top [kg*K/s/m2]
   real(r8)    qtflx_d_orgU_pblh                !  Adiabatic organization forcing. Convective downdraft flux of qt  at the PBL top [kg*(kg/kg)/s/m2]
   real(r8)    uflx_d_orgU_pblh                 !  Adiabatic organization forcing. Convective downdraft flux of u   at the PBL top [kg*(m/s)/s/m2]
   real(r8)    vflx_d_orgU_pblh                 !  Adiabatic organization forcing. Convective downdraft flux of v   at the PBL top [kg*(m/s)/s/m2]
 ! real(r8)    thvflx_d_orgU_pblh               !  Adiabatic organization forcing. Convective downdraft flux of thv at the PBL top [kg*K/s/m2]
   real(r8)    trflx_d_orgU_pblh(ncnst)         !  Adiabatic organization forcing. Convective downdraft flux of tr  at the PBL top [kg*(kg/kg)/s/m2, kg*(#/kg)/s/m2]

   real(r8)    cmf_d_orgU_pblh                  !  Organization-inducing downdraft mass flux at the PBL top interface [kg/s/m2]               
   real(r8)    thl_d_orgU_pblh                
   real(r8)    qt_d_orgU_pblh                
   real(r8)    u_d_orgU_pblh                 
   real(r8)    v_d_orgU_pblh                 
   real(r8)    tr_d_orgU_pblh(ncnst)         

   real(r8)    thl_dia_d_orgU                   !  Diabatic organization forcing of thl      within convective downdraft [ K / s ]
   real(r8)    qt_dia_d_orgU                    !  Diabatic organization forcing of qt       within convective downdraft [ kg / kg / s ]
   real(r8)    tr_dia_d_orgU(ncnst)             !  Diabatic organization forcing of tracers  within convective downdraft [ kg / kg / s  or # / kg / s ]

   real(r8)    cmf_u_org_pblh                   !  = cmf_u(kpblhm)
   real(r8)    thlflx_u_org_pblh                !  Adiabatic organization forcing. Convective updraft flux of thl at the PBL top [kg*K/s/m2]
   real(r8)    qtflx_u_org_pblh                 !  Adiabatic organization forcing. Convective updraft flux of qt  at the PBL top [kg*(kg/kg)/s/m2]
   real(r8)    uflx_u_org_pblh                  !  Adiabatic organization forcing. Convective updraft flux of u   at the PBL top [kg*(m/s)/s/m2]
   real(r8)    vflx_u_org_pblh                  !  Adiabatic organization forcing. Convective updraft flux of v   at the PBL top [kg*(m/s)/s/m2]
 ! real(r8)    thvflx_u_org_pblh                !  Adiabatic organization forcing. Convective updraft flux of thv at the PBL top [kg*K/s/m2]
   real(r8)    trflx_u_org_pblh(ncnst)          !  Adiabatic organization forcing. Convective updraft flux of tr  at the PBL top [kg*(kg/kg)/s/m2, kg*(#/kg)/s/m2]

   ! ------------------ !
   ! Tendency variables !
   ! ------------------ !

   real(r8)    slten(mkx)                       !  Total tendency of sl [J/kg/s]
   real(r8)    qtten(mkx)                       !  Total tendency of qt [kg/kg/s]
   real(r8)    qvten(mkx)                       !  Total tendency of qv [kg/kg/s]
   real(r8)    qlten(mkx)                       !  Total tendency of ql [kg/kg/s]
   real(r8)    qiten(mkx)                       !  Total tendency of qi [kg/kg/s]
   real(r8)    sten(mkx)                        !  Total tendency of s  [J/kg/s]
   real(r8)    uten(mkx)                        !  Total tendency of u  [m/s/s]
   real(r8)    vten(mkx)                        !  Total tendency of v  [m/s/s]
   real(r8)    trten(mkx,ncnst)                 !  Total tendency of tracers [ #/kg/s, kg/kg/s ]

   real(r8)    slten_u(mkx)                     !  Tendency of sl by updraft mass flux [J/kg/s]
   real(r8)    qtten_u(mkx)                     !  Tendency of qt by updraft mass flux [kg/kg/s]
   real(r8)    uten_u(mkx)                      !  Tendency of u  by updraft mass flux [m/s/s]
   real(r8)    vten_u(mkx)                      !  Tendency of v  by updraft mass flux [m/s/s]
   real(r8)    sten_u(mkx)                      !  Tendency of s  by updraft mass flux [J/kg/s]
   real(r8)    qvten_u(mkx)                     !  Tendency of qv by updraft mass flux [kg/kg/s]
   real(r8)    qlten_u(mkx)                     !  Tendency of ql by updraft mass flux [kg/kg/s]
   real(r8)    qiten_u(mkx)                     !  Tendency of qi by updraft mass flux [kg/kg/s]
   real(r8)    trten_u(mkx,ncnst)               !  Tendency of tracer by updraft mass flux [#/kg/s, kg/kg/s]

   real(r8)    slten_d(mkx)                     !  Tendency of sl by downdraft mass flux [J/kg/s]
   real(r8)    qtten_d(mkx)                     !  Tendency of qt by downdraft mass flux [kg/kg/s]
   real(r8)    uten_d(mkx)                      !  Tendency of u  by downdraft mass flux [m/s/s]
   real(r8)    vten_d(mkx)                      !  Tendency of v  by downdraft mass flux [m/s/s]
   real(r8)    sten_d(mkx)                      !  Tendency of s  by downdraft mass flux [J/kg/s]
   real(r8)    qvten_d(mkx)                     !  Tendency of qv by downdraft mass flux [kg/kg/s]
   real(r8)    qlten_d(mkx)                     !  Tendency of ql by downdraft mass flux [kg/kg/s]
   real(r8)    qiten_d(mkx)                     !  Tendency of qi by downdraft mass flux [kg/kg/s]
   real(r8)    trten_d(mkx,ncnst)               !  Tendency of tracer by downdraft mass flux [#/kg/s, kg/kg/s]

   real(r8)    slten_evp(mkx)                   !  Tendency of sl by convective precipitation and evaporation of convective precip. [J/kg/s]
   real(r8)    qtten_evp(mkx)                   !  Tendency of qt by convective precipitation and evaporation of convective precip. [kg/kg/s]
   real(r8)    uten_evp(mkx)                    !  Tendency of u  by convective precipitation and evaporation of convective precip. [m/s/s]
   real(r8)    vten_evp(mkx)                    !  Tendency of v  by convective precipitation and evaporation of convective precip. [m/s/s]
   real(r8)    sten_evp(mkx)                    !  Tendency of s  by convective precipitation and evaporation of convective precip. [J/kg/s]
   real(r8)    qvten_evp(mkx)                   !  Tendency of qv by convective precipitation and evaporation of convective precip. [kg/kg/s]
   real(r8)    qlten_evp(mkx)                   !  Tendency of ql by convective precipitation and evaporation of convective precip. [kg/kg/s]
   real(r8)    qiten_evp(mkx)                   !  Tendency of qi by convective precipitation and evaporation of convective precip. [kg/kg/s]
   real(r8)    trten_evp(mkx,ncnst)             !  Tendency of tracer by convective precipitation and evaporation of convective precip. [#/kg/s, kg/kg/s]
   real(r8)    trten_wdep(mkx,ncnst)            !  Tendency of tracer by wet deposition within environment by convective precip. [#/kg/s, kg/kg/s]

   real(r8)    slten_dis(mkx)                   !  Tendency of sl by dissipative heating of mean kinetic energy [J/kg/s]
   real(r8)    qtten_dis(mkx)                   !  Tendency of qt by dissipative heating of mean kinetic energy [kg/kg/s]
   real(r8)    uten_dis(mkx)                    !  Tendency of u  by dissipative heating of mean kinetic energy [m/s/s]
   real(r8)    vten_dis(mkx)                    !  Tendency of v  by dissipative heating of mean kinetic energy [m/s/s]
   real(r8)    sten_dis(mkx)                    !  Tendency of s  by dissipative heating of mean kinetic energy [J/kg/s]
   real(r8)    qvten_dis(mkx)                   !  Tendency of qv by dissipative heating of mean kinetic energy [kg/kg/s]
   real(r8)    qlten_dis(mkx)                   !  Tendency of ql by dissipative heating of mean kinetic energy [kg/kg/s]
   real(r8)    qiten_dis(mkx)                   !  Tendency of qi by dissipative heating of mean kinetic energy [kg/kg/s]
   real(r8)    trten_dis(mkx,ncnst)             !  Tendency of tracer by dissipative heating of mean kinetic energy [#/kg/s, kg/kg/s]

   real(r8)    slten_par(mkx)                   !  Tendency of sl by partitioning the tendency in the lowest layer in the layers within the PBL [J/kg/s]
   real(r8)    qtten_par(mkx)                   !  Tendency of qt by partitioning the tendency in the lowest layer in the layers within the PBL [kg/kg/s]
   real(r8)    qlten_par(mkx)                   !  Tendency of ql by partitioning the tendency in the lowest layer in the layers within the PBL [kg/kg/s]
   real(r8)    qiten_par(mkx)                   !  Tendency of qi by partitioning the tendency in the lowest layer in the layers within the PBL [kg/kg/s]
   real(r8)    uten_par(mkx)                    !  Tendency of u  by partitioning the tendency in the lowest layer in the layers within the PBL [m/s/s]
   real(r8)    vten_par(mkx)                    !  Tendency of v  by partitioning the tendency in the lowest layer in the layers within the PBL [m/s/s]
   real(r8)    trten_par(mkx,ncnst)             !  Tendency of tracer by partitioning the tendency in the lowest layer in the layers within the PBL [#/kg/s, kg/kg/s]

   real(r8)    uten_PGF(mkx)                    !  Tendency of u  by horizontal PGF [m/s/s]
   real(r8)    vten_PGF(mkx)                    !  Tendency of v  by horizontal PGF [m/s/s]

   real(r8)    slten_NUM(mkx)                   !  Final Numerical tendency of sl [J/kg/s]
   real(r8)    qtten_NUM(mkx)                   !  Final Numerical tendency of qt [kg/kg/s]
   real(r8)    uten_NUM(mkx)                    !  Final Numerical tendency of u  [m/s/s]
   real(r8)    vten_NUM(mkx)                    !  Final Numerical tendency of v  [m/s/s]
   real(r8)    qvten_NUM(mkx)                   !  Final Numerical tendency of qv [kg/kg/s]
   real(r8)    qlten_NUM(mkx)                   !  Final Numerical tendency of ql [kg/kg/s]
   real(r8)    qiten_NUM(mkx)                   !  Final Numerical tendency of qi [kg/kg/s]
   real(r8)    sten_NUM(mkx)                    !  Final Numerical tendency of s  [J/kg/s]
   real(r8)    trten_NUM(mkx,ncnst)             !  Final Numerical tendency of tracer [#/kg/s, kg/kg/s]

!a  real(r8)    slten_CFL(mkx)                   !  CFL-satisfying tendency of sl [J/kg/s]
!a  real(r8)    qtten_CFL(mkx)                   !  CFL-satisfying tendency of qt [kg/kg/s]
!a  real(r8)    qvten_CFL(mkx)                   !  CFL-satisfying tendency of qv [kg/kg/s]
!a  real(r8)    qlten_CFL(mkx)                   !  CFL-satisfying tendency of ql [kg/kg/s]
!a  real(r8)    qiten_CFL(mkx)                   !  CFL-satisfying tendency of qi [kg/kg/s]
!a  real(r8)    sten_CFL(mkx)                    !  CFL-satisfying tendency of s  [J/kg/s]
!a  real(r8)    uten_CFL(mkx)                    !  CFL-satisfying tendency of u  [m/s/s]
!a  real(r8)    vten_CFL(mkx)                    !  CFL-satisfying tendency of v  [m/s/s]

!a  real(r8)    slten_EMC(mkx)                   !  Energy-Moisture-Conserving tendency of sl [J/kg/s]
!a  real(r8)    qtten_EMC(mkx)                   !  Energy-Moisture-Conserving tendency of qt [kg/kg/s]
!a  real(r8)    qvten_EMC(mkx)                   !  Energy-Moisture-Conserving tendency of qv [kg/kg/s]
!a  real(r8)    qlten_EMC(mkx)                   !  Energy-Moisture-Conserving tendency of ql [kg/kg/s]
!a  real(r8)    qiten_EMC(mkx)                   !  Energy-Moisture-Conserving tendency of qi [kg/kg/s]
!a  real(r8)    sten_EMC(mkx)                    !  Energy-Moisture-Conserving tendency of s  [J/kg/s]
!a  real(r8)    uten_EMC(mkx)                    !  Energy-Moisture-Conserving tendency of u  [m/s/s]
!a  real(r8)    vten_EMC(mkx)                    !  Energy-Moisture-Conserving tendency of v  [m/s/s]

!a  real(r8)    slten_ANA(mkx)                   !  Final Analytical tendency of sl almost satisfying CFL-constraint and exactly conserving EM [J/kg/s]
!a  real(r8)    qtten_ANA(mkx)                   !  Final Analytical tendency of qt almost satisfying CFL-constraint and exactly conserving EM [kg/kg/s]
!a  real(r8)    qvten_ANA(mkx)                   !  Final Analytical tendency of qv almost satisfying CFL-constraint and exactly conserving EM [kg/kg/s]
!a  real(r8)    qlten_ANA(mkx)                   !  Final Analytical tendency of ql almost satisfying CFL-constraint and exactly conserving EM [kg/kg/s]
!a  real(r8)    qiten_ANA(mkx)                   !  Final Analytical tendency of qi almost satisfying CFL-constraint and exactly conserving EM [kg/kg/s]
!a  real(r8)    sten_ANA(mkx)                    !  Final Analytical tendency of s  almost satisfying CFL-constraint and exactly conserving EM [J/kg/s]
!a  real(r8)    uten_ANA(mkx)                    !  Final Analytical tendency of u  almost satisfying CFL-constraint and exactly conserving EM [m/s/s]
!a  real(r8)    vten_ANA(mkx)                    !  Final Analytical tendency of v  almost satisfying CFL-constraint and exactly conserving EM [m/s/s]

   real(r8)    qrten(mkx)                       !  Production rate of rain by the expels of in-cumulus excessive condensate [kg/kg/s]
   real(r8)    qsten(mkx)                       !  Production rate of snow by the expels of in-cumulus excessive condensate [kg/kg/s]
   real(r8)    trrsten(mkx,ncnst)               !  Production rate of tracers by the expels of in-cumulus excessive condensate [kg(#)/kg/s]

   real(r8)    qrten_msfc(mkx,nseg)             !  Production rate of rain by the expels of in-cumulus excessive condensate for each original updraft segment [kg/kg/s]
   real(r8)    qsten_msfc(mkx,nseg)             !  Production rate of snow by the expels of in-cumulus excessive condensate for each original updraft segment [kg/kg/s]
   real(r8)    trrsten_msfc(mkx,nseg,ncnst)     !  Production rate of tracers by the expels of in-cumulus excessive condensate for each original updraft segment [kg(#)/kg/s]

   real(r8)    qrten_u(mkx)                     !  Production rate of rain by the expels of in-cumulus excessive condensate within updraft [kg/kg/s]
   real(r8)    qsten_u(mkx)                     !  Production rate of snow by the expels of in-cumulus excessive condensate within updraft [kg/kg/s]
   real(r8)    trrsten_u(mkx,ncnst)             !  Production rate of tracers by the expels of in-cumulus excessive condensate within updraft [kg(#)/kg/s]

   real(r8)    qrten_u_msfc(mkx,nseg)           !  Production rate of rain by the expels of in-cumulus excessive condensate within updraft for each original updraft segment [kg/kg/s]
   real(r8)    qsten_u_msfc(mkx,nseg)           !  Production rate of snow by the expels of in-cumulus excessive condensate within updraft for each original updraft segment [kg/kg/s]
   real(r8)    trrsten_u_msfc(mkx,nseg,ncnst)   !  Production rate of precipitating tracers by the expels of in-cumulus tracers within updraft for each original updraft segment [kg/kg/s,#/kg/s]

   real(r8)    qrten_d(mkx)                     !  Production rate of rain by the expels of in-cumulus excessive condensate within downdraft [kg/kg/s]
   real(r8)    qsten_d(mkx)                     !  Production rate of snow by the expels of in-cumulus excessive condensate within downdraft [kg/kg/s]
   real(r8)    trrsten_d(mkx,ncnst)             !  Production rate of tracers by the expels of in-cumulus excessive condensate within downdraft [kg(#)/kg/s]

   real(r8)    qrten_d_msfc(mkx,nseg)           !  Production rate of rain by the expels of in-cumulus excessive condensate within downdraft for each original updraft segment [kg/kg/s]
   real(r8)    qsten_d_msfc(mkx,nseg)           !  Production rate of snow by the expels of in-cumulus excessive condensate within downdraft for each original updraft segment [kg/kg/s]
   real(r8)    trrsten_d_msfc(mkx,nseg,ncnst)   !  Production rate of tracers by the expels of in-cumulus excessive tracers within downdraft for each original updraft segment [kg(#)/kg/s]

   real(r8)    snowmlt_e(mkx)                   !  Snow melting tendency within environment before evaporation within downdraft [kg/kg/s]
   real(r8)    snowmlt_e_msfc(mkx,nseg)         !  Snow melting tendency within environment before evaporation within downdraft for each original updraft segment [kg/kg/s]
   real(r8)    smlttrrs_e_msfc(mkx,nseg,ncnst)  !  Tendencies of tracers by snow melting within environment before evaporation within downdraft for each original updraft segment [kg/kg/s]

!?  real(r8)    snowmlt(mkx)                     !  Snow melting tendency within environment after  evaporation within downdraft [kg/kg/s]
!?  real(r8)    snowmlt_msfc(mkx,nseg)           !  Snow melting tendency within environment after  evaporation within downdraft for each original updraft segment [kg/kg/s]

   real(r8)    thlten_dia_u(mkx)                !  Diabatic tendency of thl within   updraft [K/s]
   real(r8)    thlten_dia_d(mkx)                !  Diabatic tendency of thl within downdraft [K/s]
   
   real(r8)    qtten_dia_u(mkx)                 !  Diabatic tendency of qt within   updraft [K/s]
   real(r8)    qtten_dia_d(mkx)                 !  Diabatic tendency of qt within downdraft [K/s]

   real(r8)    qlten_dia_u(mkx)                 !  Diabatic tendency of ql within   updraft ( exclude effective tendency ) [kg/kg/s]
   real(r8)    qlten_dia_d(mkx)                 !  Diabatic tendency of ql within downdraft ( exclude effective tendency ) [kg/kg/s]

   real(r8)    qiten_dia_u(mkx)                 !  Diabatic tendency of qi within   updraft ( exclude effective tendency ) [kg/kg/s]
   real(r8)    qiten_dia_d(mkx)                 !  Diabatic tendency of qi within downdraft ( exclude effective tendency ) [kg/kg/s]

   real(r8)    trten_dia_u(mkx,ncnst)           !  Diabatic tendency of tracers within   updraft ( exclude effective tendency ) [#/kg/s, kg/kg/s]
   real(r8)    trten_dia_d(mkx,ncnst)           !  Diabatic tendency of tracers within downdraft ( exclude effective tendency ) [#/kg/s, kg/kg/s]

   real(r8)    ntraprd(mkx)                     !  Net production rate of rain ( qrten(k) + snowmlt(k) - evprain(k) ) [kg/kg/s]
   real(r8)    ntsnprd(mkx)                     !  Net production rate of snow ( qsten(k) - snowmlt(k) - evpsnow(k) ) [kg/kg/s]
   real(r8)    nttrrsprd(mkx,ncnst)             !  Net production rate of tracer ( trrsten(k) - evptrrs + wdeptrrs ) [kg(#)/kg/s]

   real(r8)    ntraprd_msfc(mkx,nseg)           !  Net production rate of rain ( qrten(k) + snowmlt(k) - evprain ) for each original updraft segment [kg/kg/s]
   real(r8)    ntsnprd_msfc(mkx,nseg)           !  Net production rate of snow ( qsten(k) - snowmlt(k) - evpsnow ) for each original updraft segment [kg/kg/s]
   real(r8)    nttrrsprd_msfc(mkx,nseg,ncnst)   !  Net production rate of tracer ( trrsten(k) - evptrrs + wdeptrrs ) for each original updraft segment [kg(#)/kg/s]

   real(r8)    evprain_e(mkx)                   !  Evaporation rate of rain in the environment [kg/kg/s]
   real(r8)    evpsnow_e(mkx)                   !  Evaporation rate of snow in the environment [kg/kg/s]
   real(r8)    evptrrs_e(mkx,ncnst)             !  Evaporation rate of tracers in the environment [kg(#)/kg/s] > 0.
   real(r8)    wdeptrrs_e(mkx,ncnst)            !  Wet deposition rate of tracers in the environment [kg(#)/kg/s] > 0.

   real(r8)    evprain_d(mkx)                   !  Evaporation rate of rain in the downdraft [kg/kg/s]
   real(r8)    evpsnow_d(mkx)                   !  Evaporation rate of snow in the downdraft [kg/kg/s]
   real(r8)    evptrrs_d(mkx,ncnst)             !  Evaporation rate of tracers in the downdraft [kg(#)/kg/s] > 0.

!?  real(r8)    evprain(mkx)                     !  Evaporation rate of rain [kg/kg/s]
!?  real(r8)    evpsnow(mkx)                     !  Evaporation rate of snow [kg/kg/s]
!?  real(r8)    evptrrs(mkx,ncnst)               !  Evaporation rate of tracers [kg(#)/kg/s] > 0.
!?  real(r8)    wdeptrrs(mkx,ncnst)              !  Wet deposition rate of tracers [kg(#)/kg/s] > 0.

   real(r8)    evprain_e_msfc(mkx,nseg)         !  Evaporation rate of rain for each original updraft segment in the environment [kg/kg/s]
   real(r8)    evpsnow_e_msfc(mkx,nseg)         !  Evaporation rate of snow for each original updraft segment in the environment [kg/kg/s]
   real(r8)    evptrrs_e_msfc(mkx,nseg,ncnst)   !  Evaporation rate of tracer for each original updraft segment in the environment [kg(#)/kg/s] > 0.
   real(r8)    wdeptrrs_e_msfc(mkx,nseg,ncnst)  !  Wet deposition rate of tracer for each original updraft segment in the environment [kg(#)/kg/s] > 0.

   real(r8)    evprain_d_msfc(mkx,nseg)         !  Evaporation rate of rain for each original updraft segment in the downdraft [kg/kg/s]
   real(r8)    evpsnow_d_msfc(mkx,nseg)         !  Evaporation rate of snow for each original updraft segment in the downdraft [kg/kg/s]
   real(r8)    evptrrs_d_msfc(mkx,nseg,ncnst)   !  Evaporation rate of tracer for each original updraft segment in the downdraft [kg(#)/kg/s] > 0.

!?  real(r8)    evprain_msfc(mkx,nseg)           !  Evaporation rate of rain for each original updraft segment [kg/kg/s]
!?  real(r8)    evpsnow_msfc(mkx,nseg)           !  Evaporation rate of snow for each original updraft segment [kg/kg/s]
!?  real(r8)    evptrrs_msfc(mkx,nseg,ncnst)     !  Evaporation rate of tracer for each original updraft segment [kg(#)/kg/s] > 0.
!?  real(r8)    wdeptrrs_msfc(mkx,nseg,ncnst)    !  Wet deposition rate of tracer for each original updraft segment [kg(#)/kg/s] > 0.

   real(r8)    cvp_rainprd(mkx)                 !  Corrective production of rain from environmental qv0 [kg/kg/s]
   real(r8)    cvp_snowprd(mkx)                 !  Corrective production of snow from environmental qv0 [kg/kg/s]
   real(r8)    cvp_trrsprd(mkx,ncnst)           !  Corrective production of tracer from environmental tr0 [kg(#)/kg/s]

   real(r8)    cvp_rainprd_msfc(mkx,nseg)       !  Corrective production of rain from environmental qv0 for each original updraft segment [kg/kg/s]
   real(r8)    cvp_snowprd_msfc(mkx,nseg)       !  Corrective production of snow from environmental qv0 for each original updraft segment [kg/kg/s]
   real(r8)    cvp_trrsprd_msfc(mkx,nseg,ncnst) !  Corrective production of tracers from environmental tr0 for each original updraft segment [kg(#)/kg/s]

!?  real(r8)    cvp_rainprd_d(mkx)               !  Corrective production of rain due only to evaporation within downdraft from environmental qv0 [kg/kg/s]
!?  real(r8)    cvp_snowprd_d(mkx)               !  Corrective production of snow due only to evaporation within downdraft from environmental qv0 [kg/kg/s]
!?  real(r8)    cvp_trrsprd_d(mkx,ncnst)         !  Corrective production of tracers due only to evaporation within downdraft from environmental tr0 [kg(#)/kg/s]

   real(r8)    qlten_eff_u(mkx)                 !  Effective diabatic tendency on the   updraft cloud condensate 'ql' [kg/kg/s]
   real(r8)    qiten_eff_u(mkx)                 !  Effective diabatic tendency on the   updraft cloud condensate 'qi' [kg/kg/s]

   real(r8)    qlten_eff_d(mkx)                 !  Effective diabatic tendency on the downdraft cloud condensate 'ql' [kg/kg/s]
   real(r8)    qiten_eff_d(mkx)                 !  Effective diabatic tendency on the downdraft cloud condensate 'qi' [kg/kg/s]

   real(r8)    trten_eff_u(mkx,ncnst)           !  Effective diabatic tendency on the   updraft tracers [#/kg/s, kg/kg/s]
   real(r8)    trten_eff_d(mkx,ncnst)           !  Effective diabatic tendency on the downdraft tracers [#/kg/s, kg/kg/s]

   real(r8)    uf(mkx)                          !  Provisional environmental      zonal wind
   real(r8)    vf(mkx)                          !  Provisional environmental meridional wind

!a  real(r8)    thl_env_ua(mkx)                  !  thl of imported airs into the layer due to the compensating subsidence by   updraft mass flux at the top interface
!a  real(r8)    qt_env_ua(mkx)                   !  qt  of imported airs into the layer due to the compensating subsidence by   updraft mass flux at the top interface
!a  real(r8)    u_env_ua(mkx)                    !  u   of imported airs into the layer due to the compensating subsidence by   updraft mass flux at the top interface
!a  real(r8)    v_env_ua(mkx)                    !  v   of imported airs into the layer due to the compensating subsidence by   updraft mass flux at the top interface
   real(r8)    ql_env_ua(mkx)                   !  ql  of imported airs into the layer due to the compensating subsidence by   updraft mass flux at the top interface
   real(r8)    qi_env_ua(mkx)                   !  qi  of imported airs into the layer due to the compensating subsidence by   updraft mass flux at the top interface

!a  real(r8)    thl_env_da(mkx)                  !  thl of imported airs into the layer due to the compensating subsidence by downdraft mass flux at the top interface
!a  real(r8)    qt_env_da(mkx)                   !  qt  of imported airs into the layer due to the compensating subsidence by downdraft mass flux at the top interface
!a  real(r8)    u_env_da(mkx)                    !  u   of imported airs into the layer due to the compensating subsidence by downdraft mass flux at the top interface
!a  real(r8)    v_env_da(mkx)                    !  v   of imported airs into the layer due to the compensating subsidence by downdraft mass flux at the top interface
   real(r8)    ql_env_da(mkx)                   !  ql  of imported airs into the layer due to the compensating subsidence by downdraft mass flux at the top interface
   real(r8)    qi_env_da(mkx)                   !  qi  of imported airs into the layer due to the compensating subsidence by downdraft mass flux at the top interface

   ! ------------------------------------------------------------------------------------ !
   ! Variables associated with mixing with multiple mixing environmental airs ( '_mxen' ) !
   ! ------------------------------------------------------------------------------------ !

   integer     ktop_mxen(niter)                 !  The top layer index of convective updraft

   real(r8)    cuorg_mxen                       !  Temporary convective organization used only for multiple mixing. Either 0 ( when iter = 1 ) or 1 ( when iter = 2 ) 
   real(r8)    cush_mxen(niter)                 !  Maximum updraft top height [ m ]
   real(r8)    cushavg_mxen(niter)              !  Updraft top height weighted by updraft mass flux at surface [ m ]

   real(r8)    cu_cmfum_mxen(mkx,niter)         !  Total amount of updraft mass flux involved in the buoyancy sorting [kg/m2/s]
   real(r8)    cu_cmfr_mxen(mkx,niter)          !  Total amount of detrained mass into the environment ( may also contain updraft properties ) [kg/m2/s]
   real(r8)    cu_thlr_mxen(mkx,niter)          !  Mass flux weighted anomalous conservative scalar of detrained airs
   real(r8)    cu_qtr_mxen(mkx,niter)       
   real(r8)    cu_ur_mxen(mkx,niter)         
   real(r8)    cu_vr_mxen(mkx,niter)         
   real(r8)    cu_qlr_mxen(mkx,niter)        
   real(r8)    cu_qir_mxen(mkx,niter)        
   real(r8)    cu_trr_mxen(mkx,ncnst,niter)       
   real(r8)    cu_cmfrd_mxen(mkx,niter)         !  Total amount of detrained mass into the environment from convective downdraft [kg/m2/s]
   real(r8)    cu_thlrd_mxen(mkx,niter)      
   real(r8)    cu_qtrd_mxen(mkx,niter)       
   real(r8)    cu_urd_mxen(mkx,niter)         
   real(r8)    cu_vrd_mxen(mkx,niter)         
   real(r8)    cu_qlrd_mxen(mkx,niter)        
   real(r8)    cu_qird_mxen(mkx,niter)        
   real(r8)    cu_trrd_mxen(mkx,ncnst,niter)

!d  real(r8)    cu_prep_mxen(niter)              !  Precipitation flux at surface or PBL top interface [ kg/m2/s ]   
!d  real(r8)    cu_cmfu_mxen(niter)              !  Updraft mass flux at surface [ kg/m2/s ] 
!d  real(r8)    cu_cmfd_mxen(niter)              !  Downdraft mass flux at surface [ kg/m2/s ]
!d  real(r8)    cu_tkePBLorg_mxen(niter)         !  TKE generated by convective organization associated with convective downdraft within PBL [ m2/s2 ]
!d  real(r8)    cu_cmfPBLorg_mxen(niter)         !  Net downdraft mass flux within PBL [ kg/m2/s ]
!d  real(r8)    cu_thlPBLorg_mxen(niter)         !  Mass-flux weighted thl generated by convective organization within PBL [ K ]
!d  real(r8)    cu_qtPBLorg_mxen(niter)
!d  real(r8)    cu_uPBLorg_mxen(niter)
!d  real(r8)    cu_vPBLorg_mxen(niter)

   real(r8)    cmf_u_mxen(0:mkx,niter)          
   real(r8)    cmf_d_mxen(0:mkx,niter)          
   real(r8)    slflx_u_mxen(0:mkx,niter)        
   real(r8)    slflx_d_mxen(0:mkx,niter)        
   real(r8)    qtflx_u_mxen(0:mkx,niter)        
   real(r8)    qtflx_d_mxen(0:mkx,niter)        
   real(r8)    uflx_u_mxen(0:mkx,niter)        
   real(r8)    uflx_d_mxen(0:mkx,niter)        
   real(r8)    vflx_u_mxen(0:mkx,niter)        
   real(r8)    vflx_d_mxen(0:mkx,niter)        

   real(r8)    flxrain_u_mxen(0:mkx,niter)        
   real(r8)    flxsnow_u_mxen(0:mkx,niter)        

!d  real(r8)    slflx_d_org_mxen(0:mkx,niter)        
!d  real(r8)    qtflx_d_org_mxen(0:mkx,niter)        

   real(r8)    thl_orgforce_mxen(niter)          !  Total forcing for organized difference between 'off-wake' and 'grid-mean' thl [ K / s ]
   real(r8)    qt_orgforce_mxen(niter)           !  Total forcing for organized difference between 'off-wake' and 'grid-mean' qt [ kg / kg / s ]
   real(r8)    u_orgforce_mxen(niter)            !  Total forcing for organized difference between 'off-wake' and 'grid-mean' u [ m / s / s ]
   real(r8)    v_orgforce_mxen(niter)            !  Total forcing for organized difference between 'off-wake' and 'grid-mean' v [ m / s / s ]
  ! real(r8)    thv_orgforce_mxen(niter)          !  Total forcing for organized difference between 'off-wake' and 'grid-mean' thv [ K / s ]
   real(r8)    tr_orgforce_mxen(ncnst,niter)     !  Total forcing for organized difference between 'off-wake' and 'grid-mean' tracers [ kg / kg / s or # / kg / s ]    
   real(r8)    awk_orgforce_mxen(niter)          !  Total forcing for wake area [ 1 / s ]

  ! Below block is for detailed diagnostic output

   real(r8)    thl_orgforce_flx_mxen(niter)      !  PBL top flux-related forcing for organized difference between 'off-wake' and 'grid-mean' thl [ K / s ]
   real(r8)    qt_orgforce_flx_mxen(niter)       !  PBL top flux-related forcing for organized difference between 'off-wake' and 'grid-mean' qt [ kg / kg / s ]
   real(r8)    u_orgforce_flx_mxen(niter)        !  PBL top flux-related forcing for organized difference between 'off-wake' and 'grid-mean' u [ m / s / s ]
   real(r8)    v_orgforce_flx_mxen(niter)        !  PBL top flux-related forcing for organized difference between 'off-wake' and 'grid-mean' v [ m / s / s ]
   real(r8)    tr_orgforce_flx_mxen(ncnst,niter) !  PBL top flux-related forcing for organized difference between 'off-wake' and 'grid-mean' tracers [ kg / kg / s or # / kg / s ]    
   real(r8)    awk_orgforce_flx_mxen(niter)      !  PBL top flux-related forcing for wake area [ 1 / s ]

   real(r8)    thl_orgforce_und_mxen(niter)      !  Up-and-Down diabatic forcing for organized difference between 'off-wake' and 'grid-mean' thl [ K / s ]
   real(r8)    qt_orgforce_und_mxen(niter)       !  Up-and-Down diabatic forcing for organized difference between 'off-wake' and 'grid-mean' qt [ kg / kg / s ]
   real(r8)    u_orgforce_und_mxen(niter)        !  Up-and-Down diabatic forcing for organized difference between 'off-wake' and 'grid-mean' u [ m / s / s ]
   real(r8)    v_orgforce_und_mxen(niter)        !  Up-and-Down diabatic forcing for organized difference between 'off-wake' and 'grid-mean' v [ m / s / s ]
   real(r8)    tr_orgforce_und_mxen(ncnst,niter) !  Up-and-Down diabatic forcing for organized difference between 'off-wake' and 'grid-mean' tracers [ kg / kg / s or # / kg / s ]    
   real(r8)    awk_orgforce_mix_mxen(niter)      !  Lateral-Mixing       forcing for wake area [ 1 / s ]

   real(r8)    thl_orgforce_env_mxen(niter)      !  Environment diabatic forcing for organized difference between 'off-wake' and 'grid-mean' thl [ K / s ]
   real(r8)    qt_orgforce_env_mxen(niter)       !  Environment diabatic forcing for organized difference between 'off-wake' and 'grid-mean' qt [ kg / kg / s ]
   real(r8)    u_orgforce_env_mxen(niter)        !  Environment diabatic forcing for organized difference between 'off-wake' and 'grid-mean' u [ m / s / s ]
   real(r8)    v_orgforce_env_mxen(niter)        !  Environment diabatic forcing for organized difference between 'off-wake' and 'grid-mean' v [ m / s / s ]
   real(r8)    tr_orgforce_env_mxen(ncnst,niter) !  Environment diabatic forcing for organized difference between 'off-wake' and 'grid-mean' tracers [ kg / kg / s or # / kg / s ]    
   real(r8)    cmf_d_org_pblh_mxen(niter)        !  Organization-inducing downdraft mass flux at the PBL top interface [ kg / m^2 / s ] 

  ! Above block is for detailed diagnostic output

   real(r8)    taui_thl_mxen(niter)              !  Inverse of damping time scale of the difference between 'off-wake' and 'grid-mean' thl [ 1 / s ]
   real(r8)    taui_qt_mxen(niter)               !  Inverse of damping time scale of the difference between 'off-wake' and 'grid-mean' qt [ 1 / s ]
   real(r8)    taui_u_mxen(niter)                !  Inverse of damping time scale of the difference between 'off-wake' and 'grid-mean' u [ 1 / s ]
   real(r8)    taui_v_mxen(niter)                !  Inverse of damping time scale of the difference between 'off-wake' and 'grid-mean' v [ 1 / s ]
   ! real(r8)    taui_thv_mxen(niter)              !  Inverse of damping time scale of the difference between 'off-wake' and 'grid-mean' thv [ 1 / s ]
   real(r8)    taui_tr_mxen(ncnst,niter)         !  Inverse of damping time scale of the difference between 'off-wake' and 'grid-mean' tracers [ 1 / s ]
   real(r8)    taui_awk_mxen(niter)              !  Inverse of damping time scale of the wake area [ 1 / s ]


   !og  
   real(r8)    del_org_mxen(niter)               !  Detrainment rate of the cold pool [ 1 / s ]
   real(r8)    del0_org_mxen(niter)              !  Effective detrainment rate of the cold pool [ 1 / s ]
   !og

   real(r8)    qvten_mxen(mkx,niter)          
   real(r8)    qlten_mxen(mkx,niter)          
   real(r8)    qiten_mxen(mkx,niter)          
   real(r8)    trten_mxen(mkx,ncnst,niter)          
   real(r8)    sten_mxen(mkx,niter)           
   real(r8)    uten_mxen(mkx,niter)           
   real(r8)    vten_mxen(mkx,niter)           
   real(r8)    qrten_mxen(mkx,niter)          
   real(r8)    qsten_mxen(mkx,niter)          

   real(r8)    rqc_l_mxen(mkx,niter)        
   real(r8)    rqc_i_mxen(mkx,niter)        
   real(r8)    rqc_mxen(mkx,niter)          
   real(r8)    rnc_l_mxen(mkx,niter)        
   real(r8)    rnc_i_mxen(mkx,niter)        

   real(r8)    cmf_det_mxen(mkx,niter)        
   real(r8)    ql_det_mxen(mkx,niter)        
   real(r8)    qi_det_mxen(mkx,niter)        

   real(r8)    evapc_mxen(mkx,niter)       

   real(r8)    am_u_mxen(mkx,niter)      
   real(r8)    qlm_u_mxen(mkx,niter)     
   real(r8)    qim_u_mxen(mkx,niter)     

   real(r8)    am_d_mxen(mkx,niter)      
   real(r8)    qlm_d_mxen(mkx,niter)     
   real(r8)    qim_d_mxen(mkx,niter)     

   real(r8)    rliq_mxen(niter)           
   real(r8)    rice_mxen(niter)           
   real(r8)    precip_mxen(niter)         
   real(r8)    snow_mxen(niter)           

   real(r8)    cnt_mxen(niter)            
   real(r8)    cnb_mxen(niter)            

   real(r8)    slten_u_mxen(mkx,niter)    
   real(r8)    qtten_u_mxen(mkx,niter)    
   real(r8)    uten_u_mxen(mkx,niter)     
   real(r8)    vten_u_mxen(mkx,niter)     
   real(r8)    sten_u_mxen(mkx,niter)     
   real(r8)    qvten_u_mxen(mkx,niter)    
   real(r8)    qlten_u_mxen(mkx,niter)    
   real(r8)    qiten_u_mxen(mkx,niter)    
   real(r8)    trten_u_mxen(mkx,ncnst,niter) 

   real(r8)    slten_d_mxen(mkx,niter)     
   real(r8)    qtten_d_mxen(mkx,niter)     
   real(r8)    uten_d_mxen(mkx,niter)      
   real(r8)    vten_d_mxen(mkx,niter)      
   real(r8)    sten_d_mxen(mkx,niter)      
   real(r8)    qvten_d_mxen(mkx,niter)     
   real(r8)    qlten_d_mxen(mkx,niter)     
   real(r8)    qiten_d_mxen(mkx,niter)     
   real(r8)    trten_d_mxen(mkx,ncnst,niter)  

   real(r8)    slten_evp_mxen(mkx,niter)  
   real(r8)    qtten_evp_mxen(mkx,niter)  
   real(r8)    uten_evp_mxen(mkx,niter)   
   real(r8)    vten_evp_mxen(mkx,niter)   
   real(r8)    sten_evp_mxen(mkx,niter)   
   real(r8)    qvten_evp_mxen(mkx,niter)  
   real(r8)    qlten_evp_mxen(mkx,niter)  
   real(r8)    qiten_evp_mxen(mkx,niter)  
   real(r8)    trten_evp_mxen(mkx,ncnst,niter) 
   real(r8)    trten_wdep_mxen(mkx,ncnst,niter) 

  ! Mar.27.2012. I don't need below anymore since dissipation heating is computed after performing
  !              all the ensemble-mean average. 
  !              So, I removed below 9 variables associated with dissipation heating.

  ! real(r8)    slten_dis_mxen(mkx,niter) 
  ! real(r8)    qtten_dis_mxen(mkx,niter) 
  ! real(r8)    uten_dis_mxen(mkx,niter)  
  ! real(r8)    vten_dis_mxen(mkx,niter)  
  ! real(r8)    sten_dis_mxen(mkx,niter)  
  ! real(r8)    qvten_dis_mxen(mkx,niter) 
  ! real(r8)    qlten_dis_mxen(mkx,niter) 
  ! real(r8)    qiten_dis_mxen(mkx,niter) 
  ! real(r8)    trten_dis_mxen(mkx,ncnst,niter) 

   real(r8)    qlten_sub_mxen(mkx,niter)     
   real(r8)    qiten_sub_mxen(mkx,niter)     

   real(r8)    qlten_det_mxen(mkx,niter)     
   real(r8)    qiten_det_mxen(mkx,niter)     

   real(r8)    thl_u_mxen(0:mkx,niter)      
   real(r8)    qt_u_mxen(0:mkx,niter)       
   real(r8)    u_u_mxen(0:mkx,niter)        
   real(r8)    v_u_mxen(0:mkx,niter)        
   real(r8)    w_u_mxen(0:mkx,niter)        
   real(r8)    ql_u_mxen(0:mkx,niter)       
   real(r8)    qi_u_mxen(0:mkx,niter)       
   real(r8)    tr_u_mxen(0:mkx,ncnst,niter)    
   real(r8)    a_u_mxen(0:mkx,niter)      
   real(r8)    num_u_mxen(0:mkx,niter)    
   real(r8)    wa_u_mxen(0:mkx,niter)     
   real(r8)    qla_u_mxen(0:mkx,niter)    
   real(r8)    qia_u_mxen(0:mkx,niter)    
   real(r8)    rad_u_mxen(0:mkx,niter)    
   real(r8)    thva_u_mxen(0:mkx,niter)     

   real(r8)    a_p_mxen(0:mkx,niter)      
   real(r8)    am_evp_mxen(mkx,niter)      
   real(r8)    am_pu_mxen(mkx,niter)      
   real(r8)    x_p_mxen(0:mkx,niter)      
   real(r8)    y_p_mxen(0:mkx,niter)      
   real(r8)    x_um_mxen(mkx,niter)      
   real(r8)    y_um_mxen(mkx,niter)      

   real(r8)    thl_d_mxen(0:mkx,niter)     
   real(r8)    qt_d_mxen(0:mkx,niter)      
   real(r8)    u_d_mxen(0:mkx,niter)       
   real(r8)    v_d_mxen(0:mkx,niter)       
   real(r8)    w_d_mxen(0:mkx,niter)       
   real(r8)    ql_d_mxen(0:mkx,niter)      
   real(r8)    qi_d_mxen(0:mkx,niter)      
   real(r8)    tr_d_mxen(0:mkx,ncnst,niter)      
   real(r8)    a_d_mxen(0:mkx,niter)          
   real(r8)    wa_d_mxen(0:mkx,niter)         
   real(r8)    qla_d_mxen(0:mkx,niter)        
   real(r8)    qia_d_mxen(0:mkx,niter)        

   real(r8)    thl_u_msfc_mxen(0:mkx,nseg,niter) 
   real(r8)    qt_u_msfc_mxen(0:mkx,nseg,niter)  
   real(r8)    u_u_msfc_mxen(0:mkx,nseg,niter)   
   real(r8)    v_u_msfc_mxen(0:mkx,nseg,niter)   
   real(r8)    w_u_msfc_mxen(0:mkx,nseg,niter)   
   real(r8)    ql_u_msfc_mxen(0:mkx,nseg,niter)  
   real(r8)    qi_u_msfc_mxen(0:mkx,nseg,niter)  
   real(r8)    tr_u_msfc_mxen(0:mkx,nseg,ncnst,niter)
   real(r8)    cmf_u_msfc_mxen(0:mkx,nseg,niter)  
   real(r8)    a_u_msfc_mxen(0:mkx,nseg,niter)    
   real(r8)    num_u_msfc_mxen(0:mkx,nseg,niter)  
   real(r8)    rad_u_msfc_mxen(0:mkx,nseg,niter)  

   real(r8)    eps0_u_msfc_mxen(0:mkx,nseg,niter)    
   real(r8)    eps_u_msfc_mxen(0:mkx,nseg,niter)     
   real(r8)    del_u_msfc_mxen(0:mkx,nseg,niter)     
   real(r8)    eeps_u_msfc_mxen(0:mkx,nseg,niter)    
   real(r8)    ddel_u_msfc_mxen(0:mkx,nseg,niter)    
   real(r8)    xc_u_msfc_mxen(0:mkx,nseg,niter)      
   real(r8)    xs_u_msfc_mxen(0:mkx,nseg,niter)      
   real(r8)    xemin_u_msfc_mxen(0:mkx,nseg,niter)   
   real(r8)    xemax_u_msfc_mxen(0:mkx,nseg,niter)    
   real(r8)    cridis_u_msfc_mxen(0:mkx,nseg,niter)   
   real(r8)    thvcuenv_u_msfc_mxen(0:mkx,nseg,niter) 
   real(r8)    thvegenv_u_msfc_mxen(0:mkx,nseg,niter) 
   real(r8)    thvxsenv_u_msfc_mxen(0:mkx,nseg,niter) 
   real(r8)    fmix_u_msfc_mxen(0:mkx,nseg,niter)     
   real(r8)    cmfumix_u_msfc_mxen(0:mkx,nseg,niter)  

   real(r8)    thl_d_msfc_mxen(0:mkx,nseg,niter)       
   real(r8)    qt_d_msfc_mxen(0:mkx,nseg,niter)       
   real(r8)    u_d_msfc_mxen(0:mkx,nseg,niter)       
   real(r8)    v_d_msfc_mxen(0:mkx,nseg,niter)       
   real(r8)    w_d_msfc_mxen(0:mkx,nseg,niter)       
   real(r8)    ql_d_msfc_mxen(0:mkx,nseg,niter)      
   real(r8)    qi_d_msfc_mxen(0:mkx,nseg,niter)      
   real(r8)    tr_d_msfc_mxen(0:mkx,nseg,ncnst,niter) 
   real(r8)    cmf_d_msfc_mxen(0:mkx,nseg,niter)   
   real(r8)    a_d_msfc_mxen(0:mkx,nseg,niter)     
   real(r8)    wa_d_msfc_mxen(0:mkx,nseg,niter)    
   real(r8)    qla_d_msfc_mxen(0:mkx,nseg,niter)   
   real(r8)    qia_d_msfc_mxen(0:mkx,nseg,niter)   

   integer     ktop_msfc_mxen(nseg,niter) 
   real(r8)    ptop_msfc_mxen(nseg,niter) 
   real(r8)    ztop_msfc_mxen(nseg,niter) 

!d  real(r8)    orgforce1_mxen(niter)                
!d  real(r8)    orgforce2_mxen(niter)                
!d  real(r8)    orgforce3_mxen(niter)                

   ! ---------------- !
   ! Single Variables !
   ! ---------------- !

   character(len=2)  numcha 
   character(len=6)  PDFtype
   integer     i, k, kv, ki, kvi, km, kp, ks, ksm, m, mm, ids, kc, kcp, kk, kkm, mt, it, l, lspec, ixi, ixf, jj
   integer     iter, ivar, iter_w_db, iacc
   integer     nseg_det, nseg_nondet
   integer     ktop, ktop_up_par, ktop_dn_par, ks_top, ks_bot, msfc
   integer     ixcldliq, ixcldice, ixnumliq, ixnumice
   integer     i_awk, i_thl, i_qt, i_u, i_v

   !f  logical     id_exit

   integer     N_up(0:mkx)                      !  # of updraft segments at the base interface [ # ]
   real(r8)    pes(mkx)                         !  Updraft buoyancy sorting level [ Pa ]

   integer     ipbl                             !  If 1, PBL is CL, while if 0, PBL is STL.
   integer     kpblh                            !  Layer index with PBL top in it or at the base interface 
   integer     kpblhm                           !  = kpblh - 1
   real(r8)    pblh                             !  PBL top height [ m ]
   real(r8)    pblhz                            !  Thickness of PBL depth in [ m ].  pblhz = zs0(kpblhm) - zs0(0).
   real(r8)    pblhp                            !  Thickness of PBL depth in [ Pa ]. pblhp = ps0(0) - ps0(kpblhm).
   real(r8)    wstar                            !  Turbulent convective velocity scale within PBL [ m/s ]
   real(r8)    tkes                             !  Turbulent kinetic energy at surface directly from the UW PBL scheme [ m/s ]
   real(r8)    went                             !  Entrainment rate at the PBL top interface directly from the UW PBL scheme [ m/s ]
   real(r8)    qflx                             !  Upward water vapor flux into atmosphere at surface [ kg/m2/s ]
   real(r8)    shflx                            !  Upward sensible heat flux into atmosphere at surface [ J/m2/s ]
   real(r8)    taux                             !  Upward zonal      wind stress into atmosphere at surface [ kg m/s /m2/s ]
   real(r8)    tauy                             !  Upward meridional wind stress into atmosphere at surface [ kg m/s /m2/s ] 
   real(r8)    aflx(ncnst)                      !  Upward tracer fluxes          into atmosphere at surface [ #/m2/s, kg/m2/s ]
   real(r8)    ocnfrac                          !  Ocean Fraction [ fraction ]
   real(r8)    landfrac                         !  Land  Fraction [ fraction ]
   real(r8)    icefrac                          !  Ice   Fraction [ fraction ]
   real(r8)    sgh                              !  Standard deviation of subgrid topographic height [ meter ] 
   real(r8)    sgh30                            !  Standard deviation of subgrid topographic height at 30 s horizontal area [ meter ] 
   real(r8)    cush                             !  Input cumulus top height [ m ]
   real(r8)    cushavg                          !  Input mean cumulus top height weighted by updraft mass flux at surface [ m ]
   real(r8)    cuorg                            !  Input convective organization [ 0-1 ]
   real(r8)    awk_PBL_raw                      !  Wake area within PBL [ 0 - 1 ]
   real(r8)    delta_thl_PBL_raw                !  Difference of thl between off-wake region and grid-mean value averaged over the PBL [ K ]
   real(r8)    delta_qt_PBL_raw                 !  Difference of qt  between off-wake region and grid-mean value averaged over the PBL [ kg/kg ]
   real(r8)    delta_u_PBL_raw                  !  Difference of u   between off-wake region and grid-mean value averaged over the PBL [ m/s ]
   real(r8)    delta_v_PBL_raw                  !  Difference of v   between off-wake region and grid-mean value averaged over the PBL [ m/s ]
   real(r8)    delta_thv_PBL_raw                !  Difference of thv between off-wake region and grid-mean value averaged over the PBL [ K ]
   real(r8)    delta_tr_PBL_raw(ncnst)          !  Difference of tr  between off-wake region and grid-mean value averaged over the PBL [ kg/kg, #/kg ]
   real(r8)    awk_PBL_max                      !  Maximum alloed wake area within PBL [ 0 - 1 ]
   real(r8)    awk_PBL                          !  Wake area within PBL [ 0 - 1 ]
   real(r8)    delta_thl_PBL                    !  Difference of thl between off-wake region and grid-mean value averaged over the PBL [ K ]
   real(r8)    delta_qt_PBL                     !  Difference of qt  between off-wake region and grid-mean value averaged over the PBL [ kg/kg ]
   real(r8)    delta_u_PBL                      !  Difference of u   between off-wake region and grid-mean value averaged over the PBL [ m/s ]
   real(r8)    delta_v_PBL                      !  Difference of v   between off-wake region and grid-mean value averaged over the PBL [ m/s ]
   real(r8)    delta_thv_PBL                    !  Difference of thv between off-wake region and grid-mean value averaged over the PBL [ K ]
   real(r8)    delta_tr_PBL(ncnst)              !  Difference of tr  between off-wake region and grid-mean value averaged over the PBL [ kg/kg, #/kg ]
   real(r8)    delta_w_PBL                      !  Difference of w   between off-wake region and grid-mean value averaged over the PBL [ m/s ]
!d  real(r8)    cu_prep(mit)     
!d  real(r8)    cu_cmfu(mit)      
!d  real(r8)    cu_cmfd(mit)      
!d  real(r8)    cu_tkePBLorg(mit)     
!d  real(r8)    cu_cmfPBLorg(mit)     
!d  real(r8)    cu_thlPBLorg(mit)     
!d  real(r8)    cu_qtPBLorg(mit)
!d  real(r8)    cu_uPBLorg(mit)
!d  real(r8)    cu_vPBLorg(mit)
   real(r8)    cu_cmfum(mkx)     
   real(r8)    cu_cmfr(mkx)      
   real(r8)    cu_thlr(mkx)      
   real(r8)    cu_qtr(mkx)       
   real(r8)    cu_ur(mkx)         
   real(r8)    cu_vr(mkx)         
   real(r8)    cu_qlr(mkx)        
   real(r8)    cu_qir(mkx)        
   real(r8)    cu_trr(mkx,ncnst)
   real(r8)    cu_cmfrd(mkx)      
   real(r8)    cu_thlrd(mkx)      
   real(r8)    cu_qtrd(mkx)       
   real(r8)    cu_urd(mkx)         
   real(r8)    cu_vrd(mkx)         
   real(r8)    cu_qlrd(mkx)        
   real(r8)    cu_qird(mkx)        
   real(r8)    cu_trrd(mkx,ncnst)
  ! real(r8)    cush_out                         !  Updated cumulus top height [ m ]
  ! real(r8)    cushavg_out                      !  Updated mean cumulus top height weighted by updraft mass flux at surface [ m ]
  ! real(r8)    cuorg_out                        !  Updated convective organization at 't + dt' for use at the next time step [ 0-1 ]
  ! real(r8)    cu_prep_out     
  ! real(r8)    cu_cmfu_out      
  ! real(r8)    cu_cmfd_out
  ! real(r8)    cu_tkePBLorg_out
  ! real(r8)    cu_cmfPBLorg_out
  ! real(r8)    cu_thlPBLorg_out     
  ! real(r8)    cu_qtPBLorg_out 
  ! real(r8)    cu_uPBLorg_out 
  ! real(r8)    cu_vPBLorg_out 
  ! real(r8)    cu_cmfum_out(mkx)     
  ! real(r8)    cu_cmfr_out(mkx)      
  ! real(r8)    cu_thlr_out(mkx)      
  ! real(r8)    cu_qtr_out(mkx)       
  ! real(r8)    cu_ur_out(mkx)         
  ! real(r8)    cu_vr_out(mkx)         
  ! real(r8)    cu_qlr_out(mkx)        
  ! real(r8)    cu_qir_out(mkx)        
  ! real(r8)    cu_trr_out(mkx,ncnst) 
  ! real(r8)    cu_cmfrd_out(mkx)      
  ! real(r8)    cu_thlrd_out(mkx)      
  ! real(r8)    cu_qtrd_out(mkx)       
  ! real(r8)    cu_urd_out(mkx)         
  ! real(r8)    cu_vrd_out(mkx)         
  ! real(r8)    cu_qlrd_out(mkx)        
  ! real(r8)    cu_qird_out(mkx)        
  ! real(r8)    cu_trrd_out(mkx,ncnst)
   real(r8)    tke1                             !  TKE in the lowest model layer [ m2/s2 ] 
   real(r8)    wstar1                           !  wstar in the lowest model layer ( = ( 2.5 integral ( bprod * dz ) )^(1/3) ) [ m/s ]
   real(r8)    wstar2                           !  wstar2 = ( bprod_sfc * PBLH )^(1/3) [ m/s ] 
   real(r8)    tkePBL                           !  TKE within the PBL [ m2/s2 ] 
   real(r8)    wstarPBL                         !  wstar within the PBL [ m/s ]. In principle, should be the sams as the input wstar but not. 
   real(r8)    dpi, dzi
   real(r8)    qt0PBL, thl0PBL, u0PBL, v0PBL, tr0PBL(ncnst)
   real(r8)    qt0min_PBL, thl0min_PBL, tr0min_PBL(ncnst)
   real(r8)    awk_PBL_eff
   real(r8)    eps_wk_eff, del_wk_eff
   real(r8)    a_oro                            !  Forbidden area from the subgrid scale variation of topography [ fraction ]
   real(r8)    a_forbid                         !  Total forbidden area ( awk_PBL + a_oro ) [ fraction ]
   real(r8)    c0_ac_z                          !  Auto-conversion efficiency of CAM5 deep convection scheme [ 1 / m ]
   real(r8)    c0_ac                            !  Auto-conversion efficiency of CAM5 deep convection scheme [ 1 / Pa ]
   real(r8)    criqc                            !  Critical condensate amount that updraft can hold [ kg / kg ] 
   real(r8)    au_base_max, au_base_min
   real(r8)    kevp_rain_dn, kevp_snow_dn
   real(r8)    kevp_rain, kevp_snow
   real(r8)    droprad_liq, droprad_ice
   real(r8)    droprad_rain, droprad_snow

   real(r8)    cnt, cnb                         !  Cloud top and base interface indices
   real(r8)    d_alpha
   real(r8)    z_b, z_m, z_t
   real(r8)    p_b, p_m, p_t
   real(r8)    dz_m, dp_m, pdelx
   real(r8)    exn_b, exn_m, exn_t
   real(r8)    thl_b, thl_m, thl_t
   real(r8)    qt_b, qt_m, qt_t
   real(r8)    tr_b(ncnst), tr_m(ncnst), tr_t(ncnst)
   real(r8)    u_b, u_m, u_t
   real(r8)    v_b, v_m, v_t
   real(r8)    ql_b, ql_m, ql_t
   real(r8)    qi_b, qi_m, qi_t
   real(r8)    thv_b, thv_t
   real(r8)    thv_mean_b, thv_mean_t
   real(r8)    thvbot, thvtop 
   real(r8)    thl0lcl, qt0lcl, thv0lcl
   real(r8)    cin, cinlcl, cinp
   real(r8)    plcl, plfc, plnb
   real(r8)    thvl_b, thvl_t
   real(r8)    rho_b, rho_m, rho_t
   real(r8)    thvl_minE, thv_minE
   real(r8)    dp, dz, rho
   real(r8)    thle_b(mkx)
   real(r8)    thle_m(mkx)
   real(r8)    thle_t(mkx)
   real(r8)    qte_b(mkx)
   real(r8)    qte_m(mkx)
   real(r8)    qte_t(mkx)
   real(r8)    tre_b(mkx,ncnst)
   real(r8)    tre_m(mkx,ncnst)
   real(r8)    tre_t(mkx,ncnst)
   real(r8)    ue_b(mkx)
   real(r8)    ue_m(mkx)
   real(r8)    ue_t(mkx)
   real(r8)    ve_b(mkx)
   real(r8)    ve_m(mkx)
   real(r8)    ve_t(mkx)
   real(r8)    we_b(mkx)
   real(r8)    we_m(mkx)
   real(r8)    we_t(mkx)
   real(r8)    qle_b(mkx)
   real(r8)    qle_m(mkx)
   real(r8)    qle_t(mkx)
   real(r8)    qie_b(mkx)
   real(r8)    qie_m(mkx)
   real(r8)    qie_t(mkx)
   real(r8)    ssthle(mkx)
   real(r8)    ssqte(mkx)
   real(r8)    ssue(mkx)
   real(r8)    ssve(mkx)
   real(r8)    ssqle(mkx)
   real(r8)    ssqie(mkx)
   real(r8)    sstre(mkx,ncnst)
   real(r8)    pe
   real(r8)    w_cu
   real(r8)    thl_cu, qt_cu
   real(r8)    ql_cu, qi_cu
   real(r8)    thl_eg, qt_eg, rh_eg
   real(r8)    thv_cu, thv_eg, thv_xs
   real(r8)    u_eg, v_eg, w_eg
   real(r8)    tr_eg(ncnst)
   real(r8)    thv_env
   real(r8)    gamv_en
   real(r8)    gamv_cu
   real(r8)    cridis
   real(r8)    thl_cumC, thl_cumS, thl_cumE 
   real(r8)    qt_cumC, qt_cumS, qt_cumE 
   real(r8)    thvl_cumC, thvl_cumS, thvl_cumE, thvl_aut
   real(r8)    thv_cumC, thv_cumS, thv_cumE
   real(r8)    xdown_min, xdown_max
   real(r8)    zbar, zbar1, zbar2 
   real(r8)    zmass, zmass1, zmass2
   real(r8)    zmass_up, zmass_up1, zmass_up2
   real(r8)    th, qv, ql, qi, qse
   real(r8)    es, qs
   integer     id_check
   real(r8)    bogbot, bogtop, boglcl, wu2 
   real(r8)    thv, thv_dt, thv_db, thvl
   real(r8)    thl, qt, u, v
   real(r8)    tr(ncnst) 
   real(r8)    thl_med, qt_med, ql_med, qi_med, qv_med, u_med, v_med
   real(r8)    thl_meu, qt_meu, ql_meu, qi_meu, qv_meu, u_meu, v_meu
   real(r8)    tr_med(ncnst), tr_meu(ncnst) 
   real(r8)    fac, sum_mix
   real(r8)    f_nu, f_nd, f_wd
   real(r8)    cmf_dt, thl_dt, qt_dt, u_dt, v_dt, w_dt
   real(r8)    tr_dt(ncnst)
   real(r8)    cmf_db, thl_db, qt_db, u_db, v_db, w_db, thvl_db
   real(r8)    tr_db(ncnst)
!q  real(r8)    thl_db_ori, qt_db_ori, tr_db_ori(ncnst)
!q  real(r8)    th_db_ori, qs_db_ori, qv_db_ori, ql_db_ori, qi_db_ori
!q  real(r8)    qw_db_ori, tw_db_ori, subsat_db_ori, w_db_ori
   real(r8)    qw_db, tw_db
   real(r8)    cmf_dbt
   real(r8)    evp_thll, evp_qtl, evp_thli, evp_qti
   real(r8)    evp_thl, evp_qt
   real(r8)    evp_max
   real(r8)    evp_tr(ncnst)
   real(r8)    prep_thll, prep_qtl, prep_thli, prep_qti
   real(r8)    prep_tr(ncnst)
!   real(r8)    wdep_tr(ncnst)
   real(r8)    exql, exqi, extr(ncnst)
   real(r8)    evpR, evpS, evpRStr(ncnst)
!z  real(r8)    S_t_ql, S_t_qi
!ice   real(r8)    frac_ice, frac_ice_eg 
   real(r8)    u_grd, v_grd, u_grdPGF, v_grdPGF, PGF_u, PGF_v
   real(r8)    cmf_aread
   real(r8)    thlten_sub, qtten_sub 
   real(r8)    thl_prog, qt_prog
   real(r8)    um, dm 
   real(r8)    thl_env_u, thl_env_d
   real(r8)    qt_env_u, qt_env_d
   real(r8)    u_env_u, u_env_d
   real(r8)    v_env_u, v_env_d
   real(r8)    ql_env_u, ql_env_d
   real(r8)    qi_env_u, qi_env_d
   real(r8)    tr_env_u, tr_env_d
   real(r8)    timeres
   !p  real(r8)    dt_evpd              !  Evaporation time scale within downdraft [ s ] 
   real(r8)    flxrain_top, flxsnow_top, flxrasn_top
   real(r8)    flxrain_top_in, flxsnow_top_in, flxrasn_top_in
   real(r8)    flxrain_bot_ee, flxsnow_bot_ee
   real(r8)    flxrain_bot_up, flxsnow_bot_up
   real(r8)    flxrain_bot_upee, flxsnow_bot_upee
   real(r8)    flxrain_bot_upeesm, flxsnow_bot_upeesm
   real(r8)    flxrain_bot, flxsnow_bot
   real(r8)    flxtrrs_top(ncnst)
   real(r8)    flxtrrs_top_in(ncnst)
   real(r8)    flxtrrs_bot_up(ncnst)
   real(r8)    flxtrrs_bot_upee(ncnst)
   real(r8)    flxtrrs_bot_upeesm(ncnst)
   real(r8)    flxtrrs_bot(ncnst)
!?  real(r8)    flx_all, flxtrrs_all(ncnst)
!?  real(r8)    flx_all_in, flxrain_all_in, flxsnow_all_in, flxtrrs_all_in(ncnst)
   real(r8)    tmp1, tmp2, tmp3, tmp4, tmp5, tmp(3), tmp_l, tmp_i, tmp_tr(ncnst)
   real(r8)    tmp_thl, tmp_qt, tmp_th, tmp_qv, tmp_ql, tmp_qi, tmp_qse
   real(r8)    thl_aut_tmp, qt_aut_tmp, tr_aut_tmp(ncnst)
   real(r8)    ql_aut_adi_prp, qi_aut_adi_prp 
   real(r8)    dp_sub, p_ini, p_fin, thl_cen, qt_cen
   real(r8)    ql_cu_ini, qi_cu_ini, thl_cu_ini, qt_cu_ini
   real(r8)    tmpx, tmpx_bot, tmpx_top, tmpy, tmpy_bot, tmpy_top, tmpw
   real(r8)    f_Rt, f_Rb, f_St, f_Sb, f_R, f_S
   real(r8)    f_Lt, f_Lb, f_It, f_Ib, f_L, f_I
   real(r8)    eps_dia_L, eps_dia_I, eps_dia_V, srcg_V
   real(r8)    dia_thl, dia_qt
   real(r8)    evplimit
   real(r8)    evprain_clr, evpsnow_clr, evplimit_clr_rain, evplimit_clr_snow, evplimit_clr
   real(r8)    subsat_clr, qw_clr, qv_clr
!?  real(r8)    subsat_db, subsat_dt
   real(r8)    subsat, tw, qw
  ! real(r8)    snowmlt
   real(r8)    rainflx              !  Convective rain flux at surface [kg/m2/s]
   real(r8)    snowflx              !  Convective snow flux at surface [kg/m2/s]
   real(r8)    trrsflx(ncnst)       !  Convective tracer flux at surface [kg(#)/m2/s]
!?  real(r8)    flxrain_all          !  Convective rain flux [kg/m2/s]
!?  real(r8)    flxsnow_all          !  Convective snow flux [kg/m2/s]
!?  real(r8)    flxrain_min          !  Convective rain flux [kg/m2/s]
!?  real(r8)    flxsnow_min          !  Convective snow flux [kg/m2/s]
   real(r8)    precip               !  Convective rain+snow flux at surface [m/s]
   real(r8)    snow                 !  Convective snow flux at surface [m/s]
   real(r8)    evapc(mkx)           !  Evaporation rate of convective precipitation within environment [ kg/kg/s ]
   real(r8)    evapc_msfc(mkx,nseg) !  Evaporation rate of convective precipitation within environment for each original updraft segment [ kg/kg/s ]
   real(r8)    rliq                 !  Vertical integration of rqc in flux unit [m/s]
   real(r8)    rice                 !  Vertical integration of rqc_l in flux unit [m/s]
!?  real(r8)    evpint_rain          !  Vertically-integrated evaporation flux of rain from the top layer to the layer just above the current layer [kg/m2/s]
!?  real(r8)    evpint_snow          !  Vertically-integrated evaporation flux of snow from the top layer to the layer just above the current layer [kg/m2/s]
!?  real(r8)    evpint_trrs(ncnst)   !  Vertically-integrated evaporation flux of tracer from the top layer to the layer just above the current layer [kg(#)/m2/s]
   real(r8)    sigma_w, sigma_thl, sigma_qt, sigma_u, sigma_v
   real(r8)    sigma_tr(ncnst)
   real(r8)    cmf_tent, au_tent, ad_tent
!?  real(r8)    eta11, eta22
   real(r8)    mass_adi, cc
   real(r8)    va_adi, va_dia, va_ext, va_i, va_f, va_ten   
!a  real(r8)    CFL
   real(r8)    alpha_cri, I_cri
   real(r8)    Ro, sigmaR
   real(r8)    Ro_min, Ro_max, sigmaR_min, sigmaR_max
   real(r8)    Ro_ocn, Ro_lnd, sigmaR_ocn, sigmaR_lnd
   ! real(r8)    cadj_area_ocn
   real(r8)    kw_min, kw_max
   real(r8)    kw_internal
   ! real(r8)    kw_min_ocn, kw_max_ocn, kw_min_lnd, kw_max_lnd 
   real(r8)    cdelta_s, cdelta_w
  ! real(r8)    R_buomin, R_buomax
  ! real(r8)    R_buomax
  ! real(r8)    R_buo
   real(r8)    rbuoy_up, rbuoy_dn
   real(r8)    mu
   real(r8)    tlcl, rlcl
   real(r8)    thv_max, thv_min, fddet  ! For continuous downdraft buoyancy sorting 

   ! ------------------------------------------------- !
   ! Variables associated with convective organization !
   ! ------------------------------------------------- !

!d  integer     nstep_org
!d  real(r8)    org_rad, org_src, org_ent, sum 
   real(r8)    org_rad, org_ent, sum 
!d  real(r8)    rhfer, b2, rei2, rei1b, rei2b, eps0_kpbl 
!d  real(r8)    prep_old, cmfu_old, cmfd_old
!d  real(r8)    cmf_d_sfcorg
!d  real(r8)    orgforce1, orgforce2, orgforce3 
!d  real(r8)    orgforce1_out(mix), orgforce2_out(mix), orgforce3_out(mix), orgforce_out(mix)
!d  real(r8)    tau_org, tau_TKE
!d  real(r8)    tau_org_out(mix), tau_TKE_out(mix)
   real(r8)    kw, au_base, au_base_ocn, au_base_lnd, AOVTU 
   real(r8)    tmpm_array(mix,mkx), tmpi_array(mix,0:mkx)
!d  real(r8)    w_org, turn_org
!d  real(r8)    tkePBLorgDN, thlPBLorgDN, qtPBLorgDN
!d  real(r8)    tkePBLorgEV, thlPBLorgEV, qtPBLorgEV
!d  real(r8)    tkePBLorg, cmfPBLorg, thlPBLorg, qtPBLorg, uPBLorg, vPBLorg
!d  real(r8)    tkePBLorg_old, cmfPBLorg_old, thlPBLorg_old, qtPBLorg_old, uPBLorg_old, vPBLorg_old
   real(r8)    ws1, went_eff
   real(r8)    cd_thl, cd_qt, cd_u, cd_v, cd_thv, cd_tr(ncnst)

   ! --------------------------- !
   ! Diagnostic Output Variables !
   ! --------------------------- !

   real(r8)    kw_out(mix)

   real(r8)    sigma_w_out(mix)
   real(r8)    sigma_thl_out(mix)
   real(r8)    sigma_qt_out(mix)
   real(r8)    sigma_u_out(mix)
   real(r8)    sigma_v_out(mix)
   
   real(r8)    w_org_out(mix)
   real(r8)    thl_org_out(mix)
   real(r8)    qt_org_out(mix)
   real(r8)    u_org_out(mix)
   real(r8)    v_org_out(mix)
   
   real(r8)    tkes_out(mix)
   real(r8)    went_out(mix)
   real(r8)    went_eff_out(mix)

   ! ----------------------------------------------------------------------------------- !
   ! Rain and snow mixing ratios at the top and base interface of each layer.            !
   ! These are used for including condensate loading effect within convective downdraft. !
   ! ----------------------------------------------------------------------------------- !

   real(r8)    qrain_t, qrain_b, qsnow_t, qsnow_b

   ! ------------------------------------------------------------------------------- !
   ! For mixing of convective downdraft with convective updraft or mean environment. !
   ! ------------------------------------------------------------------------------- !

   real(r8)    ssthl_tmp, ssqt_tmp, ssql_tmp, ssqi_tmp, ssqv_tmp, ssu_tmp, ssv_tmp
   real(r8)    sstr_tmp(ncnst)
   real(r8)    thl_tmp, qt_tmp, th_tmp, qv_tmp, ql_tmp, qi_tmp, qs_tmp, t_tmp, thv_tmp

   ! ----------------------------------------------------------------------------------------------- !
   ! Variables associated with unified treatment of various evaporation processes from top to bottom !
   ! ----------------------------------------------------------------------------------------------- !

   integer     ndb_evp     
   integer     ix_d_src(mkx,3)
   real(r8)    cmfdb_evp
   real(r8)    cmf_d_src(mkx,3), tr_d_src(mkx,3,ncnst) 
   real(r8)    thl_d_src(mkx,3), qt_d_src(mkx,3), ql_d_src(mkx,3), qi_d_src(mkx,3)
   real(r8)    u_d_src(mkx,3), v_d_src(mkx,3), w_d_src(mkx,3)
   real(r8)    fevp1_t_rate_src(mkx,3), fevp2_t_rate_src(mkx,3) 

   ! --------------------------- ! 
   ! For aerosol tendency output !
   ! --------------------------- !

   character(len=30)       :: varname

   !------------------------!
   !                        !
   ! Start Main Calculation !
   !                        !
   !------------------------!

   call cnst_get_ind( 'CLDLIQ', ixcldliq )
   call cnst_get_ind( 'CLDICE', ixcldice )
   call cnst_get_ind( 'NUMLIQ', ixnumliq )
   call cnst_get_ind( 'NUMICE', ixnumice )

   ! Sep.28.2011. Below block is commented out since it is moved into the location right
   !              after computing au_base later.
   !              Thus, incompleteness associated with using 'au_base = au_base_min' is completely removed.

   ! UNRESOLVED : I SHOULD CAREFULLY THINK WHETHER I SHOULD MULTIPLY 2 TO 'I_cri' OR NOT
   !              AS INDICATED IN THE COMMENTED-OUT LINE.
   !              It seems that current one WITHOUT multiplied by 2 is correct and is also
   !              consistent with the 'if( icudist_tail .eq. 0 ) Pau(m) = 2._r8 * au_base * Pau(m)' later.
   ! RESOLVED : Since surface flux associated with convection is discretely and consistently computed below 
   !            later both for icudist_tail = 0 or 1, current code will not use 'I_cri' in any part of the code.
   !            Thus this problem is completely solved.  

   ! May.08.2011. Below one line of 'au_base = au_base_min' is a temporary hack.
   ! Should be removed in the final code.

   ! au_base = au_base_min

   ! if( icudist_tail .eq. 1 ) then
   !     if( au_base .eq. 0.01_r8 ) then
   !         alpha_cri = 2.3265_r8
   !         I_cri     = 0.0720_r8
   !     elseif( au_base .eq. 0.05_r8 ) then
   !         alpha_cri = 1.6450_r8
   !         I_cri     = 0.2196_r8  
   !     elseif( au_base .eq. 0.06_r8 ) then
   !         alpha_cri = 1.5547_r8
   !         I_cri     = 0.2452_r8
   !     elseif( au_base .eq. 0.07_r8 ) then
   !         alpha_cri = 1.4758_r8
   !         I_cri     = 0.2681_r8
   !     elseif( au_base .eq. 0.08_r8 ) then
   !         alpha_cri = 1.4051_r8
   !         I_cri     = 0.2889_r8
   !     elseif( au_base .eq. 0.09_r8 ) then
   !         alpha_cri = 1.3408_r8
   !         I_cri     = 0.3077_r8
   !     elseif( au_base .eq. 0.10_r8 ) then
   !         alpha_cri = 1.2815_r8
   !         I_cri     = 0.3249_r8 
   !     elseif( au_base .eq. 0.20_r8 ) then
   !         alpha_cri = 0.8416_r8
   !         I_cri     = 0.4356_r8
   !     elseif( au_base .eq. 0.30_r8 ) then
   !         alpha_cri = 0.5244_r8
   !         I_cri     = 0.4823_r8
   !     elseif( au_base .eq. 0.40_r8 ) then
   !         alpha_cri = 0.2534_r8
   !         I_cri     = 0.4979_r8
   !     elseif( au_base .eq. 0.50_r8 ) then
   !         alpha_cri = 0._r8
   !         I_cri     = 0.5_r8 
   !     endif
   ! else       
   !     alpha_cri = 0._r8  
   !     I_cri     = au_base
   ! endif
   !! I_cri = 2._r8 * I_cri

   ! ----------------------------------------------------------------------------- !
   ! Define index for multiple mixing environmental airs for nter = 1 and nter = 2 !
   ! ----------------------------------------------------------------------------- !
 
   if (niter .eq. 1) then
      ixi = 1
      ixf = 1
   else
      ixi = 1
      ixf = 2
   endif

   ! ----------------------------------------------------------- !
   ! Compute number of previous time steps that will be used for !
   ! computing old organization parameter.                       !
   ! Note that it must be 'nstep_org <= mit'.                    !
   ! ----------------------------------------------------------- ! 

   !d  nstep_org = int( org_memory_time / dt )
   !d  nstep_org = min( nstep_org, mit )

   ! -------------------------------------------------------------- !
   ! Initialize formal output variables defined at all grid columns !
   ! -------------------------------------------------------------- !

   cmf_u_out(:iend,0:mkx)                            = 0._r8   
   slflx_out(:iend,0:mkx)                            = 0._r8
   qtflx_out(:iend,0:mkx)                            = 0._r8
   qvten_out(:iend,:mkx)                             = 0._r8
   qlten_out(:iend,:mkx)                             = 0._r8
   qiten_out(:iend,:mkx)                             = 0._r8
   sten_out(:iend,:mkx)                              = 0._r8
   uten_out(:iend,:mkx)                              = 0._r8
   vten_out(:iend,:mkx)                              = 0._r8 
   trten_out(:iend,:mkx,:ncnst)                      = 0._r8
   qrten_out(:iend,:mkx)                             = 0._r8
   qsten_out(:iend,:mkx)                             = 0._r8
   rqc_l_out(:iend,:mkx)                             = 0._r8
   rqc_i_out(:iend,:mkx)                             = 0._r8
   rqc_out(:iend,:mkx)                               = 0._r8
   rnc_l_out(:iend,:mkx)                             = 0._r8
   rnc_i_out(:iend,:mkx)                             = 0._r8
   rliq_out(:iend)                                   = 0._r8
   rice_out(:iend)                                   = 0._r8
   precip_out(:iend)                                 = 0._r8
   snow_out(:iend)                                   = 0._r8
   evapc_out(:iend,:mkx)                             = 0._r8
   cnt_out(:iend)                                    = real(mkx,r8)
   cnb_out(:iend)                                    = 0._r8
   am_u_out(:iend,:mkx)                              = 0._r8
   qlm_u_out(:iend,:mkx)                             = 0._r8
   qim_u_out(:iend,:mkx)                             = 0._r8
   am_d_out(:iend,:mkx)                              = 0._r8
   qlm_d_out(:iend,:mkx)                             = 0._r8
   qim_d_out(:iend,:mkx)                             = 0._r8

   cmf_det_out(:iend,:mkx)                           = 0._r8
   ql_det_out(:iend,:mkx)                            = 0._r8
   qi_det_out(:iend,:mkx)                            = 0._r8

   ! ---------------------------------------------------------------- !
   ! Initialize internal output variables defined at all grid columns !
   ! ---------------------------------------------------------------- !

   cmf_out(:iend,0:mkx)                              = 0._r8   
   uflx_out(:iend,0:mkx)                             = 0._r8 
   vflx_out(:iend,0:mkx)                             = 0._r8

   slflx_u_out(:iend,0:mkx)                          = 0._r8 
   qtflx_u_out(:iend,0:mkx)                          = 0._r8 
   uflx_u_out(:iend,0:mkx)                           = 0._r8 
   vflx_u_out(:iend,0:mkx)                           = 0._r8

   cmf_d_out(:iend,0:mkx)                            = 0._r8   
   slflx_d_out(:iend,0:mkx)                          = 0._r8 
   qtflx_d_out(:iend,0:mkx)                          = 0._r8 
   uflx_d_out(:iend,0:mkx)                           = 0._r8 
   vflx_d_out(:iend,0:mkx)                           = 0._r8

!d  slflx_d_org_out(:iend,0:mkx)                      = 0._r8 
!d  qtflx_d_org_out(:iend,0:mkx)                      = 0._r8 

   thl_orgforce_out(:iend)                           = 0._r8 
   qt_orgforce_out(:iend)                            = 0._r8 
   u_orgforce_out(:iend)                             = 0._r8 
   v_orgforce_out(:iend)                             = 0._r8 
   ! thv_orgforce_out(:iend)                           = 0._r8 
   tr_orgforce_out(:iend,:ncnst)                     = 0._r8 
   awk_orgforce_out(:iend)                           = 0._r8 

   ! Below block is for detailed diagnostic output

   flxrain_out(:iend,0:mkx)                          = 0._r8 
   flxsnow_out(:iend,0:mkx)                          = 0._r8 

   thl_orgforce_flx_out(:iend)                       = 0._r8 
   qt_orgforce_flx_out(:iend)                        = 0._r8 
   u_orgforce_flx_out(:iend)                         = 0._r8 
   v_orgforce_flx_out(:iend)                         = 0._r8 
   tr_orgforce_flx_out(:iend,:ncnst)                 = 0._r8 
   awk_orgforce_flx_out(:iend)                       = 0._r8 

   thl_orgforce_und_out(:iend)                       = 0._r8 
   qt_orgforce_und_out(:iend)                        = 0._r8 
   u_orgforce_und_out(:iend)                         = 0._r8 
   v_orgforce_und_out(:iend)                         = 0._r8 
   tr_orgforce_und_out(:iend,:ncnst)                 = 0._r8 
   awk_orgforce_mix_out(:iend)                       = 0._r8 

   thl_orgforce_env_out(:iend)                       = 0._r8 
   qt_orgforce_env_out(:iend)                        = 0._r8 
   u_orgforce_env_out(:iend)                         = 0._r8 
   v_orgforce_env_out(:iend)                         = 0._r8 
   tr_orgforce_env_out(:iend,:ncnst)                 = 0._r8 
   cmf_d_org_pblh_out(:iend)                         = 0._r8 

   ! Above block is for detailed diagnostic output

   taui_thl_out(:iend)                               = 0._r8 
   taui_qt_out(:iend)                                = 0._r8 
   taui_u_out(:iend)                                 = 0._r8 
   taui_v_out(:iend)                                 = 0._r8 
   ! taui_thv_out(:iend)                               = 0._r8 
   taui_tr_out(:iend,:ncnst)                         = 0._r8 
   taui_awk_out(:iend)                               = 0._r8 

   !og
   del_org_out(:iend)                                = 0._r8 
   del0_org_out(:iend)                               = 0._r8 
   !og

   slten_u_out(:iend,:mkx)                           = 0._r8 
   qtten_u_out(:iend,:mkx)                           = 0._r8 
   uten_u_out(:iend,:mkx)                            = 0._r8 
   vten_u_out(:iend,:mkx)                            = 0._r8
   sten_u_out(:iend,:mkx)                            = 0._r8 
   qvten_u_out(:iend,:mkx)                           = 0._r8 
   qlten_u_out(:iend,:mkx)                           = 0._r8 
   qiten_u_out(:iend,:mkx)                           = 0._r8
   trten_u_out(:iend,:mkx,:ncnst)                    = 0._r8

   slten_d_out(:iend,:mkx)                           = 0._r8 
   qtten_d_out(:iend,:mkx)                           = 0._r8 
   uten_d_out(:iend,:mkx)                            = 0._r8 
   vten_d_out(:iend,:mkx)                            = 0._r8
   sten_d_out(:iend,:mkx)                            = 0._r8 
   qvten_d_out(:iend,:mkx)                           = 0._r8 
   qlten_d_out(:iend,:mkx)                           = 0._r8 
   qiten_d_out(:iend,:mkx)                           = 0._r8
   trten_d_out(:iend,:mkx,:ncnst)                    = 0._r8

   slten_evp_out(:iend,:mkx)                         = 0._r8 
   qtten_evp_out(:iend,:mkx)                         = 0._r8 
   uten_evp_out(:iend,:mkx)                          = 0._r8 
   vten_evp_out(:iend,:mkx)                          = 0._r8
   sten_evp_out(:iend,:mkx)                          = 0._r8 
   qvten_evp_out(:iend,:mkx)                         = 0._r8 
   qlten_evp_out(:iend,:mkx)                         = 0._r8 
   qiten_evp_out(:iend,:mkx)                         = 0._r8
   trten_evp_out(:iend,:mkx,:ncnst)                  = 0._r8
   trten_wdep_out(:iend,:mkx,:ncnst)                 = 0._r8

   slten_dis_out(:iend,:mkx)                         = 0._r8 
   qtten_dis_out(:iend,:mkx)                         = 0._r8 
   uten_dis_out(:iend,:mkx)                          = 0._r8 
   vten_dis_out(:iend,:mkx)                          = 0._r8
   sten_dis_out(:iend,:mkx)                          = 0._r8 
   qvten_dis_out(:iend,:mkx)                         = 0._r8 
   qlten_dis_out(:iend,:mkx)                         = 0._r8 
   qiten_dis_out(:iend,:mkx)                         = 0._r8
   trten_dis_out(:iend,:mkx,:ncnst)                  = 0._r8

   qlten_sub_out(:iend,:mkx)                         = 0._r8       
   qiten_sub_out(:iend,:mkx)                         = 0._r8       
   qlten_det_out(:iend,:mkx)                         = 0._r8       
   qiten_det_out(:iend,:mkx)                         = 0._r8       

   thl_u_out(:iend,0:mkx)                            = 0._r8
   qt_u_out(:iend,0:mkx)                             = 0._r8
   u_u_out(:iend,0:mkx)                              = 0._r8
   v_u_out(:iend,0:mkx)                              = 0._r8
   w_u_out(:iend,0:mkx)                              = 0._r8
   ql_u_out(:iend,0:mkx)                             = 0._r8
   qi_u_out(:iend,0:mkx)                             = 0._r8 
   tr_u_out(:iend,0:mkx,:ncnst)                      = 0._r8 
   wa_u_out(:iend,0:mkx)                             = 0._r8
   qla_u_out(:iend,0:mkx)                            = 0._r8
   qia_u_out(:iend,0:mkx)                            = 0._r8
   a_u_out(:iend,0:mkx)                              = 0._r8
   rad_u_out(:iend,0:mkx)                            = 0._r8
   num_u_out(:iend,0:mkx)                            = 0._r8
   gamw_u_out(:iend,0:mkx)                           = 0._r8
   thva_u_out(:iend,0:mkx)                           = 0._r8

   thl_d_out(:iend,0:mkx)                            = 0._r8
   qt_d_out(:iend,0:mkx)                             = 0._r8
   u_d_out(:iend,0:mkx)                              = 0._r8
   v_d_out(:iend,0:mkx)                              = 0._r8
   w_d_out(:iend,0:mkx)                              = 0._r8
   ql_d_out(:iend,0:mkx)                             = 0._r8
   qi_d_out(:iend,0:mkx)                             = 0._r8
   tr_d_out(:iend,0:mkx,:ncnst)                      = 0._r8 
   wa_d_out(:iend,0:mkx)                             = 0._r8
   qla_d_out(:iend,0:mkx)                            = 0._r8
   qia_d_out(:iend,0:mkx)                            = 0._r8
   a_d_out(:iend,0:mkx)                              = 0._r8

   a_p_out(:iend,0:mkx)                              = 0._r8
   am_evp_out(:iend,:mkx)                            = 0._r8
   am_pu_out(:iend,:mkx)                             = 0._r8
   x_p_out(:iend,0:mkx)                              = 0._r8
   y_p_out(:iend,0:mkx)                              = 0._r8
   x_um_out(:iend,:mkx)                              = 0._r8
   y_um_out(:iend,:mkx)                              = 0._r8

   thl_u_msfc_out(:iend,0:mkx,:nseg,:niter)          = 0._r8
   qt_u_msfc_out(:iend,0:mkx,:nseg,:niter)           = 0._r8
   u_u_msfc_out(:iend,0:mkx,:nseg,:niter)            = 0._r8
   v_u_msfc_out(:iend,0:mkx,:nseg,:niter)            = 0._r8
   w_u_msfc_out(:iend,0:mkx,:nseg,:niter)            = 0._r8
   ql_u_msfc_out(:iend,0:mkx,:nseg,:niter)           = 0._r8
   qi_u_msfc_out(:iend,0:mkx,:nseg,:niter)           = 0._r8
   tr_u_msfc_out(:iend,0:mkx,:nseg,:ncnst,:niter)    = 0._r8
   cmf_u_msfc_out(:iend,0:mkx,:nseg,:niter)          = 0._r8
   a_u_msfc_out(:iend,0:mkx,:nseg,:niter)            = 0._r8
   num_u_msfc_out(:iend,0:mkx,:nseg,:niter)          = 0._r8
   rad_u_msfc_out(:iend,0:mkx,:nseg,:niter)          = 0._r8

   eps0_u_msfc_out(:iend,0:mkx,:nseg,:niter)         = 0._r8
   eps_u_msfc_out(:iend,0:mkx,:nseg,:niter)          = 0._r8
   del_u_msfc_out(:iend,0:mkx,:nseg,:niter)          = 0._r8
   eeps_u_msfc_out(:iend,0:mkx,:nseg,:niter)         = 0._r8
   ddel_u_msfc_out(:iend,0:mkx,:nseg,:niter)         = 0._r8
   xc_u_msfc_out(:iend,0:mkx,:nseg,:niter)           = 0._r8 
   xs_u_msfc_out(:iend,0:mkx,:nseg,:niter)           = 0._r8 
   xemin_u_msfc_out(:iend,0:mkx,:nseg,:niter)        = 0._r8
   xemax_u_msfc_out(:iend,0:mkx,:nseg,:niter)        = 0._r8
   cridis_u_msfc_out(:iend,0:mkx,:nseg,:niter)       = 0._r8
   thvcuenv_u_msfc_out(:iend,0:mkx,:nseg,:niter)     = 0._r8
   thvegenv_u_msfc_out(:iend,0:mkx,:nseg,:niter)     = 0._r8
   thvxsenv_u_msfc_out(:iend,0:mkx,:nseg,:niter)     = 0._r8
   fmix_u_msfc_out(:iend,0:mkx,:nseg,:niter)         = 0._r8
   cmfumix_u_msfc_out(:iend,0:mkx,:nseg,:niter)      = 0._r8

   thl_d_msfc_out(:iend,0:mkx,:nseg,:niter)          = 0._r8
   qt_d_msfc_out(:iend,0:mkx,:nseg,:niter)           = 0._r8
   u_d_msfc_out(:iend,0:mkx,:nseg,:niter)            = 0._r8
   v_d_msfc_out(:iend,0:mkx,:nseg,:niter)            = 0._r8
   w_d_msfc_out(:iend,0:mkx,:nseg,:niter)            = 0._r8
   ql_d_msfc_out(:iend,0:mkx,:nseg,:niter)           = 0._r8
   qi_d_msfc_out(:iend,0:mkx,:nseg,:niter)           = 0._r8
   tr_d_msfc_out(:iend,0:mkx,:nseg,:ncnst,:niter)    = 0._r8
   wa_d_msfc_out(:iend,0:mkx,:nseg,:niter)           = 0._r8
   qla_d_msfc_out(:iend,0:mkx,:nseg,:niter)          = 0._r8
   qia_d_msfc_out(:iend,0:mkx,:nseg,:niter)          = 0._r8
   cmf_d_msfc_out(:iend,0:mkx,:nseg,:niter)          = 0._r8
   a_d_msfc_out(:iend,0:mkx,:nseg,:niter)            = 0._r8  
 
   ktop_msfc_out(:iend,:nseg,:niter)                 = 0    
   ptop_msfc_out(:iend,:nseg,:niter)                 = 0._r8
   ztop_msfc_out(:iend,:nseg,:niter)                 = 0._r8

   thv_b_out(:iend,0:mkx)                            = 0._r8
   thv_t_out(:iend,0:mkx)                            = 0._r8
   thv_mt_out(:iend,0:mkx)                           = 0._r8
   thv_min_out(:iend,0:mkx)                          = 0._r8

!a  CFL_out(:iend,:mkx)                               = 0._r8

!d  orgforce1_out(:iend)                              = 0._r8
!d  orgforce2_out(:iend)                              = 0._r8
!d  orgforce3_out(:iend)                              = 0._r8   
!d  orgforce_out(:iend)                               = 0._r8
!d  tau_org_out(:iend)                                = 0._r8
!d  tau_TKE_out(:iend)                                = 0._r8

   kw_out(:iend)                                     = 0._r8  

   sigma_w_out(:iend)                                = 0._r8  
   sigma_thl_out(:iend)                              = 0._r8
   sigma_qt_out(:iend)                               = 0._r8
   sigma_u_out(:iend)                                = 0._r8
   sigma_v_out(:iend)                                = 0._r8
   w_org_out(:iend)                                  = 0._r8
   thl_org_out(:iend)                                = 0._r8
   qt_org_out(:iend)                                 = 0._r8
   u_org_out(:iend)                                  = 0._r8
   v_org_out(:iend)                                  = 0._r8
   tkes_out(:iend)                                   = 0._r8
   went_out(:iend)                                   = 0._r8
   went_eff_out(:iend)                               = 0._r8

   ! ------------------------------------------------------ !
   ! Initialize other variables defined at all grid columns !
   ! ------------------------------------------------------ !

!f  exit_Cu(:iend)                                    = 0._r8

   !---------------------------------------------------------!
   !                                                         !
   ! Start the big i loop where i is a horozontal grid index !
   !                                                         !
   !---------------------------------------------------------!

   do i = 1, iend                                 

      ! CHECK : Vertical Evolution Test of Convective Updraft and Downdraft with All Component. 
      ! It must be (1) tmp1 < 30, (2) tmp2 < tmp1, (3) tmp3 > 10, (4) tmp4 > tmp3 
      !  if( get_nstep() .eq. 5 .and. i .eq. 10  ) then
      !      call progup_thlqt(  0.00005_r8,     0._r8, 0._r8, 100000._r8,  80000._r8, 20._r8, 0.001_r8, 30._r8, tmp1 ) ! Updraft. Only mixing and gradient
      !      call progup_thlqt(  0.00005_r8, 0.0001_r8, 0._r8, 100000._r8,  80000._r8, 20._r8, 0.001_r8, 30._r8, tmp2 ) ! Updraft. Additional Precipitation Fall Out
      !      call progup_thlqt( -0.00005_r8,     0._r8, 0._r8,  80000._r8, 100000._r8, 20._r8, 0.001_r8, 10._r8, tmp3 ) ! Downdraft. Only mixing and gradient
      !      call progup_thlqt( -0.00005_r8, 0.0001_r8, 0._r8,  80000._r8, 100000._r8, 20._r8, 0.001_r8, 10._r8, tmp4 ) ! Downdraft. Additional Evaporation of Precipitation
      !      write(6,*)
      !      write(6,*) 'UNICON : Vertical Evolution Test'
      !      write(6,*) 'tmp1, tmp2, tmp3, tmp4 = ', tmp1, tmp2, tmp3, tmp4
      !      write(6,*)
      !  endif
      ! CHECK : Vertical Evolution Test of Convective Updraft and Downdraft with All Component. 

      !f    id_exit = .false.

      ! ------------------------------------------------------------------------------------------------------- !
      ! Mar.27.2012. Initialize dissipation heating variables since dissipation heating is computed after doing ! 
      !              ensemble-mean average of iter = 1, niter = 2.                                              !
      ! ------------------------------------------------------------------------------------------------------- !

      slten_dis(:mkx)                                 = 0._r8
      qtten_dis(:mkx)                                 = 0._r8
      uten_dis(:mkx)                                  = 0._r8
      vten_dis(:mkx)                                  = 0._r8
      sten_dis(:mkx)                                  = 0._r8
      qvten_dis(:mkx)                                 = 0._r8
      qlten_dis(:mkx)                                 = 0._r8
      qiten_dis(:mkx)                                 = 0._r8
      trten_dis(:mkx,:ncnst)                          = 0._r8

      uf(:mkx)                                        = 0._r8
      vf(:mkx)                                        = 0._r8

      uflx(0:mkx)                                     = 0._r8
      vflx(0:mkx)                                     = 0._r8

      ! ----------------------------------------------------------------------------------------------- !
      ! Initialize variables associated with mixing with multiple mixing environmental airs ( '_mxen' ) !
      ! ----------------------------------------------------------------------------------------------- !

      ktop_mxen(:niter)                               = 0
      cush_mxen(:niter)                               = 0._r8
      cushavg_mxen(:niter)                            = 0._r8

      cu_cmfum_mxen(:mkx,:niter)                      = 0._r8
      cu_cmfr_mxen(:mkx,:niter)                       = 0._r8
      cu_thlr_mxen(:mkx,:niter)                       = 0._r8
      cu_qtr_mxen(:mkx,:niter)                        = 0._r8
      cu_ur_mxen(:mkx,:niter)                         = 0._r8
      cu_vr_mxen(:mkx,:niter)                         = 0._r8
      cu_qlr_mxen(:mkx,:niter)                        = 0._r8
      cu_qir_mxen(:mkx,:niter)                        = 0._r8
      cu_trr_mxen(:mkx,:ncnst,:niter)                 = 0._r8
      cu_cmfrd_mxen(:mkx,:niter)                      = 0._r8
      cu_thlrd_mxen(:mkx,:niter)                      = 0._r8
      cu_qtrd_mxen(:mkx,:niter)                       = 0._r8
      cu_urd_mxen(:mkx,:niter)                        = 0._r8  
      cu_vrd_mxen(:mkx,:niter)                        = 0._r8
      cu_qlrd_mxen(:mkx,:niter)                       = 0._r8
      cu_qird_mxen(:mkx,:niter)                       = 0._r8
      cu_trrd_mxen(:mkx,:ncnst,:niter)                = 0._r8

!d    cu_prep_mxen(:niter)                            = 0._r8
!d    cu_cmfu_mxen(:niter)                            = 0._r8
!d    cu_cmfd_mxen(:niter)                            = 0._r8
!d    cu_tkePBLorg_mxen(:niter)                       = 0._r8
!d    cu_cmfPBLorg_mxen(:niter)                       = 0._r8
!d    cu_thlPBLorg_mxen(:niter)                       = 0._r8
!d    cu_qtPBLorg_mxen(:niter)                        = 0._r8
!d    cu_uPBLorg_mxen(:niter)                         = 0._r8
!d    cu_vPBLorg_mxen(:niter)                         = 0._r8

      cmf_u_mxen(0:mkx,:niter)                        = 0._r8
      cmf_d_mxen(0:mkx,:niter)                        = 0._r8
      slflx_u_mxen(0:mkx,:niter)                      = 0._r8
      slflx_d_mxen(0:mkx,:niter)                      = 0._r8
      qtflx_u_mxen(0:mkx,:niter)                      = 0._r8
      qtflx_d_mxen(0:mkx,:niter)                      = 0._r8
      uflx_u_mxen(0:mkx,:niter)                       = 0._r8
      uflx_d_mxen(0:mkx,:niter)                       = 0._r8
      vflx_u_mxen(0:mkx,:niter)                       = 0._r8
      vflx_d_mxen(0:mkx,:niter)                       = 0._r8

      flxrain_u_mxen(0:mkx,:niter)                    = 0._r8
      flxsnow_u_mxen(0:mkx,:niter)                    = 0._r8

!d    slflx_d_org_mxen(0:mkx,:niter)                  = 0._r8
!d    qtflx_d_org_mxen(0:mkx,:niter)                  = 0._r8

      thl_orgforce_mxen(:niter)                       = 0._r8 
      qt_orgforce_mxen(:niter)                        = 0._r8 
      u_orgforce_mxen(:niter)                         = 0._r8 
      v_orgforce_mxen(:niter)                         = 0._r8 
      ! thv_orgforce_mxen(:niter)                       = 0._r8 
      tr_orgforce_mxen(:ncnst,:niter)                 = 0._r8 
      awk_orgforce_mxen(:niter)                       = 0._r8 

      ! Below block is for detailed diagnostic output

      thl_orgforce_flx_mxen(:niter)                   = 0._r8 
      qt_orgforce_flx_mxen(:niter)                    = 0._r8 
      u_orgforce_flx_mxen(:niter)                     = 0._r8 
      v_orgforce_flx_mxen(:niter)                     = 0._r8 
      tr_orgforce_flx_mxen(:ncnst,:niter)             = 0._r8 
      awk_orgforce_flx_mxen(:niter)                   = 0._r8 

      thl_orgforce_und_mxen(:niter)                   = 0._r8 
      qt_orgforce_und_mxen(:niter)                    = 0._r8 
      u_orgforce_und_mxen(:niter)                     = 0._r8 
      v_orgforce_und_mxen(:niter)                     = 0._r8 
      tr_orgforce_und_mxen(:ncnst,:niter)             = 0._r8 
      awk_orgforce_mix_mxen(:niter)                   = 0._r8 

      thl_orgforce_env_mxen(:niter)                   = 0._r8 
      qt_orgforce_env_mxen(:niter)                    = 0._r8 
      u_orgforce_env_mxen(:niter)                     = 0._r8 
      v_orgforce_env_mxen(:niter)                     = 0._r8 
      tr_orgforce_env_mxen(:ncnst,:niter)             = 0._r8 
      cmf_d_org_pblh_mxen(:niter)                     = 0._r8 

      ! Above block is for detailed diagnostic output

      taui_thl_mxen(:niter)                           = 0._r8 
      taui_qt_mxen(:niter)                            = 0._r8 
      taui_u_mxen(:niter)                             = 0._r8 
      taui_v_mxen(:niter)                             = 0._r8 
      ! taui_thv_mxen(:niter)                           = 0._r8 
      taui_tr_mxen(:ncnst,:niter)                     = 0._r8 
      taui_awk_mxen(:niter)                           = 0._r8 
      !og
      del_org_mxen(:niter)                            = 0._r8 
      del0_org_mxen(:niter)                           = 0._r8 
      !og
      qvten_mxen(:mkx,:niter)                         = 0._r8
      qlten_mxen(:mkx,:niter)                         = 0._r8
      qiten_mxen(:mkx,:niter)                         = 0._r8
      trten_mxen(:mkx,:ncnst,:niter)                  = 0._r8 
      sten_mxen(:mkx,:niter)                          = 0._r8
      uten_mxen(:mkx,:niter)                          = 0._r8
      vten_mxen(:mkx,:niter)                          = 0._r8
      qrten_mxen(:mkx,:niter)                         = 0._r8
      qsten_mxen(:mkx,:niter)                         = 0._r8

      rqc_l_mxen(:mkx,:niter)                         = 0._r8
      rqc_i_mxen(:mkx,:niter)                         = 0._r8
      rqc_mxen(:mkx,:niter)                           = 0._r8
      rnc_l_mxen(:mkx,:niter)                         = 0._r8
      rnc_i_mxen(:mkx,:niter)                         = 0._r8

      cmf_det_mxen(:mkx,:niter)                       = 0._r8
      ql_det_mxen(:mkx,:niter)                        = 0._r8
      qi_det_mxen(:mkx,:niter)                        = 0._r8

      evapc_mxen(:mkx,:niter)                         = 0._r8

      am_u_mxen(:mkx,:niter)                          = 0._r8
      qlm_u_mxen(:mkx,:niter)                         = 0._r8
      qim_u_mxen(:mkx,:niter)                         = 0._r8

      am_d_mxen(:mkx,:niter)                          = 0._r8
      qlm_d_mxen(:mkx,:niter)                         = 0._r8
      qim_d_mxen(:mkx,:niter)                         = 0._r8

      rliq_mxen(:niter)                               = 0._r8
      rice_mxen(:niter)                               = 0._r8
      precip_mxen(:niter)                             = 0._r8
      snow_mxen(:niter)                               = 0._r8

      cnt_mxen(:niter)                                = 0._r8
      cnb_mxen(:niter)                                = 0._r8

      slten_u_mxen(:mkx,:niter)                       = 0._r8
      qtten_u_mxen(:mkx,:niter)                       = 0._r8
      uten_u_mxen(:mkx,:niter)                        = 0._r8
      vten_u_mxen(:mkx,:niter)                        = 0._r8
      sten_u_mxen(:mkx,:niter)                        = 0._r8
      qvten_u_mxen(:mkx,:niter)                       = 0._r8
      qlten_u_mxen(:mkx,:niter)                       = 0._r8
      qiten_u_mxen(:mkx,:niter)                       = 0._r8
      trten_u_mxen(:mkx,:ncnst,:niter)                = 0._r8

      slten_d_mxen(:mkx,:niter)                       = 0._r8
      qtten_d_mxen(:mkx,:niter)                       = 0._r8
      uten_d_mxen(:mkx,:niter)                        = 0._r8
      vten_d_mxen(:mkx,:niter)                        = 0._r8
      sten_d_mxen(:mkx,:niter)                        = 0._r8
      qvten_d_mxen(:mkx,:niter)                       = 0._r8
      qlten_d_mxen(:mkx,:niter)                       = 0._r8
      qiten_d_mxen(:mkx,:niter)                       = 0._r8
      trten_d_mxen(:mkx,:ncnst,:niter)                = 0._r8

      slten_evp_mxen(:mkx,:niter)                     = 0._r8
      qtten_evp_mxen(:mkx,:niter)                     = 0._r8
      uten_evp_mxen(:mkx,:niter)                      = 0._r8
      vten_evp_mxen(:mkx,:niter)                      = 0._r8
      sten_evp_mxen(:mkx,:niter)                      = 0._r8
      qvten_evp_mxen(:mkx,:niter)                     = 0._r8
      qlten_evp_mxen(:mkx,:niter)                     = 0._r8
      qiten_evp_mxen(:mkx,:niter)                     = 0._r8
      trten_evp_mxen(:mkx,:ncnst,:niter)              = 0._r8
      trten_wdep_mxen(:mkx,:ncnst,:niter)             = 0._r8

      ! Mar.27.2012. I don't need below anymore since dissipation heating is computed after performing
      !              all the ensemble-mean average. 
      !              So, I removed below 9 variables associated with dissipation heating.

      ! slten_dis_mxen(:mkx,:niter)                     = 0._r8
      ! qtten_dis_mxen(:mkx,:niter)                     = 0._r8
      ! uten_dis_mxen(:mkx,:niter)                      = 0._r8
      ! vten_dis_mxen(:mkx,:niter)                      = 0._r8
      ! sten_dis_mxen(:mkx,:niter)                      = 0._r8
      ! qvten_dis_mxen(:mkx,:niter)                     = 0._r8
      ! qlten_dis_mxen(:mkx,:niter)                     = 0._r8
      ! qiten_dis_mxen(:mkx,:niter)                     = 0._r8
      ! trten_dis_mxen(:mkx,:ncnst,:niter)              = 0._r8

      qlten_sub_mxen(:mkx,:niter)                     = 0._r8
      qiten_sub_mxen(:mkx,:niter)                     = 0._r8

      qlten_det_mxen(:mkx,:niter)                     = 0._r8
      qiten_det_mxen(:mkx,:niter)                     = 0._r8

      thl_u_mxen(0:mkx,:niter)                        = 0._r8
      qt_u_mxen(0:mkx,:niter)                         = 0._r8
      u_u_mxen(0:mkx,:niter)                          = 0._r8
      v_u_mxen(0:mkx,:niter)                          = 0._r8
      w_u_mxen(0:mkx,:niter)                          = 0._r8
      ql_u_mxen(0:mkx,:niter)                         = 0._r8
      qi_u_mxen(0:mkx,:niter)                         = 0._r8
      tr_u_mxen(0:mkx,:ncnst,:niter)                  = 0._r8
      a_u_mxen(0:mkx,:niter)                          = 0._r8
      num_u_mxen(0:mkx,:niter)                        = 0._r8
      wa_u_mxen(0:mkx,:niter)                         = 0._r8
      qla_u_mxen(0:mkx,:niter)                        = 0._r8
      qia_u_mxen(0:mkx,:niter)                        = 0._r8
      rad_u_mxen(0:mkx,:niter)                        = 0._r8
      thva_u_mxen(0:mkx,:niter)                       = 0._r8

      a_p_mxen(0:mkx,:niter)                          = 0._r8
      am_evp_mxen(:mkx,:niter)                        = 0._r8
      am_pu_mxen(:mkx,:niter)                         = 0._r8
      x_p_mxen(0:mkx,:niter)                          = 0._r8
      y_p_mxen(0:mkx,:niter)                          = 0._r8
      x_um_mxen(:mkx,:niter)                          = 0._r8
      y_um_mxen(:mkx,:niter)                          = 0._r8

      thl_d_mxen(0:mkx,:niter)                        = 0._r8
      qt_d_mxen(0:mkx,:niter)                         = 0._r8
      u_d_mxen(0:mkx,:niter)                          = 0._r8
      v_d_mxen(0:mkx,:niter)                          = 0._r8
      w_d_mxen(0:mkx,:niter)                          = 0._r8
      ql_d_mxen(0:mkx,:niter)                         = 0._r8
      qi_d_mxen(0:mkx,:niter)                         = 0._r8
      tr_d_mxen(0:mkx,:ncnst,:niter)                  = 0._r8
      a_d_mxen(0:mkx,:niter)                          = 0._r8
      wa_d_mxen(0:mkx,:niter)                         = 0._r8
      qla_d_mxen(0:mkx,:niter)                        = 0._r8
      qia_d_mxen(0:mkx,:niter)                        = 0._r8

      thl_u_msfc_mxen(0:mkx,:nseg,:niter)             = 0._r8
      qt_u_msfc_mxen(0:mkx,:nseg,:niter)              = 0._r8
      u_u_msfc_mxen(0:mkx,:nseg,:niter)               = 0._r8
      v_u_msfc_mxen(0:mkx,:nseg,:niter)               = 0._r8
      w_u_msfc_mxen(0:mkx,:nseg,:niter)               = 0._r8
      ql_u_msfc_mxen(0:mkx,:nseg,:niter)              = 0._r8
      qi_u_msfc_mxen(0:mkx,:nseg,:niter)              = 0._r8
      tr_u_msfc_mxen(0:mkx,:nseg,:ncnst,:niter)       = 0._r8
      cmf_u_msfc_mxen(0:mkx,:nseg,:niter)             = 0._r8
      a_u_msfc_mxen(0:mkx,:nseg,:niter)               = 0._r8
      num_u_msfc_mxen(0:mkx,:nseg,:niter)             = 0._r8
      rad_u_msfc_mxen(0:mkx,:nseg,:niter)             = 0._r8

      eps0_u_msfc_mxen(0:mkx,:nseg,:niter)            = 0._r8
      eps_u_msfc_mxen(0:mkx,:nseg,:niter)             = 0._r8
      del_u_msfc_mxen(0:mkx,:nseg,:niter)             = 0._r8
      eeps_u_msfc_mxen(0:mkx,:nseg,:niter)            = 0._r8
      ddel_u_msfc_mxen(0:mkx,:nseg,:niter)            = 0._r8
      xc_u_msfc_mxen(0:mkx,:nseg,:niter)              = 0._r8
      xs_u_msfc_mxen(0:mkx,:nseg,:niter)              = 0._r8
      xemin_u_msfc_mxen(0:mkx,:nseg,:niter)           = 0._r8
      xemax_u_msfc_mxen(0:mkx,:nseg,:niter)           = 0._r8
      cridis_u_msfc_mxen(0:mkx,:nseg,:niter)          = 0._r8
      thvcuenv_u_msfc_mxen(0:mkx,:nseg,:niter)        = 0._r8
      thvegenv_u_msfc_mxen(0:mkx,:nseg,:niter)        = 0._r8
      thvxsenv_u_msfc_mxen(0:mkx,:nseg,:niter)        = 0._r8
      fmix_u_msfc_mxen(0:mkx,:nseg,:niter)            = 0._r8
      cmfumix_u_msfc_mxen(0:mkx,:nseg,:niter)         = 0._r8

      thl_d_msfc_mxen(0:mkx,:nseg,:niter)             = 0._r8
      qt_d_msfc_mxen(0:mkx,:nseg,:niter)              = 0._r8
      u_d_msfc_mxen(0:mkx,:nseg,:niter)               = 0._r8
      v_d_msfc_mxen(0:mkx,:nseg,:niter)               = 0._r8
      w_d_msfc_mxen(0:mkx,:nseg,:niter)               = 0._r8
      ql_d_msfc_mxen(0:mkx,:nseg,:niter)              = 0._r8
      qi_d_msfc_mxen(0:mkx,:nseg,:niter)              = 0._r8
      tr_d_msfc_mxen(0:mkx,:nseg,:ncnst,:niter)       = 0._r8
      cmf_d_msfc_mxen(0:mkx,:nseg,:niter)             = 0._r8
      a_d_msfc_mxen(0:mkx,:nseg,:niter)               = 0._r8
      wa_d_msfc_mxen(0:mkx,:nseg,:niter)              = 0._r8
      qla_d_msfc_mxen(0:mkx,:nseg,:niter)             = 0._r8
      qia_d_msfc_mxen(0:mkx,:nseg,:niter)             = 0._r8

      ktop_msfc_mxen(:nseg,:niter)                    = 0
      ptop_msfc_mxen(:nseg,:niter)                    = 0._r8
      ztop_msfc_mxen(:nseg,:niter)                    = 0._r8

!d    orgforce1_mxen(:niter)                          = 0._r8
!d    orgforce2_mxen(:niter)                          = 0._r8
!d    orgforce3_mxen(:niter)                          = 0._r8

      ! --------------------------------------------- !
      ! Define 1D input variables at each grid point  !
      ! Interface index from sfc : k = 0,1,2,...,mkx  !
      ! Mid-point index from sfc : k = 1,2,3,...,mkx  !
      ! --------------------------------------------- !

      ipbl                 =                          ipbl_in(i)
      kpblh                =                         kpblh_in(i)
      pblh                 =                          pblh_in(i)
      wstar                =                         wstar_in(i)
      tkes                 =                          tkes_in(i)
      went                 =                          went_in(i)
      qflx                 =                          qflx_in(i)      
      shflx                =                         shflx_in(i)      
      taux                 =                          taux_in(i)      
      tauy                 =                          tauy_in(i)      
      aflx(:ncnst)         =                   aflx_in(i,:ncnst)
      ocnfrac              =                       ocnfrac_in(i)    
      landfrac             =                      landfrac_in(i)      
      icefrac              =                       icefrac_in(i)      
      sgh                  =                           sgh_in(i)      
      sgh30                =                         sgh30_in(i)      

      ! ------------------------------------------------------------------------------------------------------ !
      ! Aug.31.2011. In order to simplify code later, impose the condition that kpblh >=2 and                  !
      !              corresponding pblh >= zs0_in(i,1). This condition is always satisfied when                !
      !              PBL is CL, but when PBL is STL, this is imposing conservative constraint.                 !
      !              since convective is likely not to very in-active in the STL, this is not an issue at all. !
      !              Even when convection is fired in STL, there is no problem at all.                         !
      ! Sep.09.2011. Add 'kpblhm', 'pblhz', 'pblhm' since these are used very frequently.                      !
      !              All the variables are replaced by these ( e.g., kpblh - 1 = kpblhm ).                     ! 
      !              Note that 'pblhz > 0' and 'pblhp > 0'.                                                    !
      ! ------------------------------------------------------------------------------------------------------ !

      kpblh               =                      max( kpblh, 2 )
      kpblhm              =                            kpblh - 1 
      pblh                =             max( pblh, zs0_in(i,1) )
      pblhz               =       zs0_in(i,kpblhm) - zs0_in(i,0)
      pblhp               =       ps0_in(i,0) - ps0_in(i,kpblhm)

      ! ------------------------------------------------------------------------------- !
      ! Sep.16.2011. Compute auto-conversion efficienty for CAM5 deep convection scheme !
      ! ------------------------------------------------------------------------------- !

      ! if( microcu .eq. 0 ) then
      !     criqc           = criqc_ocn + ( criqc_lnd - criqc_ocn ) * landfrac
      ! elseif( microcu .eq. 1 ) then
      !     c0_ac           = c0_ac_ocn + ( c0_ac_lnd - c0_ac_ocn ) * landfrac
      ! endif

      ! ---------------------------------------------------------------------------------------------- !    
      ! May.21.2011. Is it better to change the minimums of 'cush' and 'cushavg' from 1000 to 'pblh' ? !  
      !              I should think about this later.                                                  ! 
      ! May.21.2011. For full consistency with the other parts of the code, it is good to use 'pblh'   !
      !              instead of '1000._r8' as the minimum value of 'cush, cushavg'. So, I modified     !
      !              this.                                                                             !
      ! Aug.31.2011. Add delta_thl(qt,u,v,thv,tr)_PBL fields. I may need to impose a reasonable upper  !
      !              and lower limits on these excessive variables.                                    !  
      ! Sep.09.2011. I don't prognose 'thv' anymore - it is now diagnostically computed from the       !
      !              prognosed 'thl,qt' which imposes a full consistency as well as removing unfair    !
      !              assumption that both downdraft and environment are unsaturated for computing      !
      !              buoyancy flux.                                                                    !  
      ! ---------------------------------------------------------------------------------------------- !

      cush                     =                       cush_inout(i)
      ! cush                     =               max( cush, 1000._r8 )
      cush                     =                  max( cush, pblhz )
      cushavg                  =                    cushavg_inout(i)
      ! cushavg                  =            max( cushavg, 1000._r8 )
      cushavg                  =               max( cushavg, pblhz )
      cuorg                    =                      cuorg_inout(i)
      cuorg                    =   max( 0._r8, min( 1._r8, cuorg ) )

      ! ---------------------------------------------------------------------------------------- ! 
      ! Jun.07.2012. Include advection of horizontal heterogeneity associated with               !
      !              convective organization.                                                    !
      !              For the time being, these are treated only for                              !
      !              awk_PBL, delta_thl_PBL, delta_qt_PBL, delta_u_PBL, and delta_v_PBL.         !
      !              That is, delta_tr_PBL(:ncnst) are neglected to save computation time, which !
      !              should be included in future. Ideally, cush and cushavg should be treated   !
      !              in the same way.                                                            !  
      !              Note that a constant offset of -100. is extracted when retriving 'delta_xx' !
      !              values from tracer arrays.                                                  !
      !              Advection can cause 'awk_PBL_raw >  awk_PBL_max = 1._r8 - au_max'.          ! 
      !              In this case, re-set awk_PBL_raw to awk_PBL_max.                            !  
      ! ---------------------------------------------------------------------------------------- !

      if( iorg_adv ) then
         call cnst_get_ind( 'ORGawk', i_awk )
         call cnst_get_ind( 'ORGthl', i_thl )
         call cnst_get_ind( 'ORGqto',  i_qt )
         call cnst_get_ind( 'ORGuoo',   i_u )
         call cnst_get_ind( 'ORGvoo',   i_v )
         ! if( lchnk .eq. 5 .and. i .eq. 150 ) then
         !     write(6,*)
         !     write(6,*) 'UNICON : Print-out organization-related tracers within unicon.F90'
         !     write(6,*) 'awk_PBL, delta_thl_PBL, delta_qt_PBL, delta_u_PBL, delta_v_PBL, nstep, lchnk, i = ', &
         !                 get_nstep(),                  &
         !                 lchnk,                        &   
         !                 i,                            &
         !                 tr0_in(i,10,i_awk),           &
         !                 tr0_in(i,10,i_thl) - 100._r8, & 
         !                 tr0_in(i,10,i_qt)  - 100._r8, &  
         !                 tr0_in(i,10,i_u)   - 100._r8, & 
         !                 tr0_in(i,10,i_v)   - 100._r8
         !     write(6,*) 
         ! endif
         if( get_nstep() .eq. 0 ) then
            awk_PBL_raw       = 0._r8
            delta_thl_PBL_raw = 0._r8
            delta_qt_PBL_raw  = 0._r8
            delta_u_PBL_raw   = 0._r8
            delta_v_PBL_raw   = 0._r8
         else 
            tmp1                     = 0._r8
            awk_PBL_raw              = 0._r8
            delta_thl_PBL_raw        = 0._r8
            delta_qt_PBL_raw         = 0._r8
            delta_u_PBL_raw          = 0._r8
            delta_v_PBL_raw          = 0._r8
            do k = 1, kpblhm  ! Here, 'k' is a layer index.
               tmp1              =              tmp1 +                                                       dp0_in(i,k)
               awk_PBL_raw       =       awk_PBL_raw + min( tr0_in(i,k,i_awk), 1._r8 - au_max - 1.e-5_r8 ) * dp0_in(i,k)
! JHYoon : fixing advection problem of convective organization terms in SE
! (suggested by Sungsu Park)
!              delta_thl_PBL_raw = delta_thl_PBL_raw +    ( tr0_in(i,k,i_thl) - 100._r8 )                  * dp0_in(i,k)
!              delta_qt_PBL_raw  =  delta_qt_PBL_raw +    ( tr0_in(i,k, i_qt) - 100._r8 )                  * dp0_in(i,k)
!              delta_u_PBL_raw   =   delta_u_PBL_raw +    ( tr0_in(i,k,  i_u) - 100._r8 )                  * dp0_in(i,k)
!              delta_v_PBL_raw   =   delta_v_PBL_raw +    ( tr0_in(i,k,  i_v) - 100._r8 )                  * dp0_in(i,k)
               delta_thl_PBL_raw = delta_thl_PBL_raw +    ( tr0_in(i,k,i_thl) - 10._r8 )                  * dp0_in(i,k)
               delta_qt_PBL_raw  =  delta_qt_PBL_raw +    ( tr0_in(i,k, i_qt) - 0.01_r8 )                  * dp0_in(i,k)
               delta_u_PBL_raw   =   delta_u_PBL_raw +    ( tr0_in(i,k,  i_u) - 10._r8 )                  * dp0_in(i,k)
               delta_v_PBL_raw   =   delta_v_PBL_raw +    ( tr0_in(i,k,  i_v) - 10._r8 )                  * dp0_in(i,k)
! JHYoon
               ! TEST
               ! CHECK whether generalized tracer array can carry negative value correctly
               !       and if input awk_PBL is positive. 
               ! if( tr0_in(i,k,i_awk) .lt. 0._r8 .or. tr0_in(i,k,i_awk) .gt. 1._r8 ) then
               !     write(6,*) 
               !     write(6,*) 'Error in UNICON : Input awk_PBL is unreasonable as ', tr0_in(i,k,i_awk)
               !     write(6,*)  
               ! endif
               ! if( tr0_in(i,k,i_thl) - 100._r8 .lt. 0._r8 ) then
               !     write(6,*) 
               !     write(6,*) 'Good in UNICON : Input delta_thl_PBL is negative as ', tr0_in(i,k,i_thl) - 100._r8
               !     write(6,*)  
               ! endif
               ! if( tr0_in(i,k,i_qt) - 100._r8 .lt. 0._r8 ) then
               !     write(6,*) 
               !     write(6,*) 'Good in UNICON : Input delta_qt_PBL is negative as ', tr0_in(i,k,i_qt) - 100._r8
               !     write(6,*)  
               ! endif
               ! if( tr0_in(i,k,i_u) - 100._r8 .lt. 0._r8 ) then
               !     write(6,*) 
               !     write(6,*) 'Good in UNICON : Input delta_u_PBL is negative as ', tr0_in(i,k,i_u) - 100._r8
               !     write(6,*)  
               ! endif
               ! if( tr0_in(i,k,i_v) - 100._r8 .lt. 0._r8 ) then
               !     write(6,*) 
               !     write(6,*) 'Good in UNICON : Input delta_v_PBL is negative as ', tr0_in(i,k,i_v) - 100._r8
               !     write(6,*)  
               ! endif
               ! TEST
            enddo
            awk_PBL_raw       =       awk_PBL_raw / tmp1
            delta_thl_PBL_raw = delta_thl_PBL_raw / tmp1
            delta_qt_PBL_raw  =  delta_qt_PBL_raw / tmp1
            delta_u_PBL_raw   =   delta_u_PBL_raw / tmp1
            delta_v_PBL_raw   =   delta_v_PBL_raw / tmp1
         endif
      else
         awk_PBL_raw              =                    awk_PBL_inout(i)
         delta_thl_PBL_raw        =              delta_thl_PBL_inout(i)
         delta_qt_PBL_raw         =               delta_qt_PBL_inout(i)
         delta_u_PBL_raw          =                delta_u_PBL_inout(i)
         delta_v_PBL_raw          =                delta_v_PBL_inout(i)
      endif

      ! delta_thv_PBL_raw        =              delta_thv_PBL_inout(i)
      delta_tr_PBL_raw(:ncnst) =        delta_tr_PBL_inout(i,:ncnst)

      ! ----------------------------------------------------------------------------------- !
      ! Impose consistency between the input wake area and perturbations                    !
      ! This is a just minimal constraint not a sufficient one.                             !
      ! While this is a minimal constraint, we include additional consistncy constraint     !
      ! later in computing 'delta_thl_PBL' from  'delta_thl_PBL_raw' using tmp3 and tmp4    !
      ! later even though that is not perfrect either.                                      !
      ! If there is more consistent way, I should try to find that.                         !
      ! ----------------------------------------------------------------------------------- !

      if( awk_PBL_raw .lt. 1.e-5_r8 ) then 
         awk_PBL_raw              = 0._r8
         delta_thl_PBL_raw        = 0._r8
         delta_qt_PBL_raw         = 0._r8
         delta_u_PBL_raw          = 0._r8
         delta_v_PBL_raw          = 0._r8
         ! delta_thv_PBL_raw        = 0._r8
         delta_tr_PBL_raw(:ncnst) = 0._r8
      endif

      ! CHECK
      ! write(6,*) 'UNICON : awk_PBL_raw, delta_thl_PBL_raw, delta_qt_PBL_raw, delta_u_PBL_raw, delta_v_PBL_raw'
      ! write(6,*) awk_PBL_raw, delta_thl_PBL_raw, delta_qt_PBL_raw, delta_u_PBL_raw, delta_v_PBL_raw
      ! CHECK

!d    cu_prep(:mit)            =               cu_prep_inout(i,:mit)
!d    cu_cmfu(:mit)            =               cu_cmfu_inout(i,:mit)
!d    cu_cmfd(:mit)            =               cu_cmfd_inout(i,:mit)
!d    cu_tkePBLorg(:mit)       =          cu_tkePBLorg_inout(i,:mit)
!d    cu_cmfPBLorg(:mit)       =          cu_cmfPBLorg_inout(i,:mit)
!d    cu_thlPBLorg(:mit)       =          cu_thlPBLorg_inout(i,:mit)
!d    cu_qtPBLorg(:mit)        =           cu_qtPBLorg_inout(i,:mit)
!d    cu_uPBLorg(:mit)         =            cu_uPBLorg_inout(i,:mit)
!d    cu_vPBLorg(:mit)         =            cu_vPBLorg_inout(i,:mit)
      cu_cmfum(:mkx)           =              cu_cmfum_inout(i,:mkx)
      cu_cmfr(:mkx)            =               cu_cmfr_inout(i,:mkx)
      cu_thlr(:mkx)            =               cu_thlr_inout(i,:mkx)
      cu_qtr(:mkx)             =                cu_qtr_inout(i,:mkx)
      cu_ur(:mkx)              =                 cu_ur_inout(i,:mkx)
      cu_vr(:mkx)              =                 cu_vr_inout(i,:mkx)
      cu_qlr(:mkx)             =                cu_qlr_inout(i,:mkx)
      cu_qir(:mkx)             =                cu_qir_inout(i,:mkx)
      cu_trr(:mkx,:ncnst)      =         cu_trr_inout(i,:mkx,:ncnst)
      cu_cmfrd(:mkx)           =              cu_cmfrd_inout(i,:mkx)
      cu_thlrd(:mkx)           =              cu_thlrd_inout(i,:mkx)
      cu_qtrd(:mkx)            =               cu_qtrd_inout(i,:mkx)
      cu_urd(:mkx)             =                cu_urd_inout(i,:mkx)
      cu_vrd(:mkx)             =                cu_vrd_inout(i,:mkx)
      cu_qlrd(:mkx)            =               cu_qlrd_inout(i,:mkx)
      cu_qird(:mkx)            =               cu_qird_inout(i,:mkx)
      cu_trrd(:mkx,:ncnst)     =        cu_trrd_inout(i,:mkx,:ncnst)

      ! CHECK
      ! write(6,*) 'UNICON : Input cush, cushavg, cuorg and surface flux'
      ! write(6,*) cush, cushavg, cuorg, tkes, shflx, qflx, taux, tauy, bflx
      ! CHECK

      ! ------------------------------------------------------------------ !
      ! Compute mean convective precipitation flux at surface during       ! 
      ! previous times of 'org_memory_time'.                               !
      ! Also compute average updraft and downdraft mass flux at surface.   !
      ! Jun.29.2011. Change to the pecipitation flux at the PBL top.       !
      ! Jun.30.2011. Add perturbations of TKE, temperature, and moiture    !
      !              by convective downdraft and evaporation of convective !
      !              precipitation within PBL.                             !
      ! it = 1         : The most recent time step                         !
      ! it = nstep_org : The oldest time step                              !
      ! ------------------------------------------------------------------ !     

!d    prep_old      = 0._r8
!d    cmfu_old      = 0._r8
!d    cmfd_old      = 0._r8
!d    tkePBLorg_old = 0._r8
!d    cmfPBLorg_old = 0._r8
!d    thlPBLorg_old = 0._r8
!d    qtPBLorg_old  = 0._r8
!d    uPBLorg_old   = 0._r8
!d    vPBLorg_old   = 0._r8
!d    sum           = 0._r8
!d    do it = 1, nstep_org
!d     ! ----------------------------------------------------------------------------------------------- !
!d     ! Use a inverse-linear weighting average for the following three.                                 !
!d     ! Jul.15.2011. For conservative scalar, I should also perform mass-flux weighted average later.   !
!d     !              This must befined later.                                                           !
!d     !              This is corrrectly done below since cu_tkePBLorg(it) id downdraft mass flux now on !
!d     !              Jul.15.2011.                                                                       !
!d     ! ----------------------------------------------------------------------------------------------- !
!d       tmp1           = 1._r8         ! Equal weighting. I should always use this one.
!d     ! tmp1           = 1._r8 / it    ! Inverse-distance weighting
!d       sum            =           sum + tmp1
!d       prep_old       =      prep_old + tmp1 *      cu_prep(it)
!d       cmfu_old       =      cmfu_old + tmp1 *      cu_cmfu(it)
!d       cmfd_old       =      cmfd_old + tmp1 *      cu_cmfd(it)
!d       tkePBLorg_old  = tkePBLorg_old + tmp1 * cu_tkePBLorg(it) 
!d       cmfPBLorg_old  = cmfPBLorg_old + tmp1 * cu_cmfPBLorg(it)   
!d       thlPBLorg_old  = thlPBLorg_old + tmp1 * cu_cmfPBLorg(it) * cu_thlPBLorg(it)
!d       qtPBLorg_old   =  qtPBLorg_old + tmp1 * cu_cmfPBLorg(it) *  cu_qtPBLorg(it)
!d       uPBLorg_old    =   uPBLorg_old + tmp1 * cu_cmfPBLorg(it) *   cu_uPBLorg(it)
!d       vPBLorg_old    =   vPBLorg_old + tmp1 * cu_cmfPBLorg(it) *   cu_vPBLorg(it)
!d    enddo
!d    prep_old          =      prep_old / sum
!d    cmfu_old          =      cmfu_old / sum
!d    cmfd_old          =      cmfd_old / sum
!d    tkePBLorg_old     = tkePBLorg_old / sum
!d    if( cmfPBLorg_old .gt. nonzero ) then 
!d        thlPBLorg_old = thlPBLorg_old / max( cmfPBLorg_old, nonzero )
!d        qtPBLorg_old  =  qtPBLorg_old / max( cmfPBLorg_old, nonzero )
!d        uPBLorg_old   =   uPBLorg_old / max( cmfPBLorg_old, nonzero )
!d        vPBLorg_old   =   vPBLorg_old / max( cmfPBLorg_old, nonzero )
!d    else
!d        cmfPBLorg_old = 0._r8
!d        thlPBLorg_old = 0._r8
!d        qtPBLorg_old  = 0._r8
!d        uPBLorg_old   = 0._r8
!d        vPBLorg_old   = 0._r8
!d    endif
!d    cmfPBLorg_old     = cmfPBLorg_old / sum

      ! Jul.10.2011.
      !     I may set 'tau_org' as an internal function of 'pblh' and 'tkePBLorg_old'. 
      !     In the below line, '100' is roughly '1/a_d(0)' where 'a_d(0)' is downdraft
      !     fractional area at surface.
      !     This setting is not temporary but critical. I should re-arrange this later.
      ! Jul.13.2011. 
      !     As a semi-final configuration, I inserted 'wa_d(0)' to 'tkePBLorg_inout'.
      !     This 'wa_d(0)' is directly used as a mesoscale-perturbation of convective
      !     updraft vertical velocity in the elevated-platform in conjunction with
      !     cmf_r, thl_r, qt_r etc. in the lowest model layer. Note that 'tkePBLorg'
      !     contains several previous time steps while 'cmf_r, thl_r, qt_r' are saved
      !     just at the previous time step. 
      ! Aug.15.2011. 
      !     When prognostic meso-scale TKE equation is used, set tkePBLorg_old = cu_tkePBLorg(1)
      !     as below. 

      ! tkePBLorg_old = ( 1._r8 / a_d_sfcTKEorg ) * cuorg / ( cc2_org * tau_org )
      ! tkePBLorg_old = cu_tkePBLorg(1)
      ! thlPBLorg_old = cu_thlPBLorg(1)
      ! qtPBLorg_old  =  cu_qtPBLorg(1)

      ! ------------------------------------------------------------------------------------------------- !
      ! Jul.18.2011. Computation of 'w_org' ( characteristic velocity scale of convective organization )  !
      !              and 'tau_org' ( turn-over time scale of convective organization ).                   !
      !              w_org is computed by assuming balance between the source of convective organization  !
      !              and damping, while tau_org = pblh / w_org.                                           !
      !              This is very important to impose an equilibrium feedback on the formulation of       !
      !              convective organization, so that improving diurnal cycle of convective precipitation !
      !              and MJO.                                                                             !   
      !              Note that 'pblh' is always larger than z0(1), so that model never blows out.         ! 
      !              We should impose an appropriate upper limit on tau_org.                              !
      !              Below tau_org is turn-over time scale, which might not be the same as damping time   !
      !              scale of convective organization. Thus, for completeness, I should use               !
      !              tau_org = cc0_org * turn_org.                                                        !  
      ! ------------------------------------------------------------------------------------------------- !  

    ! Jul.16.2011. Below 'w_org' seems to generate degeneracy. So, I am using more explicit alternative way.
    !              Note that 'cc0_org' has the same role as b1=5.8 in the CAM5 moist PBL scheme.

    ! Aug.02.2011. Since 'tau_org' should be defined for the whole grid-mean, it is reasonable to locate
    !              'tau_org' computation outside of 'do iter' loop as in the current UNICON.

    ! w_org    = ( 2._r8 * cuorg ) / ( a_d_sfcTKEorg * cc2_org * cc0_org * pblhz )  
    ! w_org    = max( w_org, nonzero )
   !! w_org    = sqrt( 2._r8 * tkePBLorg_old / a_d_sfcTKEorg )
    ! turn_org = pblhz / w_org
    ! tau_org  = cc0_org * turn_org
    ! tau_org  = max( 3600._r8, min( 18000._r8, tau_org ) )

    ! Jul.25.2011.
    ! Jul.30.2011. For full conceptual consistency, I should use below explicit formula
    !              as a function of pblh instead of specifying tau_org. 
    !              Note that in the below formula, I am using 'zs0(kpblhm) - zs0(0)' instead of 'pblh' for the full
    !              consistency with the computation of orgforce(3) later.
    !              Note also that I am assuming w_org = w0_org * cuorg, that is, overturning time scale of
    !              convective organization is proportional to the cuorg, which is conceptually reasonable and
    !              also can be derived by using equilibrium assumption between the organized forcing and
    !              damping term. 
    !              Note also that in computing 'tau_org' below, I used current 'cuorg' instead of using 
    !              time-varying 'cuorg' in order to analytically solve 1st differential equation for organization. 

!d    tau_org  = pblhz / max( w0_org * cuorg, nonzero )  
!d    tau_org  = max( 1800._r8, min( 18000._r8, tau_org ) )
!d    w_org    = w0_org

!d    tau_org  = 10800._r8

    ! CHECK
    ! if( kpblh .ge. 2 ) then
    !     write(6,*)
    !     write(6,*) 'UNICON : pblh, kpblh, zs0(0), zs0(kpblh-1) - zs0(0), ( zs0(kpblh-1) - zs0(0) ) / max ( w0_org * cuorg, nonzero ), cuorg, tau_org = ', &
    !                 pblh, kpblh, zs0(0), zs0(kpblh-1) - zs0(0), ( zs0(kpblh-1) - zs0(0) ) / max( w0_org * cuorg, nonzero ), cuorg, tau_org 
    !     write(6,*)
    ! endif
    ! CHECK

      ! ------------------------------------------------------------------- !
      ! Convection is performed only when surface buoyancy flux is positive ! 
      ! Note that we should use 'bflxs' not 'ipbl' in order to filter out   !
      ! radiative cooling driven, cloud-topped PBL.                         !
      ! ------------------------------------------------------------------- !

    ! Mar.02.2011. Remove below block based on ARM simulation in order to
    ! simulate convection during night when surface buoyancy flux is negative.
    ! This is necessary to correctly simulate diurnal cycle of convection
    ! and convection over land. 

    ! if( bprod0_in(i,0) .le. 0._r8 ) then 
    !     id_exit = .true. 
    !     goto 333  
    ! endif

    ! if( ipbl .eq. 0 ) then 
    !     id_exit = .true. 
    !     goto 333  
    ! endif

      ! ---------------------------------------- !
      ! Local environmental mean state variables !
      ! ---------------------------------------- !

      ps0(0:mkx)          =       ps0_in(i,0:mkx)
      zs0(0:mkx)          =       zs0_in(i,0:mkx)
      p0(:mkx)            =         p0_in(i,:mkx)
      z0(:mkx)            =         z0_in(i,:mkx)
      dp0(:mkx)           =        dp0_in(i,:mkx) 
      dpdry0(:mkx)        =     dpdry0_in(i,:mkx) 
      u0(:mkx)            =         u0_in(i,:mkx)
      v0(:mkx)            =         v0_in(i,:mkx)
      qv0(:mkx)           =        qv0_in(i,:mkx)
      ql0(:mkx)           =        ql0_in(i,:mkx)
      qi0(:mkx)           =        qi0_in(i,:mkx)
      do mt = 1, ncnst    
         tr0(:mkx,mt)     =     tr0_in(i,:mkx,mt)
      enddo
      t0(:mkx)            =         t0_in(i,:mkx)
      s0(:mkx)            =         s0_in(i,:mkx)
      ast0(:mkx)          =       ast0_in(i,:mkx)
      tke0(0:mkx)         =      tke0_in(i,0:mkx)
      bprod0(0:mkx)       =    bprod0_in(i,0:mkx)

      ! Aug.08.2013. Evaporation of stratiform precipitation
      am_evp_st(:mkx)     =  am_evp_st_in(i,:mkx)
      evprain_st(:mkx)    = evprain_st_in(i,:mkx)
      evpsnow_st(:mkx)    = evpsnow_st_in(i,:mkx)

      ! --------------------------------------------------------- !
      ! Compute other basic thermodynamic variables directly from ! 
      ! the input variables at each grid point                    !
      ! --------------------------------------------------------- !

      ! --------------------------------------------------------------- !
      ! Nov.30.2012. Layer thickness depending on dry or moist tracers. !
      ! --------------------------------------------------------------- !

      do mt = 1, ncnst
         if( cnst_get_type_byind(mt) .eq. 'wet' ) then
            dptr0(:mkx,mt) = dp0(:mkx)
         else
            dptr0(:mkx,mt) = dpdry0(:mkx)
         endif
      enddo

      ! --------------------------------------------- !
      ! Compute conservative scalars at the mid-point !
      ! --------------------------------------------- !     

      exn0(:mkx)   = ( p0(:mkx) / p00 )**rovcp
      exns0(0:mkx) = ( ps0(0:mkx) / p00 )**rovcp
      qt0(:mkx)    = ( qv0(:mkx) + ql0(:mkx) + qi0(:mkx) )
      thl0(:mkx)   = ( t0(:mkx) - xlv * ql0(:mkx) / cp - xls * qi0(:mkx) / cp ) / exn0(:mkx)
      thvl0(:mkx)  = ( 1._r8 + zvir * qt0(:mkx) ) * thl0(:mkx)
      rho0(:mkx)   = ( p0(:mkx) ) / ( r * t0(:mkx) * ( 1._r8 + zvir * qv0(:mkx) - ql0(:mkx) - qi0(:mkx) ) )
      do k = 1, mkx
       ! May.15.2015. 
       ! Because mean environment is not homogeneous, I should use input 'ql0(0:mkx), qi0(0:mkx)'
       ! instead of 'ql, qi' from 'conden', in principle. I should test this in future.               
       ! I might use below for 'conden' subroutine in the buoyancy sorting.
         call conden( p0(k), thl0(k), qt0(k), th, qv, ql, qi, qse, id_check )
!f       if( id_check .eq. 1 ) then
!f           id_exit = .true.
!f           go to 333
!f       endif
         thv0(k) = th * ( 1._r8 + zvir * qv - ql - qi )
         rh0(k)  = max( 0._r8, min( 1._r8, qv / max( nonzero, qse ) ) )
      enddo
      do k = 1, mkx
         dz0(k)  = zs0(k)  - zs0(k-1)
         if( k .eq. mkx ) then
            dzs0(k) = zs0(k) - z0(k)
            dps0(k) = p0(k) - ps0(k)
         else
            dzs0(k) = z0(k+1) - z0(k)
            dps0(k) = p0(k)   - p0(k+1)
         endif
      end do
      dzs0(0) = z0(1)
      dps0(0) = ps0(1) - p0(1)

      ! Sep.07.2011. Compute 'qt0PBL, thl0PBL' for later use in the 
      !              convective organization.
      ! Sep.09.2011. Commented out since it is not used anymore because I don't prognose 
      !              organized 'thv' anymore.
      ! Dec.17.2012. Restore below block in addition to the computation of the other thermodynamic variables since
      !              these PBL-averaged variables are critically used for the revised 'bulk' computation of
      !              organized flux at the PBL top interface. 

      tmp1            = 0._r8
      qt0PBL          = 0._r8
      thl0PBL         = 0._r8
      u0PBL           = 0._r8
      v0PBL           = 0._r8
      tr0PBL(1:ncnst) = 0._r8 
      do k = 1, kpblhm  ! Here, 'k' is a layer index.
         dpi     = ps0(k-1) - ps0(k)
         tmp1    = tmp1     + dpi
         qt0PBL  = qt0PBL   + dpi*qt0(k)
         thl0PBL = thl0PBL  + dpi*thl0(k)
         u0PBL   = u0PBL    + dpi*u0(k)
         v0PBL   = v0PBL    + dpi*v0(k)
         do mt = 1, ncnst
            tr0PBL(mt) = tr0PBL(mt) + dpi*tr0(k,mt)
         enddo
      end do
      qt0PBL   = qt0PBL  / tmp1
      thl0PBL  = thl0PBL / tmp1
      u0PBL    = u0PBL   / tmp1
      v0PBL    = v0PBL   / tmp1
      do mt = 1, ncnst
         tr0PBL(mt) = tr0PBL(mt) / tmp1
      enddo

      ! ---------------------------------------------------------------------------- !
      ! Dec.20.2012. Compute reconstructed effective entrainment rate at the PBL top !
      !              interface, 'we_eff' [m/s] for use in computing damping time     ! 
      !              scale of organized flow within PBL.                             !
      !              Use the average of two constructed from 'qt0' and 'thl0'.       !
      !              Below computation may introduce a sensitivity to vertical       !
      !              resolution but hopely that effect is likely small.              ! 
      ! ---------------------------------------------------------------------------- !

      tmp1 = abs( thl0(kpblh) - thl0(kpblhm) ) / max( abs( thl0(kpblh) - thl0PBL ), 1._r8    )  + &
             abs(  qt0(kpblh) -  qt0(kpblhm) ) / max( abs(  qt0(kpblh) -  qt0PBL ), 1.e-3_r8 )
      went_eff = 0.5_r8 * tmp1 * went
      went_eff = min( max( 0._r8, went_eff ), 1._r8 )
      went_eff_out(i) = went_eff
      went_out(i)     = went

      ! ------------------------------------------------------------------------- !
      ! Compute in-layer slopes of conservative scalars                           !
      ! Dimension of slope is implicitly (1:mkx).                                 !
      ! Unit is [K/Pa] (for thl0) with a negative when thl increases vertically.  !
      ! It turns out that using non-zero slope induces inversion of 'thv0' across !
      ! the model interface, distorting model performance, including too much     !
      ! convective downdraft from updraft buoyancy sorting. Thus, it is much      !
      ! better to use the zero slope, which almost always guarantees stratified   !
      ! input environmental profile except in the lowest model layer.             ! 
      ! ------------------------------------------------------------------------- !

      ssthl0 = slope( mkx, thl0, p0 ) 
      ssqt0  = slope( mkx, qt0 , p0 )
      ssu0   = slope( mkx, u0  , p0 )
      ssv0   = slope( mkx, v0  , p0 )
      do mt = 1, ncnst
         sstr0(:mkx,mt) = slope( mkx, tr0(:mkx,mt), p0 )
      enddo
      if( islope_on_thlqttr .eq. 0 ) then           
         ssthl0(:mkx) = 0._r8
         ssqt0(:mkx)  = 0._r8
         do mt = 1, ncnst
            sstr0(:mkx,mt) = 0._r8
         enddo
      endif
      if( islope_on_uv .eq. 0 ) then           
         ssu0(:mkx)   = 0._r8
         ssv0(:mkx)   = 0._r8
      endif

      ! ---------------------------------------------------------------------------------------- !
      ! Apr.12.2011. PGF effect on u,v are separately treated using the below 'u_grd0, v_grd0'   !
      ! in order to reasonably treat the optional case of zero internal slope of u, v, that is,  !
      ! islope_on_uv = 0. Even when islope_on_uv = 1, PGF effect is computed using u_grd0,v_grd0.!
      ! ---------------------------------------------------------------------------------------- !  
       
      do k = 1, mkx
         kp = k + 1
         km = k - 1
         if( k .eq. 1 ) then
            u_grd0(k) = ( u0(kp) -   u0(1) ) / ( p0(kp)  -  p0(k) ) 
            v_grd0(k) = ( v0(kp) -   v0(1) ) / ( p0(kp)  -  p0(k) ) 
         elseif( k .eq. mkx ) then
            u_grd0(k) = ( u0(mkx) - u0(km) ) / ( p0(mkx) - p0(km) )
            v_grd0(k) = ( v0(mkx) - v0(km) ) / ( p0(mkx) - p0(km) )
         else
            u_grd0(k) = ( u0(kp) -  u0(km) ) / ( p0(kp)  - p0(km) ) 
            v_grd0(k) = ( v0(kp) -  v0(km) ) / ( p0(kp)  - p0(km) ) 
         endif
      enddo

      ! ------------------------------------------------------------- !
      ! Compute 'qt,thl,u,v,thv,thvl' at the top/bottom interfaces    !
      ! Note 'thv,thvl' are consistently computed from the top/bottom !
      ! interface values of 'thl,qt'.                                 !
      ! ------------------------------------------------------------- !

      ! Aug.02.2011. Note that even outside of 'do iter' loop, we have 'go to 333'.
      !              Thus, it seems to be more reasonable to exit the whole computation ( not just exit a specific 'iter' loop )
      !              whenever 'go to 333' happens. Thus, keeping current structure of '333 continue'-related block is conceptually
      !              more reasonable.  

      do k = 1, mkx

         km = k - 1

         thl0bot(k)  = thl0(k) + ssthl0(k) * ( ps0(km) - p0(k) )
         qt0bot(k)   = qt0(k)  + ssqt0(k)  * ( ps0(km) - p0(k) )
!lim
         qt0bot(k)   = max( qt0bot(k), qmin(1) )
!lim
         u0bot(k)    = u0(k)   + ssu0(k)   * ( ps0(km) - p0(k) )
         v0bot(k)    = v0(k)   + ssv0(k)   * ( ps0(km) - p0(k) )
         do mt = 1, ncnst
            tr0bot(k,mt) = tr0(k,mt) + sstr0(k,mt) * ( ps0(km) - p0(k) )
!lim
            tr0bot(k,mt) = max( tr0bot(k,mt), qmin(mt) )
!lim
         enddo
         call conden( ps0(km), thl0bot(k), qt0bot(k), th, qv, ql, qi, qse, id_check )
!f       if( id_check .eq. 1 ) then
!f           id_exit = .true.
!f           go to 333
!f       endif
         thvl0bot(k) = thl0bot(k) * ( 1._r8 + zvir * qt0bot(k) )
         thv0bot(k)  = th * ( 1._r8 + zvir * qv - ql - qi )
         ql0bot(k)   = ql
         qi0bot(k)   = qi
         if( islope_on_thlqttr .eq. 0 ) then
            thv0bot(k) = thv0(k)
            ql0bot(k)  = ql0(k)
            qi0bot(k)  = qi0(k)
         endif
         rho0bot(k)  = ps0(km) / ( r * thv0bot(k) * exns0(km) )
         rh0bot(k) = max( 0._r8, min( 1._r8, qv / max( nonzero, qse ) ) )

         thl0top(k)  = thl0(k) + ssthl0(k) * ( ps0(k) - p0(k) )
         qt0top(k)   = qt0(k)  + ssqt0(k)  * ( ps0(k) - p0(k) )
!lim
         qt0top(k)   = max( qt0top(k), qmin(1) )
!lim
         u0top(k)    = u0(k)   + ssu0(k)   * ( ps0(k) - p0(k) )
         v0top(k)    = v0(k)   + ssv0(k)   * ( ps0(k) - p0(k) )
         do mt = 1, ncnst
            tr0top(k,mt) = tr0(k,mt) + sstr0(k,mt) * ( ps0(k) - p0(k) )
!lim
            tr0top(k,mt) = max( tr0top(k,mt), qmin(mt) )
!lim
         enddo
         call conden( ps0(k), thl0top(k), qt0top(k), th, qv, ql, qi, qse, id_check )
!f       if( id_check .eq. 1 ) then
!f           id_exit = .true.
!f           go to 333
!f       endif
         thvl0top(k) = thl0top(k) * ( 1._r8 + zvir * qt0top(k) )
         thv0top(k)  = th * ( 1._r8 + zvir * qv - ql - qi )
         ql0top(k)   = ql
         qi0top(k)   = qi
         if( islope_on_thlqttr .eq. 0 ) then
            thv0top(k) = thv0(k)
            ql0top(k)  = ql0(k)
            qi0top(k)  = qi0(k)
         endif
         rho0top(k)  = ps0(k) / ( r * thv0top(k) * exns0(k) )
         rh0top(k)   = max( 0._r8, min( 1._r8, qv / max( nonzero, qse ) ) )

         ssthv0(k)   = ( thv0top(k)  -  thv0bot(k) ) / ( ps0(k) - ps0(km) )
         ssthvl0(k)  = ( thvl0top(k) - thvl0bot(k) ) / ( ps0(k) - ps0(km) )
         ssql0(k)    = ( ql0top(k)   -   ql0bot(k) ) / ( ps0(k) - ps0(km) )
         ssqi0(k)    = ( qi0top(k)   -   qi0bot(k) ) / ( ps0(k) - ps0(km) )

         ! CHECK
         ! if( k .ge. kpblh .and. ( thv0top(k)+1.e-8_r8 .lt. thv0bot(k) .or. thv0bot(k) .lt. thv0top(km) ) ) then
         !     write(6,*) 
         !     write(6,*) 'UNICON : The input environmental thv0 profile is unstable'
         !     write(6,*) 'Layer index and kpblh = ', k, kpblh
         !     write(6,*) 'thv0top(km), thv0bot(k), thv0top(k) = ',thv0top(km), thv0bot(k), thv0top(k) 
         !     write(6,*)
         !   ! stop
         ! endif
         ! CHECK

      end do   ! k = 1, mkx

      ! ---------------------------------------------------------------------------- !  
      ! Compute 'tke1' and 'wstar1' in the lowest model layer                        !
      ! Below compute average 'tke' and 'wstar' from the sfc                         !
      ! to the specified top interface, kc.                                          !
      ! Also define 'wstar2' only using 'surface buoyancy production' ( bprod0(0) )  !
      ! and 'PBLH'. This 'wstar2' seems to be the most reasonable choice of          !
      ! velocity scale to compute 'sigma_w'. This 'wstar2' is also independent of    !
      ! vertical resolution of GCM model grid.                                       !
      ! ---------------------------------------------------------------------------- !

      tmp1   = 0._r8
      tmp2   = 0._r8
      tke1   = 0._r8
      wstar1 = 0._r8
      kc = 1               ! Top interface of the average domain.
      do k = 0, kc         ! Here, 'k' is an interfacial layer index.
         if( k .eq. 0 ) then
            dpi = ps0(0) - p0(1)
            dzi = z0(1) - zs0(0)
         elseif( k .eq. kc ) then
            dpi = p0(kc) - ps0(kc)
            dzi = zs0(kc) - z0(kc)
         else
            dpi = p0(k) - p0(k+1)
            dzi = z0(k+1) - z0(k)
         endif
         tmp1 = tmp1 + dpi
         tmp2 = tmp2 + dzi
         tke1 = tke1 + dpi*tke0(k)
         wstar1 = wstar1 + dzi*bprod0(k)
      end do
      tke1   = tke1 / tmp1
      wstar1 = ( 2.5_r8 * max( 0._r8, wstar1 ) )**(1._r8/3._r8)
      tmp1 = ( qv0(1) + ql0(1) + qi0(1) )
      tmp2 = ( t0(1) - xlv * ql0(1) / cp - xls * qi0(1) / cp ) / ( ( p0(1) / p00 )**rovcp )
      call conden( p0(1), tmp2, tmp1, th, qv, ql, qi, qse, id_check )
      tlcl = 55._r8 + 1._r8 / ( 1._r8 / ( t0(1) - 55._r8 ) - log( max( qv0(1), nonzero ) / qse ) / 2840._r8 )
      rlcl = 102.62_r8 * ( t0(1) - tlcl )
      ! OPTION. Combination.5. This seems to be better.
      wstar2 = ( max( 0._r8, bprod0(0) ) * pblhz )**(1._r8/3._r8)
      ! OPTION. Combination.6.
      ! wstar2 = ( max( 0._r8, bprod0(0) ) * min( pblhz, rlcl ) )**(1._r8/3._r8)
      wstar2 = max( 0._r8, min( wstar2, 10._r8 ) )

      ! OPTION
      ! Re-define 'tke1' as 'tke' at the 1st interface
      if( kiss .eq. 0 ) then
         ! Jun.28.2011. Directly use 'tkes' from the UW PBL scheme which does not include transport term.
         tke1   = tke0(0)
         ! tke1   = tkes 
      else
         tke1   = tke0(1)
      endif
      tke1   = max(1.e-5_r8,min(3._r8,tke1)) 
      ! OPTION

      tmp1     = 0._r8
      tmp2     = 0._r8
      tkePBL   = 0._r8
      wstarPBL = 0._r8
      kc       = kpblhm    ! Top interface of the average domain.
      do k = 0, kc         ! Here, 'k' is an interfacial layer index.
         if( k .eq. 0 ) then
            dpi = ps0(0) - p0(1)
            dzi = z0(1) - zs0(0)
         elseif( k .eq. kc ) then
            dpi = p0(kc) - ps0(kc)
            dzi = zs0(kc) - z0(kc)
         else
            dpi = p0(k) - p0(k+1)
            dzi = z0(k+1) - z0(k)
         endif
         tmp1   = tmp1   + dpi
         tmp2   = tmp2   + dzi
         tkePBL = tkePBL + dpi*tke0(k)
         wstarPBL = wstarPBL + dzi*bprod0(k)
      end do
      tkePBL   = tkePBL / tmp1
      tkePBL   = max(1.e-5_r8,min(3._r8,tkePBL)) 
      wstarPBL = ( 2.5_r8 * max( 0._r8, wstarPBL ) )**(1._r8/3._r8)

      ! Aug.15.2011. For consistent treatment with convective downdraft.
      ! Aug.03.2012. Test for diagnosing the sensitivity to vertical resolution.
      !              it turns out that below is the solution to solve the sensitivity to vertical resolution.
      !              That is, tke0(0) differs depending on the vertical resolution.
      !              Thus, I should use tkePBL and adjust 'kw' accordingly. 
      !              This is conceptually non-attractable but since tkePBL should be well correlated with tke0(0),
      !              below use of tke1 = tkePBL is perfectly justificable. 

      tke1 = tkePBL

      ! Nov.18.2013. Internally compute 'kw' following the MY/Galperin approach.
      !              Note that '0.5477 (the most stable) < kw_internal < 1.0536 (the most unstable)'

      ! kw_internal = 0.4450_r8 + 3.9032_r8 * 0.4_r8 * z0(1) * ( bprod0(0) / tke0(0)**(1.5_r8) )
      ! kw_internal = min( max( 0.3_r8, kw_internal ), 1.11_r8 )
      ! kw_internal = sqrt( kw_internal )

      ! kw_min_ocn  = kw_internal
      ! kw_max_ocn  = kw_internal
      ! kw_min_lnd  = kw_internal
      ! kw_max_lnd  = kw_internal
 
      ! ---------------------------------------------------------------------------- !
      ! Sep.16.2011. Compute forbidden area fraction by subgrid variation of surface !
      !              topograpgic height.                                             !
      !              Following 'tms', I am using 'sgh30' not 'sgh'.                  !
      !              Impose a upper limit of 'a_oro_max' on the 'a_oro'.             !   
      ! ---------------------------------------------------------------------------- !
  
      a_oro = sgh30 / norm_sgh
      a_oro = max( 0._r8, min( a_oro_max, a_oro ) )
  
      ! -------------------------------------------------------------------------------------------------------------------- !
      ! Aug.31.2011. Compute 'delta_w_PBL' here. Note that similar to the other 'delta_' variables, this is exactly          !
      !              the difference between off-wake area and grid-mean environment but not over the PBL                     !
      ! but at surface for UNICON.                                                                                           !
      ! Sep.07.2011. The wake ratio is now internally computed instead of specified by the user, which is very good.         !
      !              Due to the potentially very small awk_PBL and so large delta_w_PBL, we should impose an upper limit     !
      !              on delta_w_PBL.                                                                                         ! 
      ! Sep.07.2011. Compute refined 'awk_PBL' and all the 'delta_' variables by considering non-homogeneous distribution of !
      !              wake properties. In consistent with the Gaussian distribution assumption of updraft fractional area at  !
      !              surface as a function of alpha, roughly assume that the fractional area of 'the difference              !
      !              between 'wake' and 'grid-mean' follows half-Gaussian distribution.                                      !
      !              Note 'delta_thv_wc [ K ] < 0' is a minimum critical virtual temperature difference between wake and     !
      !              environment in order to be identified as the 'wake'. If '0 > delta_thv > delta_thv_wc' for some         !
      !              sub-grid wake component, we assume that that is not wake any more and are treated as non-wake.          !
      !              Note that below 'tmp1' must be positive since both 'delta_thv_wc' and 'delta_thv_PBL' are negative.     !
      !              I should carefully and reasonably treat the case when the denominator becomes zero.                     !
      ! Sep.08.2011. Be careful that 'erfc(x) = 1 - erf(x)'. CAM is providing 'erfc' not 'erf'.                              !
      !              In the below computation of tmp2, I thus used 'erfc'.                                                   !  
      !              Below formula correctly treats all the limiting cases correctly.                                        !
      ! Sep.09.2011. I should check whether I should multiply the wake area 'awk_PBL / ( 1._r8 - awk_PBL )' to the final     !
      !             'delta_w_PBL' since even though wake spreading velocity is large, it will have small contribution to the !
      !              vertical velocity perturbations of whole non-wake area. I should think about this.                      ! 
      ! Sep.09.2011. More genral wake inhomogegeneity treatment is added when 'delta_thv_PBL_raw < 0'.                       !
      !              This is a perfect, fully consistent treatment converging to the other case.                             !
      !              By doing this, I can resolve vertical profile of diagnosed 'delta_thv_PBL_raw' within PBL, which        !
      !              provides more detailed information for future additional use.                                           !             
      ! Sep.10.2011. I should impose a bound on the prognosed 'delta_' variables such that all conservative scalars are      !
      !              reasonable positive values ( except u,v ) both within 'wake' and 'non-wake' areas.                      ! 
      ! Sep.11.2011. I ceoceptually throughly checked that by using 'max( nonzero, delta_thv_PBL_raw ) in tmp1' and          !
      !             'max( nonzero, awk_PBL ) in delta_w_PBL', my below formula should produce all reasonable wake properties !
      !              including delta_w_PBL in all the limiting cases, e.g., awk_PBL -> 0. For example, when awk_PBL ->0 in   !
      !              delta_w_PBL computation, then delta_w_PBL is automatically goto zero since after wake inhomogeneity     !
      !              adjustment, it is guaranteed that delta_thv_PBL = 0 if awk_PBL -> 0. So, all of my below formula        !
      !              must produce all the reasonable values in all the limiting cases as it is - great !                     !
      ! -------------------------------------------------------------------------------------------------------------------- !

      ! --------------------------------------------------------------------------------------------------------- !
      ! Sep.11.2011. Insert a condition preventing negative thl, qt , tracers both within wake and non-wake areas !
      !              before wake-inhomogeneity adjustment.                                                        !
      ! --------------------------------------------------------------------------------------------------------- !

!lim  In fact, below limiters before buoyancy adjustment are not necessary, since buoyancy adjument of cold pool
!lim  can be done regardless of what is the value of 'delta_xxx_PBL'. So, I commented out below limiters.     
!lim  Just for computing 'delta_thv_PBL_raw' below, impose a limiter for 'delta_thl_PBL_raw, delta_qt_PBL_raw'
!lim  Also add a limiter at the surface and top interface of the PBL for full consistency.

!lim  thl0min_PBL          = thl0bot(1)
      qt0min_PBL           = qt0bot(1)
      tr0min_PBL(:ncnst)   = tr0bot(1,:ncnst)
      do k = 1, kpblhm
!lim     thl0min_PBL       = min( thl0min_PBL, thl0(k) ) 
         qt0min_PBL        = min( qt0min_PBL,   qt0(k) ) 
         do mt = 1, ncnst
            tr0min_PBL(mt) = min( tr0min_PBL(mt), tr0(k,mt) )              
         enddo
      enddo
!lim  thl0min_PBL       = min( thl0min_PBL, thl0top(kpblhm) ) 
      qt0min_PBL        = min( qt0min_PBL,   qt0top(kpblhm) ) 
      do mt = 1, ncnst
         tr0min_PBL(mt) = min( tr0min_PBL(mt), tr0top(kpblhm,mt) )              
      enddo
             
!lim  delta_thl_PBL_raw = min( max( -thl0min_PBL, delta_thl_PBL_raw ), thl0min_PBL * awk_PBL_raw / ( 1._r8 - awk_PBL_raw ) ) 
      delta_qt_PBL_raw  = min( max( qmin(1) - qt0min_PBL, delta_qt_PBL_raw ), & 
                                  ( qt0min_PBL - qmin(1) ) * awk_PBL_raw / ( 1._r8 - awk_PBL_raw ) )
      do mt = 1, ncnst    
         delta_tr_PBL_raw(mt) = min( max( qmin(mt) - tr0min_PBL(mt), delta_tr_PBL_raw(mt) ), & 
                                        ( tr0min_PBL(mt) - qmin(mt) ) * awk_PBL_raw / ( 1._r8 - awk_PBL_raw ) )
      enddo

!lim2 It seems that below 4 limiters are too physically restricted without influencing model crash and 
!lim2 computation time. So, I removed them.  

      delta_thl_PBL_raw = max( - 2.0_r8, min( 2.0_r8, delta_thl_PBL_raw ) )
      delta_qt_PBL_raw  = max( - 0.2_r8*qt0min_PBL, min( 0.2_r8*qt0min_PBL, delta_qt_PBL_raw ) )
      delta_u_PBL_raw   = max( - 2.0_r8, min( 2.0_r8 , delta_u_PBL_raw ) )
      delta_v_PBL_raw   = max( - 2.0_r8, min( 2.0_r8 , delta_v_PBL_raw ) )

!lim  In fact, below computation from individual layer computation is also unnecessary.
!lim  We only need to do a bulk computation, which is also good for saving computation time.
!lim  However, in order to use 'conden' subroutine with p0(k), it seems that below computation is inevitable.
!lim  Instead of using the above block, I simply used 'max( qt0(k) + delta_qt_PBL_raw, qmin(1) )' as an argument below.

      delta_thv_PBL_raw = 0._r8
      do k = 1, kpblhm  ! Here, 'k' is a layer index.
         call conden( p0(k), thl0(k) + delta_thl_PBL_raw, qt0(k) + delta_qt_PBL_raw, & 
                      th, qv, ql, qi, qse, id_check )
!f       if( id_check .eq. 1 ) then
!f           id_exit = .true.
!f           go to 333
!f       endif
         thv = th * ( 1._r8 + zvir * qv - ql - qi )
       ! delta_thv_PBL_raw_array(k) = thv - thv0(k)
         delta_thv_PBL_raw = delta_thv_PBL_raw + ( thv - thv0(k) ) * dp0(k)
      enddo
      delta_thv_PBL_raw = delta_thv_PBL_raw / pblhp

      awk_PBL_max = 1._r8 - au_max
      if( awk_PBL_raw .lt. 0._r8 .or. awk_PBL_raw .gt. awk_PBL_max ) then
         write(6,*)
         write(6,*) 'UNICON : Unreasonable wake area awk_PBL_raw before inhomogeneity adjustment'
         write(6,*) 'awk_PBL_raw = ', awk_PBL_raw 
         call endrun('STOP : UNICON')
         write(6,*)  
      endif
      if( delta_thv_PBL_raw .lt. 0._r8 ) then
         awk_PBL                  = 0._r8
         delta_thl_PBL            = 0._r8
         delta_qt_PBL             = 0._r8
         delta_u_PBL              = 0._r8
         delta_v_PBL              = 0._r8
         delta_thv_PBL            = 0._r8
         do mt = 1, ncnst    
            delta_tr_PBL(mt)      = 0._r8
         enddo
         delta_w_PBL              = 0._r8
      else
         ! -------------------------------------------------------------------------------------------------- !
         ! Sep.10.2011. I should carefully consider whether below treatment obtained from 'thv' consideration !
         !              can be generally applicable for all conservative scalars.                             !
         !              Strictly speaking, this is not perfectly correct, but just a good approximation.      !
         !              There is no free lunch. The best way is to use very large 'nseg' and do adjustment    !
         !              using explicit individual wake properties - but this will take tremendous amount of   !
         !              time. But I think that my below treatment is reasonably OK.                           !
         !              From the statistical distribution point of view, my below formula is completely OK    !
         !              and perfectly reasonable. So, let's keep my beautiful below formula.                  !
         ! Oct.03.2011. We may need to constrain these 'delta_**_PBL' variables in order to prevent model     !
         !              crash associated with unreasonable aerosol optical depth of dust and sea-salt as      !
         !              shown in many sensitivity simulations. This must be done as soon as possible.         !   
         ! Apr.27.2012. Multiply an inhomogeneity factor of 'cdelta' to 'thl,qt,u,v,tr' in the below to take  !
         !              into account of non-homogeneity distribution within 'a_U'. We implicitly assume that  !
         !              turbulent updrafts at surface that grow into convective updrafts (i.e., the ones      !
         !              simulated by UNICON) tend to preferentially located into the portion of 'a_U'         !
         !              where 'delta' perturbation is large. This is a reasonable assumption.                 !
         !              Note that I should not change 'thv' since it is used for computing organization TKE   !
         !              that uses 'mean' the difference between wake and non-wake area.                       !    
         !              This approach is perfectly conceptually reasonable as long as we use 'iau_base = 1'.  !
         !              Note also that I am multiplying 'cdelta' before imposing constraints.                 ! 
         ! Apr.27.2012. I found that I should not multiply 'cdelta' below since 'delta_' variables are used   !
         !              for computing mixing environmental airs and also updating 'delta_' variables at the   !
         !              next time step. So, I multiplied 'cdelta' when these 'delta' variables are actually   !
         !              into convective updraft at surface later.                                             !                                       
         ! -------------------------------------------------------------------------------------------------- !
         tmp1                     = delta_thv_wc * awk_PBL_raw / ( awk_PBL_raw - 1._r8 ) / max( nonzero, delta_thv_PBL_raw )
         ! tmp2                     = 1._r8 - erf( tmp1 / sqrt( 3.141592_r8 ) )
         tmp2                     = erfc( tmp1 / sqrt( 3.141592_r8 ) )
         tmp3                     = exp( - tmp1**2._r8 / 3.141592_r8 )
         tmp4                     = ( 1._r8 - awk_PBL_raw ) / ( 1._r8 - tmp2 * awk_PBL_raw ) 
         awk_PBL                  = tmp2 * awk_PBL_raw
         delta_thl_PBL            = tmp3 * tmp4 *   delta_thl_PBL_raw    
         delta_qt_PBL             = tmp3 * tmp4 *    delta_qt_PBL_raw
         delta_u_PBL              = tmp3 * tmp4 *     delta_u_PBL_raw
         delta_v_PBL              = tmp3 * tmp4 *     delta_v_PBL_raw
         delta_thv_PBL            = tmp3 * tmp4 *   delta_thv_PBL_raw 
         do mt = 1, ncnst    
            delta_tr_PBL(mt)      = tmp3 * tmp4 * delta_tr_PBL_raw(mt)
         enddo

    !lim Oct.4. Even though we apply non-negative limiter for 'delta_qt_PBL' and 'delta_tr_PBL' here, there is no way     
    !lim        to consistently change 'delta_thv_PBL' that influences the computation of 'delta_thv_PBL' below.
    !lim        Thus, the limiters for 'delta_qt_PBL' and 'delta_tr_PBL' are done later without any option.

         ! ----------------------------------------------------------------------------------------------------------------------------- !
         ! Sep.11.2011. Conceptually, when wake area is small, its contribution to the WHOLE non-wake area is likely to be must be small !
         !              since we are computing the acerage delta_w_PBL averaged over the whole non-wake PBL, which is uniformly added    !
         !              to updraft vertical velocity perturbation to all the updraft segment. Thus, we may need to additionally multiply !
         !              the factor 'awl_PBL / ( 1._r8 - awk_PBL )' outside of sqrt to the below formula delta_w_PBL.                     !
         !              Depending on the simulation, I should carefully think about including this.                                      !
         ! Sep.12.2011. Below final constraint of 'if( awk_PBL .lt. 1.e-3_r8 ) delta_w_PBL = 0._r8' is really good, but I should check   !
         !              whether this constraint does not distort simulation results.                                                     !
         ! Sep.23.2011. I recomputed 'delta_w_PBL' completely based on the solid theory based on the concept of available potential      !
         !              energy.                                                                                                          !
         ! Mar.02.2012. Compute correct 'delta_w_PBL' following 'UNICON.Part-I' draft. This is likely to have an impact of reducing      !
         !              the diurnal timing of maximum precipitation at surface.                                                          !
         ! ----------------------------------------------------------------------------------------------------------------------------- !

         ! Mar.01.2012. Below is the most correct code consistent with the manuscript in the 'UNICON.Part-I' draft.
         delta_w_PBL = kw_omega * sqrt( kstar * 0.5_r8 * ( g / thv_ref ) * pblhz * awk_PBL * max( 0._r8, delta_thv_PBL ) )
         ! Nov.08.2011. Below is the most recent code on Nov.08.2011 by assuming that the released APE is entirely concentrated within
         !              non-wake area for promoting convective updraft. Thus, I divide the original formula by ( 1._r8 - awk_PBL ).
         !              By removing this deadblock, convective organization can freely grow without oppositing negative feedback by
         !              the factor of ( 1._r8 - awk_PBL ), hoping to improve the diurnal cycle over summer continent.
         ! delta_w_PBL              = kw_omega * sqrt( kstar * 0.5_r8 * ( g / thv_ref ) * pblhz * max( 0._r8, delta_thv_PBL ) )
         ! Below is a new code on Sep.23.2011.
         ! delta_w_PBL              = kw_omega * sqrt( kstar * 0.5_r8 * ( g / thv_ref ) * pblhz * ( 1._r8 - awk_PBL ) * max( 0._r8, delta_thv_PBL ) )
         ! Below is the old code before Sep.23.2011.
         ! delta_w_PBL              = kstar * sqrt( ( 1._r8 - awk_PBL ) / max( nonzero, awk_PBL ) * 2._r8 * ( g / thv_ref ) * pblhz * max( 0._r8, delta_thv_PBL ) )   

         !og When advanced cold pool formula is used, use below formula. use below formula
         !og instead of the above formula.
         !og Below 'delta_w_PBL' is the one when the rising branch is the same as the entire '1 - awl_PBL'. 
         !og Note that I don't need to newly define the other thermodynamic scalars, 'delta_thl_PBL, ..., delta_tr_PBL(mt)'
         !og since they are identical even in the new cold pool formula.
         !og Below is used only for the fully energy-consistent formula.
         if( i_energy_coldpool .eq. 2 ) then
             delta_w_PBL = sqrt( 2._r8 ) * ( g / thv_ref ) * b1 * pblhz**2._r8 * &
                           del_wk0 * awk_PBL * max( 0._r8, delta_thv_PBL ) 
             delta_w_PBL = delta_w_PBL**(1._r8/3._r8) * sqrt( awk_PBL ) / &
                           max( nonzero, ( 1._r8 - awk_PBL )**(1._r8/6._r8) )             
         endif
         !og
         !og

         delta_w_PBL              = min( 10._r8, delta_w_PBL )
         if( awk_PBL .lt. 1.e-3_r8 ) delta_w_PBL = 0._r8
      endif
      if( delta_thv_PBL .lt. 0._r8 .or. awk_PBL .lt. 0._r8 .or. awk_PBL .gt. awk_PBL_max ) then
         write(6,*)
         write(6,*) 'UNICON : Unreasonable wake properties after inhomogeneity adjustment'
         write(6,*) 'delta_thv_PBL, awk_PBL = ', delta_thv_PBL, awk_PBL 
         call endrun('STOP : UNICON')  
         write(6,*)
      endif

      ! --------------------------------------------------------------------------------------------------------- !
      ! Sep.11.2011. Insert a condition preventing negative thl, qt , tracers both within wake and non-wake areas !
      !              after wake-inhomogeneity adjustment.                                                         !
      ! Aug.03.2012. I may need to below limiters in association with the use of internally computed              !
      !              cdelta_s and cdelta_w.                                                                       ! 
      ! Oct.04.2014. Consider 'tmp1 = 1/cdelta_s' too.                                                            !
      !              Also remove the limiter for 'delta_thl_PBL' since it is highly likely that it does not       !
      !              happens but takes computation time.                                                          ! 
      ! --------------------------------------------------------------------------------------------------------- !
             
      tmp1 = au_base_min_ocn * cadj_area_ocn + ( au_base_min_lnd * cadj_area_lnd - au_base_min_ocn * cadj_area_ocn ) * landfrac 

!lim  delta_thl_PBL = min( max(-tmp1 * thl0min_PBL, delta_thl_PBL ), thl0min_PBL * awk_PBL / ( 1._r8 - awk_PBL ) ) 
      delta_qt_PBL  = min( max( tmp1 * ( qmin(1) - qt0min_PBL ), delta_qt_PBL ), & 
                              ( qt0min_PBL - qmin(1) ) * awk_PBL / ( 1._r8 - awk_PBL ) )
      do mt = 1, ncnst    
         delta_tr_PBL(mt) = min( max( tmp1 * ( qmin(mt) - tr0min_PBL(mt) ), delta_tr_PBL(mt) ), & 
                                    ( tr0min_PBL(mt) - qmin(mt) ) * awk_PBL / ( 1._r8 - awk_PBL ) )
      enddo
      ! Nov.28.2012. For consistent treatment in the mixing with organized detrained airs with condensate later, 
      !              simply assume below two lines.
      delta_tr_PBL(ixnumliq) = 0._r8
      delta_tr_PBL(ixnumice) = 0._r8

!lim4 I removed below 4 limiters because it seems to be too strict without any physical reason.

      delta_thl_PBL = max( - 2.0_r8, min( 2.0_r8, delta_thl_PBL ) )
      delta_qt_PBL  = max( - 0.2_r8*qt0min_PBL, min( 0.2_r8*qt0min_PBL, delta_qt_PBL ) )
      delta_u_PBL   = max( - 2.0_r8, min( 2.0_r8 , delta_u_PBL ) )
      delta_v_PBL   = max( - 2.0_r8, min( 2.0_r8 , delta_v_PBL ) )

    ! Mar.04.2015. In order to stabilize the system, remove the perturbations of momentum and tracers.
    !              That is, only consider the perturbations of 'thl,qt'.

      delta_u_PBL   = 0._r8
      delta_v_PBL   = 0._r8
      do mt = 1, ncnst    
         delta_tr_PBL(mt) = 0._r8
      enddo

    ! Mar.04.2015. End of stabilization.

!lim  Replace the above limiter as below.
!lim  Practically, only need to worry about tracer, and I should take into account of the effect of 'cdelta_s'.
!lim  Note that below 'tmp1 = 1 / cdelta_s' ( I should double check this ).

!lim  delta_qt_PBL = min( max( tmp1 * ( qmin(1) - qt0PBL ), delta_qt_PBL ), & 
!lim                    ( qt0PBL - qmin(1) ) * awk_PBL / ( 1._r8 - awk_PBL ) )
!lim  do mt = 1, ncnst    
!lim     delta_tr_PBL(mt) = min( max( tmp1 * ( qmin(mt) - tr0PBL(mt) ), delta_tr_PBL(mt) ), & 
!lim                           ( tr0PBL(mt) - qmin(mt) ) * awk_PBL / ( 1._r8 - awk_PBL ) )
!lim  enddo
!lim  ! Nov.28.2012. For consistent treatment in the mixing with organized detrained airs with condensate later, 
!lim  !              simply assume below two lines.
!lim  delta_tr_PBL(ixnumliq) = 0._r8
!lim  delta_tr_PBL(ixnumice) = 0._r8

!lim
!lim
!lim

      ! -------------------------------------------------------------------------------------------------------------------- !
      ! Sep.16.2011. Define effective 'eps_wk_eff, del_wk_eff' to allow the initial development of wake                      ! 
      !              from zero area by effectively reduce too large detrainment dilution effect of thermodynamic             !
      !              scalars, 'del_wk / awk_PBL * ( 1._r8 - awk_PBL) )' due to 'zero awk_PBL' at the beginning.              !
      !              This can be done in a fully consistent way as follows.                                                  !
      !               (1) Define 'awk_PBL_eff = max( awk_PBL, awk_PBL_min )' where 'awk_PBL_min' is user-specified           !
      !                   value, such as 0.01, 0.05 or 0.1 etc. enough to allow initial development of strong wake           !
      !                   but still supressing weak wake.                                                                    ! 
      !               (2) Define 'eps_wk_eff' and 'del_wk_eff' as follows and use them in all the codes instead of           !
      !                   using 'eps_wk' and 'del_wk'.                                                                       !
      !                       tmp1 = ( awk_PBL * ( 1. - awk_PBL ) ) / ( awk_PBL_eff * ( 1. - awk_PBL_eff ) )                 ! 
      !                       eps_wk_eff = tmp1 * eps_wk                                                                     !
      !                       del_wk_eff = tmp1 * del_wk                                                                     !
      !                   Note that in the later code defining 'taui', we use the nonzero limiter                            !
      !                   of '1 / max( nonzero, awk_PBL * ( 1._r8 - awk_PBL ) )'. Thus, if we don't                          !
      !                   impose the same nonzero limiter on the above 'tmp1', our ' eps_wk_eff, del_wk_eff ' become         !
      !                   zero when the awk_PBL becomes very small ( < nonzero ).                                            !
      !                   This 'zero' values of 'eps_wk_eff, del_wk_eff' at the initial state of zero awk_PBL seems          ! 
      !                   to be perfectly OK and also guarantees                                                             ! 
      !                   (a) del_wk_eff / max( nonzero, ( awk_PBL * ( 1._r8 - awk_PBL) ) ) = 0                              !
      !                       eps_wk_eff / max( nonzero, ( awk_PBL * ( 1._r8 - awk_PBL) ) ) = 0                              ! 
      !                       at the beginning ( note these two formula are actually used in the code ),                     !
      !                   (b) prevent unexpected numerical round-off errors due to the 'multiplication' and 'division' of    !
      !                       the same extremely small number.                                                               !
      !                   Thus, let's use the above two-step strategy.                                                       !
      !                   As a whole, whole of these two procedures are simply equivalent to using 'eps_wk_eff,del_wk_eff'   !
      !                   instead of 'eps_wk,del_wk' both in the mass and scalar budget equations in a fully consistent way. !
      !               Note that this is also completely compatible with my computation of 'corrective detrainment ' : I      !
      !               don't need to modify anything except the above two.                                                    !  
      !               Note also that this mod is still fully allowing us to use different 'eps_wk,del_wk' values in the      !
      !               parameter sentences, which is really great because it fully keeps the generality of the model.         !
      !               Note also that if 'awk_PBL >= awk_PBL_min', it becomes 'eps_wk_eff = eps_wk, del_wk_eff = del_wk',     !
      !               indicating a fully consistent restoration to the original state, which is perfectly good.              !    
      ! -------------------------------------------------------------------------------------------------------------------- ! 

      awk_PBL_eff = max( awk_PBL, awk_PBL_min )
      tmp1        = ( awk_PBL * ( 1._r8 - awk_PBL ) ) / ( awk_PBL_eff * ( 1._r8 - awk_PBL_eff ) ) 
      eps_wk_eff  = tmp1 * eps_wk                                                           
      del_wk_eff  = tmp1 * del_wk

      !og
      !og   When the advanced cold pool formulation is used, use below formulat instead.
      if( i_energy_coldpool .eq. 1 .or. i_energy_coldpool .eq. 2 ) then
         eps_wk_eff  = eps_wk0 * awk_PBL                                                          
         del_wk_eff  = del_wk0 * awk_PBL
      endif
      !og
      !og
      ! ------------------------------------------------------------------------------------------------------------- !
      ! Compute convective organization parameter, 0 <= org_rad <= 1.                                                 ! 
      ! This  'org_rad' is used for computing updraft plume radius at surface                                         !
      ! Later 'org_ent' is defined for lateral mixing later as an option.                                             !
      ! The 'cuorg' can be computed in many different ways ( e.g., using convective precipitation flux at surface ).  !
      ! Here, I am using the ratio of 'downdraft mass flux' to 'updraft mass flux' at the previous time step because  !
      ! conceptually, strong downward motion is likely to generate meso-scale organized circulation near surface.     !
      ! ------------------------------------------------------------------------------------------------------------- !

      ! Jun.30.2011. Use diagnostically-computed organization parameter instead of default prognostic orginization.

      ! Aug.02.2011. For more flexibility, we can move below block for 'org_rad'-related part into 'do iter' loop,
      !              so that different 'org_rad' and related variables can be used for each 'iter'.
      !              However, current setting is conceptually reasonable enough.

      ! Feb.06.2013. As of today, always choose i_diagorg = 1 and remove this option.

!c    if( i_diagorg .eq. 1 ) then

      ! Aug.15.2011. cuorg is diagnosed using diagnostic TKE from the moist turbulence scheme and 
      !              prognostic TKE induced by convective downdraft.
      ! cuorg = tkePBLorg_old / max( nonzero, ( tkePBLorg_old + max( tkePBL, 0.1_r8 ) ) )
      ! cuorg = tkePBLorg_old / 1.5_r8
      ! Below if block is the old one.
      ! if( i_persrc .eq. 1 ) then
      !     cuorg = con_org_tke * tkePBLorg_old / max( tke1 + con_org_tke * tkePBLorg_old, nonzero ) 
      ! elseif( i_persrc .eq. 2 ) then
      !     cuorg = con_org_tke * tkePBLorg_old / max( tke1 + con_org_tke * tkePBLorg_old, nonzero ) 
      ! endif
      ! Aug.31.2011. Compute diagnostic cuorg using the prognostically-updated thv difference between off-wake and grid mean
      !              averaged over the whole PBL.
      ! cuorg = delta_thv_PBL / delta_thv_NORM 
      ! Sep.07.2011. As the most physically-reasonable choice, define 'cuorg = awk_PBL / awk_PBL_max' where
      !              awk_PBL_max = 1._r8 - au_max. Note that this awk_PBL should be the one after applying
      !              non-homogeneous distribution procedure on the various wake properties, which correponds to
      !              the use of large 'nseg'.
      !              awk_PBL_max is defined above.
      ! Sep.08.2011. By defining convective organization as an area concept, I can also include the organization
      !              associated with other process, such as (1) orographic effect, and (2) land-sea breeze effect.
      !              In this case, I should simply compute the 'wake-like prohibited fractional area' that convective
      !              updraft is not allowed to grow and add it to 'awk_PBL' below in the 'cuorg = awk_PBL / awk_PBL_max'.
      !              Thus, in a most geeral sense, 'awk_PBL' in the 'cuorg' formula can be understood as the
      !              the 'prohibited fractional area' for convective updraft. As this prohibited area increase, convective
      !              updraft is more organized.    
      ! Sep.09.2011. The most general definition of 'cuorg' should be
      !             'cuorg = ( 1._r8 - The fractional area that updraft can grow )       / ( 1._r8 - au_max ) =
      !                    = ( The fractional area that updraft in not allowed to grow ) / ( 1._r8 - au_max )' 
      !              By using this definition, we can easily include the (1) orographic effect, and (2) land-sea breeze effect
      !              by additionally adding the 'prohibited' area by these two (1) and (2) processes. 
      ! Sep.16.2011. Add 'a_oro' here.   

      a_forbid = a_oro + awk_PBL
      a_forbid = max( 0._r8, min( awk_PBL_max, a_forbid ) ) 
      cuorg    = a_forbid / awk_PBL_max
      cuorg    = max( 0._r8, min( 1._r8, cuorg ) )

!c    endif

      ! Dec.20.2012. Turn-off organization feedback.
      if( orgfeedback_off ) then
         cuorg = 0._r8
      endif

      ! org_rad = fac_org_rad * cu_cmfd(1) / max( nonzero, cu_cmfu(1) ) ! Original      
      ! org_rad = fac_org_rad * cmfd_old   / max( nonzero, cmfu_old )   ! New     
      org_rad = fac_org_rad * cuorg                                   ! Mar.11.2011. Most Advanced.     
      org_rad = max( 0._r8, min( 1._r8, org_rad ) )                   ! Force to be [0,1] after multiplication of fac_org_rad.

      ! Below is the original sign function 

      ! Ro     = Ro_min + ( Ro_max - Ro_min ) * 0.5_r8 * ( 1._r8 + sin( 3.141592_r8 * ( org_rad - 0.5_r8 ) ) )   
      ! sigmaR = sigmaR_min + ( sigmaR_max - sigmaR_min ) * 0.5_r8 * ( 1._r8 + sin( 3.141592_r8 * ( org_rad - 0.5_r8 ) ) )   

      ! Below is the alternative linear function similar to org_ent. Mar.11.2011. 
      ! May.09.2011. I added 'kw' and 'au_base' as an organization-dependent function.
      ! May.21.2011. In order to minimize BOMEX L80 effect, use the original sine function
      !              instead of linear function.
      ! May.21.2011. But it turns out that it does not help, but instead, the source of sensitivity to vertical resolution
      !              turns out to be due to 'rlc = -1.'.
      !              So, I can use either the original linear function or more-refined sign function. 
      !              Since 'convective organization' is defined as the probability for the convective updraft to rise into 
      !              the specific horizontal plot, it is perfectly conceptually OK to use either the original linear 
      !              function or more-refined smooth sign function. Let's use the more smooth sign function.  
      !              Note that sign function has a continuous gradient as well as the value itself. 

      ! Ro      = Ro_min      + org_rad * ( Ro_max - Ro_min )
      ! sigmaR  = sigmaR_min  + org_rad * ( sigmaR_max - sigmaR_min )
      ! kw      = kw_min      + org_rad * ( kw_max - kw_min )      
      ! au_base = au_base_min + org_rad * ( au_base_max - au_base_min )

      ! Option.1. Linear line.
      ! tmp1    = org_rad
      ! Option.2. Continuous sinusoidal organization line.
      ! Aug.15.2011. Below sine function seems to be more appropriate to suppress the effect of very small
      !              organization for shallow cumulus case, BOMEX, for example.
      !              However, in order to increase organization effect over land, it may be good to use a linear 
      !              function. So, let's use a linear function.
      ! Apr.18.2012. In order to further retard the maximum timing of diurnal cycle of precipitation, it may be
      !              to use exponential function below. In addition, it may help to maintain cloud deck in the
      !              trade-cumulus regime over the ocean. So, I am using sine function on this day.
      ! tmp1    = 0.5_r8 * ( 1._r8 + sin( 3.141592_r8 * ( org_rad - 0.5_r8 ) ) )
      ! Option.3. Square-Root Line.
      ! Jan.08.2013. In order to reduce too strong SWCF over the west of Panama, it might be bettter to use 
      !              a square function that increases rapidly in the small regime of organization.  
      !              This will provide an additional flexibility to use a larger value of criqc, e.g., 7.e-4 to
      !              maintain cloud deck over the trade cumulus regime. I should watch over whether below choice
      !              does not degrade diurnal cycle of precipitation over summer continent. In order not to
      !              degrade diurnal cycle, I may need to use larger criqc, which is consistent with the above argument
      !              associated with maintaining stratocumulus over the trade cumulus.   
      ! tmp1    = sqrt( org_rad )
      ! Jan.09.2013. Add the most general option with the parameter 0 < orp.
      ! Apr.01.2013. Also include the treatment of 'sinusoidal' function when orp = -1.
      if( orp .ge. 0._r8 ) then
         tmp1 = org_rad**orp
      else
         tmp1 = 0.5_r8 * ( 1._r8 + sin( 3.141592_r8 * ( org_rad - 0.5_r8 ) ) )
      endif

      ! Aug.15.2011. For 'Ro_min,Ro_max,sigmaR_min,sigmaR_max', different values were assigned over the ocean and land.
      !              Thus, compute area-weighting averages of these values. Note that 'ice' surface is treated in the 
      !              same way as the 'ocean' fraction. I checked that the sum of 'ocnfrac,icefrac,landfrac' is exactly
      !              1 for all cases.
      !              We can do the similar separate treatments for 'kw' and 'au_base' over land and ocn-ice in future
      !              if necessary. 
      ! Aug.31.2011. From the geometric point of view of wake parameterization, it is more reasonable to reduce 'au_base_max'
      !              instead of reducing 'kw_max' when cuorg is developed. 
      !              Reducing 'kw_max' compared to 'kw_min' does not make any physical sence. 
      !              In addition, reduction of 'kw_max' will increase 'sigme_thl(qt.u.v)' which is
      !              likely to be unreasonable double counting since by introducing 'delta_thv(qt,u,v,w,tr)_PBL', we already obtained the
      !              desirable change of conservative scalars at surface. Thus, we must set kw_max = kw_min. 
      ! Sep.07.2011. From the geometric point of view, it might be reasonable to assume 'au_base = au_base_min * ( 1._r8 - awk_PBL )'.
      !              Since cuorg = awk_PBL / awk_PBL_max, this corresponds to 'au_base = au_base_min * ( 1._r8 - awk_PBL_max * cuorg )'
      !              which is roughly similar to the below line. 
      !              Alternatively, in order to be fully compatible with the organization concept, we should set au_base_min = au_base_max.
      !              I should think more about this in connection with future generalization of cuorg by including (1) orographic effect,
      !              and (2) land-sea breeze effect. 
      ! Jun.13.2012. Include land-ocean average of cdelta_s and cdelta_w.
      ! Dec.19.2012. Note that below averaging treatment only using 'landfrac' as a weighting factor implies that
      !              we treat 'ice portion (icefrac)' as a part of 'ocn portion'.

      ! write(6,*)
      ! write(6,*) 'UNICON : ocnfrac + icefrac + landfrac'
      ! write(6,*) 'ocnfrac + icefrac + landfrac = ', ocnfrac + icefrac + landfrac
      ! write(6,*) 

      ! ------------------------------------------------------------------------------- !
      ! Compute Land-Ocean Avarage Parameters                                           ! 
      ! ------------------------------------------------------------------------------- !

      ! if( microcu .eq. 0 ) then
      !     criqc           = criqc_ocn + ( criqc_lnd - criqc_ocn ) * landfrac
      ! elseif( microcu .eq. 1 ) then
      !     criqc           = criqc_ocn + ( criqc_lnd - criqc_ocn ) * landfrac
      ! endif

      criqc               = criqc_ocn        + ( criqc_lnd        -        criqc_ocn ) * landfrac
      c0_ac_z             = c0_ac_ocn        + ( c0_ac_lnd        -        c0_ac_ocn ) * landfrac
      kevp_rain           = kevp_rain_ocn    + ( kevp_rain_lnd    -    kevp_rain_ocn ) * landfrac
      kevp_snow           = kevp_snow_ocn    + ( kevp_snow_lnd    -    kevp_snow_ocn ) * landfrac
      kevp_rain_dn        = kevp_rain_dn_ocn + ( kevp_rain_dn_lnd - kevp_rain_dn_ocn ) * landfrac
      kevp_snow_dn        = kevp_snow_dn_ocn + ( kevp_snow_dn_lnd - kevp_snow_dn_ocn ) * landfrac
      droprad_liq         = droprad_liq_ocn  + ( droprad_liq_lnd  -  droprad_liq_ocn ) * landfrac
      droprad_ice         = droprad_ice_ocn  + ( droprad_ice_lnd  -  droprad_ice_ocn ) * landfrac
      droprad_rain        = droprad_rain_ocn + ( droprad_rain_lnd - droprad_rain_ocn ) * landfrac
      droprad_snow        = droprad_snow_ocn + ( droprad_snow_lnd - droprad_snow_ocn ) * landfrac

      ! Aug.03.2012. Assuming organization-related perturbation is confined only in the 'au_base' at surface,
      !              I compute 'cdelta_s,cdelta_w' as 'cdelta_s = ( 1._r8 - awk_PBL ) / max( nonzero, au_base )'
      !              and 'cdelta_w = sqrt( cdelta_s )' later below after computing 'au_base' instead of 
      !              specifying as the parameters.
      !              This new method is the most perfect and physically reasonable computation.
      !              This new way allows me to use a reasonably small 'kstar'.
      ! Dec.19.2012. As of today, 'cdelta_s_ocn, cdelta_s_lnd' are internally compute further below without using the 
      !              specififed values. Thus, I commented out below line for 'cdelta_s'.                                                     
      ! cdelta_s            = cdelta_s_ocn     + ( cdelta_s_lnd     -     cdelta_s_ocn ) * landfrac
      !! cdelta_w            = cdelta_w_ocn     + ( cdelta_w_lnd     -     cdelta_w_ocn ) * landfrac

      tmp2 = au_base_max_lnd
      if( iau_base_lnd .eq. 1 ) then
         tmp2 = au_base_min_lnd * ( 1._r8 - awk_PBL_max )
      endif
      tmp3 = au_base_max_ocn
      if( iau_base_ocn .eq. 1 ) then
         tmp3 = au_base_min_ocn * ( 1._r8 - awk_PBL_max )
      endif

      au_base_min = au_base_min_ocn + ( au_base_min_lnd - au_base_min_ocn ) * landfrac
      au_base_max = tmp3            + ( tmp2            -            tmp3 ) * landfrac
      Ro_min      = Ro_min_ocn      + ( Ro_min_lnd      -      Ro_min_ocn ) * landfrac
      Ro_max      = Ro_max_ocn      + ( Ro_max_lnd      -      Ro_max_ocn ) * landfrac
      sigmaR_min  = sigmaR_min_ocn  + ( sigmaR_min_lnd  -  sigmaR_min_ocn ) * landfrac
      sigmaR_max  = sigmaR_max_ocn  + ( sigmaR_max_lnd  -  sigmaR_max_ocn ) * landfrac
      kw_min      = kw_min_ocn      + ( kw_min_lnd      -      kw_min_ocn ) * landfrac
      kw_max      = kw_max_ocn      + ( kw_max_lnd      -      kw_max_ocn ) * landfrac

      Ro_ocn      = Ro_min_ocn      + ( Ro_max_ocn      -      Ro_min_ocn ) * tmp1
      Ro_lnd      = Ro_min_lnd      + ( Ro_max_lnd      -      Ro_min_lnd ) * tmp1
      sigmaR_ocn  = sigmaR_min_ocn  + ( sigmaR_max_ocn  -  sigmaR_min_ocn ) * tmp1
      sigmaR_lnd  = sigmaR_min_lnd  + ( sigmaR_max_lnd  -  sigmaR_min_lnd ) * tmp1
    
      Ro          = Ro_min          + ( Ro_max          -          Ro_min ) * tmp1
      sigmaR      = sigmaR_min      + ( sigmaR_max      -      sigmaR_min ) * tmp1
      kw          = kw_min          + ( kw_max          -          kw_min ) * tmp1

      ! Apr.18.2012. Since 'kw' is an anisotropic factor of non-organized turbulence, this is not likely to be a function
      !              of organization. Thus, in the parameter sentence, I always set kw_min = kw_max, so that
      !              below ramping function actually does not do anything.
      ! May.17.2012. Now 'kw' is separately computed as above. Below line for 'kw' is commented out on this day.
      ! kw          = kw_min          + ( kw_max          -          kw_min ) * tmp1
      ! au_base     = au_base_min     + ( au_base_max     -     au_base_min ) * tmp1
      ! Apr.18.2012. We can let 'au_base' to be always a linear function of organization as below
      !              instead of above choice of 'tmp1'. This may provide more flexibility to
      !              set 'Ro,sigmaR' as an sign function of organization, which may help to
      !              keep cloud deck in the Sc-to-Cu transition regime. Note that this 
      !              In order to be consistent with the probability-related explanation of organization
      !              associated with Eqn.(97), I should set this a linear function always.
      !              Thus, let's set this to be always linear function instead of using above
      !              as a function of 'tmp1'.
      ! Dec.19.2012. Add the computation of 'au_base_ocn' and 'au_base_lnd' for later use below.
      !              By construction, 'au_base = au_base_ocn + ( au_base_lnd - au_base_ocn ) * landfrac' is automatically satisfied.

      au_base     = au_base_min     + ( au_base_max     -     au_base_min     ) * org_rad
      au_base_ocn = au_base_min_ocn + ( tmp3            -     au_base_min_ocn ) * org_rad
      au_base_lnd = au_base_min_lnd + ( tmp2            -     au_base_min_lnd ) * org_rad

      ! Aug.03.2012. Assuming organization-related perturbation is confined only in the 'au_base' at surface,
      !              I compute 'cdelta_s,cdelta_w' as 'cdelta_s = ( 1._r8 - awk_PBL ) / max( nonzero, au_base )'
      !              and 'cdelta_w = sqrt( cdelta_s )' later below after computing 'au_base' instead of 
      !              specifying as the parameters.
      !              This new method is the most perfect and physically reasonable computation.
      !              This new way allows me to use a reasonably small 'kstar'.
      !              Note that below computation eventually leads to 'cdelta_s = 1 / au_base_min'
      !              which is an independent function of 'awk_PBL'. 
      !              This is perfectly conceptually reasonable. 
      !              Note also that if 'au_base_min' is set to be large (small), 'cdelta_s,cdelta_w'
      !              becomes small (large), so that the increase of updraft mass flux at surface as organization increases
      !              is self-constrained instead of being amplified, which is also a very good stablizing properties.     
      !              This internal computation of 'cdelta_s,cdelta_w' solves lots of conceptual problems in addition to
      !              allowing me to use a physically-reasonable smaller values of 'kstar'.
      ! Dec.12.2012. If 'cdelta_s' is internally computed using 'cdelta_s = ( 1._r8 - awk_PBL ) / max( nonzero, AOVTU )' where
      !              the 'AOVTU < 1._r8 - awk_PBL' is the portion of 'a_U = 1._r8 - awk_PBL' where perturbations different grid-mean
      !              values are concentrated and convective overtuning occurs. For 'AOVTU', there are 4 different choices:
      !                  (1) AOVTU = a_U ( i.e., cdelta_s = 1, this produces bad diurnal cycle )
      !                  (2) AOVTU = au_max ( fixed value of 0.1 )
      !                  (3) AOVTU = au_base_min ( the value when org = 0, this is less physical choice )
      !                  (4) AOVTU = au_base ( the value decreasing as org increases )
      !              where for all the cases, it should be 'cdelta_w = sqrt( cdelta_s )'. Since (1) produced bad diurnal cycle 
      !              over land, we should consider only (2)-(4) options.
      !              Note that we are using 'au_base = au_base_min + ( au_base_max - au_base_min ) * org_rad' 
      !              where 'au_base_max = au_base_min * ( 1._r8 - awk_PBL_max )' and 'awk_PBL_max = 1._r8 - au_max'.
      !              Thus, eventually, 
      !                    'au_base = au_base_min * ( 1 - awk_PBL_max * org )'.
      !              Thus, when org = 1, au_base is reduced to 10% of au_base_min (non-organized value) if au_max = 0.1.
      !              This reduction of area fraction as a function of 'org' is determined independent of the choice of 'AOVTU',
      !              i.e., AOVTU only controls the magnitude of perturbations of conservative scalars (i.e., qt) and vertical velocity (w)
      !              within au_base. Since AOVTU controls w, AOVTU also controls updraft mass flux.
      !              Now, (a) cdelta_s = ( 1._r8 - awk_PBL ) / max( nonzero, AOVTU ),
      !                   (b) awk_PBL = org * awk_PBL_max ( neglect a_oro )
      !              and so 'cdelta_s = ( 1 - org * awk_PBL_max ) / max( nonzero, AOVTU ).
      !              If we choose (4) au_base = au_base_min * ( 1 - awk_PBL_max * org ), then
      !              this becomes 'cdelta_s = 1 / au_base_min = 1/0.05 = 20', which seems to be very large. 
      !              It seems to be more reasonable to assume that 'AOVTU = au_max = 0.1', so that
      !                   '1 ( when org = 1 ) <= cdelta_s = ( 1._r8 - awk_PBL ) / au_max <= 10 ( when org = 0 )'
      !              This choice increases perturbations more in the less-organized state than in the more-organized state.
      !              This general assumption of restricting perturbations only in a certain portion of 'a_U' rather than over
      !              the entire 'a_U' is perfectly consistent with general conceptual and observational understanding of the
      !              cold pool and wake phenomena too. In fact, specifying 'cdelta_s' as an external constant is equivalent to using
      !              the above (4) options.
      !              Thus, in a final summary, there are two possible choices for choosing 'cdelta_s' :
      !                 (1) cdelta_s = 'externally specified as an constant' which is equivalent to 
      !                                 using AOVTU = cc * au_base, so that 
      !                                'cdelta_s = 1 / ( cadj_area * au_base_min ) = 20 / cadj_area (au_base_min = 0.05) or 10 / cadj_area (au_base_min = 0.1)'.
      !                 (2) 1 ( when org = 1 ) <= cdelta_s = ( 1._r8 - awk_PBL ) / max( nonzero, au_max ) <= 10 ( when org = 0 ).
      !              where above (1) is equivalent to assuming that 'the area where anomalous perturbation with respect to the grid-mean and 
      !              convective overturning circulation occurs within a_U is a multiple ('cadj_area') fraction of au_base, 'AOVTU = cadj_area * au_base',
      !              while above (2) assume that this area is fixed by 'AOVTU = au_max' regardless of the organization. 
      !              Both approaches seem to be reasonable.  
      !              However, the (2) choice enhances perturbations more in the less-organized state than in the more organized state,
      !              while (1) enhances perturbations equally in the organized and non-organized states. 
      !              Considering that the peryphery of wake cells increases as org increases, it seems to be more reasonable to
      !              use (2) rather than (1), although none of two choices are perfect.
      ! Dec.19.2012. I checked that above (1) produces better diurnal cycle than (2). Thus, it is good to choose (1).
      !              Specifying 'cdelta_s = 4' when 'au_base_min = 0.05'  is equivalent to set cadj_area = 5 if a_oro = 0.
      !              Similarly, 'cdelta_s = 8' when 'au_base_min = 0.025' is equivalent to set cadj_area = 5 if a_oro = 0.
      !              If a_oro = 0, then 
      !                'cdelta_s = ( 1._r8 - awk_PBL ) / max( nonzero, au_base * cadj_area ) = 1 / ( au_base_min * cadj_area )'. (***)
      !              As a result, for conceptual clearness, it is much transparent to use the above formula with the 
      !              bounded constraints on 'cadj_area' such that 
      !                                '1 <= cadj_area <= 1 / au_base_min' 
      !              where the left lower limit comes
      !              from the argument that convective overtuning upward portion area should be larger than updraft fractional area (au_base),
      !              so that entire 'au_base' will get the organization-related perturbation. The right upper limit comes from the argument
      !              that 'cadj_area * au_base' should be smaller than 'a_U = 1._r8 - awk_PBL' (we can derive this relationship).
      !              If 'cadj_area = 1 / au_base_min', overturning upward portion exists in the entire a_U, leading to previous original formula.
      !              Note that conceptually and physically, this is the most attractable choice.
      !              We can potentially define separate 'cadj_area_lnd' and 'cadj_area_ocn', but for simplicity, let's keep it as a single value
      !              for the time being.
      ! Dec.19.2012. I added complete separate treatment over land and ocean in computing AOVTU below.
      !              Below treatment of averaging is completely correct.
      !              I found that the use of 'cdelta_s' in the !TEST produces slightly different results from the default one
      !              below probably due to truncation error. But it is not a problem at all, so that we can go ahead.  
      ! Jan.18.2012. I added an option to internally compute 'cadj_area_ocn' instead of specifying it as a parameter.
      !              I derived that this option is fully conceptual reasonable roughly similar to assuming that number density of wake is
      !              proportional to the number density of convective updraft plume. 
      !              Note that still it should be satisfied that '1 <= cadj_area_ocn <= 1 / au_base_min_ocn = 10 ( when au .. = 0.1 ) ~ 25 ( when au .. = 0.04 )'
      !              which is almost always guaranteed as long as 'cadj_area_lnd < 5'. For reasonable simulation of diurnal cycle over land with the use
      !              of reasonable kevp = 1.e-5, I should use cadj_area_lnd < 3. Thus, this is almost always guaranteed.
      !              Note that I used a median plume radius at alpha = 1 in computing cadj_area_ocn, which is completely reasonable.
      !              Below internal computation implies that not only the difference in 'au_base_min' but also the difference in the median plume radius
      !              between the land and the ocean is contributing the difference of the cadj_area, which is roughly derived from the assumption that
      !              number density of the wake is proportional to the number density of convective updraft plumes at surface. 
      !              Note that below treatment of the approximation of the exac treatment of AOVTV = sqrt( awk_PBL(org) * au_base(org) ) / R(org)',
      !              designed to easily impose the lower and upper limit on cadj_area. However this approximation roughly mimics the excat functional
      !              form both in terms of the dependency on 'org' and on 'land-sea' difference of cadj_area.  

      ! AOVTU = au_max
      ! AOVTU = au_base * cadj_area
      ! Jan.18.2013. Added for internal computation of cadj_area_ocn. 
      !              If cadj_area_ocn is specified as a parameter, I should comment out below line.
      !              Note that in general, 'cadj_area_ocn (org) >= cadj_area_ocn (org)'.
      !              Note also that while 'cadj_area_lnd' is specified as a constant, the ratio of 'cadj_area_ocn/cadj_area_lnd'
      !              is computed as a function of org because the difference in the median plume radius matters over the ocean and the land. 
      ! cadj_area_ocn = cadj_area_lnd * ( Ro_lnd + sigmaR_lnd ) / ( Ro_ocn + sigmaR_ocn )
      AOVTU = au_base_ocn * cadj_area_ocn + ( au_base_lnd * cadj_area_lnd - au_base_ocn * cadj_area_ocn ) * landfrac 
      cdelta_s = ( 1._r8 - awk_PBL ) / max( nonzero, AOVTU )
      ! TEST
      ! cdelta_s = cdelta_s_ocn + ( cdelta_s_lnd - cdelta_s_ocn ) * landfrac
      ! TEST
      cdelta_s = max( 1._r8, min( cdelta_s, 100._r8 ) ) 

      ! Dec.20.2012. Turn-off organization feedback.
      if( orgfeedback_off ) then
         cdelta_s = 0._r8
      endif

      cdelta_w = sqrt( cdelta_s ) 

      !og When advanced cold pool formula is used, I should re-define 'cdelta_w' in the below block.
      !og Note that I don't need to newly define 'cdelta_s', since it is identical even in this new
      !og cold pool formula.
      !og Below is used only for the fully energy-consistent formula
      if( i_energy_coldpool .eq. 2 ) then
         cdelta_w = sqrt( cdelta_s ) / max( nonzero, ( AOVTU + awk_PBL )**(1._r8/6._r8) )   
      endif
      !og

      ! cdelta_w = 1._r8

      ! CHECK
      ! write(6,*)
      ! write(6,*) 'UNICON : cdelta_s, cdelta_w, 1/au_base_min'
      ! write(6,*)  cdelta_s, cdelta_w, 1._r8/au_base_min
      ! write(6,*)
      ! CHECK

      ! if( iau_base .eq. 1 ) then
      !     au_base = au_base_min * ( 1._r8 - cuorg * awk_PBL_max )
      ! endif

      ! Impose a upper and lower limits for safety.
      ! 1.May.2011. Below two lines are redundant since above guarantees below already.
      !             So, I commented out below two lines. 

      ! Ro     = max( Ro_min, min( Ro_max, Ro ) )
      ! sigmaR = max( sigmaR_min, min( sigmaR_max, sigmaR ) )

      ! CHECK
      ! write(6,*) 'UNICON : org_rad and intercept plume radius at surface'
      ! write(6,*)  org_rad, Ro
      ! CHECK
     
      ! Sep.28.2011. Below block is moved from the above into here after computing au_base.
      !              This is exactly the right location of this block. 
      ! UNRESOLVED : I SHOULD CAREFULLY THINK WHETHER I SHOULD MULTIPLY 2 TO 'I_cri' OR NOT
      !              AS INDICATED IN THE COMMENTED-OUT LINE.
      !              It seems that current one WITHOUT multiplied by 2 is correct and is also
      !              consistent with the 'if( icudist_tail .eq. 0 ) Pau(m) = 2._r8 * au_base * Pau(m)' later.
      ! RESOLVED : Since surface flux associated with convection is discretely and consistently computed below 
      !            later both for icudist_tail = 0 or 1, current code will not use 'I_cri' in any part of the code.
      !            Thus this problem is completely solved.  
      ! May.17.2012. If I chose 'alpha_max = 2' instead of '3', below case of au_base = 0.01 with
      !              alpha_cri = 2.3265_r8 will not work. I should consider this and carefully
      !              choose 'alpha_max' when I choose 'icudist_tail = 1'.
      !              However, there is no limitation in choosing 'alpha_max' if I chose icudist_tail = 0
      !              as usual.

      if( icudist_tail .eq. 1 ) then
         if( au_base .eq. 0.01_r8 ) then
            alpha_cri = 2.3265_r8
            I_cri     = 0.0720_r8
         elseif( au_base .eq. 0.05_r8 ) then
            alpha_cri = 1.6450_r8
            I_cri     = 0.2196_r8  
         elseif( au_base .eq. 0.06_r8 ) then
            alpha_cri = 1.5547_r8
            I_cri     = 0.2452_r8
         elseif( au_base .eq. 0.07_r8 ) then
            alpha_cri = 1.4758_r8
            I_cri     = 0.2681_r8
         elseif( au_base .eq. 0.08_r8 ) then
            alpha_cri = 1.4051_r8
            I_cri     = 0.2889_r8
         elseif( au_base .eq. 0.09_r8 ) then
            alpha_cri = 1.3408_r8
            I_cri     = 0.3077_r8
         elseif( au_base .eq. 0.10_r8 ) then
            alpha_cri = 1.2815_r8
            I_cri     = 0.3249_r8 
         elseif( au_base .eq. 0.20_r8 ) then
            alpha_cri = 0.8416_r8
            I_cri     = 0.4356_r8
         elseif( au_base .eq. 0.30_r8 ) then
            alpha_cri = 0.5244_r8
            I_cri     = 0.4823_r8
         elseif( au_base .eq. 0.40_r8 ) then
            alpha_cri = 0.2534_r8
            I_cri     = 0.4979_r8
         elseif( au_base .eq. 0.50_r8 ) then
            alpha_cri = 0._r8
            I_cri     = 0.5_r8 
         endif
      else       
         alpha_cri = 0._r8  
         I_cri     = au_base
      endif
      ! I_cri = 2._r8 * I_cri

      ! --------------------------------------------- !
      !                                               !
      ! Main computation of cumulus updraft evolution !
      !                                               !
      ! --------------------------------------------- !

      do iter = 1, niter

         ! ------------------------------------------------------------------------------------------- !
         ! Aug.01.2011. Brian Juwon Park's Birthday. This 'do iter' routine can be used for explicit   !
         !              mixing of convective updraft and downdraft with different mixing environmental !
         !              airs because vertical evolution of convective updraft and downdraft is highly  !
         !              non-linear to the properties of mixing environmental airs. Thus, the simple    !
         !              use of mean environmental airs for mixing is not ideal. This explicit mixing   !
         !              process will inevitably increase computation time but seems to be important.   !
         !                 (1) iter = 1 : mixing with mean environmental airs at the current time step !
         !                                ( with the probability of '1._r8 - cuorg' )                  ! 
         !                 (2) iter = 2 : mixing with detrained + cumulus updraft airs at the previous !
         !                                time step ( with the probability of 'cuorg' )                !
         !              Note that this 'cuorg_mxen' is used only for 'org_ent', neither 'org_rad' nor  !
         !             'org_src' since 'cuorg_mxen' is designed to choose mixing environmental airs.   ! 
         ! ------------------------------------------------------------------------------------------- !

         ! Aug.12.2011. Specify different plume radius for '1-cuorg' and 'cuorg' portion.
         ! Aug.13.2011. Conceptually, it is more reasonable to assume a uniform source air properties
         !              across the grid since (1) organization is defined all over the grid, (2) 
         !              Cathy's formulation can be more correctly implemented, and (3) we can reduce
         !              computation time in future. Thus, I commented out below two lines for 
         !              defining Ro and sigmaR.

         if( niter .eq. 1 ) then
            cuorg_mxen = cuorg
         else
            if( iter .eq. 1 ) then 
               cuorg_mxen = 0._r8
               ! Ro         = 100._r8
               ! sigmaR     = 0._r8 
            elseif( iter .eq. 2 ) then   
               cuorg_mxen = 1._r8
               ! Ro         = 1000._r8
               ! sigmaR     = 0._r8 
            endif
         endif

         ! ------------------------------------------------------------------------------------------------------- !
         !                                                                                                         !                
         ! Iteration for treating accretion should start here.                                                     ! 
         !                                                                                                         !
         ! The variables used for the next accretion iteration computations within 'subroutine prod_prep_up' are   !
         !                                                                                                         !
         !  1. flxrain_msfc(k,msfc), flxsnow_msfc(k,msfc)                                                          !
         !  2. a_p_msfc(k,msfc)                                                                                    ! 
         !  3. am_us_msfc(k,msfc)                                                                                  !
         !  4. am_pu_msfc(k,msfc)                                                                                  ! 
         !                                                                                                         !
         ! all of which will be computed before the end of accretion iteration loop.                               ! 
         !                                                                                                         !
         ! ------------------------------------------------------------------------------------------------------- !

         do iacc = 1, nacc

            if( iacc .eq. 1 ) then

               ! -------------------------------------------------------------------------------------- !
               ! Initialize below variables only at the first iteration, since at the second iteration, !
               ! non-zero values will be used for accretion.                                            ! 
               ! -------------------------------------------------------------------------------------- !

               flxrain_msfc(0:mkx,:nseg)                = 0._r8
               flxsnow_msfc(0:mkx,:nseg)                = 0._r8
               flxtrrs_msfc(0:mkx,:nseg,:ncnst)         = 0._r8

               a_p_msfc(0:mkx,:nseg)                    = 0._r8

               am_u_msfc(:mkx,:nseg)                    = 0._r8 
               am_up_msfc(:mkx,:nseg)                   = 0._r8 
               am_us_msfc(:mkx,:nseg)                   = 0._r8 

               am_evp_msfc(:mkx,:nseg)                  = 0._r8 
               am_pu_msfc(:mkx,:nseg)                   = 0._r8
               am_pd_msfc(:mkx,:nseg)                   = 0._r8
               am_pr_msfc(:mkx,:nseg)                   = 0._r8
               am_ps_msfc(:mkx,:nseg)                   = 0._r8

            endif

            ! --------------------------------------------------- !
            !                                                     !                
            !                                                     ! 
            ! Iteration for treating accretion should start here. ! 
            !                                                     !
            !                                                     !
            ! --------------------------------------------------- !

            ! --------------------------------------------------------------------------- !
            ! Initialization of ensemble-mean arrays in each layer inside the 'iter' loop !
            ! --------------------------------------------------------------------------- !

            ! if( iter .eq. 1 ) then
            !   ! cmf_u_mix_org(:mkx)                  = 0._r8
            !   ! cmf_r_org(:mkx)                      = 0._r8 
            !   ! thl_r_org(:mkx)                      = 0._r8
            !   ! qt_r_org(:mkx)                       = 0._r8
            !   ! u_r_org(:mkx)                        = 0._r8
            !   ! v_r_org(:mkx)                        = 0._r8 
            !   ! ql_r_org(:mkx)                       = 0._r8 
            !   ! qi_r_org(:mkx)                       = 0._r8 
            !   ! tr_r_org(:mkx,:ncnst)                = 0._r8
            !   ! eta1_a(:mkx)                         = 0._r8
            !   ! eta2_a(:mkx)                         = 0._r8
            ! endif

            flxrain(0:mkx)                           = 0._r8
            flxsnow(0:mkx)                           = 0._r8
            flxtrrs(0:mkx,:ncnst)                    = 0._r8

            !i    flxrain_msfc(0:mkx,:nseg)                = 0._r8
            !i    flxsnow_msfc(0:mkx,:nseg)                = 0._r8
            !i    flxtrrs_msfc(0:mkx,:nseg,:ncnst)         = 0._r8

            !? flxrain_prevp(0:mkx)                     = 0._r8
            !? flxsnow_prevp(0:mkx)                     = 0._r8
            !? flxtrrs_prevp(0:mkx,:ncnst)              = 0._r8
            
            !? flxrain_prevp_msfc(0:mkx,:nseg)          = 0._r8
            !? flxsnow_prevp_msfc(0:mkx,:nseg)          = 0._r8
            !? flxtrrs_prevp_msfc(0:mkx,:nseg,:ncnst)   = 0._r8

            !? flxrain_ava(0:mkx)                       = 0._r8
            !? flxsnow_ava(0:mkx)                       = 0._r8
            !? flxtrrs_ava(0:mkx,:ncnst)                = 0._r8

            !? flxrain_ava_msfc(0:mkx,:nseg)            = 0._r8
            !? flxsnow_ava_msfc(0:mkx,:nseg)            = 0._r8
            !? flxtrrs_ava_msfc(0:mkx,:nseg,:ncnst)     = 0._r8
            
            !? flxrain_aftdn(0:mkx)                     = 0._r8
            !? flxsnow_aftdn(0:mkx)                     = 0._r8
            !? flxtrrs_aftdn(0:mkx,:ncnst)              = 0._r8

            cmf_u_mix(:mkx)                          = 0._r8
            cmf_r(:mkx)                              = 0._r8 
            thl_r(:mkx)                              = 0._r8
            qt_r(:mkx)                               = 0._r8
            u_r(:mkx)                                = 0._r8
            v_r(:mkx)                                = 0._r8
            ql_r(:mkx)                               = 0._r8
            qi_r(:mkx)                               = 0._r8
            tr_r(:mkx,:ncnst)                        = 0._r8

            cmf_r2(:mkx)                             = 0._r8 
            thl_r2(:mkx)                             = 0._r8
            qt_r2(:mkx)                              = 0._r8
            u_r2(:mkx)                               = 0._r8
            v_r2(:mkx)                               = 0._r8
            ql_r2(:mkx)                              = 0._r8
            qi_r2(:mkx)                              = 0._r8
            tr_r2(:mkx,:ncnst)                       = 0._r8

            thl_u(0:mkx)                             = 0._r8
            qt_u(0:mkx)                              = 0._r8
            u_u(0:mkx)                               = 0._r8
            v_u(0:mkx)                               = 0._r8
            cmf_u(0:mkx)                             = 0._r8
            w_u(0:mkx)                               = 0._r8
            wa_u(0:mkx)                              = 0._r8
            a_u(0:mkx)                               = 0._r8
            num_u(0:mkx)                             = 0._r8
            rad_u(0:mkx)                             = 0._r8  
            gamw_u(0:mkx)                            = 0._r8
            ql_u(0:mkx)                              = 0._r8   
            qi_u(0:mkx)                              = 0._r8   
            tr_u(0:mkx,:ncnst)                       = 0._r8   
            qla_u(0:mkx)                             = 0._r8   
            qia_u(0:mkx)                             = 0._r8   
            thva_u(0:mkx)                            = 0._r8   
            
            cmf_u_dia(:mkx)                          = 0._r8
            evp_thll_u(:mkx)                         = 0._r8
            evp_qtl_u(:mkx)                          = 0._r8
            evp_thli_u(:mkx)                         = 0._r8
            evp_qti_u(:mkx)                          = 0._r8
            prep_thll_u(:mkx)                        = 0._r8
            prep_qtl_u(:mkx)                         = 0._r8
            prep_thli_u(:mkx)                        = 0._r8
            prep_qti_u(:mkx)                         = 0._r8
            eff_ql_u(:mkx)                           = 0._r8
            eff_qi_u(:mkx)                           = 0._r8
            PGF_u_u(:mkx)                            = 0._r8
            PGF_v_u(:mkx)                            = 0._r8
            evp_tr_u(:mkx,:ncnst)                    = 0._r8
            prep_tr_u(:mkx,:ncnst)                   = 0._r8
            !     wdep_tr_u(:mkx,:ncnst)                   = 0._r8
            eff_tr_u(:mkx,:ncnst)                    = 0._r8

            thl_srcd(:mkx)                           = 0._r8
            qt_srcd(:mkx)                            = 0._r8
            u_srcd(:mkx)                             = 0._r8
            v_srcd(:mkx)                             = 0._r8
            tr_srcd(:mkx,:ncnst)                     = 0._r8
            f_srcd(:mkx)                             = 0._r8
            ql_srcd(:mkx)                            = 0._r8
            qi_srcd(:mkx)                            = 0._r8

            thl_srcds(:mkx,:nseg,1:3)                = 0._r8
            qt_srcds(:mkx,:nseg,1:3)                 = 0._r8
            u_srcds(:mkx,:nseg,1:3)                  = 0._r8
            v_srcds(:mkx,:nseg,1:3)                  = 0._r8
            tr_srcds(:mkx,:nseg,1:3,:ncnst)          = 0._r8
            f_srcds(:mkx,:nseg,1:3)                  = 0._r8
            ql_srcds(:mkx,:nseg,1:3)                 = 0._r8
            qi_srcds(:mkx,:nseg,1:3)                 = 0._r8

            thl_srcr(:mkx)                           = 0._r8
            qt_srcr(:mkx)                            = 0._r8
            u_srcr(:mkx)                             = 0._r8
            v_srcr(:mkx)                             = 0._r8
            tr_srcr(:mkx,:ncnst)                     = 0._r8
            f_srcr(:mkx)                             = 0._r8
            ql_srcr(:mkx)                            = 0._r8
            qi_srcr(:mkx)                            = 0._r8

            thl_srcr2(:mkx)                          = 0._r8
            qt_srcr2(:mkx)                           = 0._r8
            u_srcr2(:mkx)                            = 0._r8
            v_srcr2(:mkx)                            = 0._r8
            tr_srcr2(:mkx,:ncnst)                    = 0._r8
            f_srcr2(:mkx)                            = 0._r8
            ql_srcr2(:mkx)                           = 0._r8
            qi_srcr2(:mkx)                           = 0._r8

            thl_srcrs(:mkx,:nseg,1:3)                = 0._r8
            qt_srcrs(:mkx,:nseg,1:3)                 = 0._r8
            u_srcrs(:mkx,:nseg,1:3)                  = 0._r8
            v_srcrs(:mkx,:nseg,1:3)                  = 0._r8
            tr_srcrs(:mkx,:nseg,1:3,:ncnst)          = 0._r8
            f_srcrs(:mkx,:nseg,1:3)                  = 0._r8
            ql_srcrs(:mkx,:nseg,1:3)                 = 0._r8
            qi_srcrs(:mkx,:nseg,1:3)                 = 0._r8

            thl_srcrs2(:mkx,:nseg,1:3)               = 0._r8
            qt_srcrs2(:mkx,:nseg,1:3)                = 0._r8
            u_srcrs2(:mkx,:nseg,1:3)                 = 0._r8
            v_srcrs2(:mkx,:nseg,1:3)                 = 0._r8
            tr_srcrs2(:mkx,:nseg,1:3,:ncnst)         = 0._r8
            f_srcrs2(:mkx,:nseg,1:3)                 = 0._r8
            ql_srcrs2(:mkx,:nseg,1:3)                = 0._r8
            qi_srcrs2(:mkx,:nseg,1:3)                = 0._r8

            kdtd(:mkx,:nseg,1:3)                     = 0

            cmf_ru(:mkx)                             = 0._r8 
            thl_ru(:mkx)                             = 0._r8
            qt_ru(:mkx)                              = 0._r8
            u_ru(:mkx)                               = 0._r8
            v_ru(:mkx)                               = 0._r8
            ql_ru(:mkx)                              = 0._r8
            qi_ru(:mkx)                              = 0._r8
            tr_ru(:mkx,:ncnst)                       = 0._r8

            cmf_ru2(:mkx)                            = 0._r8 
            thl_ru2(:mkx)                            = 0._r8
            qt_ru2(:mkx)                             = 0._r8
            u_ru2(:mkx)                              = 0._r8
            v_ru2(:mkx)                              = 0._r8
            ql_ru2(:mkx)                             = 0._r8
            qi_ru2(:mkx)                             = 0._r8
            tr_ru2(:mkx,:ncnst)                      = 0._r8

            cmf_ad(0:mkx,:mkx,1:nseg,1:3)            = 0._r8
            thl_ad(0:mkx,:mkx,1:nseg,1:3)            = 0._r8
            qt_ad(0:mkx,:mkx,1:nseg,1:3)             = 0._r8
            u_ad(0:mkx,:mkx,1:nseg,1:3)              = 0._r8
            v_ad(0:mkx,:mkx,1:nseg,1:3)              = 0._r8
            w_ad(0:mkx,:mkx,1:nseg,1:3)              = 0._r8
            a_ad(0:mkx,:mkx,1:nseg,1:3)              = 0._r8
            ql_ad(0:mkx,:mkx,1:nseg,1:3)             = 0._r8
            qi_ad(0:mkx,:mkx,1:nseg,1:3)             = 0._r8
            tr_ad(0:mkx,:mkx,1:nseg,1:3,:ncnst)      = 0._r8

            dpad(:mkx,:mkx,1:nseg,1:3)               = 0._r8

            cmf_ar(:mkx,:mkx,1:nseg,1:3)             = 0._r8
            thl_ar(:mkx,:mkx,1:nseg,1:3)             = 0._r8
            qt_ar(:mkx,:mkx,1:nseg,1:3)              = 0._r8
            u_ar(:mkx,:mkx,1:nseg,1:3)               = 0._r8
            v_ar(:mkx,:mkx,1:nseg,1:3)               = 0._r8
            tr_ar(:mkx,:mkx,1:nseg,1:3,:ncnst)       = 0._r8
            ql_ar(:mkx,:mkx,1:nseg,1:3)              = 0._r8
            qi_ar(:mkx,:mkx,1:nseg,1:3)              = 0._r8

            cmf_ad_dia(:mkx,:mkx,1:nseg,1:3)         = 0._r8
            evp_thll_ad(:mkx,:mkx,1:nseg,1:3)        = 0._r8
            evp_qtl_ad(:mkx,:mkx,1:nseg,1:3)         = 0._r8
            evp_thli_ad(:mkx,:mkx,1:nseg,1:3)        = 0._r8
            evp_qti_ad(:mkx,:mkx,1:nseg,1:3)         = 0._r8
            prep_thll_ad(:mkx,:mkx,1:nseg,1:3)       = 0._r8
            prep_qtl_ad(:mkx,:mkx,1:nseg,1:3)        = 0._r8
            prep_thli_ad(:mkx,:mkx,1:nseg,1:3)       = 0._r8
            prep_qti_ad(:mkx,:mkx,1:nseg,1:3)        = 0._r8
            eff_ql_ad(:mkx,:mkx,1:nseg,1:3)          = 0._r8
            eff_qi_ad(:mkx,:mkx,1:nseg,1:3)          = 0._r8
            PGF_u_ad(:mkx,:mkx,1:nseg,1:3)           = 0._r8
            PGF_v_ad(:mkx,:mkx,1:nseg,1:3)           = 0._r8
            evp_tr_ad(:mkx,:mkx,1:nseg,1:3,:ncnst)   = 0._r8
            prep_tr_ad(:mkx,:mkx,1:nseg,1:3,:ncnst)  = 0._r8
            wdep_tr_ad(:mkx,:mkx,1:nseg,1:3,:ncnst)  = 0._r8
            eff_tr_ad(:mkx,:mkx,1:nseg,1:3,:ncnst)   = 0._r8

            cmf_d(0:mkx)                             = 0._r8
            thl_d(0:mkx)                             = 0._r8
            qt_d(0:mkx)                              = 0._r8
            u_d(0:mkx)                               = 0._r8
            v_d(0:mkx)                               = 0._r8
            w_d(0:mkx)                               = 0._r8
            a_d(0:mkx)                               = 0._r8
            wa_d(0:mkx)                              = 0._r8
            ql_d(0:mkx)                              = 0._r8   
            qi_d(0:mkx)                              = 0._r8   
            tr_d(0:mkx,:ncnst)                       = 0._r8   
            qla_d(0:mkx)                             = 0._r8   
            qia_d(0:mkx)                             = 0._r8   

            !d    cmf_d_org(0:mkx)                         = 0._r8
            !d    thl_d_org(0:mkx)                         = 0._r8
            !d    qt_d_org(0:mkx)                          = 0._r8

            cmf_d_dia(:mkx)                          = 0._r8
            evp_thll_d(:mkx)                         = 0._r8
            evp_qtl_d(:mkx)                          = 0._r8
            evp_thli_d(:mkx)                         = 0._r8
            evp_qti_d(:mkx)                          = 0._r8
            prep_thll_d(:mkx)                        = 0._r8
            prep_qtl_d(:mkx)                         = 0._r8
            prep_thli_d(:mkx)                        = 0._r8
            prep_qti_d(:mkx)                         = 0._r8
            eff_ql_d(:mkx)                           = 0._r8
            eff_qi_d(:mkx)                           = 0._r8
            PGF_u_d(:mkx)                            = 0._r8
            PGF_v_d(:mkx)                            = 0._r8
            evp_tr_d(:mkx,:ncnst)                    = 0._r8
            prep_tr_d(:mkx,:ncnst)                   = 0._r8
            !     wdep_tr_d(:mkx,:ncnst)                   = 0._r8
            eff_tr_d(:mkx,:ncnst)                    = 0._r8

            cmf_rd(:mkx)                             = 0._r8
            thl_rd(:mkx)                             = 0._r8
            qt_rd(:mkx)                              = 0._r8
            u_rd(:mkx)                               = 0._r8
            v_rd(:mkx)                               = 0._r8
            ql_rd(:mkx)                              = 0._r8
            qi_rd(:mkx)                              = 0._r8
            tr_rd(:mkx,:ncnst)                       = 0._r8

            qlten_sub(:mkx)                          = 0._r8
            qiten_sub(:mkx)                          = 0._r8

            rqc_l(:mkx)                              = 0._r8
            rqc_i(:mkx)                              = 0._r8
            rqc(:mkx)                                = 0._r8
            rnc_l(:mkx)                              = 0._r8
            rnc_i(:mkx)                              = 0._r8

            cmf_det(:mkx)                            = 0._r8
            ql_det(:mkx)                             = 0._r8
            qi_det(:mkx)                             = 0._r8

            qlten_det(:mkx)                          = 0._r8 
            qiten_det(:mkx)                          = 0._r8 

            !i    am_u_msfc(:mkx,:nseg)                    = 0._r8
            am_d_msfc(:mkx,:nseg)                    = 0._r8
            
            am_u(:mkx)                               = 0._r8
            am_d(:mkx)                               = 0._r8
            am_e(:mkx)                               = 0._r8

            qlm_u_msfc(:mkx,:nseg)                   = 0._r8
            qim_u_msfc(:mkx,:nseg)                   = 0._r8
            thlm_u_msfc(:mkx,:nseg)                  = 0._r8
            qtm_u_msfc(:mkx,:nseg)                   = 0._r8
            um_u_msfc(:mkx,:nseg)                    = 0._r8
            vm_u_msfc(:mkx,:nseg)                    = 0._r8
            trm_u_msfc(:mkx,:nseg,:ncnst)            = 0._r8

            qlm_u(:mkx)                              = 0._r8
            qim_u(:mkx)                              = 0._r8
            thlm_u(:mkx)                             = 0._r8
            qtm_u(:mkx)                              = 0._r8
            um_u(:mkx)                               = 0._r8
            vm_u(:mkx)                               = 0._r8
            trm_u(:mkx,:ncnst)                       = 0._r8

            qlm_d_msfc(:mkx,:nseg)                   = 0._r8
            qim_d_msfc(:mkx,:nseg)                   = 0._r8

            qlm_d(:mkx)                              = 0._r8
            qim_d(:mkx)                              = 0._r8

            am_s(:mkx)                               = 0._r8
            am_r(:mkx)                               = 0._r8
            am_up(:mkx)                              = 0._r8
            am_us(:mkx)                              = 0._r8

!i    am_up_msfc(:mkx,:nseg)                   = 0._r8
!i    am_us_msfc(:mkx,:nseg)                   = 0._r8

            a_p(0:mkx)                               = 0._r8
!i    a_p_msfc(0:mkx,:nseg)                    = 0._r8

!i    am_evp_msfc(:mkx,:nseg)                  = 0._r8 
!i    am_pu_msfc(:mkx,:nseg)                   = 0._r8
!i    am_pd_msfc(:mkx,:nseg)                   = 0._r8
!i    am_pr_msfc(:mkx,:nseg)                   = 0._r8
!i    am_ps_msfc(:mkx,:nseg)                   = 0._r8

            am_evp(:mkx)                             = 0._r8 
            am_pu(:mkx)                              = 0._r8
            am_pd(:mkx)                              = 0._r8
            am_pr(:mkx)                              = 0._r8
            am_ps(:mkx)                              = 0._r8

!?    a_p_prevp(0:mkx)                         = 0._r8
!?    a_p_prevp_msfc(0:mkx,:nseg)              = 0._r8

            thl_u_msfc(0:mkx,:nseg)                  = 0._r8
            qt_u_msfc(0:mkx,:nseg)                   = 0._r8
            u_u_msfc(0:mkx,:nseg)                    = 0._r8
            v_u_msfc(0:mkx,:nseg)                    = 0._r8
            w_u_msfc(0:mkx,:nseg)                    = 0._r8
            ql_u_msfc(0:mkx,:nseg)                   = 0._r8
            qi_u_msfc(0:mkx,:nseg)                   = 0._r8
            tr_u_msfc(0:mkx,:nseg,:ncnst)            = 0._r8
            cmf_u_msfc(0:mkx,:nseg)                  = 0._r8
            a_u_msfc(0:mkx,:nseg)                    = 0._r8
            num_u_msfc(0:mkx,:nseg)                  = 0._r8 
            rad_u_msfc(0:mkx,:nseg)                  = 0._r8

            eps0_u_msfc(0:mkx,:nseg)                 = 0._r8
            eps_u_msfc(0:mkx,:nseg)                  = 0._r8
            del_u_msfc(0:mkx,:nseg)                  = 0._r8
            eeps_u_msfc(0:mkx,:nseg)                 = 0._r8
            ddel_u_msfc(0:mkx,:nseg)                 = 0._r8
            xc_u_msfc(0:mkx,:nseg)                   = 0._r8
            xs_u_msfc(0:mkx,:nseg)                   = 0._r8
            xemin_u_msfc(0:mkx,:nseg)                = 0._r8
            xemax_u_msfc(0:mkx,:nseg)                = 0._r8
            cridis_u_msfc(0:mkx,:nseg)               = 0._r8
            thvcuenv_u_msfc(0:mkx,:nseg)             = 0._r8
            thvegenv_u_msfc(0:mkx,:nseg)             = 0._r8
            thvxsenv_u_msfc(0:mkx,:nseg)             = 0._r8
            fmix_u_msfc(0:mkx,:nseg)                 = 0._r8
            cmfumix_u_msfc(0:mkx,:nseg)              = 0._r8

            x_um_msfc(:mkx,:nseg)                    = 0._r8 
            y_um_msfc(:mkx,:nseg)                    = 0._r8
            x_p_msfc(0:mkx,:nseg)                    = 0._r8
            y_p_msfc(0:mkx,:nseg)                    = 0._r8

            thl_d_msfc(0:mkx,:nseg)                  = 0._r8
            qt_d_msfc(0:mkx,:nseg)                   = 0._r8
            u_d_msfc(0:mkx,:nseg)                    = 0._r8
            v_d_msfc(0:mkx,:nseg)                    = 0._r8
            w_d_msfc(0:mkx,:nseg)                    = 0._r8
            ql_d_msfc(0:mkx,:nseg)                   = 0._r8
            qi_d_msfc(0:mkx,:nseg)                   = 0._r8
            tr_d_msfc(0:mkx,:nseg,:ncnst)            = 0._r8
            wa_d_msfc(0:mkx,:nseg)                   = 0._r8
            qla_d_msfc(0:mkx,:nseg)                  = 0._r8
            qia_d_msfc(0:mkx,:nseg)                  = 0._r8
            cmf_d_msfc(0:mkx,:nseg)                  = 0._r8
            a_d_msfc(0:mkx,:nseg)                    = 0._r8

            slflx_u(0:mkx)                           = 0._r8
            qtflx_u(0:mkx)                           = 0._r8
            uflx_u(0:mkx)                            = 0._r8
            vflx_u(0:mkx)                            = 0._r8
            qlflx_u(0:mkx)                           = 0._r8
            qiflx_u(0:mkx)                           = 0._r8
            trflx_u(0:mkx,:ncnst)                    = 0._r8

            slten_u(:mkx)                            = 0._r8
            qtten_u(:mkx)                            = 0._r8
            uten_u(:mkx)                             = 0._r8
            vten_u(:mkx)                             = 0._r8
            sten_u(:mkx)                             = 0._r8
            qvten_u(:mkx)                            = 0._r8
            qlten_u(:mkx)                            = 0._r8
            qiten_u(:mkx)                            = 0._r8
            trten_u(:mkx,:ncnst)                     = 0._r8

            slflx_d(0:mkx)                           = 0._r8
            qtflx_d(0:mkx)                           = 0._r8
            uflx_d(0:mkx)                            = 0._r8
            vflx_d(0:mkx)                            = 0._r8
            qlflx_d(0:mkx)                           = 0._r8
            qiflx_d(0:mkx)                           = 0._r8
            trflx_d(0:mkx,:ncnst)                    = 0._r8

            !d    slflx_d_org(0:mkx)                       = 0._r8
            !d    qtflx_d_org(0:mkx)                       = 0._r8

            slten_d(:mkx)                            = 0._r8
            qtten_d(:mkx)                            = 0._r8
            uten_d(:mkx)                             = 0._r8
            vten_d(:mkx)                             = 0._r8
            sten_d(:mkx)                             = 0._r8
            qvten_d(:mkx)                            = 0._r8
            qlten_d(:mkx)                            = 0._r8
            qiten_d(:mkx)                            = 0._r8
            trten_d(:mkx,:ncnst)                     = 0._r8

            slten_evp(:mkx)                          = 0._r8
            qtten_evp(:mkx)                          = 0._r8
            uten_evp(:mkx)                           = 0._r8
            vten_evp(:mkx)                           = 0._r8
            sten_evp(:mkx)                           = 0._r8
            qvten_evp(:mkx)                          = 0._r8
            qlten_evp(:mkx)                          = 0._r8
            qiten_evp(:mkx)                          = 0._r8
            trten_evp(:mkx,:ncnst)                   = 0._r8
            trten_wdep(:mkx,:ncnst)                  = 0._r8

            ! Mar.27.2012. Below initialization of '_dis' variables are moved outside of 'do iter = 1, niter'
            !              loop. Also, 'uflx,vflx' variables are correspondingly moved.
            
            ! slten_dis(:mkx)                          = 0._r8
            ! qtten_dis(:mkx)                          = 0._r8
            ! uten_dis(:mkx)                           = 0._r8
            ! vten_dis(:mkx)                           = 0._r8
            ! sten_dis(:mkx)                           = 0._r8
            ! qvten_dis(:mkx)                          = 0._r8
            ! qlten_dis(:mkx)                          = 0._r8
            ! qiten_dis(:mkx)                          = 0._r8
            ! trten_dis(:mkx,:ncnst)                   = 0._r8

            ! uflx(0:mkx)                              = 0._r8
            ! vflx(0:mkx)                              = 0._r8

            qrten(:mkx)                              = 0._r8
            qsten(:mkx)                              = 0._r8
            trrsten(:mkx,:ncnst)                     = 0._r8

            qrten_msfc(:mkx,:nseg)                   = 0._r8
            qsten_msfc(:mkx,:nseg)                   = 0._r8
            trrsten_msfc(:mkx,:nseg,:ncnst)          = 0._r8

            evapc(:mkx)                              = 0._r8
            evapc_msfc(:mkx,:nseg)                   = 0._r8

            qrten_u(:mkx)                            = 0._r8
            qsten_u(:mkx)                            = 0._r8
            trrsten_u(:mkx,:ncnst)                   = 0._r8

            qrten_u_msfc(:mkx,:nseg)                 = 0._r8
            qsten_u_msfc(:mkx,:nseg)                 = 0._r8
            trrsten_u_msfc(:mkx,:nseg,:ncnst)        = 0._r8

            qrten_d(:mkx)                            = 0._r8
            qsten_d(:mkx)                            = 0._r8
            trrsten_d(:mkx,:ncnst)                   = 0._r8

            qrten_d_msfc(:mkx,:nseg)                 = 0._r8
            qsten_d_msfc(:mkx,:nseg)                 = 0._r8
            trrsten_d_msfc(:mkx,:nseg,:ncnst)        = 0._r8

            snowmlt_e(:mkx)                          = 0._r8
            snowmlt_e_msfc(:mkx,:nseg)               = 0._r8
            smlttrrs_e_msfc(:mkx,:nseg,:ncnst)       = 0._r8

            !?    snowmlt(:mkx)                            = 0._r8
            !?    snowmlt_msfc(:mkx,:nseg)                 = 0._r8

            thlten_dia_u(:mkx)                       = 0._r8       
            thlten_dia_d(:mkx)                       = 0._r8

            qtten_dia_u(:mkx)                        = 0._r8        
            qtten_dia_d(:mkx)                        = 0._r8

            qlten_dia_u(:mkx)                        = 0._r8        
            qlten_dia_d(:mkx)                        = 0._r8

            qiten_dia_u(:mkx)                        = 0._r8        
            qiten_dia_d(:mkx)                        = 0._r8

            trten_dia_u(:mkx,:ncnst)                 = 0._r8
            trten_dia_d(:mkx,:ncnst)                 = 0._r8

            ntraprd(:mkx)                            = 0._r8
            ntsnprd(:mkx)                            = 0._r8
            nttrrsprd(:mkx,:ncnst)                   = 0._r8

            ntraprd_msfc(:mkx,:nseg)                 = 0._r8
            ntsnprd_msfc(:mkx,:nseg)                 = 0._r8
            nttrrsprd_msfc(:mkx,:nseg,:ncnst)        = 0._r8

            evprain_e(:mkx)                          = 0._r8
            evpsnow_e(:mkx)                          = 0._r8
            evptrrs_e(:mkx,:ncnst)                   = 0._r8
            wdeptrrs_e(:mkx,:ncnst)                  = 0._r8

            evprain_d(:mkx)                          = 0._r8
            evpsnow_d(:mkx)                          = 0._r8
            evptrrs_d(:mkx,:ncnst)                   = 0._r8

            !?    evprain(:mkx)                            = 0._r8
            !?    evpsnow(:mkx)                            = 0._r8
            !?    evptrrs(:mkx,:ncnst)                     = 0._r8
            !?    wdeptrrs(:mkx,:ncnst)                    = 0._r8

            evprain_e_msfc(:mkx,:nseg)               = 0._r8
            evpsnow_e_msfc(:mkx,:nseg)               = 0._r8
            evptrrs_e_msfc(:mkx,:nseg,:ncnst)        = 0._r8
            wdeptrrs_e_msfc(:mkx,:nseg,:ncnst)       = 0._r8

            evprain_d_msfc(:mkx,:nseg)               = 0._r8
            evpsnow_d_msfc(:mkx,:nseg)               = 0._r8
            evptrrs_d_msfc(:mkx,:nseg,:ncnst)        = 0._r8

            !?    evprain_msfc(:mkx,:nseg)                 = 0._r8
            !?    evpsnow_msfc(:mkx,:nseg)                 = 0._r8
            !?    evptrrs_msfc(:mkx,:nseg,:ncnst)          = 0._r8
            !?    wdeptrrs_msfc(:mkx,:nseg,:ncnst)         = 0._r8

            cvp_rainprd(:mkx)                        = 0._r8
            cvp_snowprd(:mkx)                        = 0._r8
            cvp_trrsprd(:mkx,:ncnst)                 = 0._r8

            cvp_rainprd_msfc(:mkx,:nseg)             = 0._r8
            cvp_snowprd_msfc(:mkx,:nseg)             = 0._r8
            cvp_trrsprd_msfc(:mkx,:nseg,:ncnst)      = 0._r8

            !?    cvp_rainprd_d(:mkx)                      = 0._r8
            !?    cvp_snowprd_d(:mkx)                      = 0._r8
            !?    cvp_trrsprd_d(:mkx,:ncnst)               = 0._r8

            qlten_eff_u(:mkx)                        = 0._r8
            qiten_eff_u(:mkx)                        = 0._r8

            qlten_eff_d(:mkx)                        = 0._r8
            qiten_eff_d(:mkx)                        = 0._r8

            trten_eff_u(:mkx,:ncnst)                 = 0._r8
            trten_eff_d(:mkx,:ncnst)                 = 0._r8

            qlten_par(:mkx)                          = 0._r8
            qiten_par(:mkx)                          = 0._r8
            qtten_par(:mkx)                          = 0._r8
            slten_par(:mkx)                          = 0._r8
            uten_par(:mkx)                           = 0._r8
            vten_par(:mkx)                           = 0._r8
            trten_par(:mkx,:ncnst)                   = 0._r8

            uten_PGF(:mkx)                           = 0._r8
            vten_PGF(:mkx)                           = 0._r8

            ! Mar.27.2012. Below 'uf,vf' associated with dissipation heating are initialized outside of
            !              do iter = 1, niter loop. 
            ! uf(:mkx)                                 = 0._r8
            ! vf(:mkx)                                 = 0._r8

            !a    thl_env_ua(:mkx)                         = 0._r8   
            !a    qt_env_ua(:mkx)                          = 0._r8 
            !a    u_env_ua(:mkx)                           = 0._r8
            !a    v_env_ua(:mkx)                           = 0._r8
            ql_env_ua(:mkx)                          = 0._r8
            qi_env_ua(:mkx)                          = 0._r8

            !a    thl_env_da(:mkx)                         = 0._r8   
            !a    qt_env_da(:mkx)                          = 0._r8 
            !a    u_env_da(:mkx)                           = 0._r8
            !a    v_env_da(:mkx)                           = 0._r8
            ql_env_da(:mkx)                          = 0._r8
            qi_env_da(:mkx)                          = 0._r8

            sten_NUM(:mkx)                           = 0._r8
            slten_NUM(:mkx)                          = 0._r8
            qtten_NUM(:mkx)                          = 0._r8
            uten_NUM(:mkx)                           = 0._r8
            vten_NUM(:mkx)                           = 0._r8
            qvten_NUM(:mkx)                          = 0._r8
            qlten_NUM(:mkx)                          = 0._r8
            qiten_NUM(:mkx)                          = 0._r8
            trten_NUM(:mkx,:ncnst)                   = 0._r8

            !a    sten_CFL(:mkx)                           = 0._r8
            !a    slten_CFL(:mkx)                          = 0._r8
            !a    qtten_CFL(:mkx)                          = 0._r8
            !a    uten_CFL(:mkx)                           = 0._r8
            !a    vten_CFL(:mkx)                           = 0._r8
            !a    qvten_CFL(:mkx)                          = 0._r8
            !a    qlten_CFL(:mkx)                          = 0._r8
            !a    qiten_CFL(:mkx)                          = 0._r8

            !a    sten_EMC(:mkx)                           = 0._r8
            !a    slten_EMC(:mkx)                          = 0._r8
            !a    qtten_EMC(:mkx)                          = 0._r8
            !a    uten_EMC(:mkx)                           = 0._r8
            !a    vten_EMC(:mkx)                           = 0._r8
            !a    qvten_EMC(:mkx)                          = 0._r8
            !a    qlten_EMC(:mkx)                          = 0._r8
            !a    qiten_EMC(:mkx)                          = 0._r8
            
            !a    sten_ANA(:mkx)                           = 0._r8
            !a    slten_ANA(:mkx)                          = 0._r8
            !a    qtten_ANA(:mkx)                          = 0._r8
            !a    uten_ANA(:mkx)                           = 0._r8
            !a    vten_ANA(:mkx)                           = 0._r8
            !a    qvten_ANA(:mkx)                          = 0._r8
            !a    qlten_ANA(:mkx)                          = 0._r8
            !a    qiten_ANA(:mkx)                          = 0._r8

            qlten(:mkx)                              = 0._r8
            qiten(:mkx)                              = 0._r8
            qvten(:mkx)                              = 0._r8
            qtten(:mkx)                              = 0._r8
            slten(:mkx)                              = 0._r8
            sten(:mkx)                               = 0._r8
            uten(:mkx)                               = 0._r8
            vten(:mkx)                               = 0._r8
            trten(:mkx,:ncnst)                       = 0._r8

            N_up(0:mkx)                              = 0
            pes(:mkx)                                = 0._r8
            ptops(:mkx,:nseg)                        = 0._r8
            ztops(:mkx,:nseg)                        = 0._r8
            m_from_msfc(:mkx,:nseg)                  = 0 
            msfc_from_m(:mkx,:nseg)                  = 0      
            ktop_msfc(:nseg)                         = 0
            ptop_msfc(:nseg)                         = 0._r8
            ztop_msfc(:nseg)                         = 0._r8  

            thle_b(:mkx)                             = 0._r8
            thle_m(:mkx)                             = 0._r8
            thle_t(:mkx)                             = 0._r8
            qte_b(:mkx)                              = 0._r8
            qte_m(:mkx)                              = 0._r8
            qte_t(:mkx)                              = 0._r8 
            tre_b(:mkx,:ncnst)                       = 0._r8
            tre_m(:mkx,:ncnst)                       = 0._r8
            tre_t(:mkx,:ncnst)                       = 0._r8
            ue_b(:mkx)                               = 0._r8
            ue_m(:mkx)                               = 0._r8 
            ue_t(:mkx)                               = 0._r8
            ve_b(:mkx)                               = 0._r8
            ve_m(:mkx)                               = 0._r8
            ve_t(:mkx)                               = 0._r8
            we_b(:mkx)                               = 0._r8
            we_m(:mkx)                               = 0._r8
            we_t(:mkx)                               = 0._r8
            qle_b(:mkx)                              = 0._r8
            qle_m(:mkx)                              = 0._r8
            qle_t(:mkx)                              = 0._r8
            qie_b(:mkx)                              = 0._r8
            qie_m(:mkx)                              = 0._r8
            qie_t(:mkx)                              = 0._r8
            ssthle(:mkx)                             = 0._r8
            ssqte(:mkx)                              = 0._r8
            ssue(:mkx)                               = 0._r8 
            ssve(:mkx)                               = 0._r8
            ssqle(:mkx)                              = 0._r8
            ssqie(:mkx)                              = 0._r8
            sstre(:mkx,:ncnst)                       = 0._r8

            ! ---------------------------------------------------------------------------------------------------------------- !
            ! Nov.03.2012. REFINEMENT IS NECESSARY FOR TREATING ACCRETION OF CLOUD DROPLETS.                                   !
            !              The iteration loop for computing accretion of cloud droplet will start here.                        !
            !              However, correct initialization of several summed array variables may be necessary here again.      !
            !              I should be careful on this initialization.                                                         ! 
            ! ---------------------------------------------------------------------------------------------------------------- !

            ! --------------------------------------- !
            !                                         ! 
            ! Beginning of Updraft Computation Upward !
            !                                         ! 
            ! --------------------------------------- !

            do k = kiss + 1, mkx - 1    ! Here, 'k'  is a layer index.

               km = k - 1        ! Here, 'km' is a base interface index.

               ! ----------------------------------------- !
               ! Define environmental structure variables. ! 
               ! ----------------------------------------- !

               z_b         =      zs0(km)     
               z_m         =        z0(k)
               z_t         =       zs0(k)

               p_b         =      ps0(km)
               p_m         =        p0(k)
               p_t         =       ps0(k)

               dz_m        =       dz0(k)
               dp_m        =       dp0(k)
               
               exn_b       =    exns0(km)
               exn_m       =      exn0(k)
               exn_t       =     exns0(k)          

               thl_b       =   thl0bot(k)
               thl_m       =      thl0(k)
               thl_t       =   thl0top(k)         

               qt_b        =    qt0bot(k)
               qt_m        =       qt0(k)
               qt_t        =    qt0top(k)         

               u_b         =     u0bot(k)
               u_m         =        u0(k)
               u_t         =     u0top(k)         

               v_b         =     v0bot(k)
               v_m         =        v0(k)
               v_t         =     v0top(k)         

               ql_b        =    ql0bot(k)
               ql_m        =       ql0(k)
               ql_t        =    ql0top(k)         

               qi_b        =    qi0bot(k)
               qi_m        =       qi0(k)
               qi_t        =    qi0top(k)         

               thv_b       =   thv0bot(k)
               thv_t       =   thv0top(k)         

               thvl_b      =  thvl0bot(k)
               thvl_t      =  thvl0top(k)         

               rho_b       =   rho0bot(k)
               rho_m       =      rho0(k)
               rho_t       =   rho0top(k)         

               do mt = 1, ncnst
                  tr_b(mt) = tr0bot(k,mt)
                  tr_m(mt) =    tr0(k,mt)
                  tr_t(mt) = tr0top(k,mt)         
               enddo

               ! ------------------------------------------------------------ !
               ! Mar.06.2015. Change the unit of 'c0_ac' from [1/z] to [1/Pa] ! 
               ! ------------------------------------------------------------ !

               c0_ac = c0_ac_z / ( rho_m * g )

               ! ------------------------------------------------------------ !
               ! Mar.06.2015. Change the unit of 'c0_ac' from [1/z] to [1/Pa] ! 
               ! ------------------------------------------------------------ !

               if( k .gt. 1 ) then
                  ! ------------------------------------- !
                  ! Below is applied for mixing downdraft !
                  ! ------------------------------------- !
                  mu        = mu_mix
                  tmp1      = ( 1._r8 - mu ) * thvl0top(km) + mu * thvl_b
                  tmp2      = ( 1._r8 - mu ) * thv0top(km)  + mu * thv_b
                  thvl_minE = min( min( thvl_b, thvl_t ), tmp1 ) 
                  thv_minE  = min( min( thv_b,  thv_t  ), tmp2 ) 
                ! Apr.15.2014. Modified formula for thv_minE to obtain a reasonable solution when the mean inversion exists.
                  thv_minE  = max( thv0top(km), tmp2 ) 
                ! Apr.15.2014. Modified formula for thv_minE
                  thvl_minE = thvl_minE + offset_minE
                  thv_minE  = thv_minE  + offset_minE
                  ! ----------------- !
                  ! Diagnostic Output ! 
                  ! ----------------- !
                  thv_b_out(i,km)   = thv_b
                  thv_t_out(i,km)   = thv_t    
                  thv_mt_out(i,km)  = tmp2 
                  thv_min_out(i,km) = thv_minE    
                  ! ----------------- !
                  ! Diagnostic Output ! 
                  ! ----------------- !
               else
                  thvl_minE  = -1.e8_r8 ! Always detrain downdraft in the lowest model layer after all diabatic forcings
                  thv_minE   = -1.e8_r8 ! Always detrain downdraft in the lowest model layer after all diabatic forcings
               endif

               ! -------------------------------------------------------- !
               !                                                          !
               ! Closure Conditions at the first interface k = 0 or k = 1 !
               ! Use 'rho_b,thl_b,...' not 'rho_m,thl_m'.                 !
               !                                                          !
               ! -------------------------------------------------------- !

               if( k .eq. kiss + 1 ) then    ! Here, 'k' is a layer-index.

                  d_alpha   = ( alpha_max - alpha_cri ) / nseg
                  ! May.17.2012. When nseg = 1, locate alpha = 1, i.e., (1./0.242/2) =  where 0.242 is the hard-wired value of Pa(alpha=1).    
                  ! if( nseg .eq. 1 .and. icudist_tail .eq. 0 ) d_alpha = 2.0661_r8
                  ! Option. I can choose any velocity scale among 'tkes, tke1, tkePBL' and
                  !         'wstar1, wstarPBL'.
                  ! Sep.25.2010. It is important to impose an upper/lower limits on 'sigma_' especially,
                  !              due to unreasonable turbulent stress and too large sigma_u, sigma_v
                  !              which was the cause of model crash in the initial CAM5 simulation. 
                  !              Note that 'thl' and 'qt' of the outmost convective updraft in the distribution should be also 
                  !              positive, as included in the below limiters.
                  !              It is best ideal to use 'wstar2' with kw = 0.2. This use 'wstar2' will
                  !              automatically reduce convective activity in the stratocumulus-topped regime, such as DYCOMSrf01.   
                  ! Mar.11.2011. Now, 'sigma_w' is fully internally computed using 'tkes', 'taux', and 'tauy'. It turns out that
                  !              this only (+) sign is physically plausible since TKES should increase as surface buoyancy
                  !              flux increases. Theoretically maximum value of kw is 'sqrt(2)=1.4142' when there is no horizontal
                  !              perturbations. Theoretical minimum value of kw is zero. In neutral case, below formula
                  !              combined with UW PBL scheme produces kw = 1.4023 ( 0.1828 for (-) sign case which is physically
                  !              unreasonable )
                  ! Oct.17.2011. In order to improve the timing of diurnal cycle and to be conceptually more consistent ( at surface, 
                  !              surface wind shear always exists and so there must be background sigma_wo ), add intercept
                  !              background sigma_wo. Then, I don't need to separately specify minimum value of sigma_w. 
                  !              Note that in order to improve diurnal cycle, this use of 'sigma_wo' needs to be accompanied
                  !              by the small value of kw.   
                  ! Mar.12.2013. Use 'wstar' directly from UWMT, which is 'wstar within PBL' without including negative buoyancy flux at surface.
                  !              This input 'wstar' is already set to zero if PBL is STL. 
                  !              Since we impose a certain lower limit on 'sigma_w' later, this zero input 'wstar' for STL is not a problem at all.
                  !              This use of input 'wstar' is also consistent with the use of input 'went' (entrainment rate at the PBL top).
                  !              However, be careful that if TKE-based entrainment closure is used within UWMT, 'wstar' will be set to zero.
                  !              Thus, in that situation, I should use internally computed 'wstar2' instead of input 'wstar'.     
                  
                  ! Option.1. Specified kw 
                  ! sigma_w   =   sigma_wo + kw * wstar2
                  sigma_w   =   sigma_wo + min( kw,   1.4142_r8 ) * sqrt( tke1 )
                  ! sigma_w   =   sigma_wo + kw * wstar

                  ! Option.2. Computed kw
                  ! tmp1      =   sqrt( 1._r8 + sqrt( 1._r8 - ( taux**2._r8 + tauy**2._r8 ) / ( rho_b**2._r8 * tke1**2._r8 ) ) )
                  ! sigma_w   =   sigma_wo + min( tmp1, 1.4142_r8 ) * sqrt( tke1 )
                  ! Jun.29.2011. When choose my analytical formula of 'i_persrc = 1', I should use TKE averaged over PBL ( tkePBL )
                  !              not the surface TKE ( tke1 ) for consistency with the computation of downdraft and evaporation
                  !              induced TKE within PBL. 
                  ! if( i_persrc .eq. 1 ) then
                  !     sigma_w   = sigma_wo + min( kw,   1.4142_r8 ) * sqrt( tke1 )
                  ! elseif( i_persrc .eq. 2 ) then
                  !     sigma_w   = sigma_wo + min( kw,   1.4142_r8 ) * sqrt( tke1 )
                  ! elseif( i_persrc .eq. 3 ) then
                  !     sigma_w   = sigma_wo + min( kw,   1.4142_r8 ) * sqrt( tke1 )
                  ! endif             

                  ! CHECK
                  ! write(6,*)
                  ! write(6,*) 'UNICON'
                  ! write(6,*) 'Time step : ', get_nstep()
                  ! write(6,*) 'sqrt(tke0(0)), sigma_w, tmp1 = ', sqrt(tke0(0)), sigma_w, tmp1
                  ! write(6,*)
                  ! CHECK

                  ! March.02.2011. In order to simulate convection during night, minimum value of sigma_w is
                  ! relaxed from '1.e-3_r8' to 0.01.
                  ! May.21.2011. The minimum value of 'sigma_w' is relaxed from 0.01 to 0.1 to impose
                  !              stability.  
                  ! Jun.28.2011. The minimum value of 'sigma_w' before imposing convective organization is
                  !              raised to '0.2' from '0.1' in ordre to reduce the mangitude of negative 'sigma_qt'
                  !              in stable or night time, partly to improve the simulation of diurnal cycle of
                  !              convection.  
                  ! Oct.16.2011. Due to the use of 'sigma_wo', I don't need to separately specify minimum value
                  !              of sigma_w.
                  ! Nov.08.2011. In order to prevent model crash due to too large concentration of dust and sea-salt due to
                  !              surface flux proportional to the cube of surface wind speed (instead of linear ), set
                  !              sigma_tr(mt) = 0 for dust and sea-salt both in the accumulation and coarse mode.      
                  ! Aug.03.2012. I may need to use smaller value for the lower limit of sigma_w, i.e., 1.e-2 instead of
                  !              1.e-1. Note that in general, small TKE accompanies with small shflx and lhflx. Thus,
                  !              use of small limit for sigma_w does not project into the large value of sigma_qt.
                  !              In addition, I found that over the ocean (TOGAII), when kw = 0.3 is chosen, 
                  !              sigma_w almost always hits 1.e-1. Thus, I should use smaller limit for sigma_w.

                  ! sigma_w   =   max( 1.e-2_r8, min( 1.0_r8, sigma_w ) ) 
                  sigma_w   =   max( 1.e-1_r8, min( 1.0_r8, sigma_w ) ) 
                  ! sigma_w   =   max(    0._r8, min( 1.0_r8, sigma_w ) ) 
                  sigma_thl =   sigfac * shflx / ( rho_b * cp * exn_b * sigma_w )
                  sigma_qt  =   sigfac * qflx  / ( rho_b *              sigma_w )
                  sigma_u   =   sigfac * taux  / ( rho_b *              sigma_w )
                  sigma_v   =   sigfac * tauy  / ( rho_b *              sigma_w )
                  do mt = 1, ncnst
                     sigma_tr(mt) = sigfac * aflx(mt)  / ( rho_b * sigma_w )
                  enddo
#ifdef MODAL_AERO
                  sigma_tr(lptr_dust_a_amode(modeptr_coarse)) = 0._r8
                  sigma_tr(lptr_dust_a_amode(modeptr_accum))  = 0._r8
                  sigma_tr(lptr_nacl_a_amode(modeptr_coarse)) = 0._r8
                  sigma_tr(lptr_nacl_a_amode(modeptr_accum))  = 0._r8
                  ! Mar.27.2012. Added below line.
                  sigma_tr(lptr_nacl_a_amode(modeptr_aitken)) = 0._r8
#endif
                  
                  ! TEST for diurnal cycle
                  !  sigma_w   = 0.3_r8
                  !  sigma_thl = 0._r8
                  !  sigma_qt  = 0._r8
                  !  sigma_u   = 0._r8
                  !  sigma_v   = 0._r8
                  !  do mt = 1, ncnst
                  !     sigma_tr(mt) = 0._r8
                  !  enddo              
                  ! TEST

                  ! CHECK
                  ! write(6,*)
                  ! write(6,*) 'UNICON: sigma at the launching interface before adding organization perturbation'
                  ! write(6,*) 'Launching interface index : ', kiss
                  ! write(6,*) 'sigma_w   : ', sigma_w 
                  ! write(6,*) 'sigma_thl : ', sigma_thl
                  ! write(6,*) 'sigma_qt  : ', sigma_qt 
                  ! write(6,*) 'sigma_u   : ', sigma_u 
                  ! write(6,*) 'sigma_v   : ', sigma_v 
                  ! write(6,*)
                  ! CHECK

                  ! March.12.2011. Add additional perturbation on 'sigma_w, sigma_thl, sigma_qt' by convective organization.
                  !                This is necessary since given surface flux does not include the component of convective
                  !                organization. This is a critical procedure to obtain reasonable diurnal cycle of
                  !                convective precipitations. Do not change 'sigma_u,sigma_v,sigma_tr(mt)' since we don't 
                  !                know how to handle these. Note that enhanced 'sigma_w' also enhances updraft mass flux
                  !                at surface when org > 0. This is good.  
                  ! sigma_w   =   sigma_w   + csig_w   * org_rad * abs(sigma_w)
                  ! sigma_qt  =   sigma_qt  + csig_qt  * org_rad * abs(sigma_qt)
                  ! sigma_thl =   sigma_thl - csig_thl * org_rad * abs(sigma_thl)
                  ! May.21.2011. In order to reduce sensitivity for BOMEX L80 case, use the original sine function
                  !              similar to the other treatments above. 
                  ! May.21.2011. But it turns out that it does not help, but instead, the source of sensitivity to vertical resolution
                  !              turns out to be due to 'rlc = -1.'.
                  !              So, I can use either the original linear function or more-refined sign function. 
                  !              Since 'convective organization' is defined as the probability for the convective updraft to rise into 
                  !              the specific horizontal plot, it is perfectly conceptually OK to use either the original linear 
                  !              function or more-refined smooth sign function. Let's use the more smooth sign function.  
                  ! sigma_w   =   ( csig_w   * org_rad + 1._r8 ) * sigma_w
                  ! sigma_thl =   ( csig_thl * org_rad + 1._r8 ) * sigma_thl
                  ! sigma_qt  =   ( csig_qt  * org_rad + 1._r8 ) * sigma_qt
                  ! Jun.29.2011. Below formula does not change the negative sign of 'sigma_thl' and 'sigma_qt' in the
                  !              stable regime. Thus, I removed below 3 lines. Instead, additional TKE will be provided
                  !              to compute sigma_w, and uniform perturbation will be provided to updraft 'qt,thl' later
                  !              in association with convective organization later instead of changing sigma_thl and sigma_qt.   
                  ! tmp1      =     0.5_r8 * ( 1._r8 + sin( 3.141592_r8 * ( org_rad - 0.5_r8 ) ) )
                  ! sigma_w   =   ( csig_w   * tmp1    + 1._r8 ) * sigma_w
                  ! sigma_thl =   ( csig_thl * tmp1    + 1._r8 ) * sigma_thl
                  ! sigma_qt  =   ( csig_qt  * tmp1    + 1._r8 ) * sigma_qt
                  ! Apr.25.2011. Impose positive value constraints on 'thl,qt,tracers'. 
                  ! May.21.2011. Impose maximum value of 1.0 [ m/s ] on sigma_w.
                  !              In case of 'sigma_qt', impose 10% of 'qt_b' as the upper limit
                  !              instead of a fixed value 1.e-3. Note that this 'sigma_w,thl,qt,u,v' are the values when 'alpha = 1' not
                  !              'alpha = alpha_max'. Thus, we don't need to use impose enormously loose constraint here.
                  !              Imposing constraint starting from '1.' seems to be consistent and OK.
                  ! Jun.28.2011. Redefine 'sigma_w' by adding downdraft-induced additional TKE, 'cuorg / ( cc2_org * tau_org )' to the
                  !              definition of 'sigma_w'. Also, relax the upper limit of sigma_w to 2 [m/s] from 1 [ m/s ].
                  !              The lower limit is also raised from 0.1 to 0.2.        
                  !              Add the form from Cathy's work.
                  ! sigma_w   = sigma_wo + min( kw,   1.4142_r8 ) * sqrt( tke1 + cwtke * cuorg / ( cc2_org * tau_org ) )

                  ! Option.1. Explicit analytical formula. In this case, I should use tkePBL not tke1, for consistency with 
                  !           the treatment of convective organization associated with convective downdraft and evaporation
                  !           of convective precipitation within PBL.
                  ! Option.2. Cathy's empirical formula.  
                  ! Feb.06.2013. As of today, always choose 'i_persrc = 1' and removes this option.

                  !b           if( i_persrc .eq. 1 ) then
                  ! July.13.2011. As a semi-final configuration, 'tkePBLorg_old = wa_d(0,it=1)' and this mean vertical
                  !               velocity of convective downdraft will be added as additional back-ground vertical 
                  !               velocity instead of enhancing the variance of vertical velocity. Thus, 'sigma_w' is
                  !               solely coming from turbulence-scale TKE. 
                  ! sigma_w   = sigma_wo + min( kw,   1.4142_r8 ) * sqrt( tke1 + con_org_tke * tkePBLorg_old )
                  sigma_w   = sigma_wo + min( kw,   1.4142_r8 ) * sqrt( tke1 )
                  ! sigma_w   = sigma_wo + kw * wstar

                  ! TEST for diurnal cycle
                  ! sigma_w   = 0.3_r8
                  ! TEST

                  !b           elseif( i_persrc .eq. 2 ) then
                  !b               sigma_w   = sigma_wo + min( kw,   1.4142_r8 ) * sqrt( tke1 + prep_old * 24._r8 * 3600._r8 * 0.2_r8 * pblhz / 1000._r8 )
                  !b           elseif( i_persrc .eq. 3 ) then
                  !b               tmp1      =     0.5_r8 * ( 1._r8 + sin( 3.141592_r8 * ( org_rad - 0.5_r8 ) ) )
                  !b               sigma_w   =   ( csig_w   * tmp1    + 1._r8 ) * sigma_w
                  !b               sigma_thl =   ( csig_thl * tmp1    + 1._r8 ) * sigma_thl
                  !b               sigma_qt  =   ( csig_qt  * tmp1    + 1._r8 ) * sigma_qt
                  !b           endif

                  ! Oct.03.2011. Sometimes, UNICON produced too much concentration of sea-salt and dust, probably due to
                  !              too much upward flux of aerosol and sea-salt probably due to too strong surface wind
                  !              speed. In order to prevent this model crash for a given 'taux,tauy' which includes
                  !              tms, we may need to reduce the upper/lower limits of 'sigma_u,sigma_v' by 0.5 from
                  !              the 1. Alternatively, I can remove 'tms' from the input 'taux,tauy'. 
                  !              This must be explored in future.
                  !              In addition, we should not set PGFc_up=PGFc_dn = 0 : then, the model is likely to  
                  !              crash due to the same reason above by too strong convective downdraft transport of
                  !              horizontal momentum. This should be carefully explored in future.
                  ! Oct.16.2011. Due to the use of sigma_wo, I don't need to separately specify minimum value of sigma_w
                  !              in the below block.
                  ! Feb.08.2013. Below 'tmp1', the largest updraft 'alpha' value, changes as 'nseg' is changed.
                  !              This tmp1' however should be independent of 'nseg' in the below limiter block.
                  !              Thus, for this purpose, I set 'tmp1' to 'alpha_max', so that below limiter is 
                  !              independent of (insensitive to) 'nseg'. 
                  !j           tmp1      = alpha_cri + d_alpha * ( nseg - 0.5_r8 )
                  ! May.17.2012. When nseg = 1, locate alpha = 1.
                  !              Below limiters of various 'sigma_xx' might be the source of model
                  !              sensitivity to 'nseg=1' vs 'nseg>1'. I should re-check this.
                  !j           if( nseg .eq. 1 .and. icudist_tail .eq. 0 ) tmp1 = 1._r8
                  tmp1      = alpha_max 
                  sigma_w   = max( 1.e-1_r8, min( 1.0_r8, sigma_w ) ) 
                  ! sigma_w   = max(    0._r8, min( 1.0_r8, sigma_w ) ) 

            !lim  Oct.3. I commented out below limiter block. But instead, impose non-negative limiters later
            !lim         further below.  

            !lim  sigma_thl = max( - thl_b / tmp1, min( thl_b / tmp1 , sigma_thl ) )
                  sigma_thl = max( - 2.0_r8, min( 2.0_r8, sigma_thl ) )
            !lim  sigma_qt  = max( - qt_b / tmp1, min( qt_b / tmp1 , sigma_qt ) )
            !lim  ! sigma_qt  = max( - 5.e-4_r8, min( 1.e-3_r8, sigma_qt ) )
                  sigma_qt  = max( - 0.2_r8*qt_b, min( 0.2_r8*qt_b, sigma_qt ) )
                  sigma_u   = max( - 2.0_r8, min( 2.0_r8 , sigma_u ) ) 
                  sigma_v   = max( - 2.0_r8, min( 2.0_r8 , sigma_v ) )
            !lim  do mt = 1, ncnst
            !lim     sigma_tr(mt) = max( - tr_b(mt) / tmp1, min( tr_b(mt) / tmp1 , sigma_tr(mt) ) )
            !lim  enddo

                ! Mar.04.2015. In order to stabilize the system, turn-off the perturbations of momentum and 
                !              tracers. In other word, only 'thl,qt' perturbations are considered.

                  sigma_u   = 0._r8
                  sigma_v   = 0._r8
                  do mt = 1, ncnst
                     sigma_tr(mt) = 0._r8
                  enddo

                ! Mar.04.2015. End of stabilization 

                  ! CHECK
                  ! write(6,*)
                  ! write(6,*) 'UNICON: sqrt(tkes), sqrt(tke1), sqrt(tkePBL), wstar1, wstar, wstarPBL'
                  ! write(6,*) 'Time step & Launching interface index : ', get_nstep(), kiss
                  ! write(6,*) 'sqrt(tkes), sqrt(tke1), sqrt(tkePBL) = ', sqrt(tkes), sqrt(tke1), sqrt(tkePBL) 
                  ! write(6,*) 'wstar1, wstar, wstarPBL = ', wstar1, wstar, wstarPBL 
                  ! write(6,*)
                  ! CHECK

                  ! CHECK
                  ! write(6,*)
                  ! write(6,*) 'UNICON: sigma at the launching interface after adding organization perturbation'
                  ! write(6,*) 'Launching interface index : ', kiss
                  ! write(6,*) 'sigma_w   : ', sigma_w 
                  ! write(6,*) 'sigma_thl : ', sigma_thl
                  ! write(6,*) 'sigma_qt  : ', sigma_qt 
                  ! write(6,*) 'sigma_u   : ', sigma_u 
                  ! write(6,*) 'sigma_v   : ', sigma_v 
                  ! write(6,*)
                  ! CHECK

                  ! Sep.21.2011. Critical Bug !!!
                  !              Below computation of cmf_au(m) does not include 'delta_w_PBL' !!!
                  !              So, I can easily expect that all the previous simulations with non-zero organization are completely wrong. 
                  !              This bug is likely to explain all the strange features in my previous simulations - poor diurnal cycle,
                  !              too strong precipitation climatology, strange insensitivity of simulation to the inclusion of 'a_oro' to
                  !              convective organization. 
                  !              Note that 'Pmu' is used only for computing 'cmf_au(m)' in the below block and for computing 'cushavg_mxen'
                  !              later. I uniformly add 'delta_w_PBL' all over the 'm' segment. Thus, the only modification what I should do
                  !              to impose a full consistency is to recompute 'cmf_au(m)' by including delta_w_PBL later. 
                  !              Since I will always use 'iorg_src = 0', below incomplete computation of 'sum' is not a problem at all since
                  !              this 'sum' is used in 'no' part of the code if I choose 'iorg_src'.
                  ! Sep.21.2011. A easiest and perfect solution for this issue is to add 'delta_w_PBL' in the below definition of 'Pmu'.
                  !              This will clearly solve all the issues without any other modifications. 
                  !              So, I am imposing this modifiation.  
                  ! May.17.2012. In order to understand the sensitivity to the choice of 'nseg' (especially from nseg=1 to nseg>1),
                  !              impose exact updraft fraction area of 'au_base' by using the area normalization factor 'norm'. 
                  ! Feb.17.2013. Below 'cmfu_base' is a physical updraft mass flux at surface without organization component.

                  if( icudist_tail .eq. 0 ) cmfu_base = au_base * rho_b * ( sigma_w * sqrt( 2._r8 / 3.141592_r8 ) )
                  rnorm_a = 0._r8            
                  rnorm_m = 0._r8            
                  do m = 1, nseg
                     ! Computation of individual updraft segment value
                     alpha(m)  = alpha_cri + d_alpha * ( m - 0.5_r8 )
                     ! May.17.2012. When nseg = 1, locate alpha = 1.
                     if( nseg .eq. 1 .and. icudist_tail .eq. 0 ) alpha(m) = 1._r8
                     Pau(m)    = exp(-0.5_r8*alpha(m)**2._r8)/sqrt(2._r8*3.141592_r8)
                     ! In order to simulate stabilizing CIN effect, choose icudist_tail = 0.
                     ! It may be necessary to remove 2._r8 in the below line. 
                     ! I should think further later. 
                     ! This is an VERY IMPORTANT ISSUE. 
                     ! It seems that below current formula with 2._r8 is correct and consistent with the computation of 'I_cri'
                     ! above ( where I_cri should NOT multiplied by 2 ). 
                     ! Feb.08.2013. By multiplying '2._r8 * au_base', the resulting Pau(m) becomes physical quantities, i.e., 
                     !              integration of the resulting Pau(m) from zero to infinite becomes 'au_base'.
                     !              Similarly, integrating below Pmu(m) from zero to infinite becomes 'cmfu_base', which does not
                     !              include organization component.  
                     if( icudist_tail .eq. 0 ) then
                        Pau(m) = 2._r8 * au_base * Pau(m)
                        Pmu(m) = Pau(m) * rho_b * ( sigma_w * alpha(m) )
                     endif
                     rnorm_a   = rnorm_a +  Pau(m) * d_alpha 
                     rnorm_m   = rnorm_m +  Pmu(m) * d_alpha
                  enddo

                  ! May.17.2012. Include 'tmp1' just to check whether the sum of updraft fractional area is exactly 
                  !              same as the specified 'au_base' regardless of the use of different 
                  !              values of 'nseg' and 'alpha_max'
                  tmp1 = 0._r8
                  sum  = 0._r8            
                  do m = 1, nseg
                     ! Computation of individual updraft segment value
                     alpha(m)  = alpha_cri + d_alpha * ( m - 0.5_r8 )
                     ! May.17.2012. When nseg = 1, locate alpha = 1.
                     if( nseg .eq. 1 .and. icudist_tail .eq. 0 ) alpha(m) = 1._r8
                     Pau(m)    = exp(-0.5_r8*alpha(m)**2._r8)/sqrt(2._r8*3.141592_r8)
                     ! In order to simulate stabilizing CIN effect, choose icudist_tail = 0.
                     ! It may be necessary to remove 2._r8 in the below line. 
                     ! I should think further later. 
                     ! This is an VERY IMPORTANT ISSUE. 
                     ! It seems that below current formula with 2._r8 is correct and consistent with the computation of 'I_cri'
                     ! above ( where I_cri should NOT multiplied by 2 ). 
                     if( icudist_tail .eq. 0 ) Pau(m) = 2._r8 * au_base * Pau(m)
                     ! May.17.2012. Force the updraft fractional area to be exactly 'au_base'
                     ! Feb.09.2013. Force either 'au_base' is conserved ( inorm .eq. 1 ) or 'cmfu_base' is conserved ( inorm .eq. 2 ) at surface. 
                     if( inorm .eq. 1 ) then
                        Pau(m) = Pau(m) * ( au_base / rnorm_a )   
                     elseif( inorm .eq. 2 ) then
                        Pau(m) = Pau(m) * ( cmfu_base / rnorm_m )   
                     endif
                     ! Sep.21.2011. Below is the corrected code - I added 'delta_w_PBL'.
                     ! May.15.2012. Bug fix. Multiply 'cdelta_w' in the below line.
                     Pmu(m)    = Pau(m) * rho_b * ( sigma_w * alpha(m) + delta_w_PBL * cdelta_w )
                     ! Below is the original code before Sep.21.2011. 
                     ! Pmu(m)    = Pau(m) * rho_b * sigma_w * alpha(m)
                     Pnu(m)    = Pau(m) / ( 3.141592_r8 * ( Ro + sigmaR * alpha(m) )**2._r8 )
                     a_au(m)   = Pau(m) * d_alpha                            ! Updraft fractional area          [ no unit ] 
                     cmf_au(m) = Pmu(m) * d_alpha                            ! Updraft mass flux                [ kg / s / m^2 ]
                     num_au(m) = Pnu(m) * d_alpha                            ! Number of updraft plumes         [ # / m^2 ]
                     rad_au(m) = Ro     + sigmaR   * alpha(m)                ! Physical radius of updraft plume [ m ]
                     sum       = sum    + cmf_au(m) 
                     tmp1      = tmp1   + a_au(m)
                  enddo

                  ! CHECK
                  ! if( abs(tmp1-au_base) .gt. 1.e-5_r8 ) then  
                  !     write(6,*)
                  !     write(6,*) 'UNICON: The sum of discrete updraft fractional area at surface differs from the specified au_base'
                  !     write(6,*) 'specified_au_abase, discrete_au_base = ', au_base, tmp1
                  !     write(6,*)
                  ! endif
                  ! CHECK

                  ! Jun.27.2011. Below computation of 'org_src' is added for imposing organized perturbation
                  !              source air properties of convective updraft at surface. 
                  ! Jul.13.2011. Note that except the adding of 'f_srcrs(k,m,2)' by updraft buoyancy sorting at surface
                  !              interface in the lowest model layer, 'cu_cmfr' is the same as the sum of downdrfat mass 
                  !              flux at surface since all detrainment occurs at surface.
                  !              Thus, below computation of 'org_src' based on the comparison between 'sum' and 'cu_cmfr'
                  !              is perfectly reasonable. Note that 'cu_thlr, cu_thlr,...' are mass-flux weighted average
                  !              using 'cu_cmfr'. Thus, comparision with mass-flux concept ( not the area average ), and
                  !              corresponding mass-flux weighted 'cu_thlr, etc' are fully consistent.
                  ! Sep.21.2011. Note that 'sum' in the below does not include 'delta_w_PBL' which is a bug. However,
                  !              since we will always use 'iorg_src = 0' to perfectly use the heterogeneity of PBL,
                  !              this incomplete computation of 'sum' is not a problem at all.
                  ! Sep.21.2011. Now, by re-defining 'Pmu(m)' above, 'sum' in the below computation is also perfectly 
                  !              correct.   

                  !e Feb.06.2013. As of today, always use iorg_src = 0 and remove this and related options.

                  !e           if( iorg_src .eq. 1 ) then
                  !e             ! Jul.15.2011. Use mean downdraft mass flux at surface during org_memory_time scale, 'tkePBLorg_old' ( note that this is not TKE
                  !e             !              but downdraft mass flux at surface as of Jul.15.2011 ).
                  !e             ! Jul.16.2011. 'cmfPBLorg_old' contains correct mass flux and this is used instead.
                  !e             ! org_src = min( fac_org_src * cuorg , cu_cmfr(1)    / max( sum, nonzero ) ) ! The second argument sets the upper limit of org_src.
                  !e               org_src = min( fac_org_src * cuorg , cmfPBLorg_old / max( sum, nonzero ) ) ! The second argument sets the upper limit of org_src.
                  !e           else
                  !e               org_src = 0._r8
                  !e           endif
                  !e           org_src = max( 0._r8, min( 1._r8, org_src ) ) 

                  ! CHECK
                  ! write(6,*)
                  ! write(6,*) 'UNICON: Organization source'
                  ! write(6,*) 'cuorg, org_src, cu_cmfr(1), sum  = ', cuorg, org_src, cu_cmfr(1), sum
                  ! write(6,*)
                  ! CHECK

                  ! CHECK
                  ! write(6,*)
                  ! write(6,*) 'UNICON: source air modification by convective organization'
                  ! write(6,*) 'org_src, cu_qtr(1) - qt0(1)    = ', org_src, 1000._r8 * ( cu_qtr(1) - qt0(1) ), 1000._r8 * cu_qtr(1), 1000._r8 * qt0(1)
                  ! write(6,*) 'org_src, cu_thlr(1) - thl0(1)  = ', org_src, cu_thlr(1) - thl0(1), cu_thlr(1), thl0(1)
                  ! write(6,*) 'org_src, cu_ur(1) - u0(1)      = ', org_src, cu_ur(1) - u0(1) 
                  ! write(6,*) 'org_src, cu_vr(1) - v0(1)      = ', org_src, cu_vr(1) - v0(1)
                  ! write(6,*)
                  ! CHECK

                  do m = 1, nseg

                     ! Sep.27.2010. In order to reduce the sensitivity to the thickness of the lowest model layer and
                     !              to be fully compatible with the constant flux layer theory, updraft perturbation
                     !              should be defined in terms of the mean value of the LOWEST model layer.
                     !              And then, we should consider vertical evolution convective updraft from the surface
                     !              to the top interface of the lowest model layer. This is equivalent to setting 
                     !              kiss = 0 & I_cri = 0.
                     ! Apr.3.2011.  It seems that I should use 'thl_m' and etc. not 'thl_b', in order to be consistent with the
                     !              given surface flux. In addition, I should explore the sensitivity to 'islope_on_thlqttr' and
                     !             'islope_on_uv'. Test on the latter should be done cautiously considering PGFc. In order to
                     !              treat PGFc effect, I must set 'islope_on_uv=1'  
                     ! May.12.2011. Add convective organization effect directly to the source properties of 'qt_at' and 'thl_au'
                     !              not into 'sigma_thl' and 'sigma_qt'. When organization is developed, decrease 'thl' but
                     !              increase 'qt'. First, only increase 'qt' since reduction of 'thl' may cause too negative
                     !              buoyancy.
                     ! Jun.27.2011. Add uniform ( independent of alpha(m) ) perturbations associated with organization here
                     !              instead of changing sigma_xxx above. This can be important to simulate reasonable
                     !              diurnal cycle of precipitation over land. 
                     !              If necessary, I can add additional perturbation asociated with upward moisture and heat 
                     !              flux during the organized horizontal flow.
                     !              Note that below formula exactly conserves ( reconstructs ) the given surface flux since
                     !              (1) the perturbation is not a function of 'alpha', and (2) vertical velocity perturbation
                     !              is neglected.    
                     ! thl_au(m) = thl_b  + sigma_thl * alpha(m) + org_src * ( cu_thlrd(1) - thl_b )
                     ! qt_au(m)  = qt_b   + sigma_qt  * alpha(m) + org_src * ( cu_qtrd(1)  - qt_b  )
                     ! u_au(m)   = u_b    + sigma_u   * alpha(m) + org_src * ( cu_urd(1)   - u_b   )
                     ! v_au(m)   = v_b    + sigma_v   * alpha(m) + org_src * ( cu_vrd(1)   - v_b   )
                     ! do mt = 1, ncnst
                     !    tr_au(m,mt) = tr_b(mt) + sigma_tr(mt) * alpha(m) + org_src * ( cu_trrd(1,mt) - tr_b(mt) )
                     ! enddo
                     
                     ! Option.1. Explicit computation of temperature and moisture perturbation by solving detailed
                     !           processes of convective downdraft and evaporation of convective precipitation 
                     !           within environment. 
                     ! Option.2. Add Cathy's moisture perturbation ( tmp2 ). Note that no temperature perturbation ( tmp1 )
                     !           in Cathy's formula.
                     ! Jun.30.2011. Below block can be relocated out of the above do-loop to save computation time.
                     
                     ! if( i_persrc .eq. 1 ) then
                     !     tmp1 = con_org_thl * thlPBLorg_old
                     !     tmp2 = con_org_qt  * qtPBLorg_old
                     ! elseif( i_persrc .eq. 2 ) then
                     !     tmp1 = 0._r8
                     !     if( prep_old * 24._r8 * 3600._r8 .gt. 0.2_r8 ) then
                     !         tmp2 = min( log( prep_old * 24._r8 * 3600._r8 ), 3._r8 )
                     !         tmp2 = exp( -0.7_r8 + 0.14_r8 * tmp2 + 0.024_r8 * tmp2 * tmp2 ) / 1000._r8
                     !     else
                     !         tmp2 = 0._r8
                     !     endif
                     ! endif

                     ! thl_au(m) = thl_b  + sigma_thl * alpha(m) + tmp1 
                     ! qt_au(m)  = qt_b   + sigma_qt  * alpha(m) + tmp2 
                     ! u_au(m)   = u_b    + sigma_u   * alpha(m) 
                     ! v_au(m)   = v_b    + sigma_v   * alpha(m) 
                     ! w_au(m)   =          sigma_w   * alpha(m)
                     ! call conden( p_b, thl_au(m), qt_au(m), th, qv, ql, qi, qse, id_check )
                     ! if( id_check .eq. 1 ) then
                     !     id_exit = .true.
                     !     go to 333
                     ! endif
                     ! ql_au(m)  = ql
                     ! qi_au(m)  = qi
                     ! thv_au(m) = th * ( 1._r8 + zvir * qv - ql - qi )
                     ! do mt = 1, ncnst
                     !    tr_au(m,mt) = tr_b(mt) + sigma_tr(mt) * alpha(m)
                     ! enddo

                     ! Jul.13.2011. Similar to other anomalous conservative scalars in the lowest model layer,
                     !              I added anomalous mean-updraft vertical velocity induced by convective
                     !              organization at surface as below. Note that in this semi-final configuration
                     !              tkePBLorg_old = wa_d(0,it=1) consistent and same as 'cu_thlr(1)...etc'.  
                     ! Jul.13.2011. Note that I used below 'thl_au(m) = thl_b  + sigma_thl * alpha(m) + org_src * cu_thlr(1)'
                     !              instead of 'thl_au(m) = thl_b  + sigma_thl * alpha(m) + org_src * ( cu_thlr(1) - thl_b )' where
                     !              cu_thlr(k) is not the anomaly but explicit temperature. This treatment is made
                     !              to be consistent with the corresponding treatment of entrained air
                     !              properties into convective updraft later, i.e., 'thle_b =  max( 0._r8, thl_b  + org_ent * cu_thlr(k) )'.
                     !              The reason why I used below anomalous formula is because not only grid-mean value but also
                     !              detrained value can be changed by subsequent non-convective processes between current and
                     !              next time step. 
                     ! Feb.06.2013. As of today, always choose 'i_persrc = 1' and remove this option.

                     !b            if( i_persrc .eq. 1 ) then

                     ! Jul.15.2011. For complete treatment, I should add modification of downdraft properties during displacement
                     !              at neat surface as below. 0 < cc = vertical scale of gust / ~ pblh < 1.
                     !              However, for the time being, let's neglect this additional perturbation.
                     !              strictly speaking, I should use 'org_src' instead of 'cuorg' in the below lines. However,
                     !              'org_src' should be based on area ratio not the mass-flux ratio, implying that there is 
                     !              uncertainty even in the limitation of org_src. So, I simply used cuorg in the below for the time being.
                     !              For the time being, aerosol perturbation is neglected since current aerosol array does not allow 
                     !              multi-time step saving --> actually not since I only consider the value at the surface not in the 
                     !              entire layers. So this aerosol perturbation should be added later.
                     !              Note that all the perturbation including vertical velocity includes 'cuorg' in it.
                     !              As an alternative, w perturbation can be done in a similar way as the other conservative scalars instead of
                     !              backing-out from the organization.
                     ! Jul.15.2011. I correctly use 'org_src' which is limited by mean downdraft mass flux during the organization time scale.
                     !              Also, I multiplied 'org_src' for vertical velocity for conceptual consistency. 

                     ! thl_au(m) = thl_b  + sigma_thl * alpha(m) + org_src * thlPBLorg_old 
                     ! qt_au(m)  = qt_b   + sigma_qt  * alpha(m) + org_src *  qtPBLorg_old
                     ! u_au(m)   = u_b    + sigma_u   * alpha(m) + org_src *   uPBLorg_old
                     ! v_au(m)   = v_b    + sigma_v   * alpha(m) + org_src *   vPBLorg_old 
                     ! As an option, I can use 'org_src * sqrt( 2._r8 * tkePBLorg_old )' instead in the below line
                     ! w_au(m)   =          sigma_w   * alpha(m) + org_src * sqrt( 2._r8 * ( 1._r8 / a_d_sfcTKEorg ) * cuorg / ( cc2_org * tau_org ) )
                     ! w_au(m)   = ( 2._r8 * cuorg ) / ( a_d_sfcTKEorg * cc2_org * cc0_org * pblhz )  
                     ! w_au(m)   =          sigma_w   * alpha(m) + org_src * sqrt( 2._r8 * ( 1._r8 / a_d_sfcTKEorg ) * tkePBLorg_old )
                     ! Aug.15.2011. When prognostic mesn-scale TKE is used, use tkePBLorg_old as the bulk perturbation of
                     !              w_au(m). 
                     ! thl_au(m) = thl_b  + sigma_thl * alpha(m) + thlPBLorg_old 
                     ! qt_au(m)  = qt_b   + sigma_qt  * alpha(m) + qtPBLorg_old
                     ! u_au(m)   = u_b    + sigma_u   * alpha(m) 
                     ! v_au(m)   = v_b    + sigma_v   * alpha(m) 
                     ! w_au(m)   =          sigma_w   * alpha(m) + sqrt( ( 2._r8 / 3._r8 ) * tkePBLorg_old )

                     ! Aug.31.2011. Simple parameterization of density current is added. Note that all scalars are
                     !              consistently modified by the excess in the wake-free region. This new method
                     !              does not use org_src. 'ql_au' and 'qi_au' are computed from 'thl_au' and 'qt_au'
                     !              from the variable conversion, which is perfectly reasonable. 
                     !              Here, 'delta_w_PBL' is additional vertical velocity by the spreading of wake in [ m/s ]
                     !              Note that all the perturbation associated with density current should be uniformly
                     !              added to all the updraft segment regardles of alpha(m). This clear view is a very
                     !              nice feature. Here, wake_ratio = (1-aw)/aw where 'aw' is the wake area fraction.
                     !              Since I don't treat the detailed wake geometry, this 0 < wake_ratio < 10 should
                     !              be specified by the user. Since delta_thv_PBL can be negative ( even though it is highly likely to
                     !              be positive ), I forced it to be positive.
                     !              Note that even when cuorg = 0, the other delta_thl(qt,u,v,tr)_PBL can be non-zero. 
                     !              We can remove this seemingly inconsistent feature by only choosing the component of 'thvflx_d_org_pblh > 0'
                     !              in computing excess between off-wake and grid-mean averaged over the PBL.
                     !              By realizing this potential inconsistency issue, I only choose the component of 'thvflx_d_org_pblh > 0'.
                     !              We can also impose a reasonable limiter on 'delta_thl(qt,u,v,tr,w)_PBL' if necessary.
                     !              I hope that below is the final the most consistent closure.
                     !              I computed 'delta_w_PBL' at the beginning of the program to save computation time, so that 
                     !              I commented out below line computing delta_w_PBL.
                     ! Sep.15.2011. Note that these 'delta_thl_PBL' is an inherent function of 'cuorg' already.
                     ! Sep.22.2011. I may need to use 'thl_m' instead of 'thl_b' in order to reduce the sensitivity to the
                     !              internal slope in the lowest model layer.
                     !              This may be the reason of too much PREH2O in my previous simulations.  
                     !              Note that in the surface flux computation routine of the CAM5, the 'thl_m' not 'thl_b' is
                     !              used. Thus, for consistency, we may need to use 'thl_m' not 'thl_b'.

                     ! Below block is the new using 'thl_m'.
                     ! thl_au(m) = thl_m  + sigma_thl * alpha(m) + delta_thl_PBL
                     ! qt_au(m)  = qt_m   + sigma_qt  * alpha(m) +  delta_qt_PBL
                     ! u_au(m)   = u_m    + sigma_u   * alpha(m) +   delta_u_PBL
                     ! v_au(m)   = v_m    + sigma_v   * alpha(m) +   delta_v_PBL
                     ! w_au(m)   =          sigma_w   * alpha(m) +   delta_w_PBL
                     ! call conden( p_b, thl_au(m), qt_au(m), th, qv, ql, qi, qse, id_check )
                     ! if( id_check .eq. 1 ) then
                     !     id_exit = .true.
                     !     go to 333
                     ! endif
                     ! ql_au(m)  = ql
                     ! qi_au(m)  = qi
                     ! thv_au(m) = th * ( 1._r8 + zvir * qv - ql - qi )
                     ! do mt = 1, ncnst
                     !    tr_au(m,mt) = tr_m(mt) + sigma_tr(mt) * alpha(m) + delta_tr_PBL(mt)
                     ! enddo

                     ! Apr.27.2012. I multiply 'cdelta' to take into account of inhomogeneity within 'a_U'.
                     !              See description on the same day. Note that I am using both 'cdelta_s' and 'cdelta_w'
                     !              where 's' denotes scalar and 'w' denotes vertical velocity.              
                     ! Below block is the original using 'thl_b'.
                     thl_au(m) = thl_b  + sigma_thl * alpha(m) + delta_thl_PBL * cdelta_s
                     qt_au(m)  = qt_b   + sigma_qt  * alpha(m) +  delta_qt_PBL * cdelta_s
                !lim
                     qt_au(m)  = max( qt_au(m), qmin(1) ) 
                !lim 
                     u_au(m)   = u_b    + sigma_u   * alpha(m) +   delta_u_PBL * cdelta_s
                     v_au(m)   = v_b    + sigma_v   * alpha(m) +   delta_v_PBL * cdelta_s
                     w_au(m)   =          sigma_w   * alpha(m) +   delta_w_PBL * cdelta_w
                     call conden( p_b, thl_au(m), qt_au(m), th, qv, ql, qi, qse, id_check )
                     !f              if( id_check .eq. 1 ) then
                     !f                  id_exit = .true.
                     !f                  go to 333
                     !f              endif
                     ql_au(m)  = ql
                     qi_au(m)  = qi
                     thv_au(m) = th * ( 1._r8 + zvir * qv - ql - qi )
                     do mt = 1, ncnst
                        tr_au(m,mt) = tr_b(mt) + sigma_tr(mt) * alpha(m) + delta_tr_PBL(mt) * cdelta_s
                !lim 
                        tr_au(m,mt) = max( tr_au(m,mt), qmin(mt) )
                !lim 
                     enddo

                     ! Mar.13.2013. 
                     ! Initialize 'S_b_ql_au(m) = S_b_qi_au(m) = 0' at surface.

                     S_b_ql_au(m) = 0._r8
                     S_b_qi_au(m) = 0._r8

                     ! Imsi 

                     ! thl_au(m) = max( 0._r8, thl_b  + sigma_thl * alpha(m) + org_src * 0._r8 ) 
                     ! qt_au(m)  = max( 0._r8, qt_b   + sigma_qt  * alpha(m) + org_src * 1._r8 * 0.001_r8  )  
                     ! u_au(m)   = u_b    + sigma_u   * alpha(m) + org_src * 0._r8   
                     ! v_au(m)   = v_b    + sigma_v   * alpha(m) + org_src * 0._r8   
                     ! w_au(m)   =          sigma_w   * alpha(m) + org_src * 2._r8 
                     ! call conden( p_b, thl_au(m), qt_au(m), th, qv, ql, qi, qse, id_check )
                     ! if( id_check .eq. 1 ) then
                     !     id_exit = .true.
                     !     go to 333
                     ! endif
                     ! ql_au(m)  = ql
                     ! qi_au(m)  = qi
                     ! thv_au(m) = th * ( 1._r8 + zvir * qv - ql - qi )
                     ! do mt = 1, ncnst
                     !    tr_au(m,mt) = max( 0._r8, tr_b(mt) + sigma_tr(mt) * alpha(m) + org_src * 0._r8 )
                     ! enddo
                     
                     ! thl_au(m) = max( 0._r8, thl_b  + sigma_thl * alpha(m) + org_src * cu_thlr(1) ) 
                     ! qt_au(m)  = max( 0._r8, qt_b   + sigma_qt  * alpha(m) + org_src * cu_qtr(1)  )  
                     ! u_au(m)   = u_b    + sigma_u   * alpha(m) + org_src * cu_ur(1)   
                     ! v_au(m)   = v_b    + sigma_v   * alpha(m) + org_src * cu_vr(1)   
                     ! w_au(m)   =          sigma_w   * alpha(m) + org_src * tkePBLorg_old 
                     ! call conden( p_b, thl_au(m), qt_au(m), th, qv, ql, qi, qse, id_check )
                     ! if( id_check .eq. 1 ) then
                     !     id_exit = .true.
                     !     go to 333
                     ! endif
                     ! ql_au(m)  = ql
                     ! qi_au(m)  = qi
                     ! thv_au(m) = th * ( 1._r8 + zvir * qv - ql - qi )
                     ! do mt = 1, ncnst
                     !    tr_au(m,mt) = max( 0._r8, tr_b(mt) + sigma_tr(mt) * alpha(m) + org_src * cu_trr(1,mt) )
                     ! enddo

                     !b            elseif( i_persrc .eq. 2 ) then

                     !b              tmp1 = 0._r8
                     !b              if( prep_old * 24._r8 * 3600._r8 .gt. 0.2_r8 ) then
                     !b                  tmp2 = min( log( prep_old * 24._r8 * 3600._r8 ), 3._r8 )
                     !b                  tmp2 = exp( -0.7_r8 + 0.14_r8 * tmp2 + 0.024_r8 * tmp2 * tmp2 ) / 1000._r8
                     !b              else
                     !b                  tmp2 = 0._r8
                     !b              endif

                     !b              thl_au(m) = thl_b  + sigma_thl * alpha(m) + tmp1 
                     !b              qt_au(m)  = qt_b   + sigma_qt  * alpha(m) + tmp2
                     !b              u_au(m)   = u_b    + sigma_u   * alpha(m) 
                     !b              v_au(m)   = v_b    + sigma_v   * alpha(m) 
                     !b              w_au(m)   =          sigma_w   * alpha(m) 
                     !b              call conden( p_b, thl_au(m), qt_au(m), th, qv, ql, qi, qse, id_check )
                     !b              if( id_check .eq. 1 ) then
                     !b                  id_exit = .true.
                     !b                  go to 333
                     !b              endif
                     !b              ql_au(m)  = ql
                     !b              qi_au(m)  = qi
                     !b              thv_au(m) = th * ( 1._r8 + zvir * qv - ql - qi )
                     !b              do mt = 1, ncnst
                     !b                 tr_au(m,mt) = tr_b(mt) + sigma_tr(mt) * alpha(m)
                     !b              enddo

                     !b            elseif( i_persrc .eq. 3 ) then

                     !b              thl_au(m) = thl_b  + sigma_thl * alpha(m)
                     !b              qt_au(m)  = qt_b   + sigma_qt  * alpha(m)
                     !b              u_au(m)   = u_b    + sigma_u   * alpha(m) 
                     !b              v_au(m)   = v_b    + sigma_v   * alpha(m) 
                     !b              w_au(m)   =          sigma_w   * alpha(m) 
                     !b              call conden( p_b, thl_au(m), qt_au(m), th, qv, ql, qi, qse, id_check )
                     !b              if( id_check .eq. 1 ) then
                     !b                  id_exit = .true.
                     !b                  go to 333
                     !b              endif
                     !b              ql_au(m)  = ql
                     !b              qi_au(m)  = qi
                     !b              thv_au(m) = th * ( 1._r8 + zvir * qv - ql - qi )
                     !b              do mt = 1, ncnst
                     !b                 tr_au(m,mt) = tr_b(mt) + sigma_tr(mt) * alpha(m)
                     !b              enddo

                     !b            endif

                     ! -------------------------------------------------------------------------------------------------------------- !
                     ! Nov.28.2012. Imposing Consistency between 'droplet mass' and 'droplet number'                                  !
                     ! For the fully consistent treatment of microphysics process, it is important to                                 !
                     ! impose a full consistency between 'ql_au(m),tr_au(m,ixnumliq)' and 'qi_au(m),tr_au(m,ixnumice)'                !
                     ! here from the surface. Similar consistency will be imposed at all the interfaces above too as                  !
                     ! well as for convective downdraft.                                                                              !
                     ! Consistency should be imposed based on the 'ql_au(m),qi_au(m)' not on 'tr_au(m,ixnumliq),tr_au(m,ixnumice)'    !
                     ! since computation of 'droplet mass' is more reliable than 'droplet number' in the current situation.           !
                     ! If air is already saturated at surface with non-zero condensate, compute tr_au(m,ixnumliq) and                 ! 
                     ! tr_au(m,ixnumice) with a externally specified droplet radius. This can be done later using aerosol information !
                     ! or using stratiform cloud information at surface. However, this case will happen in a very rare way.           !
                     ! -------------------------------------------------------------------------------------------------------------- !

                     if( ql_au(m) .eq. 0._r8 ) then
                        tr_au(m,ixnumliq) = 0._r8
                     else
                        tr_au(m,ixnumliq) = ql_au(m) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_liq**3 * density_liq )
                     endif

                     if( qi_au(m) .eq. 0._r8 ) then
                        tr_au(m,ixnumice) = 0._r8
                     else
                        tr_au(m,ixnumice) = qi_au(m) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_ice**3 * density_ice )
                     endif

                     ! ----------------------------------------------------- !
                     ! Compute the original updraft segment index at surface !
                     ! ----------------------------------------------------- !

                     msfc_from_m(k,m) = m

                     ! CHECK
                     ! write(6,*)
                     ! write(6,*) 'UNICON: source air properties at the launching interface'
                     ! write(6,*) 'Updraft segment index, m = ', m
                     ! write(6,*) 'a(',m,')    = ', a_au(m) 
                     ! write(6,*) 'cmf(',m,')  = ', cmf_au(m)
                     ! write(6,*) 'num(',m,')  = ', num_au(m) 
                     ! write(6,*) 'rad(',m,')  = ', rad_au(m) 
                     ! write(6,*) 'thl(',m,')  = ', thl_au(m) 
                     ! write(6,*) 'qt(',m,')   = ', qt_au(m) 
                     ! write(6,*) 'u(',m,')    = ', u_au(m) 
                     ! write(6,*) 'v(',m,')    = ', v_au(m) 
                     ! write(6,*) 'w(',m,')    = ', w_au(m) 
                     ! write(6,*) 'ql(',m,')   = ', ql_au(m) 
                     ! write(6,*) 'qi(',m,')   = ', qi_au(m) 
                     ! write(6,*)
                     ! CHECK

                     thl_u(kiss)  = thl_u(kiss) +  thl_au(m) * cmf_au(m)
                     qt_u(kiss)   =  qt_u(kiss) +   qt_au(m) * cmf_au(m)
                     u_u(kiss)    =   u_u(kiss) +    u_au(m) * cmf_au(m)
                     v_u(kiss)    =   v_u(kiss) +    v_au(m) * cmf_au(m) 
                     w_u(kiss)    =   w_u(kiss) +    w_au(m) * cmf_au(m) 
                     wa_u(kiss)   =  wa_u(kiss) +    w_au(m) *   a_au(m)
                     ql_u(kiss)   =  ql_u(kiss) +   ql_au(m) * cmf_au(m)  
                     qi_u(kiss)   =  qi_u(kiss) +   qi_au(m) * cmf_au(m)  
                     do mt = 1, ncnst
                        tr_u(kiss,mt) = tr_u(kiss,mt) + tr_au(m,mt) * cmf_au(m)  
                     enddo
                     qla_u(kiss)  = qla_u(kiss) +   ql_au(m) *   a_au(m)  
                     qia_u(kiss)  = qia_u(kiss) +   qi_au(m) *   a_au(m)  
                     rad_u(kiss)  = rad_u(kiss) +  rad_au(m)**2._r8 * num_au(m) ! Effective plume radius [ m ]
                     cmf_u(kiss)  = cmf_u(kiss) +  cmf_au(m) 
                     a_u(kiss)    =   a_u(kiss) +    a_au(m)
                     num_u(kiss)  = num_u(kiss) +  num_au(m)
                     ! Mar.07.2013. Add below line for use in the computation of the evolution of vertical velocity
                     !              of convective updraft and downdraft later for developing more complete 
                     !              scale-adaptive scheme.  
                     thva_u(kiss) =thva_u(kiss) +  thv_au(m) *   a_au(m)

                     ! ------------------------------------------------------------------------------------- !
                     ! Compute discretized surface flux being considered in the current convection scheme.   !
                     ! Below discrete computation is fully appropriate and should be used since the input    !
                     ! surface flux can be unreasonably large for some cases.                                !
                     ! Sep.12.2011. I double checked that my below 'ipartition' formula is perfect because   !
                     !              (1) it conserves column-integrated energy, and (2) it completely remove  !
                     !              the generation of unreasonable convective tendency in the lowest model   !
                     !              layer by convection, so that it grauantees computation of reasonable     ! 
                     !              surface heat, moisture, momentum, and tracer fluxes at surface in the    !  
                     !              following surface flux computation routine in the CAM. Also, I don't     !
                     !              need to modify any parts of CAM5 ( e.g., PBL scheme, surface flux        !
                     !              routine ), since all the required modifications are contained in the     !
                     !              UNICON in a fully reasonable way.                                        !
                     !              By using 'ipartition = 1' option, I don't need to combine 'symmetric     !
                     !              moist turbulence scheme' with the 'asymmetric moist turbulence scheme'   !
                     !              within the implicit iteration loop, so that I can save tremendous amount !    
                     !              of computation time.                                                     !
                     ! Mar.19.2014. I added 'qlflx_u(0),qiflx_u(0)' in the below lines for fully consistent  ! 
                     !              treatment in association with 'ipartition=1' and with the same tratment  !
                     !              for convective downdraft flux later.                                     !  
                     ! ------------------------------------------------------------------------------------- !

                   ! if( ipartition .eq. 1 .and. kiss .eq. 0 ) then

                        ! Below block is the new using 'thl_m'.
                        ! slflx_u(0) = slflx_u(0) + cp * exns0(0) * cmf_au(m) * ( thl_au(m)   -    thl_m )
                        ! qtflx_u(0) = qtflx_u(0) +                 cmf_au(m) * ( qt_au(m)    -     qt_m )
                        ! uflx_u(0)  =  uflx_u(0) +                 cmf_au(m) * ( u_au(m)     -      u_m )
                        ! vflx_u(0)  =  vflx_u(0) +                 cmf_au(m) * ( v_au(m)     -      v_m )
                        ! qlflx_u(0) = qlflx_u(0) +                 cmf_au(m) * ( ql_au(m)    -     ql_m )
                        ! qiflx_u(0) = qiflx_u(0) +                 cmf_au(m) * ( qi_au(m)    -     qi_m )
                        ! do mt = 1, ncnst
                        !    trflx_u(0,mt) = trflx_u(0,mt) +        cmf_au(m) * ( tr_au(m,mt) - tr_m(mt) )
                        ! enddo 
                        
                        ! Below block is the original using 'thl_b'.
                        slflx_u(0) = slflx_u(0) + cp * exns0(0) * cmf_au(m) * ( thl_au(m)   -    thl_b )
                        qtflx_u(0) = qtflx_u(0) +                 cmf_au(m) * ( qt_au(m)    -     qt_b )
                        uflx_u(0)  =  uflx_u(0) +                 cmf_au(m) * ( u_au(m)     -      u_b )
                        vflx_u(0)  =  vflx_u(0) +                 cmf_au(m) * ( v_au(m)     -      v_b )
                        qlflx_u(0) = qlflx_u(0) +                 cmf_au(m) * ( ql_au(m)    -     ql_b )
                        qiflx_u(0) = qiflx_u(0) +                 cmf_au(m) * ( qi_au(m)    -     qi_b )
                        do mt = 1, ncnst
                           trflx_u(0,mt) = trflx_u(0,mt) +        cmf_au(m) * ( tr_au(m,mt) - tr_b(mt) )
                        enddo

                   ! endif

                  enddo  ! do m = 1, nseg


                  ! Mean convective updraft values at the launching interface
                  ! By construction, 'cmf_u(kiss),a_u(kiss),num_u(kiss)' are non-zero.
                  ! Mar.07.2013. Add the computation of thva_u(kiss) for use in the computation of the evolution of vertical velocity
                  !              of convective updraft and downdraft later for developing more complete scale-adaptive scheme.  

                  thl_u(kiss)  = thl_u(kiss) / cmf_u(kiss)
                  qt_u(kiss)   =  qt_u(kiss) / cmf_u(kiss)
                  u_u(kiss)    =   u_u(kiss) / cmf_u(kiss)
                  v_u(kiss)    =   v_u(kiss) / cmf_u(kiss)
                  w_u(kiss)    =   w_u(kiss) / cmf_u(kiss)
                  wa_u(kiss)   =  wa_u(kiss) /   a_u(kiss)
                  ql_u(kiss)   =  ql_u(kiss) / cmf_u(kiss)
                  qi_u(kiss)   =  qi_u(kiss) / cmf_u(kiss)
                  do mt = 1, ncnst
                     tr_u(kiss,mt) = tr_u(kiss,mt) / cmf_u(kiss)
                  enddo
                  qla_u(kiss)  = qla_u(kiss) /   a_u(kiss)
                  qia_u(kiss)  = qia_u(kiss) /   a_u(kiss)
                  rad_u(kiss)  = sqrt( rad_u(kiss) / num_u(kiss) )    ! Effective plume radius [ m ]
                  gamw_u(kiss) =   w_u(kiss) /  wa_u(kiss)            ! Ratio of mass-flux-weighted to area weighted vertical velocity 
                  N_up(kiss)   = nseg                                 ! Total number of updraft plumes at the launching interface
                  thva_u(kiss) =thva_u(kiss) /   a_u(kiss)            ! Mean potential temperature within convective updraft.

                  ! CHECK
                  ! write(6,*)
                  ! write(6,*) 'UNICON: Mean source air properties at the launching interface'
                  ! write(6,*) 'thl_u   = ', thl_u(kiss) 
                  ! write(6,*) 'qt_u    = ', qt_u(kiss)
                  ! write(6,*) 'u_u     = ', u_u(kiss) 
                  ! write(6,*) 'v_u     = ', v_u(kiss) 
                  ! write(6,*) 'w_u     = ', w_u(kiss) 
                  ! write(6,*) 'wa_u    = ', wa_u(kiss) 
                  ! write(6,*) 'ql_u    = ', ql_u(kiss) 
                  ! write(6,*) 'qi_u    = ', qi_u(kiss) 
                  ! write(6,*) 'qla_u   = ', qla_u(kiss)
                  ! write(6,*) 'qia_u   = ', qia_u(kiss)
                  ! write(6,*) 'rad_u   = ', rad_u(kiss)
                  ! write(6,*) 'gamw_u  = ', gamw_u(kiss) 
                  ! write(6,*) 'N_up    = ', N_up(kiss) 
                  ! write(6,*) 'thva_u  = ', thva_u(kiss)
                  ! write(6,*)
                  ! CHECK

                  ! ---------------------------------------------------------- !
                  ! Diagnostic Output for Checking Final Source Air Properties !
                  ! ---------------------------------------------------------- !

                  ! July.14.2011. Note the difference in sigma_w between my semi-final one ( which does not include
                  !               organization term ) and Cathy's one ( which does include organization term ).

                  kw_out(i)        = kw

                  sigma_w_out(i)   = sigma_w
                  sigma_thl_out(i) = sigma_thl
                  sigma_qt_out(i)  = sigma_qt * 1.e3_r8
                  sigma_u_out(i)   = sigma_u
                  sigma_v_out(i)   = sigma_v 

                  !b Feb.06.2013. As of today, always choose 'i_persrc = 1' and remove this option.

                  !b           if( i_persrc .eq. 1 ) then
                  ! July.13.2011. In the semi-final configuration, 'tkePBLorg_old = wa_d(0,it=1)'
                  !               Thus, I don't need to multiply 'con_org_tke' in the below line
                  !               anymore, even though this is a diagnostic output. 
                  ! July.15.2011. In the below line, the 'tke_org_src' is lifted updraft vertical velocity by convective organization, not TKE.
                  ! July.16.2011. As an option, I can use alternative line for tke_org_out as below.
                  ! Aug.15.2011.  When prognostic meso-scale TKE is used induced by convective organization, 
                  !               use more simplified tke_org_out as the final line of below block.
                  ! tke_org_out(i) = org_src * sqrt( 2._r8 * ( 1._r8 / a_d_sfcTKEorg ) * cuorg / ( cc2_org * tau_org ) )
                  ! tke_org_out(i) = ( 2._r8 * cuorg ) / ( a_d_sfcTKEorg * cc2_org * cc0_org * pblhz )  
                  ! tke_org_out(i) = org_src * sqrt( 2._r8 * ( 1._r8 / a_d_sfcTKEorg ) * tkePBLorg_old )
                  ! tke_org_out(i) = tkePBLorg_old
                  tkes_out(i)    = tke1
                  ! thl_org_out(i) = org_src * cu_thlr(1) 
                  ! qt_org_out(i)  = org_src * cu_qtr(1) * 1.e3_r8
                  ! u_org_out(i)   = org_src * cu_ur(1) 
                  ! v_org_out(i)   = org_src * cu_vr(1)
                  ! thl_org_out(i) = org_src * thlPBLorg_old
                  ! qt_org_out(i)  = org_src *  qtPBLorg_old
                  ! u_org_out(i)   = org_src *   uPBLorg_old
                  ! v_org_out(i)   = org_src *   vPBLorg_old             
                  ! thl_org_out(i) =           thlPBLorg_old
                  ! qt_org_out(i)  =            qtPBLorg_old
                  ! u_org_out(i)   = 0._r8
                  ! v_org_out(i)   = 0._r8
                  ! Aug.31.2011. Following the wake parameterization, I am inserting new consistent and correct outputs.
                  w_org_out(i)   = delta_w_PBL   * cdelta_w
                  thl_org_out(i) = delta_thl_PBL * cdelta_s
                  qt_org_out(i)  = delta_qt_PBL  * cdelta_s
                  u_org_out(i)   = delta_u_PBL   * cdelta_s
                  v_org_out(i)   = delta_v_PBL   * cdelta_s
                  !b           elseif( i_persrc .eq. 2 ) then
                  !b               tke_org_out(i) = prep_old * 24._r8 * 3600._r8 * 0.2_r8 * pblhz / 1000._r8
                  !b               tkes_out(i)    = tke1
                  !b               thl_org_out(i) = 0._r8
                  !b               qt_org_out(i)  = tmp2 * 1.e3_r8
                  !b               u_org_out(i)   = 0._r8
                  !b               v_org_out(i)   = 0._r8
                  !b           endif

                  ! ---------------------------------------------------------- !
                  ! Diagnostic Output for Checking Final Source Air Properties !
                  ! ---------------------------------------------------------- !             

               else      ! 'if( k .eq. kiss + 1 )'

                  N_up(km)     = nseg_nondet 

               endif     ! 'if( k .eq. kiss + 1 )'
 
               ! ---------------------------------------------------------------------------------------------------------- !
               ! Mar.07.2013.                                                                                               !
               ! Compute grid-mean (which includes both environment and convective updraft) virtual potential temperature   !
               ! at the base interface for use in computing vertical evolution of vertical velocity of convective           !
               ! updraft and downdraft for developing a full scale-adaptive parameterization.                               !
               ! Note that 'thv_mean_t' will be computed later in a separate way depending on 'thv_au(m)' for each updraft. !       
               ! ---------------------------------------------------------------------------------------------------------- !

               thv_mean_b = a_u(km) * thva_u(km) + ( 1._r8 - a_u(km) ) * thv_b

               ! ---------------------------------------------------------------------------------------------------------------------------------------------- !
               ! Aug.31.2011. I introduced a new wake parameterization. Then, within the PBL, convective updraft should be mixed with the airs in the           ! 
               !              'off-wake' area. In the off-wake area, I can additionally force the updraft with additional 'cu_thlr'. However, in the            !
               !              lowest model layer ( and even in any layers within the PBL ), the 'cu_thlr' is direcly from the properties of detrained           !
               !              convective downdraft which is likely to constitute the properties of 'wake-airs' not the 'off-wake' airs. Thus, it is             !
               !              most reasonable not to use 'cu_thlr(qt,etc)' but only uses 'delta_thl(qt,u,v,tr)_PBL' within the PBL, while only                  !
               !              uses 'cu_thlr(qt,etc)' above the PBL. This exclusive and independent use between 'within the PBL layers' and                      !
               !              'above PBL layers' seems to be most reasonable and fully consistent with my conceptual view of density current parameterization.  !
               !              Note that I have assumed that the wake height is PBL depth.                                                                       !
               !              Also note that I am assuming 'delta_thl(qt,u,v,tr)_PBL' is equally applied in all the layers within the PBL.                      !
               !              From this view point of cuorg from the density current, it is clear that I should use a linear line ( tmp1 = org_ent ) instead of !
               !              continuous sinusoidal line in the below line.                                                                                     !
               !              Thus, within the PBL, I don't need to limit 'org_ent' based on 'cu_cmfr'.                                                         !
               !              I should carefully modify the code such that it also correctly treat two different cuorg_mxen values within 'iter' loop.          ! 
               !              In addition, the mixing of horizontal momentum should also be carefully considered.                                               !
               !              Finally, the mixing of convective downdraft must be also carefully considered in a fully consistent way as convective updraft :   !
               !              simply speaking, in the layers above the PBL, both the convective updraft and downdraft should be mixed with the same identical   !
               !              mixing environmental airs, however, in the layer below PBL top, convective downdraft should be mixed with 'within-wake' airs      !
               !              e.g., 'delta_thl_PBL_wake = - wake_ratio * delta_thl_PBL'. This also remove the ambiguity of the choice of mixing environmental   !
               !              airs that convective downdraft is mixed with. This removal of ambiguity is extremely good. But I should carefully and maybe       !
               !              differently treat the mixing of penetratively entrained downdraft airs.                                                           !
               !              Also, even though the mass of non-wake areas are abundant ( so that we don't need to limit org_ent ), the mass of wake ares is    !
               !              not necessarily large and also don't know the exact amount of mass flux in the wake area. Thus, it might be easy to mix with      !
               !              the grid-mean airs for convective downdraft. We can set this as an option. Since I did not impose a correct limit on the amount   !
               !              of mixing environmental airs that downdraft is mixed with ( note however that we can extract this information at least within     !
               !              PBL layers from the wake_ratio ), it may be good to assume that downdraft is mixed with the mean environmental airs through the   !
               !              whole layers.                                                                                                                     !
               !              I must carefully modify the code by considering all of these aspects.                                                             !
               ! KEY ASSUMPTIONS :                                                                                                                              !
               !  1. Within PBL layers: Regardless of cuorg_mxen or iter, convective updraft is mixed with 'off-wake airs'.                                     !
               !                        Difference of 'ql,qi' between the 'off-wake' and 'grid-mean' areas are simply neglected since it is likely that         !
               !                        there is no difference. However, we can include explicit 'ql,qi' from variable conversion layer if necessary.           !
               !                        Since delta_thl_PBL is height-independent constant, it should not change the internal slope.                            !                          
               !  2. Above  PBL layers: Follow previous code separating cuorg_mxen or iter, and explicit limit of 'org_ent' based on the 'sum' ( the amount of  !
               !                        available detrained airs.                                                                                               !
               !                                                                                                                                                !
               ! Sep.03.2011. Similar to the treatment above the PBL ( k .ge. kpblh ), we may be able to include 'tmp1 * cu_thlr(k)' terms if 'cu_thlr(k)' here !
               !              are defined only from the detrained airs all over the grid, not only into the wake area. However, current formulation seems to be ! 
               !              also reasonably OK, fully consistent with how I defined source air properties.                                                    !
               ! Sep.15.2011. Given the new specification of 'cu_thlr' as the value of previous time step's convective updraft instead of detrained airs,       ! 
               !              there is no conceptual at all in entraining this 'cu_thlr' in the lowest model layer. So, it seems to be clear that even within   !
               !              the PBL, I should entrain 'cu_thlr' by convective organization in addition to 'delta_thl_PBL'. This will impose a perfect         !
               !              internal model consistency with a full conceptual consistency also. Thus, i relocate the block to compute 'org_ent' right below   !
               !              this comment line.                                                                                                                !
               !              Note also that now 'cu_cmfr = ( am_u(k) * dp0(k) ) / ( g * dt )' not the 'cmf_u(km)' at the previous time step. When dz = 100 [m] !
               !              i.e., dp0(k) = 1000 [ Pa ], am_u(k) = 0.05, dt = 1800 [ s ], this new cu_cmfr = 0.003 which is one order smaller than the typical !
               !              cmf_u = 0.03. Thus the extremely strong response feature of the UNICON to this choice of 'previous time step's convective updraft !
               !              as the 'cu_cmfr' is likely to be much reduced which is good. Note that if plume radius is 500 ( 100 ) [ m ], the values of        ! 
               !              dp_m * eps0(m) * cmf_au(m) is roughly 0.0048 ( 0.024 ) assuming cmf_au = 0.03 for saturated updraft with enough in-cloud LWC+IWC, !
               !              which is enoughly larger than the cu_cmfr = 0.003. Thus, we can expect reasonable self-regulated model behavior with enough       !
               !              sensitivity to the amount of 'dp_m * eps0(m) * cmf_au(m)' and the new cu_cmfr. thus, larger plume will enoughly entrain cu_cmfr   !
               !              which in case of smaller plume, cu_cmfr will be only a portion of total mixing environmental airs entrained. Thus the new setting !
               !              of 'cu_cmfr = ( am_u(k) * dp0(k) ) / ( g * dt )' provides a fully physically reasonable interaction to the whole system, which is !
               !              extremely good.                                                                                                                   !
               ! ---------------------------------------------------------------------------------------------------------------------------------------------- !

               ! --------------------------------------------------------------------------- !
               ! Environmental airs involved in buoyancy sorting via mesoscale organization. !
               ! This can be mixtures of ensemble-mean environmental air and detrained airs. !
               ! This is used only for the mixing purpose not for diabatic buoyancy forcing. !
               ! Assuming each updraft equally reaches to dp0(k), solve discrete ( not       !
               ! continuous ) mass flux equation to compute total amount of updraft mass that!
               ! is involved in the buoyancy sorting.                                        !   
               ! The available mass per unit time per unit area [ kg/s/m^2 ]                 !
               !     Environmental airs : ae(k)*dp_m/g/dt                                    !
               !     Detrained airs     : cmf_r_org(k)                                       !
               !     The updraft mass involved in the buoyancy sorting : sum                 !
               ! --------------------------------------------------------------------------- !

               ! --------------------------------------------------------------------------------------------- !
               ! Compute (1) fractional mixing rate, eps0 and (2) organization factor for lateral entrainment. !
               !   . sum :     The estimate of updraft mass flux that will be involved in                      ! 
               !               buoyancy sorting at the current time step. [ kg/m^2/s ]                         !
               !   . cu_cmfr : Total amount of detrained mass at the previous time [ kg/m^2/s ]                !
               ! --------------------------------------------------------------------------------------------- !

               sum = 0._r8
               do m = 1, N_up(km)
                  ! -------------------------------------------------------------------- !
                  !                                                                      !
                  ! Fractional Mixing Rates eps0 [ 1/Pa ] : This is the key of the model !
                  ! Aug.15.2011. Below block of computing 'eps0(m)' is used only for     !
                  !              computing 'sum' and so constrain 'org_ent'.             !
                  !              Later below, precise 'eps0(m)' will be computed again.  !
                  !              In order to ensure perfectly safe computation, we       !
                  !              compute 'fmix(m)' and 'xc(m)' here, which will increase !
                  !              computation time and require the iteration loop. It is  !
                  !              really unnecessary to do this complex computation here. !
                  !              The safest way to ensure full consistency is to assume  !
                  !              (1) fmix = fmix_max' and (2) xc(m) = xc_min. These two  !
                  !              together compute the maximum amount of the updraft airs !
                  !              involved in the mixing with the environment air ( sum ).!
                  !              Thus, I use these (1) and (2) ONLY in this block for    !
                  !              computing 'sum' and limiting 'org_ent'. This impose a   !
                  !              fully consistent & most conservative safe constraint.   !
                  !              Again, precise computation of 'eps0(m)' is done later.  !
                  !              If I use 0.5 instead of xc_min as the argument of       !
                  !              subroutine 'compute_epsdelnod', I can obtain less       !
                  !              conservative constraint, which can induce inconsistency !
                  !              for some very unusual case but is more generously       !
                  !              applicable.                                             ! 
                  !              As an more accurate approach, I can solve subroutine    !
                  !              buosorts_UW here, but it will increase computation time !
                  !              without comparable amount of effects.                   ! 
                  !              As a win-win strategy to save computation time but with !
                  !              more precise results, use 'thv_au(m) - thv_b' to check  !
                  !              which one ( xc_min or 0.5 ) is more reasonable.         !
                  !              Below treat the penetrative entrainment zone in a more  !
                  !              realistic way.                                          !
                  ! Aug.15.2011. I removed fmix_max since it is set to be infinite.      !
                  !              Note that below limiter is inevitable approximation     !
                  !              that can be refined in future by consuming more         !
                  !              computation time in future.                             !  
                  ! -------------------------------------------------------------------- !
                  ! Aug.23.2011. I restored to the very original formulation.
                  ! Aug.09.2011. Below setting of tmp2 = 1._r8 turns out to be very important for reducing
                  !              PRECT in this cm_thlr = thlr simulation.
                  ! Aug.13.2011. Conceptually, however, it is reasonable to take tmp2 > 1. This large tmp2
                  !              also helps to maintain reasonable Kelvin wave as well as improving
                  !              the phase of diurnal cycle. So, I reset this to 2._r8 instead of 1._r8.
                  ! Aug.31.2011. Since 'eps0(m)' will be recomputed later using the exactly same formula, it is completely OK
                  !              to put below block within 'elseif( k .ge. kpblh ) then' block.
                  !              Note that 'sum' and 'org_ent' computed within this if block is not used anywhere outside of
                  !              this if block. Thus, this 'if block' works completely correctly without any problem.
                  ! Oct.16.2011. Add the option of 'i_eps0' by simply assuming that xc = 0.5 for this purpose.
                  !              This choice of 0.5 is designed to save computation time but obtain non-biased results.
                  !              Note that if xc = 0.5, it becomes fmix = 1.
                  ! Oct.24.2011. Add a third option which additionally includes the dependence on the environmental RH.
                  !              This is the most perfect, physically-reasonable approach, and analogous to the 
                  !              evaporative enhancement of entrainment rate at the stratocumulus-topped PBL, which
                  !              provides much more confidence on this final formulation for eps0. The evaporative
                  !              enhancement parameter 'cevpeps0' should be in the range of '5 < cevpeps0 < 100'.    
                  !              For this computation of org_ent, I simply use the RH of environmental air, not 
                  !              the mixing environmental air for simplicity, which is a reasonably good assumption.

                  if( i_eps0 .eq. 0 ) then
                     ! tmp1 = max( 0._r8, ( ql_au(m) + qi_au(m) ) / 1.e-3_r8 )  
                     tmp1 = max( 0._r8, sqrt( ( ql_au(m) + qi_au(m) ) / 1.e-3_r8 ) )  
                     ! Below is from 'unicon.F90.016' 
                     ! tmp1 = min( 1._r8, max( 0._r8, ( ql_au(m) + qi_au(m) ) / 1.e-4_r8 ) )
                     tmp2 = 1._r8 + cevpeps0 * tmp1
                     eps0(m) = tmp2 * c0 / max( rad_au(m), Ro_eps0 ) / ( rho_b * g )
                  elseif( i_eps0 .eq. 1 ) then
                     ! tmp1 = ( ( ql_au(m) + qi_au(m) ) / 1.e-3_r8 ) * ( 1._r8 - rh0bot(k) )
                     ! tmp1 = ( ( ql_au(m) + qi_au(m) ) / 1.e-3_r8 ) * ( 1._r8 - max( 0.5_r8, min( 0.8_r8, rh0bot(k) ) ) )
                     ! tmp1 = ( ( ql_au(m) + qi_au(m) ) / 1.e-3_r8 ) * ( 1._r8 - max( 0.0_r8, min( 1.0_r8, rh0bot(k) ) ) )
                     ! tmp1 = sqrt( ( ( ql_au(m) + qi_au(m) ) / 1.e-3_r8 ) * ( 1._r8 - max( 0.0_r8, min( 0.85_r8, rh0bot(k) ) ) ) )
                     tmp1 = sqrt( ( ( ql_au(m) + qi_au(m) ) / 1.e-3_r8 ) * ( 1._r8 - max( 0.0_r8, min( 1.00_r8, rh0bot(k) ) ) ) )
                     ! tmp1 = sqrt( min( 1._r8, max( 0._r8, ( ql_au(m) + qi_au(m) ) / 1.e-4_r8 ) ) * ( 1._r8 - max( 0.0_r8, min( 1.00_r8, rh0bot(k) ) ) ) )   
                     tmp2 = 1._r8 + cevpeps0 * tmp1
                     eps0(m) = tmp2 * c0 / max( rad_au(m), Ro_eps0 ) / ( rho_b * g )
                  elseif( i_eps0 .eq. 2 ) then
                     call compute_epsdelnod( 'PDFbsQ', 0.5_r8, tmp1, tmp2 )                  
                     eps0(m) = c0 / max( rad_au(m), Ro_eps0 ) / ( rho_b * g ) / tmp1
                  endif

                  ! Below is the original advanced formulation.
                  ! if( thv_au(m) - thv_b .ge. -1._r8 ) then
                  !     tmp3 = 0.5_r8
                  ! else
                  !     tmp3 = xc_min
                  ! endif
                  ! call compute_epsdelnod( 'PDFbsQ', tmp3, tmp1, tmp2 )
                  ! eps0(m) = c0 / max( rad_au(m), Ro_eps0 ) / ( rho_b * g ) / tmp1

                  ! -------------------------------------------------------------------------------------------------- !
                  ! Jan.30.2013. Impose a constraint on 'eps0(m)' here. On this day, we are directly imposing          ! 
                  !              eps0(m) using the specified 'fmix_frac = ln(10)' instead of imposing 'eps' and 'del'. ! 
                  !              Thus, it is perfectly reasonable to impose eps0(m) here as well as imposing later     ! 
                  !              for the full consistency of the model.                                                !
                  ! Feb.06.2013. Always choose 'exp_cmf = 1' from this day.                                            !                                                       
                  ! Nov.18.2013. Impose a perfectly physical, stable limiter using 'epsz0_max' instead of 'fmix_frac'. !
                  ! -------------------------------------------------------------------------------------------------- !

                  if( exp_cmf .eq. 1 ) then ! Original exponential computation of cmf_u and cmf_d. 
                     ! Below is a old limiter before Nov.18.2013.
                     ! eps0(m) = min( eps0(m), fmix_frac / dp_m )
                     ! Below is a new limiter on Nov.18.2013. 
                     ! Since 'epsz0_max' is specified in unit of [1/m], I should multiply 'dz_m' in the below
                     ! line, where 'dz_m' is already-well defined above.
                     eps0(m) = min( eps0(m), log( 1._r8 + epsz0_max * dz_m ) / dp_m )
                  endif

                  ! if( k .ge. kpblh ) eps0(m) = 0._r8             
                  ! sum = sum + fmix_max * dp_m * eps0(m) * cmf_au(m) 
                  sum = sum +            dp_m * eps0(m) * cmf_au(m) 
                  ! ---------------------------------------------------------------------------- !
                  ! The 'eps0' computed above is used to limit 'org_ent' below. Other than this, !
                  ! this 'eps0' is not used in other places until 'xc' is computed from the      !
                  ! buoyancy sorting subroutine later in buosorts_UW. Then, precise 'eps0(m)'    !
                  ! will be computed again.                                                      !
                  ! ---------------------------------------------------------------------------- !
               enddo

               ! ----------------------------------------------------------------------------------------- !
               ! Aug.01.2011. Brian Juwon Park's 10th Birthday.                                            !
               !             'cuorg' is replaced by 'cuorg_mxen' in the below line computing 'org_ent' for ! 
               !              treating mixing with several mixing environmental airs.                      !
               !              cuorg_mxen = 0 ( iter = 1 ) or 1 ( iter = 2 ).                               !
               ! ----------------------------------------------------------------------------------------- !

               if( iorg_ent .eq. 1 ) then
                  org_ent = min( fac_org_ent * cuorg_mxen , cu_cmfr(k) / max( sum, nonzero ) ) ! The second argument sets the upper limit of org.
               else
                  org_ent = 0._r8
               endif
               org_ent = max( 0._r8, min( 1._r8, org_ent ) ) 

               ! ----------------------------------------------- !
               ! Define environmental properties using 'org_ent' !
               ! ----------------------------------------------- !

               ! Apr.22.2011. Below assumes that detrained airs are uniformly ( same for top, middle, bottom )
               !              added in each layer, which is pefectly reasonable and consistent with the other
               !              part of the code.
               ! Jul.13.2011. Note that I used below 'thle_b =  max( 0._r8, thl_b  + org_ent * cu_thlr(k) )'
               !              instead of 'thle_b = ( 1._r8 - org_ent ) * thl_b  + org_ent * cu_thlr(k) ' where
               !              cu_thlr(k) is not the anomaly but explicit temperature. This treatment is made
               !              to be consistent with the corresponding perturbation of updraft source air
               !              properties at surface, i.e., 'thl_au(m) = thl_b  + sigma_thl * alpha(m) + org_src * cu_thlr(1)'.
               !              The reason why I used below anomalous formula is because not only grid-mean value but also
               !              detrained value can be changed by subsequent non-convective processes between current and
               !              next time step. 
               ! Jul.29.2011. Similar to the 'org_rad', allows continuous sinusoidal organization line. This option is
               !              added with a hope that it develops deep convection in a smooth way, so that MJO can be
               !              well simulated.
               ! Aug.01.2011. Brian Juwon Park' 10th Birthday. 
               !              Instead of mixing with a certain averaged mixing environmental airs, I may need to perform 
               !              an ensemble of explicit mixing since vertical evolutions of updraft ( also downdraft ) mass flux,
               !              vertical velocity, and conservative scalars are highly non-linear to the properties of mixing 
               !              environmental airs. Note that 'cu_thlr' and others are anomaly fields.
               ! Aug.31.2011. I introduced a new wake parameterization. Then, within the PBL, convective updraft should be mixed with the airs in the
               !              'off-wake' area. In the off-wake area, I can additionally force the updraft with additional 'cu_thlr'. However, in the
               !              lowest model layer ( and even in any layers within the PBL ), the 'cu_thlr' is direcly from the properties of detrained
               !              convective downdraft which is likely to constitute the properties of 'wake-airs' not the 'off-wake' airs. Thus, it is 
               !              most reasonable not to use 'cu_thlr(qt,etc)' but only uses 'delta_thl(qt,u,v,tr)_PBL' within the PBL, while only
               !              uses 'cu_thlr(qt,etc)' above the PBL. This exclusive and independent use between 'within the PBL layers' and 
               !              'above PBL layers' seems to be most reasonable and fully consistent with my conceptual view of density current parameterization.
               !              Note that I have assumed that the wake height is PBL depth. 
               !              Also note that I am assuming 'delta_thl(qt,u,v,tr)_PBL' is equally applied in all the layers within the PBL.
               !              From this view point of cuorg from the density current, it is clear that I should use a linear line ( tmp1 = org_ent ) instead of
               !              continuous sinusoidal line in the below line.
               !              Thus, within the PBL, I don't need to limit 'org_ent' based on 'cu_cmfr'. 
               !              I should carefully modify the code such that it also correctly treat two different cuorg_mxen values within 'iter' loop.
               !              In addition, the mixing of horizontal momentum should also be carefully considered.
               !              Finally, the mixing of convective downdraft must be also carefully considered in a fully consistent way as convective updraft :
               !              simply speaking, in the layers above the PBL, both the convective updraft and downdraft should be mixed with the same identical
               !              mixing environmental airs, however, in the layer below PBL top, convective downdraft should be mixed with 'within-wake' airs
               !              e.g., 'delta_thl_PBL_wake = - wake_ratio * delta_thl_PBL'. This also remove the ambiguity of the choice of mixing environmental
               !              airs that convective downdraft is mixed with. This removal of ambiguity is extremely good.
               !              I must carefully modify the code by considering all of these aspects.
               ! Sep.15.2011. As mentioned above, below computation of 'tmp1' is moved here for equal application in all the atmospheric layers including
               !              the layers within PBL. This will impose a full and perfect physical consistency.
               !              In future, I can remove below if block by defining tmp3 = delta_thl_PBL within PBL but tmp3 = 0 above PBL and adding tmp3 into
               !              thle_b(k) to save computation time.
               ! Mar.07.2013. I muptiplied 'cdelta_s' in front of 'delta_***_PBL' variables below since within PBL, convective updraft
               !              is assumed to rise into 'cadj_area * au_base' instead of a_U, where the anomalous concentration of
               !              conservative scalar is 'cdelta_s * delta_***_PBL'. 
               !              When updraft rises within PBL, its area fraction may increase within PBL, so that it can be larger than the area with concentrated
               !              organization-related perturbation within a_U. However, since cadj_area = 3 or 5 (enoughly larger than 1), this is not likely to
               !              happen. So, my below setting is almost perfect in conceptual point of view.  
               !              By doing this, I can minimize the dilution of convective updraft upto the PBL top, which seems to be much more reasonable 
               !              considering what is happening in nature. 
               !              Note also that since the increase of updraft momentum is influenced by the updraft buoyancy computed as the anomaly 
               !              from the grid-mean virtual potential temperature (not with respect to the environmental mean), below setting does not
               !              much influence vertical evolution of convective updraft velocity compared to previous setting without 'cdelta_s'.
               !              Thus, in summary, at the PBL top, convective updraft can sustain strong vertical velocity as before, but with much
               !              less dilution, which is perfect.   

               ! Option.1. Linear line.
               tmp1    = org_ent
               ! Option.2. Continuous sinusoidal organization line.
               ! tmp1    = 0.5_r8 * ( 1._r8 + sin( 3.141592_r8 * ( org_ent - 0.5_r8 ) ) )

               if( k .lt. kpblh ) then

                  if( iorg_detrain .eq. 4 ) then  ! Mixing environmental air is Convective Updraft 

                     thle_b(k)       =  max( 0._r8,    thl_b + tmp1 *   cu_thlr(k) +    cdelta_s * delta_thl_PBL )
                     thle_m(k)       =  max( 0._r8,    thl_m + tmp1 *   cu_thlr(k) +    cdelta_s * delta_thl_PBL )
                     thle_t(k)       =  max( 0._r8,    thl_t + tmp1 *   cu_thlr(k) +    cdelta_s * delta_thl_PBL )

                     qte_b(k)        =  max( qmin(1),   qt_b + tmp1 *    cu_qtr(k) +     cdelta_s * delta_qt_PBL )
                     qte_m(k)        =  max( qmin(1),   qt_m + tmp1 *    cu_qtr(k) +     cdelta_s * delta_qt_PBL )
                     qte_t(k)        =  max( qmin(1),   qt_t + tmp1 *    cu_qtr(k) +     cdelta_s * delta_qt_PBL )

                     ue_b(k)         =     (             u_b + tmp1 *     cu_ur(k) +      cdelta_s * delta_u_PBL )
                     ue_m(k)         =     (             u_m + tmp1 *     cu_ur(k) +      cdelta_s * delta_u_PBL )
                     ue_t(k)         =     (             u_t + tmp1 *     cu_ur(k) +      cdelta_s * delta_u_PBL )

                     ve_b(k)         =     (             v_b + tmp1 *     cu_vr(k) +      cdelta_s * delta_v_PBL )
                     ve_m(k)         =     (             v_m + tmp1 *     cu_vr(k) +      cdelta_s * delta_v_PBL )
                     ve_t(k)         =     (             v_t + tmp1 *     cu_vr(k) +      cdelta_s * delta_v_PBL )

                     we_b(k)         =     (                                              cdelta_w * delta_w_PBL )
                     we_m(k)         =     (                                              cdelta_w * delta_w_PBL )
                     we_t(k)         =     (                                              cdelta_w * delta_w_PBL )

                     qle_b(k)        =  max( 0._r8,     ql_b + tmp1 *    cu_qlr(k) +                       0._r8 )
                     qle_m(k)        =  max( 0._r8,     ql_m + tmp1 *    cu_qlr(k) +                       0._r8 )
                     qle_t(k)        =  max( 0._r8,     ql_t + tmp1 *    cu_qlr(k) +                       0._r8 )

                     qie_b(k)        =  max( 0._r8,     qi_b + tmp1 *    cu_qir(k) +                       0._r8 )
                     qie_m(k)        =  max( 0._r8,     qi_m + tmp1 *    cu_qir(k) +                       0._r8 )
                     qie_t(k)        =  max( 0._r8,     qi_t + tmp1 *    cu_qir(k) +                       0._r8 )

                     do mt = 1, ncnst
                        tre_b(k,mt)  =  max( qmin(mt), tr_b(mt) + tmp1 * cu_trr(k,mt) + cdelta_s * delta_tr_PBL(mt) )
                        tre_m(k,mt)  =  max( qmin(mt), tr_m(mt) + tmp1 * cu_trr(k,mt) + cdelta_s * delta_tr_PBL(mt) )
                        tre_t(k,mt)  =  max( qmin(mt), tr_t(mt) + tmp1 * cu_trr(k,mt) + cdelta_s * delta_tr_PBL(mt) )
                     enddo

                     ! Sep.18.2011. Below is added to mimic 031j which produced very good MJO.

                     ssthle(k) =  ssthl0(k) * ( 1._r8 - tmp1 )
                     ssqte(k)  =   ssqt0(k) * ( 1._r8 - tmp1 )
                     ssue(k)   =    ssu0(k) * ( 1._r8 - tmp1 )
                     ssve(k)   =    ssv0(k) * ( 1._r8 - tmp1 )
                     ssqle(k)  =   ssql0(k) * ( 1._r8 - tmp1 )
                     ssqie(k)  =   ssqi0(k) * ( 1._r8 - tmp1 )
                     do mt = 1, ncnst
                        sstre(k,mt) = sstr0(k,mt) * ( 1._r8 - tmp1 ) 
                     enddo

                  else

                     thle_b(k)       =  max( 0._r8,    thl_b +               cdelta_s * delta_thl_PBL )
                     thle_m(k)       =  max( 0._r8,    thl_m +               cdelta_s * delta_thl_PBL )
                     thle_t(k)       =  max( 0._r8,    thl_t +               cdelta_s * delta_thl_PBL )
                     
                     qte_b(k)        =  max( qmin(1),  qt_b +                cdelta_s * delta_qt_PBL )
                     qte_m(k)        =  max( qmin(1),  qt_m +                cdelta_s * delta_qt_PBL )
                     qte_t(k)        =  max( qmin(1),  qt_t +                cdelta_s * delta_qt_PBL )

                     ue_b(k)         =     (             u_b +                 cdelta_s * delta_u_PBL )
                     ue_m(k)         =     (             u_m +                 cdelta_s * delta_u_PBL )
                     ue_t(k)         =     (             u_t +                 cdelta_s * delta_u_PBL )

                     ve_b(k)         =     (             v_b +                 cdelta_s * delta_v_PBL )
                     ve_m(k)         =     (             v_m +                 cdelta_s * delta_v_PBL )
                     ve_t(k)         =     (             v_t +                 cdelta_s * delta_v_PBL )

                     we_b(k)         =     (                                   cdelta_w * delta_w_PBL )
                     we_m(k)         =     (                                   cdelta_w * delta_w_PBL )
                     we_t(k)         =     (                                   cdelta_w * delta_w_PBL )

                     qle_b(k)        =  max( 0._r8,     ql_b +                                  0._r8 )
                     qle_m(k)        =  max( 0._r8,     ql_m +                                  0._r8 )
                     qle_t(k)        =  max( 0._r8,     ql_t +                                  0._r8 )

                     qie_b(k)        =  max( 0._r8,     qi_b +                                  0._r8 )
                     qie_m(k)        =  max( 0._r8,     qi_m +                                  0._r8 )
                     qie_t(k)        =  max( 0._r8,     qi_t +                                  0._r8 )

                     do mt = 1, ncnst
                        tre_b(k,mt)  =  max( qmin(mt), tr_b(mt) +         cdelta_s * delta_tr_PBL(mt) )
                        tre_m(k,mt)  =  max( qmin(mt), tr_m(mt) +         cdelta_s * delta_tr_PBL(mt) )
                        tre_t(k,mt)  =  max( qmin(mt), tr_t(mt) +         cdelta_s * delta_tr_PBL(mt) )
                     enddo

                     ! Sep.18.2011. Below is added to mimic 031j which produced very good MJO.
                     !              The rationalie is that 'delta_thl_PBL' is uniform across the whole PBL depth,
                     !              so that it should not change the pre-computed slope. 

                     ssthle(k) =  ssthl0(k)
                     ssqte(k)  =   ssqt0(k)
                     ssue(k)   =    ssu0(k)
                     ssve(k)   =    ssv0(k)
                     ssqle(k)  =   ssql0(k)
                     ssqie(k)  =   ssqi0(k)
                     do mt = 1, ncnst
                        sstre(k,mt) = sstr0(k,mt)
                     enddo

                  endif

               elseif( k .ge. kpblh ) then

                  thle_b(k)       =  max( 0._r8,    thl_b + tmp1 *   cu_thlr(k) )
                  thle_m(k)       =  max( 0._r8,    thl_m + tmp1 *   cu_thlr(k) )
                  thle_t(k)       =  max( 0._r8,    thl_t + tmp1 *   cu_thlr(k) )

                  qte_b(k)        =  max( qmin(1),   qt_b + tmp1 *    cu_qtr(k) )
                  qte_m(k)        =  max( qmin(1),   qt_m + tmp1 *    cu_qtr(k) )
                  qte_t(k)        =  max( qmin(1),   qt_t + tmp1 *    cu_qtr(k) )

                  ue_b(k)         =     (             u_b + tmp1 *     cu_ur(k) )
                  ue_m(k)         =     (             u_m + tmp1 *     cu_ur(k) )
                  ue_t(k)         =     (             u_t + tmp1 *     cu_ur(k) )

                  ve_b(k)         =     (             v_b + tmp1 *     cu_vr(k) )
                  ve_m(k)         =     (             v_m + tmp1 *     cu_vr(k) )
                  ve_t(k)         =     (             v_t + tmp1 *     cu_vr(k) )

                  we_b(k)         =  0._r8
                  we_m(k)         =  0._r8
                  we_t(k)         =  0._r8

                  qle_b(k)        =  max( 0._r8,     ql_b + tmp1 *    cu_qlr(k) )
                  qle_m(k)        =  max( 0._r8,     ql_m + tmp1 *    cu_qlr(k) )
                  qle_t(k)        =  max( 0._r8,     ql_t + tmp1 *    cu_qlr(k) )

                  qie_b(k)        =  max( 0._r8,     qi_b + tmp1 *    cu_qir(k) )
                  qie_m(k)        =  max( 0._r8,     qi_m + tmp1 *    cu_qir(k) )
                  qie_t(k)        =  max( 0._r8,     qi_t + tmp1 *    cu_qir(k) )

                  do mt = 1, ncnst
                     tre_b(k,mt)  =  max( qmin(mt), tr_b(mt) + tmp1 * cu_trr(k,mt) )
                     tre_m(k,mt)  =  max( qmin(mt), tr_m(mt) + tmp1 * cu_trr(k,mt) )
                     tre_t(k,mt)  =  max( qmin(mt), tr_t(mt) + tmp1 * cu_trr(k,mt) )
                  enddo

                  ! Sep.18.2011. Below is added to mimic 031j which produced very good MJO.

                  ssthle(k) =  ssthl0(k) * ( 1._r8 - tmp1 )
                  ssqte(k)  =   ssqt0(k) * ( 1._r8 - tmp1 )
                  ssue(k)   =    ssu0(k) * ( 1._r8 - tmp1 )
                  ssve(k)   =    ssv0(k) * ( 1._r8 - tmp1 )
                  ssqle(k)  =   ssql0(k) * ( 1._r8 - tmp1 )
                  ssqie(k)  =   ssqi0(k) * ( 1._r8 - tmp1 )
                  do mt = 1, ncnst
                     sstre(k,mt) = sstr0(k,mt) * ( 1._r8 - tmp1 ) 
                  enddo

                  ! CHECK
                  !  if( get_nstep() .eq. 614 .or. get_nstep() .eq. 616 .or. get_nstep() .eq. 618 ) then
                  !  write(6,*)
                  !  write(6,*) 'UNICON: Mean and Organized environmental airs mixed with convective updraft at the base interface'
                  !  write(6,*) 'nstep = ', get_nstep()
                  !  write(6,*) 'Layer Index, cuorg, org_ent = ', k, cuorg, org_ent 
                  !  write(6,*) 'thle_b, thl_b, cu_thlr(k)    = ', thle_b(k), thl_b(k), cu_thlr(k)
                  !  write(6,*) 'qte_b, qt_b, cu_qtr(k)       = ', qte_b(k), qt_b(k), cu_qtr(k)
                  !  write(6,*) 'ue_b, u_b, cu_ur(k)          = ', ue_b(k), u_b(k), cu_ur(k) 
                  !  write(6,*) 've_b, v_b, cu_vr(k)          = ', ve_b(k), v_b(k), cu_vr(k) 
                  !  write(6,*) 'qle_b, ql_b, cu_qlr(k)       = ', qle_b(k), ql_b(k), cu_qlr(k) 
                  !  write(6,*) 'qie_b, qi_b, cu_qir(k)       = ', qie_b(k), qi_b(k), cu_qir(k) 
                  !  write(6,*)
                  !  endif
                  ! CHECK

                  ! In case of 'org_ent = 0', convective momemtum transport due to vertical PGF can be
                  ! unreasonably zero due to ssue = ssve = 0. 

                  ! CHECK
                  ! write(6,*)
                  ! write(6,*) 'UNICON: Mean and Organized environmental airs mixed with convective updraft at the base interface'
                  ! write(6,*) 'Layer Index      = ', k 
                  ! write(6,*) 'thl_b, thle_b    = ', thl_b(k), thle_b(k) 
                  ! write(6,*) 'qt_b, qte_b      = ', qt_b(k), qte_b(k) 
                  ! write(6,*) 'u_b, ue_b        = ', u_b(k), ue_b(k) 
                  ! write(6,*) 'v_b, ve_b        = ', v_b(k), ve_b(k) 
                  ! write(6,*)
                  ! CHECK

               endif ! End of 'if( k .lt. kpblh )' and 'elseif( k .ge. kpblh)' blocks to define the properties of mixing environmental airs.

               ! Sep.15.2011. Note that on this day, the same slope should be used in 
               !              all the layers ( both 'k .lt. kpblh' and 'k .ge. kpblh' ).
               !              So, below block is located outside of 'if' since it is now common.
               ! Sep.15.2011. Since 'cu_thlr' which is anomaly field is assumed to be uniform in each layer, there should be no change of ssthl0(k).
               !              So, I fixed the slope to the original one. This was clearly a bug.

               ! ssthle(k) =  ssthl0(k)
               ! ssqte(k)  =   ssqt0(k)
               ! ssue(k)   =    ssu0(k)
               ! ssve(k)   =    ssv0(k)
               ! ssqle(k)  =   ssql0(k)
               ! ssqie(k)  =   ssqi0(k)
               ! do mt = 1, ncnst
               !    sstre(k,mt) = sstr0(k,mt)
               ! enddo

               ! ssthle(k) =  ssthl0(k) * ( 1._r8 - tmp1 )
               ! ssqte(k)  =   ssqt0(k) * ( 1._r8 - tmp1 )
               ! ssue(k)   =    ssu0(k) * ( 1._r8 - tmp1 )
               ! ssve(k)   =    ssv0(k) * ( 1._r8 - tmp1 )
               ! ssqle(k)  =   ssql0(k) * ( 1._r8 - tmp1 )
               ! ssqie(k)  =   ssqi0(k) * ( 1._r8 - tmp1 )
               ! do mt = 1, ncnst
               !    sstre(k,mt) = sstr0(k,mt) * ( 1._r8 - tmp1 ) 
               ! enddo

               ! ------------------------------------ !
               !                                      !
               ! Individual Updraft Plume Computation !
               !                                      ! 
               ! ------------------------------------ !

               ! ---------------------------------------- !
               ! Initialization of updraft segment arrays !
               ! ---------------------------------------- !

               ytop(:nseg)               = 0._r8       ! 0 : Not reach the top interface, 1 : Reach the top interface 
               ! Apr.21.2011. Remove explicit dependency on 'ybot(m)=1' to save computation time.
               ! ybot(:nseg)               = 0._r8       ! 0 : Remain in the current layer, 1 : Move down into the lower layer
               xc(:nseg)                 = 0._r8       
               xs(:nseg)                 = 0._r8       
               eeps(:nseg)               = 0._r8
               ddel(:nseg)               = 0._r8
               eps(:nseg)                = 0._r8
               del(:nseg)                = 0._r8
               ! eps0(:nseg)               = 0._r8
               xe_min(:nseg)             = 0._r8
               xe_max(:nseg)             = 0._r8
               dpa(:nseg)                = 0._r8
               dza(:nseg)                = 0._r8
               ptop(:nseg)               = 0._r8
               ztop(:nseg)               = 0._r8
               fmix(:nseg)               = 0._r8
               f_wu(:nseg)               = 0._r8

               thl_aut(:nseg)            = 0._r8
               qt_aut(:nseg)             = 0._r8
               u_aut(:nseg)              = 0._r8
               v_aut(:nseg)              = 0._r8
               ql_aut(:nseg)             = 0._r8
               qi_aut(:nseg)             = 0._r8
               cmf_aut(:nseg)            = 0._r8
               w_aut(:nseg)              = 0._r8
               a_aut(:nseg)              = 0._r8
               num_aut(:nseg)            = 0._r8
               rad_aut(:nseg)            = 0._r8
               tr_aut(:nseg,:ncnst)      = 0._r8
               thv_aut(:nseg)            = 0._r8
               S_t_ql_au(:nseg)          = 0._r8 
               S_t_qi_au(:nseg)          = 0._r8 
          !ice frac_ice_aut(:nseg)       = 0._r8

               evp_thll_au(:nseg)        = 0._r8         
               evp_qtl_au(:nseg)         = 0._r8
               evp_thli_au(:nseg)        = 0._r8         
               evp_qti_au(:nseg)         = 0._r8
               prep_thll_au(:nseg)       = 0._r8         
               prep_qtl_au(:nseg)        = 0._r8
               prep_thli_au(:nseg)       = 0._r8         
               prep_qti_au(:nseg)        = 0._r8
               eff_ql_au(:nseg)          = 0._r8
               eff_qi_au(:nseg)          = 0._r8
               PGF_u_au(:nseg)           = 0._r8
               PGF_v_au(:nseg)           = 0._r8
               evp_tr_au(:nseg,:ncnst)   = 0._r8
               prep_tr_au(:nseg,:ncnst)  = 0._r8         
               !        wdep_tr_au(:nseg,:ncnst)  = 0._r8         
               eff_tr_au(:nseg,:ncnst)   = 0._r8

               do m = 1, N_up(km)

                  ! -------------------------------------------------- !
                  ! Compute R-dependent buoyancy coefficient, rbuoy_up !
                  ! -------------------------------------------------- !

                  ! Mar.21.2011. Ramp 'rbuoy_up' between 0.33 and 1.0 for R_buomin = 600 and R_buomax = 200 [ m ]
                  ! Apr.12.2011. R_buomin and R_buomax are internally computed instead of specifying as parameter.
                  ! May.22.2011. Comment out 'R_buomax' for sensitivity test.
                  ! Mar.27.2012. New formula based on a single 'R_buo' is added, which replaces 'rbuoy_up' computation.

                  ! R_buomin = Ro_max + 2._r8 * sigmaR_max
                  ! R_buomax = Ro_min + 2._r8 * sigmaR_min 

                  ! Apr.21.2011. Below 'if' block is simplified into one line following text without
                  !              the change of answer.
                  ! Below is before Mar.27.2012.

                  ! rbuoy_up = rbuoy_max - ( rbuoy_max - rbuoy_min ) * &
                  !                          min( 1._r8, max( 0._r8, ( rad_au(m) - R_buomax ) / ( R_buomin - R_buomax ) ) )

                  ! Below is new on Mar.27.2012.

                  rbuoy_up = rbuoy_min * ( 1._r8 + ( rbuoy_max / rbuoy_min - 1._r8 ) * exp( - rad_au(m) / R_buo ) )

                  ! if( rad_au(m) .lt. R_buomax ) then
                  !     rbuoy_up = rbuoy_max
                  ! elseif( rad_au(m) .ge. R_buomax .and. rad_au(m) .lt. R_buomin ) then
                  !     rbuoy_up = rbuoy_max + ( rad_au(m) - R_buomax ) * ( rbuoy_min - rbuoy_max ) / ( R_buomin - R_buomax )
                  ! else
                  !     rbuoy_up = rbuoy_min
                  ! endif
                  
                  ! Below is previous old.

                  ! if( rad_au(m) .lt. Ro_min ) then
                  !     rbuoy_up = rbuoy_max
                  ! elseif( rad_au(m) .ge. Ro_min .and. rad_au(m) .lt. Ro_max ) then
                  !     rbuoy_up = rbuoy_max + ( rad_au(m) - Ro_min ) * ( rbuoy_min - rbuoy_max ) / ( Ro_max - Ro_min )
                  ! else
                  !     rbuoy_up = rbuoy_min
                  ! endif

                  ! --------------------------------------------------------------------------- !
                  ! Updraft Buoyancy Sorting                                                    !
                  ! We should define                                                            !
                  !   1. Level of buoyancy sorting ( pe )                                       !
                  !   2. Ambient airs involved in buoyancy sorting ( thl_eg, qt_eg )            !
                  ! Here,                                                                       !
                  !   1. Buoyancy sorting occurs at the base interface with organized env airs. !
                  !   2. But cumulus buoyancy is computed using mean-environmental airs.        !
                  ! As an option, the updraft can mix with mean environmental airs, instead of  !
                  ! the value at the base interface. In order to use this option, all I need to !
                  ! do is to set                                                                !
                  !      thl_eg = thle_m                                                        !
                  !      qt_eg  =  qte_m                                                        !
                  !      u_eg   =   ue_m                                                        ! 
                  !      v_eg   =   ve_m                                                        !                                           
                  ! The 'thl_dd' is automatically consistently treated later.                   !
                  ! Mar.11.2013. Add 'w_eg' within PBL for treating the effect of organized flow!
                  !              on the buoyancy sorting.                                       !
                  ! --------------------------------------------------------------------------- !
                  pe        =  p_b
                  w_cu      =  w_au(m)
                  thl_cu    =  thl_au(m)
                  qt_cu     =  qt_au(m)
                  thl_eg    =  thle_b(k) 
                  qt_eg     =  qte_b(k)
                  u_eg      =  ue_b(k)        ! Not used here, but for consistent treatment of buoyancy sorting 
                  v_eg      =  ve_b(k)        ! with the detrained airs : 'thl_dd, etc.' later
                  w_eg      =  we_b(k) 
                  do mt = 1, ncnst
                     tr_eg(mt) = tre_b(k,mt)  ! Not used here in this buoyancy sorting but for defining tr_eg(mt). 
                  enddo
                  thv_env   =  thv_b
                  ! gamv_en   =  ( thv_t - thv_b ) / ( z_t - z_b )   ! [ K / m ]
                  gamv_en   =  0._r8                               ! [ K / m ] For comparing with UW
                  gamv_cu   =  0._r8                               ! [ K / m ]
                  ! Sep.27.2010. Following my uwshcu.F90, compute cridis to be 10% of cumulus top height 
                  !              of the previous time step. This may be important to impose positive 
                  !              feedback in the transition of shallow to deep convection.   
                  ! Mar.21.2011. Use 'cushavg' instead of 'cush' for reasonably treating multiple updraft plume cases.
                  ! cridis    =  dz_m                                ! [ m ]. Previous.
                  ! cridis    =  rlc * cush                          ! [ m ]. New for positive feedback. 
                  cridis    =  rlc * cushavg                       ! [ m ]. New for positive feedback. 
                  ! Below line is for testing purpose. Note that 'dt_evpd' also use 'dz', so that the use of
                  ! cridis = dz_m may be able to be justified.
                  ! May.21.2011. Below use of 'cridis = dz_m' was the source of vertical resolution sensitivity for BOMEX L30/L80.
                  !              Thus, I should discard below option of 'cridis = dz_m'.  
                  if( rlc .eq. -1._r8 ) cridis = dz_m 
                  if( icridis .eq. 0  ) cridis = cridis_in
                  ! ---------------------------------------------------------------------- !
                  ! If cumulus buoyancy is smaller than thv_env, always set cridis = 1.e8. !
                  ! This is necessary to impose consistency with the following code using  !
                  ! undiluted cin when bogbot < 0. Note that due to the way how I          !
                  ! construct the code, thv_eg is always smaller than the thv_evn          !
                  ! regardless of the setting of organization. This is very good.          !
                  ! ---------------------------------------------------------------------- !
                  ! OPTION : In order to distinguish the treatment of 'inversion just above the PBL top' and 
                  !          the 'inversion in the penetrative entrainment zone near cumulus top', it may be
                  !          better to use 'if( thv .lt. thv_env .and. ql .lt. nonzero )'. instead of the
                  !          'if( thv .lt. thv_env )'. This modification should be accompanied by the 
                  !          corresponding modification of 'if( bogbot .lt. 0._r8 .and. ql .lt. nonzero )' below. 
                  ! ------------------------------------------------------------------------------------------ !
                  ! Mar.15.2015.                                                                               !
                  ! I need to use a correct value of 'frac_ice' in the below subroutine 'conden' in the layers !
                  ! above the lowest model layer.                                                              !
                  ! ------------------------------------------------------------------------------------------ !
          !ice    if( k .eq.  kiss + 1 ) then ! Lowest model layer.
                      call conden( pe, thl_cu, qt_cu, th, qv, ql, qi, qse, id_check )
          !ice    else
          !ice        frac_ice = frac_ice_au(m)
          !ice        call conden( pe, thl_cu, qt_cu, th, qv, ql, qi, qse, id_check, frac_ice = frac_ice )
          !ice    endif

                  !f          if( id_check .eq. 1 ) then
                  !f              id_exit = .true.
                  !f              go to 333
                  !f          endif
                  ql_cu = ql
                  qi_cu = qi
                  thv  = th * ( 1._r8 + zvir * qv - ql - qi )
                  ! OPTION. 1 : Original ( corresponding OPTION later should be also consistently set.
                  !g          if( icridis_negbuoy .eq. 1 .and. thv .lt. thv_env ) cridis = 1.e8_r8
                  ! OPTION. 2 : Advanced ( corresponding OPTION later should be also consistently set.  
                  ! if( icridis_negbuoy .eq. 1 .and. thv .lt. thv_env .and. ql .lt. nonzero ) cridis = 1.e8_r8

                  ! --------------------------------------------------------------------------- !
                  ! When gamv_en is non-zero, my code always produces xc = 0 or 1.              !
                  ! Not clear why. So, I use the reliable UW buosorting subroutine which        !
                  ! was fully tested to produce the same results as mine when gamv_en = 0 and   !
                  ! for any cridis. Note that buosorts_UW assumes gamv_en = gamv_cu = 0.        !
                  ! Mar.11.2013. Add 'w_eg' within PBL for treating the effect of organized flow!
                  !              on the buoyancy sorting.                                       !
                  !              Note that 'w_eg' is added only for 'buosorts_UW' subroutine,   !
                  !              so that the other buoyancy sorting subroutines should be       !
                  !              modified in future if I want to use them.                      ! 
                  ! ------------------------------------------------------------------------------------------ !
                  ! Mar.15.2015.                                                                               !
                  ! I need to use a correct value of 'frac_ice' in the below subroutine 'conden' in the layers !
                  ! above the lowest model layer.                                                              !
                  ! Note that as of today, subroutine 'buosorts' is not functional but only 'buosorts_UW' is   !
                  ! functional, since only the latter has the optional input argument of 'frac_ice'.           !        
                  ! ------------------------------------------------------------------------------------------ !
                  ! call buosorts( rbuoy_up, pe, w_cu, thl_cu, qt_cu, thl_eg, qt_eg, &
                  !                          thv_env, gamv_en, gamv_cu, cridis,  &
                  !                          xc(m), xs(m) )

             !ice if( k .eq.  kiss + 1 ) then ! Lowest model layer.
                      call buosorts_UW( rbuoy_up, pe, w_cu, thl_cu, qt_cu, w_eg, thl_eg, qt_eg, &
                                        thv_env, cridis, xc(m), xs(m), thv_cu, thv_eg, thv_xs )
             !ice else
             !ice     frac_ice = frac_ice_au(m)
             !ice     call buosorts_UW( rbuoy_up, pe, w_cu, thl_cu, qt_cu, w_eg, thl_eg, qt_eg, &
             !ice                       thv_env, cridis, xc(m), xs(m), thv_cu, thv_eg, thv_xs, frac_ice=frac_ice )
             !ice endif

                  ! TEST. Computation of parasite xc_tmp(m) with cridis = 1.e8.
                  ! call buosorts_UW(  rbuoy_up, pe, w_cu, thl_cu, qt_cu, thl_eg, qt_eg, &
                  !                    thv_env, 1.e8_r8, xc_tmp(m), tmp1, tmp2, tmp3, tmp4 )
                  ! TEST. Computation of parasite xc_tmp(m) with cridis = 1.e8.

                  ! -------------------------------------------------------- !
                  ! We can impose a lower and upper limit on xc(m) as below. !
                  ! -------------------------------------------------------- !
                  xc(m) = max( xc_min, min( xc_max, xc(m) ) )
                  ! -------------------------------------------------------- !
                  ! Compute non-dimensional entrainment and detrainment rate !
                  ! -------------------------------------------------------- !
                  call compute_epsdelnod( 'PDFbsQ', xc(m), eeps(m), ddel(m) )
                  ! -------------------------------------------------------------------- !
                  !                                                                      !
                  ! Fractional Mixing Rates eps0 [ 1/Pa]  : This is the key of the model !
                  ! Aug.15.2011. In contrast to the computation in the above block for   !
                  !              limiting org_ent, precise value of eps0(m) should be    !
                  !              computed here.                                          ! 
                  !                                                                      !
                  ! -------------------------------------------------------------------- !  
                  ! Aug.31.2011. In consistent with the introduction of density current parameterization above, 
                  !              I should re-compute eps0(m) here.
                  ! Oct.24.2011. Add a third option which additionally includes the dependence on the environmental RH.
                  !              This is the most perfect, physically-reasonable approach, and analogous to the 
                  !              evaporative enhancement of entrainment rate at the stratocumulus-topped PBL, which
                  !              provides much more confidence on this final formulation for eps0. The evaporative
                  !              enhancement parameter 'cevpeps0' should be in the range of '5 < cevpeps0 < 100'.    

                  if( i_eps0 .eq. 0 ) then
                     ! tmp1 = max( 0._r8, ( ql_au(m) + qi_au(m) ) / 1.e-3_r8 )
                     tmp1 = max( 0._r8, sqrt( ( ql_au(m) + qi_au(m) ) / 1.e-3_r8 ) )  
                     ! Below is from 'unicon.F90.016' 
                     ! tmp1 = min( 1._r8, max( 0._r8, ( ql_au(m) + qi_au(m) ) / 1.e-4_r8 ) )
                     tmp2 = 1._r8 + cevpeps0 * tmp1
                     eps0(m) = tmp2 * c0 / max( rad_au(m), Ro_eps0 ) / ( rho_b * g )
                  elseif( i_eps0 .eq. 1 ) then
                     call conden( pe, thl_eg, qt_eg, th, qv, ql, qi, qse, id_check )
                     !f              if( id_check .eq. 1 ) then
                     !f                  id_exit = .true.
                     !f                  go to 333
                     !f              endif
                     rh_eg = max( 0._r8, min( 1._r8, qv / max( nonzero, qse ) ) )
                     ! tmp1 = ( ( ql_au(m) + qi_au(m) ) / 1.e-3_r8 ) * ( 1._r8 - rh_eg )
                     ! tmp1 = ( ( ql_au(m) + qi_au(m) ) / 1.e-3_r8 ) * ( 1._r8 - max( 0.5_r8, min( 0.8_r8, rh_eg ) ) )
                     ! tmp1 = ( ( ql_au(m) + qi_au(m) ) / 1.e-3_r8 ) * ( 1._r8 - max( 0.0_r8, min( 1.0_r8, rh_eg ) ) )
                     ! tmp1 = sqrt( ( ( ql_au(m) + qi_au(m) ) / 1.e-3_r8 ) * ( 1._r8 - max( 0.0_r8, min( 0.85_r8, rh_eg ) ) ) )
                     tmp1 = sqrt( ( ( ql_au(m) + qi_au(m) ) / 1.e-3_r8 ) * ( 1._r8 - max( 0.0_r8, min( 1.00_r8, rh_eg ) ) ) )
                     ! tmp1 = sqrt( min( 1._r8, max( 0._r8, ( ql_au(m) + qi_au(m) ) / 1.e-4_r8 ) ) * ( 1._r8 - max( 0.0_r8, min( 1.00_r8, rh_eg ) ) ) )   
                     tmp2 = 1._r8 + cevpeps0 * tmp1
                     eps0(m) = tmp2 * c0 / max( rad_au(m), Ro_eps0 ) / ( rho_b * g )
                  elseif( i_eps0 .eq. 2 ) then
                     eps0(m) = c0 / max( rad_au(m), Ro_eps0 ) / ( rho_b * g ) / eeps(m)
                  endif

                  ! 0. Fully consistent formula with the observation. Below formula ensures
                  !    huge amount of mixing ( eps0 not eps ) and correspondingly large 
                  !    amount of detrainment in the penetrative entrainment zone above the
                  !    LNB. This seems to be much more consistent with the observations. 
                  !    Note that by setting 'xc_min > 0', eeps(m) is guaranteed to be non-zero
                  !    positive values.
                  !    Aug.22.2011. I don't need below line anymore since I restored to the original formulation
                  !    on this day.  
                  !    eps0(m) = c0 / max( rad_au(m), Ro_eps0 ) / ( rho_b * g ) / eeps(m)
                  ! 1. Turner 1973 ( 'T' )
                  !    eps0(m)   = c0 / max( rad_au(m), 100._r8 ) / ( rho_b * g )      
                  ! 2. Saturated Turner ( 'ST' )
                  !    eps0(m)   = 5._r8 * c0 / max( rad_au(m), 100._r8 ) / ( rho_b * g )
                  ! 3. Combined Turner ( 'CT' )  
                  !    Form 'eps = eps0 * xc**2', it is clear that 'eps0 = 4 * eps' for the average saturated 
                  !    updraft case. Thus, I multiplied 4 for saturated updraft case. Note that for unsaturated
                  !    updraft, xc = 1 and so 'eps0 = eps'. This multiplication factor of 4 is also used in my
                  !    UW shallow convection scheme. 
                  !    Note that regardless whether convective updraft is saturated or not, observation has shown
                  !    that 'eps ( NOT eps0 ) = c0 / rad_au(m)' with c0 = 0.2. My below formula is exactly consistent
                  !    with the previous observations.     
                  !    if( ( ql + qi ) .lt. nonzero ) then
                  !          eps0(m) = c0 / max( rad_au(m), 100._r8 ) / ( rho_b * g )
                  !    else
                  !          eps0(m) = 4._r8 * c0 / max( rad_au(m), 100._r8 ) / ( rho_b * g )
                  !    endif
                  ! 3.5. More advanced smooth transition. The ramper 'qc_c0' should be specified.
                  !    tmp1 = min( 1._r8, max( 0._r8, ( ql + qi ) / qc_c0 ) )
                  !    tmp2 = 1._r8 * ( 1._r8 - tmp1 ) + 4._r8 * tmp1    
                  !    eps0(m) = tmp2 * c0 / max( rad_au(m), 200._r8 ) / ( rho_b * g )
                  ! if( k .ge. kpblh ) eps0(m) = 0._r8             
                  ! 4. Formula fully consistent with laboratory experiment.
                  ! eps0(m) = c0 / max( rad_au(m) * eeps(m), 100._r8 ) / ( rho_b * g )
                  ! eps0(m) = c0 / max( rad_au(m) * eeps(m), nonzero ) / ( rho_b * g )
                  ! eps0(m) = min( 8.e-3_r8, c0 / max( rad_au(m) * eeps(m), nonzero ) ) / ( rho_b * g )  
                  ! 5. UW ShCu with the treatment witnin the PBL
                  !    eps0(m)   = ( cm / max( z_b, pblhz ) ) / ( rho_b * g )                  
                  ! 6. Constant area formulation based on analytical formula ( not quite conserve area fraction at this stage ).
                  !    eps0(m)   = ( rbuoy_up * ( thv_cu / thv_env - 1._r8 ) + w_au(m)**2._r8 * ( rho_t - rho_b ) / dp_m ) / &
                  !                ( rdrag * eeps(m) + eeps(m) - ddel(m) ) / ( rho_b * w_au(m)**2._r8 ) 
                  ! 7. EDMF ( Soares et al. 2004. QJRMS. )
                  !    eps0(m)   = 0.5_r8 * ( 1._r8 / ( z_b + dz_m ) + 1._r8 / ( pblhz - z_b + dz_m  ) )
                  ! 8. HPB
                  !    if( k .lt. kpblh ) then
                  !        tmp1 = min( 1._r8, max( 0._r8, ( ql + qi ) / qc_c0 ) )
                  !        tmp2 = 1._r8 * ( 1._r8 - tmp1 ) + 4._r8 * tmp1    
                  !        eps0(m) = tmp2 * c0 / max( rad_au(m), 200._r8 ) / ( rho_b * g )                  
                  !    else
                  !        xc(m) = max( xc(m) ,0.1_r8 )
                  !        if( k .ge. 12 ) xc(m) = min( xc(m), 0.5_r8 )
                  !        eeps(m) = xc(m)**2
                  !        ddel(m) = 1._r8 - 2._r8*xc(m) + xc(m)**2
                  !        if( k .eq. kpblh ) then
                  !            eps0(m) = exp( -5.5_r8 ) / g / rho_b / max( w_au(m), 0.5_r8 )
                  !            eps0_kpbl = eps0(m)
                  !        end if
                  !        rhfer = prep_old * 24._r8 * 3600._r8
                  !        b2 = -0.3_r8
                  !        if( rhfer .le. 0.1_r8 ) then
                  !            rei2 = 0.6_r8 / 1000._r8
                  !        else
                  !            rei2 = exp( -1.3_r8 + b2 * log( rhfer ) ) / 1000._r8
                  !        endif
                  !        eps0(m) = eps0_kpbl + ( rei2 - eps0_kpbl ) / 1500._r8 * ( zs0(k) - zs0(kpblh) )
                  !        if( k .le. kpblh + 2 ) then
                  !            rei1b  = exp( -1.3_r8 + b2 * log( 5._r8 ) ) / 1000._r8
                  !            rei1b  = min( rei1b, rei2 )
                  !            eps0(m) = eps0_kpbl + ( rei1b - eps0_kpbl ) / 1500._r8 * ( zs0(k) - zs0(kpblh) )
                  !        endif
                  !        if( ( zs0(k) .gt. zs0(kpblh) + 1500._r8 ) .and. ( rhfer .gt. 0.1_r8 ) ) then
                  !              b2 = -0.19_r8
                  !              rei2b = exp( -1.7_r8 + b2 * log(rhfer) ) / 1000._r8
                  !              eps0(m) = rei2 + ( rei2b - rei2 ) / 1500._r8 * ( zs0(k) - zs0(kpblh) - 1500._r8 )
                  !        endif
                  !        eps0(m) = max( eps0(m), 0.05_r8 / 1000._r8 )
                  !    endif

                  ! -------------------------------------------------------------------- !
                  !                                                                      !
                  ! Fractional Mixing Rates eps0 [ 1/Pa ] : This is the key of the model !
                  !                                                                      !
                  ! -------------------------------------------------------------------- !  

                  eps0(m)   =  max( 0._r8, eps0(m) )

                  ! Sungsu for TEST
                  eps0org(m) = eps0(m)
                  ! Sungsu for TEST

                  ! ----------------------------------------------------------------------------------------------------------------------- !                    
                  ! CRITICALLY IMPORTANT : IMPOSING A REASONABLE LIMIT FOR eps0(m)                                                          !
                  !                                                                                                                         !
                  ! Aug.15.2011. Total amount of environmental airs involved in the buoyancy sorting during dt cannot be                    !
                  !              larger than 'fmix_frac' of the available mass in each layer.                                               !
                  !              It can be shown that if below is satisfied, the above original constraint is automatically satisfied.      !
                  !              Thus, the above original block is removed. Note that instead of using 0.9, I am using 'fmix_frac=0.5' to   !
                  !              impose a more strict constraint mimicking fmix_max = 2 effect also.                                        !  
                  ! Aug.22.2011. Below is problematic if eeps(m)-ddel(m) < 0 since the argument of log can be negative.                     !
                  !              Thus, I return to the above original formula. In addition, below seems to dissipate                        !
                  !              most of subtropical low clouds.                                                                            !
                  ! Aug.23.2011. I added additional constraint requiring positive argument of log function.                                 !
                  !              If the argument is negative, the constraint is satisfied regardless of the eps0(m).                        !
                  !              So, in this case, I don't need to impose any constraint.                                                   !
                  !              Below is perfect final formula.                                                                            !
                  ! Aug.02.2012. Temporary test. Remove below entire if block.                                                              !
                  ! Aug.14.2012. I checked that below constraint is too strong, often resulting in too small 'eps0(m)' after                !
                  !              correction, forcing even small plume to behave as a large plume, so that small plume                       !
                  !              can unreasonably grow into the very deep layer.                                                            !
                  !              Thus, I strongly recommend to remove below constraint to ensure natural behavior of the model.             !
                  !              This may help to improve diurnal cycle and may fix many remaining issues.                                  ! 
                  ! Aug.14.2012. CRITICALLY IMPORTANT. Since vertical evolution of updraft mass flux is an exponential function             !
                  !              as 'cmf_aut(m) = cmf_au(m) * exp( dp_m * ( eps(m) - del(m) ) )', small positive values of 'eps(m)-del(m)'  !
                  !              combined with large value of 'dp_m' (e.g., 10000 [Pa] ) can generate extremely large 'cmf_aut(m)', which   !
                  !              induces extremely large downdraft mass flux, resulting in the model crash.                                 !
                  !              For example, a set of the following possible configuration of 'Ro=25[m], cevpeps = 5, ql+qi = 1.e-3,       !
                  !              1-RH = 0.3, rho_b = 0.73' produces eps0(m) = 0.0031, and if xc = 0 and cmf_au = 0.01 and dp_m = 10000 [Pa] ! 
                  !              ( possible case in the upper troposphere at around 500 hPa level ), this will produces                     !
                  !              cmf_aut = 0.01*exp(0.0031*10000) = 2.9*e11 !!!.                                                            !
                  !              Thus, it is extremely important to provide a reasonable limit for eps0(m), so that the model               !
                  !              does not crash, and at the same time, it does conserves the right functional dependency of 'eps0(m)'       !
                  !              on the plume radius R.                                                                                     !
                  !              It turns out that this is a really important issue especially in the simulations with coarse vertical      !
                  !              operational resolution. We can partially correct this feature either by increasing Ro_eps from 25 to 50,   !
                  !              or by using a small value of cevpeps0 = 2 or 3 instead of 5.                                               !
                  !              However, we need a more fundamental fix for this.                                                          !
                  ! Aug.14.2012. I added the option to use linear function of mass flux with height instead of exponential function to      !
                  !              solve this issue.                                                                                          !
                  ! Jan.30.2013. Impose the most clear and simple limiter on eps0(m).                                                       !
                  !              This imposes a smooth variation of updraft mass flux with height picking up only when                      !
                  !              dp_m becomes very large. By doing this, vertical variation of                                              !
                  !              updraft mass flux between any two interfaces is constrained by                                             ! 
                  !                  ' 1 / ( e ^ fmix_frac )  <  M(p+dp)/M(p)  <  e ^ fmix_frac '                                           !
                  !              for each convectie updraft. Thus, if fmix_frac = 1,                                                        !
                  !                  ' 0.37 < M(p+dp)/M(p) < 2.72 '                                                                         !   
                  !              and if fmix_frac = 2,                                                                                      !  
                  !                  ' 0.14 < M(p+dp)/M(p) < 7.39 '                                                                         ! 
                  !              and if fmix_frac = 3,                                                                                      !
                  !                  ' 0.05 < M(p+dp)/M(p) < 20.0 '                                                                         !
                  !              In order not to interrupt the performance of the model but still prevent model crash,                      !
                  !              we should use reasonable value for fmix_frac. If I set fmix_frac = ln(10) = 2.3026,                        !
                  !              it becomes                                                                                                 !
                  !                  ' 0.1 < M(p+dp)/M(p) < 10.0 '                                                                          !
                  !              Thus, let's choose 'fmix_frac =  ln(10) = 2.3026'.                                                         !
                  !              Physically, this constraint with 'fmix_frac =  ln(10) = 2.3026' says that vertical variation of updraft    !
                  !              mass flux between any two interface level is confined between 0.1 and 10. This is a safety constraint that !
                  !              is only active when dp is very large. In normal situation, this limiter will not work.                     !
                  !              This constraint is the most complete one and is applied for each updraft segment and downdraft without any !
                  !              conceptual problem.                                                                                        !    
                  ! Jan.30.2013. Below constraint on eps0(m) is moved above on this day, which is perfectly consistent.                     !
                  ! Nov.18.2013. Impose a fully physically reasonable, stable limiter using 'epsz0_max' instead of 'fmix_frac'.             !
                  ! ----------------------------------------------------------------------------------------------------------------------- !
                  
                  ! Feb.06.2013. Always choose physically reasonable exp_cmf = 1 as of this day.

                  if( exp_cmf .eq. 1 ) then ! Original exponential computation of cmf_u and cmf_d. 
          
                     ! Aug.15.2011. Below is original block before Aug.15.2011. 

                     ! if( eeps(m) .gt. ddel(m) ) then
                     !     eps0(m) = min( eps0(m), log(1._r8+0.9_r8*dp_m/N_up(km)/g/dt/cmf_au(m))/dp_m/(eeps(m)-ddel(m)) )   
                     ! endif                                                                                              
                     
                     ! Aug.14.2012. Below is the new more general ones. 

                     ! if( eeps(m) .eq. ddel(m) ) then
                     !     eps0(m) = min( eps0(m), fmix_frac/N_up(km)/g/cmf_au(m)/dt ) 
                     ! elseif( ( eeps(m) .gt. ddel(m) ) .or.  &
                     !         ( eeps(m) .lt. ddel(m)  .and. (fmix_frac*dp_m/N_up(km)/g/cmf_au(m)/dt*(eeps(m)-ddel(m))) .gt. -1._r8 ) ) then
                     !     eps0(m) = min( eps0(m), log(1._r8+fmix_frac*dp_m/N_up(km)/g/cmf_au(m)/dt*(eeps(m)-ddel(m)))/dp_m/(eeps(m)-ddel(m)) )  
                     ! endif

                     ! Jan.30.2013. Below is the most recent one with the simplest and clearest treatment.
                     ! eps0(m) = min( eps0(m), fmix_frac / dp_m ) 
                     ! Nov.18.2013. Below is a new limiter on Nov.18.2013. 
                     ! Since 'epsz0_max' is specified in unit of [1/m], I should multiply 'dz_m' in the below
                     ! line, where 'dz_m' is already-well defined above.
                     eps0(m) = min( eps0(m), log( 1._r8 + epsz0_max * dz_m ) / dp_m )

                  endif

                  eps(m)    = eps0(m) * eeps(m)
                  del(m)    = eps0(m) * ddel(m)

                  ! CHECK
                  ! write(6,*) 
                  ! write(6,*) 'UNICON: Write asin value'
                  ! write(6,*) 'asin(0), asin(0.2), asin(0.5), asin(0.7), asin(1)  = ', &
                  !             asin(0._r8), asin(0.2_r8), asin(0.5_r8), asin(0.7_r8), asin(1._r8) 
                  ! write(6,*) 
                  ! CHECK

                  ! CHECK
                  ! write(6,*) 
                  ! write(6,*) 'UNICON: Compare xc from buosorts and buosorts_UW'
                  ! write(6,*) 'xc, xc_UW  = ', xc(m), xc_UW(m) 
                  ! write(6,*) 'gamv_en  = ', gamv_en 
                  ! write(6,*) 
                  ! CHECK

                  ! CHECK
                  ! Test whether computed 'xc' is correct or not.
                  ! do kk = 1, 3
                  !    if( kk .eq. 1 ) then
                  !         tmp1 = xc(m) - 0.03_r8
                  !    elseif( kk .eq. 2 ) then
                  !         tmp1 = xc(m)
                  !    else
                  !         tmp1 = xc(m) + 0.03_r8
                  !    endif  
                  !    call conden(pe,thl_cu+tmp1*(thl_eg-thl_cu),qt_cu+tmp1*(qt_eg-qt_cu),th,qv,ql,qi,qse,id_check)
                  !    thv  = th * ( 1._r8 + zvir*qv - ql - qi )
                  !    tmp(kk) = (w_cu*(1._r8-tmp1))**2._r8 + 2._r8*(rbuoy_up*g/thv_env)*cridis*(thv-thv_env)
                  ! enddo
                  ! if ( xc(m) .ge. 0.03_r8 .and. xc(m) .le. 0.97_r8 .and. tmp(1)*tmp(3) .ge. 0._r8 ) then
                  !      write(6,*) 'UNICON: Warning - xc from subroutine buosorts is wrong'
                  !      write(6,*) 'xc  = ', xc(m) 
                  !      write(6,*) 'f(xc-delta), f(xc), f(xc+delta) = ', tmp(1), tmp(2), tmp(3) 
                  !      write(6,*)
                  ! endif 
                  ! CHECK

                  ! write(6,*)
                  ! write(6,*) 'UNICON: Updraft buoyancy sorting at the base interface'
                  ! write(6,*) 'Layer and updraft segment indices  = ', k, m 
                  ! write(6,*) 'w_cu    = ', w_cu 
                  ! write(6,*) 'thl_cu  = ', thl_cu
                  ! write(6,*) 'qt_cu   = ', qt_cu
                  ! write(6,*) 'thl_eg  = ', thl_eg
                  ! write(6,*) 'qt_eg   = ', qt_eg
                  ! write(6,*) 'cridis  = ', cridis
                  ! write(6,*) 'xs      = ', xs(m)
                  ! write(6,*) 'xc      = ', xc(m)
                  ! write(6,*) 'eps0    = ', eps0(m)
                  ! write(6,*) 'eps     = ', eps(m)
                  ! write(6,*) 'del     = ', del(m)
                  ! write(6,*)
                  ! CHECK

                  ! ----------------------------------------------------------------------------- !
                  ! Compute which mixtures can be the source of downdraft ( xe_min < x < xe_max ) !
                  ! ----------------------------------------------------------------------------- !
       
                  thl_cumC  = thl_cu  + xc(m) * ( thl_eg - thl_cu )
                  qt_cumC   = qt_cu   + xc(m) * ( qt_eg  -  qt_cu )
             !ice if( ipartition_fice .eq. 0 ) then ! Temperature-dependent ice fraction
             !ice     if( k .gt. (kiss + 1) .and. xc(m) .eq. 0._r8 ) then 
             !ice         frac_ice = frac_ice_au(m)
             !ice         call conden( pe, thl_cumC, qt_cumC, th, qv, ql, qi, qse, id_check, frac_ice=frac_ice )
             !ice     else
                          call conden( pe, thl_cumC, qt_cumC, th, qv, ql, qi, qse, id_check )
             !ice     endif
             !ice else ! Explicitly averaged ice fraction between updraft and environment
             !ice     if( k .eq. kiss + 1 ) then
             !ice         call conden( pe, thl_cumC, qt_cumC, th, qv, ql, qi, qse, id_check )
             !ice     else
             !ice         frac_ice_eg = qie_b(k) / max( qle_b(k) + qie_b(k), nonzero )
             !ice         frac_ice = frac_ice_au(m) + xc(m) * ( frac_ice_eg - frac_ice_au(m) )
             !ice         call conden( pe, thl_cumC, qt_cumC, th, qv, ql, qi, qse, id_check, frac_ice=frac_ice )
             !ice     endif
             !ice endif
                  !f          if( id_check .eq. 1 ) then
                  !f              id_exit = .true.
                  !f              go to 333
                  !f          endif
                  thv_cumC  = th *  ( 1._r8 + zvir * qv - ql - qi )
                  thvl_cumC = thl_cumC * ( 1._r8 + zvir * qt_cumC )

                  thl_cumS  = thl_cu  + xs(m) * ( thl_eg - thl_cu )
                  qt_cumS   = qt_cu   + xs(m) * ( qt_eg  -  qt_cu )
             !ice if( ipartition_fice .eq. 0 ) then ! Temperature-dependent ice fraction
             !ice     if( k .gt. (kiss + 1) .and. xs(m) .eq. 0._r8 ) then 
             !ice         frac_ice = frac_ice_au(m)
             !ice         call conden( pe, thl_cumS, qt_cumS, th, qv, ql, qi, qse, id_check, frac_ice=frac_ice )
             !ice     else
                          call conden( pe, thl_cumS, qt_cumS, th, qv, ql, qi, qse, id_check )
             !ice     endif
             !ice else ! Explicitly averaged ice fraction between updraft and environment
             !ice     if( k .eq. kiss + 1 ) then
             !ice         call conden( pe, thl_cumS, qt_cumS, th, qv, ql, qi, qse, id_check )
             !ice     else
             !ice         frac_ice_eg = qie_b(k) / max( qle_b(k) + qie_b(k), nonzero )
             !ice         frac_ice = frac_ice_au(m) + xs(m) * ( frac_ice_eg - frac_ice_au(m) )
             !ice         call conden( pe, thl_cumS, qt_cumS, th, qv, ql, qi, qse, id_check, frac_ice=frac_ice )
             !ice     endif
             !ice endif
                  !f          if( id_check .eq. 1 ) then
                  !f              id_exit = .true.
                  !f              go to 333
                  !f          endif
                  thv_cumS  = th *  ( 1._r8 + zvir * qv - ql - qi )
                  thvl_cumS = thl_cumS * ( 1._r8 + zvir * qt_cumS )

                  call conden( pe, thl_eg, qt_eg, th, qv, ql, qi, qse, id_check )
                  !f          if( id_check .eq. 1 ) then
                  !f              id_exit = .true.
                  !f              go to 333
                  !f          endif
                  thv_cumE  = th *  ( 1._r8 + zvir * qv - ql - qi )
                  thvl_cumE = thl_eg   * ( 1._r8 + zvir *   qt_eg )

                  if( ithv_minE .eq. -1 ) then
                     call buosort_downdraft( thvl_cumC, thvl_cumE, thvl_minE, xdown_min, xdown_max )
                     xe_min(m) = xc(m) + ( 1._r8 - xc(m) ) * xdown_min
                     xe_max(m) = xc(m) + ( 1._r8 - xc(m) ) * xdown_max
                  else
                     if( xc(m) .ge. xs(m) ) then
                        call buosort_downdraft( thv_cumC, thv_cumE, thv_minE, xdown_min, xdown_max )
                        xe_min(m) = xc(m) + ( 1._r8 - xc(m) ) * xdown_min
                        xe_max(m) = xc(m) + ( 1._r8 - xc(m) ) * xdown_max     
                     else
                        call buosort_downdraft( thv_cumC, thv_cumS, thv_minE, xdown_min, tmp1 )
                        xe_min(m) = xc(m) + ( xs(m) - xc(m) ) * xdown_min
                        call buosort_downdraft( thv_cumS, thv_cumE, thv_minE, tmp2, xdown_max )
                        xe_max(m) = xs(m) + ( 1._r8 - xs(m) ) * xdown_max
                        ! CHECK
                        ! Test whether 'xdown_min' and 'xdown_max' are correctly computed.
                        ! It must be always tmp1 = 1 and tmp2 = 0.  
                        ! if ( tmp1 .ne. 1._r8 .or. tmp2 .ne. 0._r8 ) then
                        !      write(6,*) 'UNICON: Warning - xdown_min and xdown_max from subroutine buosorts_downdrafts is wrong'
                        !      write(6,*) 'xc(m),     xs(m)      = ', xc(m), xs(m) 
                        !      write(6,*) 'xdown_min, xdown_max  = ', xdown_min, xdown_max 
                        !      write(6,*) 'xe_min,    xe_max     = ', xe_min(m), xe_max(m) 
                        !      write(6,*) 'tmp1,      tmp2       = ', tmp1, tmp2 
                        !      write(6,*)
                        ! endif 
                        ! CHECK
                     endif
                  endif

                  ! ---------------------------------------------------------------------------------- !
                  ! Updraft Top Height & Vertical Velocity at the Top Interface                        ! 
                  ! 1. This takes into account of the mixing with the organized ambient airs.          !
                  ! 2. But the buoyancy of updraft is computed using mean environmental airs.          !
                  ! 3. Currently, use 'hybrid' forward explicit integration but can be refined later.  !
                  ! 4. Below simple choice is consistent with 'buosorts' where we set gamv_cu = 0. and !
                  !    produces reasonably small updraft fractional area almost never reaching to the  !
                  !    au_max.                                                                         !
                  ! Mar.07.2013. In order to use as a full scale-adaptive parameterization even in the !
                  !              future prognostic convection scheme, use 'thv_mean_b' instead of      !
                  !              the 'thv_b' in below computation of 'bogbot'.                         !
                  !              If we do this, it becomes 'bogbot --> 0' if 'a_u -->1', which is a    !
                  !              desirable required property.                                          !
                  ! Mar.07.2013. I removed 'call conden' and 'thvbot = th * ( .... )' and use already  !
                  !              computed thv_au(m) (which is identical to thvbot = th * ( .... )' for !
                  !              saving computation time.                                              !  
                  ! ---------------------------------------------------------------------------------- !
                  
                  !f          call conden( p_b, thl_au(m), qt_au(m), th, qv, ql, qi, qse, id_check )
                  !f          if( id_check .eq. 1 ) then
                  !f              id_exit = .true.
                  !f              go to 333
                  !f          endif
                  !f          thvbot  = th * ( 1._r8 + zvir * qv - ql - qi )
                  thvbot  = thv_au(m) 
                  bogbot  = rbuoy_up * ( thvbot / thv_mean_b - 1._r8 )
                  ! bogbot  = rbuoy_up * ( thvbot / thv_b - 1._r8 )

                  ! ---------------------------------------------------------------------------------- ! 
                  ! If 'bogbot < 0', 'buosorts_UW' computes eps = 0 for both non-organized ( org = 0 ) ! 
                  ! and organized ( org > 0 ) mixing. This is because (1) buosorts_UW is performed at  !
                  ! the base interface, and (2) I set cridis = 1.e8_r8 when bogbot < 0. Note also that !
                  ! for organized mixing, it is automatically guaranteed that 'thv_eg < thv_v'. Thus,  !
                  ! below block which makes use of eps = 0 when bogbot < 0 is generally applicable in  !
                  ! all situations.                                                                    !
                  ! ---------------------------------------------------------------------------------- !
                  
                  ! OPTION : Below 'no entrainment' block is designed to accurately resolve inversion
                  !          structure just above the PBL top, including the existencey of LCL. 
                  !          Thus, in order to distinguish the treatment of 'inversion just above the PBL top'
                  !          and the 'inversion in the penetrative entrainment zone near cumulus top', it may be
                  !          better to use 'if( bogbot .lt. 0._r8 .and. ql .lt. nonzero )' instead of
                  !          using 'if( bogbot .lt. 0._r8 )'.
                  !          This modification should be accompanied by the corresponding modification 
                  !          of 'if( thv .lt. thv_env .and. ql .lt. nonzero )' above.             
                  ! Dec.02.2012. Below 'microcu' option block is not performed when 'icridis_negbuoy .eq. 0'
                  !              which is the current configuration. 
                  ! Feb.06.2013. As of today, always use icridis_negbuoy = 0 since this is more physically reasonable.

                  ! OPTION. 1 : Original ( corresponding OPTION above should be also consistently set. )
                  !g          if( icridis_negbuoy .eq. 1 .and. bogbot .lt. 0._r8 ) then
                  !g        ! OPTION. 2 : Advanced ( corresponding OPTION above should be also consistently set. )
                  !g        ! if( icridis_negbuoy .eq. 1 .and. bogbot .lt. 0._r8 .and. ql .lt. nonzero ) then

                  !g              ! -------------------------------------------------------------------------- !
                  !g              ! In this case, no entrainment mixing occurs. The equation set in this block !
                  !g              ! is formulated by assuming 'eps = 0' ( not eps0 = 0 ).                      !
                  !g              ! -------------------------------------------------------------------------- !
                  !g              if( eps(m) .gt. nonzero ) then
                  !g                  write(6,*) 
                  !g                  write(6,*) 'UNICON : Error : Entrainment rate of convective updraft with bogbot < 0 is unreasonably non-zero !'
                  !g                  write(6,*) 'bogbot, w_au(m) = ', bogbot, w_au(m)
                  !g                  write(6,*) 'eps(m),  del(m) = ', eps(m),  del(m)
                  !g                  write(6,*)                           
                  !g              endif
                  !g              ! ------------------------------------------ !
                  !g              ! Computation of undiluted CIN in each layer !
                  !g              ! ------------------------------------------ !
                  !g              call conden( p_t, thl_au(m), qt_au(m), th, qv, ql, qi, qse, id_check )
                  !f              if( id_check .eq. 1 ) then
                  !f                  id_exit = .true.
                  !f                  go to 333
                  !f              endif
                  !g              ! ------------------------------------------------------------------------------------------------ !
                  !g              ! Note that both below microcu = 0 and microcu = 1 are vertical resolution-insensitive computation !
                  !g              ! when microcu = 0 (1) is used upward-final (centered) differencing as in the current code.        !     
                  !g              ! ------------------------------------------------------------------------------------------------ !
                  !g              if( microcu .eq. 0 ) then
                  !g                  if( ( ql + qi ) .gt. criqc ) then
                  !g                        exql = c0_ac * ( ( ql + qi ) - criqc ) * ql / ( ql + qi )
                  !g                        exqi = c0_ac * ( ( ql + qi ) - criqc ) * qi / ( ql + qi )
                  !g                  else
                  !g                        exql = 0._r8
                  !g                        exqi = 0._r8 
                  !g                  endif 
                  !g              elseif( microcu .eq. 1 ) then
                  !g                ! --------------------------------------------------------------------------------------- !
                  !g                ! May.25.2012. Below is the most perfect treatment fully consistent and symmetric with    !
                  !g                !              the treatment of evaporation of precipitation within convective downdraft, ! 
                  !g                !              with minimum sensitivity to the vertical resolution, and                   !
                  !g                !              with correct appropriate limiters.                                         !
                  !g                ! --------------------------------------------------------------------------------------- !
                  !g                  if( ( ql + qi ) .gt. criqc ) then
                  !g                      f_Lt = ( c0_ac / ( 1._r8 ) ) * ( ( ql + qi ) - criqc ) * ( ql / ( ql + qi ) ) ! [ kg/kg/Pa ]
                  !g                      f_It = ( c0_ac / ( 1._r8 ) ) * ( ( ql + qi ) - criqc ) * ( qi / ( ql + qi ) ) ! [ kg/kg/Pa ]
                  !g                  else
                  !g                      f_Lt = 0._r8
                  !g                      f_It = 0._r8
                  !g                  endif                 
                  !g                  if( ( ql_cu + qi_cu ) .gt. criqc ) then
                  !g                      f_Lb = ( c0_ac / ( 1._r8 ) ) * ( ( ql_cu + qi_cu ) - criqc ) * ( ql_cu / ( ql_cu + qi_cu ) )
                  !g                      f_Ib = ( c0_ac / ( 1._r8 ) ) * ( ( ql_cu + qi_cu ) - criqc ) * ( qi_cu / ( ql_cu + qi_cu ) )
                  !g                  else
                  !g                      f_Lb = 0._r8
                  !g                      f_Ib = 0._r8
                  !g                  endif                 
                  !g                  f_L  = f_Lb
                  !g                  f_I  = f_Ib 
                  !g                ! f_L  = 0.5_r8 * ( f_Lt + f_Lb )
                  !g                ! f_I  = 0.5_r8 * ( f_It + f_Ib ) 
                  !g                  dia_qt  =   f_L + f_I 
                  !g                  dia_thl = - ( ( xlv / cp / exn0(k) ) * f_L + ( xls / cp / exn0(k) ) * f_I )
                  !g                ! Apr.18.2012. I double-checked that below 'progup_thlqt' with 'dia_thl,dia_qt' correctly work and 
                  !g                !              produces the right values with the right signs.
                  !g                !              That is, the sign of 'dia_qt,dia_thl' is correct. 
                  !g                  call progup_thlqt( 0._r8, dia_thl, p_b, p_t, 0._r8, 0._r8, thl_au(m), tmp_thl )
                  !g                  call progup_thlqt( 0._r8, dia_qt,  p_b, p_t, 0._r8, 0._r8,  qt_au(m), tmp_qt  )
                  !g                  call conden( p_t, tmp_thl, tmp_qt, tmp_th, tmp_qv, tmp_ql, tmp_qi, qse, id_check )
                  !f                  if( id_check .eq. 1 ) then
                  !f                      id_exit = .true.
                  !f                      go to 333
                  !f                  endif
                  !g                  exql = min( max( ql - tmp_ql, 0._r8 ), 0.99_r8 * ql )
                  !g                  exqi = min( max( qi - tmp_qi, 0._r8 ), 0.99_r8 * qi )
                  !g                ! I can add below 4 lines if I want to guarantee that precipitation production
                  !g                ! does not reduce 'ql + qi' down below 'criqc'. 
                  !g                  if( mclimit .eq. 1 ) then
                  !g                      tmp1 = exql + exqi
                  !g                      tmp2 = min( tmp1, max( ql + qi - criqc, 0._r8 ) ) ! To impose a continuous variation across ql + qi = criqc.
                  !g                      exql = exql * ( tmp2 / max( tmp1, nonzero ) )
                  !g                      exqi = exqi * ( tmp2 / max( tmp1, nonzero ) )
                  !g                  endif
                  !g              elseif( microcu .eq. 2 ) then
                  !g                  dp_sub = ( p_t - p_b ) / nsub_dia
                  !g                  do jj = 1, nsub_dia
                  !g                     p_ini   = p_b   + dp_sub * ( jj - 1 )
                  !g                     p_fin   = p_ini + dp_sub
                  !g                     thl_cen = thle_b(k) + ssthle(k) * ( 0.5_r8 * ( p_fin + p_ini ) - p_b )
                  !g                     qt_cen  =  qte_b(k) +  ssqte(k) * ( 0.5_r8 * ( p_fin + p_ini ) - p_b )
                  !g                     if( jj .eq. 1 ) then
                  !g                         ql_cu_ini  = ql_cu
                  !g                         qi_cu_ini  = qi_cu
                  !g                         thl_cu_ini = thl_au(m)
                  !g                         qt_cu_ini  = qt_au(m)
                  !g                     endif                      
                  !g                     if( ( ql_cu_ini + qi_cu_ini ) .gt. criqc ) then
                  !g                         f_L = ( c0_ac / ( 1._r8 ) ) * ( ( ql_cu_ini + qi_cu_ini ) - criqc ) * ( ql_cu_ini / ( ql_cu_ini + qi_cu_ini ) )
                  !g                         f_I = ( c0_ac / ( 1._r8 ) ) * ( ( ql_cu_ini + qi_cu_ini ) - criqc ) * ( qi_cu_ini / ( ql_cu_ini + qi_cu_ini ) )
                  !g                     else
                  !g                         f_L = 0._r8
                  !g                         f_I = 0._r8
                  !g                     endif  
                  !g                     dia_qt  =   f_L + f_I 
                  !g                     dia_thl = - ( ( xlv / cp / exn0(k) ) * f_L + ( xls / cp / exn0(k) ) * f_I )
                  !g                   ! Apr.18.2012. I double-checked that below 'progup_thlqt' with 'dia_thl,dia_qt' correctly work and 
                  !g                   !              produces the right values with the right signs.
                  !g                   !              That is, the sign of 'dia_qt,dia_thl' is correct. 
                  !g                     call progup_thlqt( 0._r8, dia_thl, p_ini, p_fin, 0._r8, 0._r8, thl_cu_ini, tmp_thl )
                  !g                     call progup_thlqt( 0._r8, dia_qt,  p_ini, p_fin, 0._r8, 0._r8,  qt_cu_ini, tmp_qt )
                  !g                     call conden( p_fin, tmp_thl, tmp_qt, tmp_th, tmp_qv, tmp_ql, tmp_qi, qse, id_check )
                  !f                     if( id_check .eq. 1 ) then
                  !f                         id_exit = .true.
                  !f                         go to 333
                  !f                     endif
                  !g                     ql_cu_ini  = tmp_ql
                  !g                     qi_cu_ini  = tmp_qi
                  !g                     thl_cu_ini = tmp_thl
                  !g                     qt_cu_ini  = tmp_qt
                  !g                  enddo
                  !g                  exql = min( max( ql - tmp_ql, 0._r8 ), 0.99_r8 * ql )
                  !g                  exqi = min( max( qi - tmp_qi, 0._r8 ), 0.99_r8 * qi )
                  !g                ! I can add below 4 lines if I want to guarantee that precipitation production
                  !g                ! does not reduce 'ql + qi' down below 'criqc'. 
                  !g                ! tmp1 = exql + exqi
                  !g                ! tmp2 = min( tmp1, max( ql + qi - criqc, 0._r8 ) ) ! To impose a continuous variation across ql + qi = criqc.
                  !g                ! exql = exql * ( tmp2 / max( tmp1, nonzero ) )
                  !g                ! exqi = exqi * ( tmp2 / max( tmp1, nonzero ) )
                  !g              endif
                  !g            ! ql = ql - exql
                  !g            ! qi = qi - exqi
                  !g            ! ----------------------------------------------------------------------------------- !
                  !g            ! Jun.16.2012. I should recompute the buoyancy using updated state variables as below !
                  !g            !              similar to CAM5 shallow convection scheme. It turns out that           !
                  !g            !              this update is important and has non-negligible impact on the          !
                  !g            !              simulation. Comment-out above two lines.                               !
                  !g            !              For simplicity, just use exns0(k) at the top interface.                ! 
                  !g            ! ----------------------------------------------------------------------------------- ! 
                  !g              call conden( p_t, thl_au(m) + ( xlv / cp / exns0(k) ) * exql + ( xls / cp / exns0(k) ) * exqi, qt_au(m) - exql - exqi, &
                  !g                                th, qv, ql, qi, qse, id_check )
                  !f              if( id_check .eq. 1 ) then
                  !f                  id_exit = .true.
                  !f                  go to 333
                  !f              endif
                  !g              thvtop  = th * ( 1._r8 + zvir * qv - ql - qi )
                  !g              bogtop  = rbuoy_up * ( thvtop / thv_t - 1._r8 )
                  !g              cin  = 0._r8 
                  !g              plfc = 0._r8
                  !g              plcl = qsinvert( qt_au(m), thl_au(m), ps0(0) )

                  !g            ! CHECK
                  !g            ! write(6,*)
                  !g            ! write(6,*) 'UNICON : Computation of plcl'
                  !g            ! write(6,*) 'Layer index and segment = ', k, m 
                  !g            ! write(6,*)
                  !g            ! CHECK

                  !g              if( plcl .lt. p_b .and. plcl .gt. p_t ) then
                  !g                  thl0lcl = thl0(k) + ssthl0(k) * ( plcl - p_m )
                  !g                  qt0lcl  = qt0(k)  + ssqt0(k)  * ( plcl - p_m )
                  !g                  call conden( plcl, thl0lcl, qt0lcl, th, qv, ql, qi, qse, id_check )
                  !f                  if( id_check .eq. 1 ) then
                  !f                      id_exit = .true.
                  !f                      go to 333
                  !f                  end if
                  !g                  thv0lcl = th * ( 1._r8 + zvir * qv - ql - qi )
                  !g                  if( islope_on_thlqttr .eq. 0 ) thv0lcl = thv0(k)
                  !g                  boglcl = rbuoy_up * ( thvbot / thv0lcl - 1._r8 )                    
                  !g                  call getbuoy( p_b, thv_b, plcl, thv0lcl, thvbot, thvbot, rho_m, plfc, cin )
                  !g                  cinlcl = cin 
                  !g                  if( plfc .lt. nonzero ) then
                  !g                      call getbuoy( plcl, thv0lcl, p_t, thv_t, thvbot, thvtop, rho_m, plfc, cin )
                  !g                  endif
                  !g              else
                  !g                  call getbuoy( p_b, thv_b, p_t, thv_t, thvbot, thvtop, rho_m, plfc, cin )
                  !g              endif
                  !g              ! ----------------------------------------------------------------------------------- !
                  !g              ! Check whether convective updraft can overcome CIN and reaches to the top interface. !
                  !g              ! If then, compute vertical velocity at the top interface. Note that consistent with  !
                  !g              ! the pre-computed eps = 0, I still assume non-entrainment from the LFC to the top    !
                  !g              ! interface.                                                                          !
                  !g              ! ----------------------------------------------------------------------------------- !
                  !g              if( w_au(m) .ge. sqrt( 2._r8 * rbuoy_up * cin ) ) then
                  !g                  dpa(m)   = p_b - p_t
                  !g                  if( plcl .lt. p_b .and. plcl .gt. p_t ) then
                  !g                      if( plfc .ge. plcl .and. plfc .lt. p_b ) then
                  !g                          cinp   = 0.5_r8 * ( boglcl / rbuoy_up ) * ( plfc - plcl ) / rho_m
                  !g                          cinp   = cinp + 0.5_r8 * ( ( boglcl + bogtop ) / rbuoy_up ) * ( plcl - p_t ) / rho_m
                  !g                      elseif( plfc .lt. plcl .and. plfc .ge. p_t ) then
                  !g                          cinp   = 0.5_r8 * ( bogtop / rbuoy_up ) * ( plfc - p_t ) / rho_m
                  !g                      else
                  !g                          cinp   = 0._r8
                  !g                      endif
                  !g                  else
                  !g                      if( plfc .lt. p_b .and. plfc .ge. p_t ) then
                  !g                          cinp   = 0.5_r8 * ( bogtop / rbuoy_up ) * ( plfc - p_t ) / rho_m
                  !g                      else
                  !g                          cinp   = 0._r8
                  !g                      endif
                  !g                  endif

                  !g                ! CHECK
                  !g                ! write(6,*)
                  !g                ! write(6,*) 'UNICON : Computation of cinp'
                  !g                ! write(6,*) 'p_b, p_t, plcl, plfc = ', p_b, p_t, plcl, plfc 
                  !g                ! write(6,*)
                  !g                ! CHECK

                  !g                  w_aut(m) = sqrt( w_au(m)**2._r8 - 2._r8 * rbuoy_up * cin + 2._r8 * rbuoy_up * cinp )
                  !g                  w_aut(m) = max( w_aut(m), wumin )
                  !g                ! w_aut(m) = min( wumax, max( w_aut(m), wumin ) )
                  !g              else
                  !g                  if( plcl .lt. p_b .and. plcl .gt. p_t ) then
                  !g                      if( plfc .ge. plcl .and. plfc .lt. p_b ) then
                  !g                          dpa(m) = compute_dp_zeroeps( rho_m, p_b, plfc, bogbot,  0._r8, w_au(m)**2._r8 )  
                  !g                      elseif( plfc .lt. plcl .and. plfc .ge. p_t ) then
                  !g                          tmp1 = w_au(m)**2._r8 - 2._r8 * rbuoy_up * cinlcl
                  !g                          if( tmp1 .le. 0._r8 ) then
                  !g                              dpa(m) = compute_dp_zeroeps( rho_m, p_b, plcl, bogbot, boglcl, w_au(m)**2._r8 )                   
                  !g                          else
                  !g                              dpa(m) = compute_dp_zeroeps( rho_m, plcl, plfc, boglcl, 0._r8, tmp1 )
                  !g                              dpa(m) = dpa(m) + ( p_b - plcl )       
                  !g                          endif 
                  !g                      elseif( plfc .lt. p_t ) then
                  !g                          tmp1 = w_au(m)**2._r8 - 2._r8 * rbuoy_up * cinlcl
                  !g                          if( tmp1 .le. 0._r8 ) then
                  !g                              dpa(m) = compute_dp_zeroeps( rho_m, p_b, plcl, bogbot, boglcl, w_au(m)**2._r8 )                   
                  !g                          else
                  !g                              dpa(m) = compute_dp_zeroeps( rho_m, plcl, p_t, boglcl, bogtop, tmp1 )                              
                  !g                              dpa(m) = dpa(m) + ( p_b - plcl )       
                  !g                          endif 
                  !g                      else
                  !g                          call endrun('UNICON : Impossible case of plfc vs plcl')  
                  !g                      endif
                  !g                  else
                  !g                      if( plfc .lt. p_b .and. plfc .ge. p_t ) then
                  !g                          dpa(m) = compute_dp_zeroeps( rho_m, p_b, plfc, bogbot, 0._r8, w_au(m)**2._r8 )  
                  !g                      else
                  !g                          dpa(m) = compute_dp_zeroeps( rho_m, p_b, p_t, bogbot, bogtop, w_au(m)**2._r8 )  
                  !g                      endif 
                  !g                  endif
                  !g                  dpa(m)   = max( 0._r8, min( p_b - p_t, dpa(m) ) )
                  !g                  w_aut(m) = 0._r8
                  !g              endif
                  !g          else
                  ! ------------------------------------------------------------------------- !
                  ! In this case, entrainment mixing occurs. So, simply use the previous code !
                  ! by assuming a simple linear profile of buoyancy from the base to the top  !
                  ! interface.                                                                !
                  ! Apr.17.2012. In order to remove ambiguity, I am using thl_meu, qt_meu     !
                  !              in the below block.                                          !
                  ! ------------------------------------------------------------------------- !
                  thl_meu = thle_b(k) + ssthle(k) * 0.5_r8 * ( p_t - p_b )
                  qt_meu  = qte_b(k)  + ssqte(k)  * 0.5_r8 * ( p_t - p_b )
                  ql_meu  = qle_b(k)  + ssqle(k)  * 0.5_r8 * ( p_t - p_b )
                  qi_meu  = qie_b(k)  + ssqie(k)  * 0.5_r8 * ( p_t - p_b )
                  call progup_thlqt( eps(m), 0._r8, 0._r8, p_b, p_t, thl_meu, ssthle(k), thl_au(m), thl_aut_tmp )
                  call progup_thlqt( eps(m), 0._r8, 0._r8, p_b, p_t,  qt_meu,  ssqte(k),  qt_au(m),  qt_aut_tmp )
                  call progup_thlqt( eps(m), 0._r8, 0._r8, p_b, p_t,  ql_meu,  ssqle(k),  ql_au(m),  ql_aut_adi )
                  call progup_thlqt( eps(m), 0._r8, 0._r8, p_b, p_t,  qi_meu,  ssqie(k),  qi_au(m),  qi_aut_adi )
                  call conden( p_t, thl_aut_tmp, qt_aut_tmp, th, qv, ql, qi, qse, id_check )
                  !f              if( id_check .eq. 1 ) then
                  !f                  id_exit = .true.
                  !f                  go to 333
                  !f              endif
                  do mt = 1, ncnst
                     tr_meu(mt)  = tre_b(k,mt)  + sstre(k,mt)  * 0.5_r8 * ( p_t - p_b )
                     call progup_thlqt( eps(m), 0._r8, 0._r8, p_b, p_t, tr_meu(mt), sstre(k,mt), tr_au(m,mt), tr_aut_tmp(mt) )
                  enddo

                  ! ------------------------------------------------------------------------------------ !
                  ! Feb.07.2013.                                                                         !
                  ! Compute precipitation production at the top interface.                               !
                  ! Use approximation of w_au(m) = w_aut(m), since we don't know w_aut(m) at this stage. !
                  ! Note since am_pu_msfc(k,msfc) is computed using am_us_msfc(k,msfc) not by using      !
                  ! am_u_msfc(k,msfc), I am using am_us_msfc(k,msfc) in the below subroutine as an input !
                  ! argument. However, in association with the use of beta2 = 1 and evaporation within   !
                  ! PBL environment, I should come up with more satisfactory cloud overlapping structure !
                  ! in future. This is always related with the treatment of wet deposition of aerosols   !
                  ! within unsaturated convective updraft. I should figure this out before AMWG.         !
                  ! Feb.09.2013.                                                                         !
                  ! Note that the input argument is 'am_u_msfc(k,msfc)' not 'am_us_msfc(k,msfc)' since   !
                  ! evaporation within updraft is also treated when updraft is unsaturated.              !
                  ! Apr.08.2013. Fully analytical computation of precipitation fallout is added, which   !
                  !              replaces previous 'prod_prep_up' subroutine.                            !
                  ! ------------------------------------------------------------------------------------ !

                  ! ------------------------------------------------------------------------- !
                  ! Compute 'exql,exqi' by solving analytical vertical integration of 'ql,qi' ! 
                  ! by including differential precipitation fall-out in the integration.      !
                  ! In the below simplified microphysics, 'eps_dia_L = eps_dia_I'. However,   !
                  ! in the future refined microphysics, they can differ. Thus, I am keeping   !
                  ! both 'eps_dia_L' and 'eps_dia_I'.                                         !   
                  ! ------------------------------------------------------------------------- !

                  if( iprd_prep .eq. 5 ) then  ! Backward Analytical Method

                  if( ( ql_cu + qi_cu ) .gt. criqc ) then
                     eps_dia_L = c0_ac * ( ( ql_cu + qi_cu ) - criqc ) / ( ql_cu + qi_cu )
                     eps_dia_I = c0_ac * ( ( ql_cu + qi_cu ) - criqc ) / ( ql_cu + qi_cu )
                  else
                     eps_dia_L = 0._r8
                     eps_dia_I = 0._r8
                  endif
                  call progup_thlqt( eps(m), eps_dia_L, 0._r8, p_b, p_t, ql_meu, ssqle(k), ql_au(m), ql_aut_adi_prp )
                  call progup_thlqt( eps(m), eps_dia_I, 0._r8, p_b, p_t, qi_meu, ssqie(k), qi_au(m), qi_aut_adi_prp )
                  exql = min( max( ql_aut_adi - ql_aut_adi_prp, 0._r8 ), 0.99_r8 * ql )  ! This should be guaranteed to be positive at this stage.
                  exqi = min( max( qi_aut_adi - qi_aut_adi_prp, 0._r8 ), 0.99_r8 * qi )  ! This should be guaranteed to be positive at this stage.
                  if( mclimit .eq. 1 ) then
                     tmp1 = exql + exqi
                     !prp                tmp2 = min( tmp1, max( ql_aut_adi + qi_aut_adi - criqc, 0._r8 ) ) ! To impose a continuous variation across ql_aut_adi + qi_aut_adi = criqc.
                     ! Consistent with downdraft treatment, the limiter should be imposed using 'ql,qi' computed from 
                     ! adiabatic 'thl_aut_tmp, qt_aut_tmp' (that includes both 'mixing' and 'CEF') from direct variable
                     ! conversion using 'conden' subroutine. 
                     tmp2 = min( tmp1, max( ql + qi - criqc, 0._r8 ) )                 ! To impose a continuous variation across ql + qi = criqc.
                     exql = exql * ( tmp2 / max( tmp1, nonzero ) )
                     exqi = exqi * ( tmp2 / max( tmp1, nonzero ) )
                  endif
                  ! -------------------------------------------------- !
                  ! Evaporation within Updraft.                        !
                  ! Set it to be zero, but can be refined in future.   !
                  ! -------------------------------------------------- !
                  evpR = 0._r8
                  evpS = 0._r8

                  else ! The others of Backward Analytical Method

                  ! ------------------------------------------------------------------------- !
                  ! Below is previous block replaced by the above full                        !
                  ! analytical treatment of precipitation fall-out within convective updraft. !
                  ! ------------------------------------------------------------------------- !

                  msfc = msfc_from_m(k,m)
                  call prod_prep_up( z_b, z_t, p_b, p_t, exn_t, exn0(k),                         &
                                     w_au(m), w_au(m),                                           &
                                     thl_aut_tmp, qt_aut_tmp, ql, qi, tr_aut_tmp(1:ncnst),       &
                                     S_b_ql_au(m), S_b_qi_au(m), iprd_prep,                      &
                                     ql_cu, qi_cu, eps(m),                                       &
                                     thl_meu, ssthle(k), thl_au(m), qt_meu, ssqte(k), qt_au(m),  & 
                                     ncnst, ixcldliq, ixcldice, ixnumliq, ixnumice, i, k, lchnk, &
                                     flxrain_msfc(k,msfc), flxsnow_msfc(k,msfc),                 &     
                                     a_p_msfc(k,msfc), am_u_msfc(k,msfc), am_pu_msfc(k,msfc),    & 
                                     caer, criqc, c0_ac, droprad_liq, droprad_ice,               &
                                     exql, exqi, extr(1:ncnst), S_t_ql_au(m), S_t_qi_au(m),      &
                                     evpR, evpS, evpRStr(1:ncnst) )

                  endif ! End of Backward Analytical Method

                  !h              ! ---------------------------------------------------------------------------------------- !
                  !h              ! Dec.03.2012.                                                                             !
                  !h              ! Below 'microcu' block is used only for computing buoyancy at the top interface, thvtop,  !
                  !h              ! which is designed to compute 'ptop(m)' and 'ztop(m)' in each layer, instead of computing !
                  !h              ! cumulus updraft properties at the 'ptop(m)' after precipitation fall-out, which will be  !
                  !h              ! computed later.                                                                          ! 
                  !h              ! ---------------------------------------------------------------------------------------- ! 
                  !h              ! ------------------------------------------------------------------------------------------------ !
                  !h              ! Note that both below microcu = 0 and microcu = 1 are vertical resolution-inseisitive computation !
                  !h              ! when microcu = 0 (1) is used upward-final (centered) differencing as in the current code.        !     
                  !h              ! ------------------------------------------------------------------------------------------------ !
                  !h              if( microcu .eq. 0 ) then
                  !h                  if( ( ql + qi ) .gt. criqc ) then
                  !h                        exql = c0_ac * ( ( ql + qi ) - criqc ) * ql / ( ql + qi )
                  !h                        exqi = c0_ac * ( ( ql + qi ) - criqc ) * qi / ( ql + qi )
                  !h                  else
                  !h                        exql = 0._r8
                  !h                        exqi = 0._r8 
                  !h                  endif
                  !h              elseif( microcu .eq. 1 ) then
                  !h                ! ------------------------------------------------------------------------------------------------- !
                  !h                ! Note that I don't need to compute 'exql,exqi' since they are not used in the further below block. !
                  !h                ! The only variable I should compute is 'th,qv,ql,qi' at the top interface which are only used for  !
                  !h                ! computing 'thvtop  = th * ( 1._r8 + zvir * qv - ql - qi )' just below of this if block.           !
                  !h                ! Thus, below computation is enough and accurate.                                                   !
                  !h                ! However, in order to be fully compatible with the other 'microcu' block, and in order to be       !
                  !h                ! consistent with the idea that 'precipitation production only reduces ql,qi without changing the   !
                  !h                ! other thermodynamic variables, it is good to perform all the computations solely based on the     !
                  !h                ! exql and exqi. Thus, I restored to the computation of exql and exqi.                              !
                  !h                ! ------------------------------------------------------------------------------------------------- !
                  !h                ! --------------------------------------------------------------------------------------- !
                  !h                ! May.25.2012. Below is the most perfect treatment fully consistent and symmetric with    !
                  !h                !              the treatment of evaporation of precipitation within convective downdraft, ! 
                  !h                !              with minimum sensitivity to the vertical resolution, and                   !
                  !h                !              with correct appropriate limiters.                                         !
                  !h                ! --------------------------------------------------------------------------------------- !
                  !h                  if( ( ql + qi ) .gt. criqc ) then
                  !h                      f_Lt = ( c0_ac / ( 1._r8 ) ) * ( ( ql + qi ) - criqc ) * ( ql / ( ql + qi ) ) ! [ kg/kg/Pa ]
                  !h                      f_It = ( c0_ac / ( 1._r8 ) ) * ( ( ql + qi ) - criqc ) * ( qi / ( ql + qi ) ) ! [ kg/kg/Pa ]
                  !h                  else
                  !h                      f_Lt = 0._r8
                  !h                      f_It = 0._r8
                  !h                  endif                 
                  !h                  if( ( ql_cu + qi_cu ) .gt. criqc ) then
                  !h                      f_Lb = ( c0_ac / ( 1._r8 ) ) * ( ( ql_cu + qi_cu ) - criqc ) * ( ql_cu / ( ql_cu + qi_cu ) )
                  !h                      f_Ib = ( c0_ac / ( 1._r8 ) ) * ( ( ql_cu + qi_cu ) - criqc ) * ( qi_cu / ( ql_cu + qi_cu ) )
                  !h                  else
                  !h                      f_Lb = 0._r8
                  !h                      f_Ib = 0._r8
                  !h                  endif      
                  !h                  f_L  = f_Lb
                  !h                  f_I  = f_Ib            
                  !h                ! f_L  = 0.5_r8 * ( f_Lt + f_Lb )
                  !h                ! f_I  = 0.5_r8 * ( f_It + f_Ib ) 
                  !h                  dia_qt  =   f_L + f_I 
                  !h                  dia_thl = - ( ( xlv / cp / exn0(k) ) * f_L + ( xls / cp / exn0(k) ) * f_I )
                  !h                ! Apr.18.2012. I double-checked that below 'progup_thlqt' with 'dia_thl,dia_qt' correctly work and 
                  !h                !              produces the right values with the right signs.
                  !h                !              That is, the sign of 'dia_qt,dia_thl' is correct.
                  !h                  call progup_thlqt( eps(m), dia_thl, p_b, p_t, thl_meu, ssthle(k), thl_au(m), tmp_thl )
                  !h                  call progup_thlqt( eps(m), dia_qt,  p_b, p_t,  qt_meu,  ssqte(k),  qt_au(m), tmp_qt )
                  !h                  call conden( p_t, tmp_thl, tmp_qt, tmp_th, tmp_qv, tmp_ql, tmp_qi, qse, id_check )
                  !f                  if( id_check .eq. 1 ) then
                  !f                      id_exit = .true.
                  !f                      go to 333
                  !f                  endif
                  !h                  exql = min( max( ql - tmp_ql, 0._r8 ), 0.99_r8 * ql )
                  !h                  exqi = min( max( qi - tmp_qi, 0._r8 ), 0.99_r8 * qi )
                  !h                ! I can add below 4 lines if I want to guarantee that precipitation production
                  !h                ! does not reduce 'ql + qi' down below 'criqc'. 
                  !h                  if( mclimit .eq. 1 ) then
                  !h                      tmp1 = exql + exqi
                  !h                      tmp2 = min( tmp1, max( ql + qi - criqc, 0._r8 ) ) ! To impose a continuous variation across ql + qi = criqc.
                  !h                      exql = exql * ( tmp2 / max( tmp1, nonzero ) )
                  !h                      exqi = exqi * ( tmp2 / max( tmp1, nonzero ) )
                  !h                  endif
                  !h              elseif( microcu .eq. 2 ) then
                  !h                  dp_sub = ( p_t - p_b ) / nsub_dia
                  !h                  do jj = 1, nsub_dia
                  !h                     p_ini   = p_b   + dp_sub * ( jj - 1 )
                  !h                     p_fin   = p_ini + dp_sub
                  !h                     thl_cen = thle_b(k) + ssthle(k) * ( 0.5_r8 * ( p_fin + p_ini ) - p_b )
                  !h                     qt_cen  =  qte_b(k) +  ssqte(k) * ( 0.5_r8 * ( p_fin + p_ini ) - p_b )
                  !h                     if( jj .eq. 1 ) then
                  !h                         ql_cu_ini  = ql_cu
                  !h                         qi_cu_ini  = qi_cu
                  !h                         thl_cu_ini = thl_au(m)
                  !h                         qt_cu_ini  = qt_au(m)
                  !h                     endif                      
                  !h                     if( ( ql_cu_ini + qi_cu_ini ) .gt. criqc ) then
                  !h                         f_L = ( c0_ac / ( 1._r8 ) ) * ( ( ql_cu_ini + qi_cu_ini ) - criqc ) * ( ql_cu_ini / ( ql_cu_ini + qi_cu_ini ) )
                  !h                         f_I = ( c0_ac / ( 1._r8 ) ) * ( ( ql_cu_ini + qi_cu_ini ) - criqc ) * ( qi_cu_ini / ( ql_cu_ini + qi_cu_ini ) )
                  !h                     else
                  !h                         f_L = 0._r8
                  !h                         f_I = 0._r8
                  !h                     endif  
                  !h                     dia_qt  =   f_L + f_I 
                  !h                     dia_thl = - ( ( xlv / cp / exn0(k) ) * f_L + ( xls / cp / exn0(k) ) * f_I )
                  !h                   ! Apr.18.2012. I double-checked that below 'progup_thlqt' with 'dia_thl,dia_qt' correctly work and 
                  !h                   !              produces the right values with the right signs.
                  !h                   !              That is, the sign of 'dia_qt,dia_thl' is correct. 
                  !h                     call progup_thlqt( eps(m), dia_thl, p_ini, p_fin, thl_cen, ssthle(k), thl_cu_ini, tmp_thl )
                  !h                     call progup_thlqt( eps(m), dia_qt,  p_ini, p_fin,  qt_cen,  ssqte(k),  qt_cu_ini, tmp_qt )
                  !h                     call conden( p_fin, tmp_thl, tmp_qt, tmp_th, tmp_qv, tmp_ql, tmp_qi, qse, id_check )
                  !f                     if( id_check .eq. 1 ) then
                  !f                         id_exit = .true.
                  !f                         go to 333
                  !f                     endif
                  !h                     ql_cu_ini  = tmp_ql
                  !h                     qi_cu_ini  = tmp_qi
                  !h                     thl_cu_ini = tmp_thl
                  !h                     qt_cu_ini  = tmp_qt
                  !h                  enddo
                  !h                  exql = min( max( ql - tmp_ql, 0._r8 ), 0.99_r8 * ql )
                  !h                  exqi = min( max( qi - tmp_qi, 0._r8 ), 0.99_r8 * qi )
                  !h                ! I can add below 4 lines if I want to guarantee that precipitation production
                  !h                ! does not reduce 'ql + qi' down below 'criqc'. 
                  !h                ! tmp1 = exql + exqi
                  !h                ! tmp2 = min( tmp1, max( ql + qi - criqc, 0._r8 ) ) ! To impose a continuous variation across ql + qi = criqc.
                  !h                ! exql = exql * ( tmp2 / max( tmp1, nonzero ) )
                  !h                ! exqi = exqi * ( tmp2 / max( tmp1, nonzero ) )
                  !h              endif
                  ! ql = ql - exql
                  ! qi = qi - exqi
                  ! ----------------------------------------------------------------------------------- !
                  ! Jun.16.2012. I should recompute the buoyancy using updated state variables as below !
                  !              similar to CAM5 shallow convection scheme. It turns out that           !
                  !              this update is important and has non-negligible impact on the          !
                  !              simulation. Comment-out above two lines.                               !
                  !              For simplicity, use exner function defined at the top interface since  !
                  !              p_t is defined at the top model interface.                             !
                  !              The correct cumulus top is computed later below.                       ! 
                  !              It turns out that computation of 'thvtop' has huge influences on the   !
                  !              CLDLOW and SWCF in the trade cumulus regime.                           !     
                  ! Feb.10.2013. Add contribution of evaporation within updraft in computing updraft    !
                  !              buoyancy at the cumulus top.                                           !
                  ! Mar.07.2013. In order to ensure 'bogtop --> 0' when 'a_u(km) --> 1' for the case of !
                  !              single updraft (note that at this stage, we don't know what is 'a_u(k)'!
                  !              so we use 'a_u(km)' here instead), we define 'thv_mean_t' in a hybrid  !
                  !              way as below.                                                          !
                  !              In addition, 'bogtop' is defined using 'thv_mean_t' instead of 'thv_t'.!   
                  ! Mar.13.2013. In principle, without using 'conden', we can compute 'th, qv, ql, qi'  !
                  !              since 'exql,exqi' do not change 'th', and the changes of 'th,qv' by    !
                  !              the 'evpR, evpS' can be analytically computed.                         !
                  !              This analytical computation without using 'conden' should be done in   !
                  !              future to save computation time. In other word, whenever possible,     !
                  !              I should not use 'conden'.                                             !       
                  ! Mar.15.2015. Add 'frac_ice = qi - exqi / (ql + qi - exql - exqi)' as an optional    !
                  !              argument for subroutine 'conden' below. This optional argument is used !
                  !              only when we priori know 'frac_ice' before doing 'conden'. This input  !
                  !              frac_ice is used in subroutine 'conden' instead of using T-dependent   !
                  !              function. This optional argument should be used                        !
                  !              when we used subroutine 'conden' after precipitation production.       !      
                  ! ----------------------------------------------------------------------------------- ! 
             !ice frac_ice = ( qi - exqi ) / max( ql + qi - exql - exqi, nonzero ) 
             !ice frac_ice = max( 0._r8, min( 1._r8, frac_ice ) )
             !ice call conden( p_t, thl_aut_tmp + ( xlv / cp / exn_t ) * ( exql - evpR ) + ( xls / cp / exn_t ) * ( exqi - evpS ), &
             !ice                   qt_aut_tmp - exql - exqi + evpR + evpS, &
             !ice                   th, qv, ql, qi, qse, id_check, frac_ice = frac_ice )
                  call conden( p_t, thl_aut_tmp + ( xlv / cp / exn_t ) * ( exql - evpR ) + ( xls / cp / exn_t ) * ( exqi - evpS ), &
                                    qt_aut_tmp - exql - exqi + evpR + evpS, &
                                    th, qv, ql, qi, qse, id_check)
                  !f              if( id_check .eq. 1 ) then
                  !f                  id_exit = .true.
                  !f                  go to 333
                  !f              endif
                  thvtop  = th * ( 1._r8 + zvir * qv - ql - qi )
                  thv_mean_t = a_u(km) * thvtop + ( 1._r8 - a_u(km) ) * thv_t
                  bogtop  = rbuoy_up * ( thvtop / thv_mean_t - 1._r8 )
                  ! bogtop  = rbuoy_up * ( thvtop / thv_t - 1._r8 )
                  ! TEST
                  ! bogtop = bogbot
                  ! TEST  

                  ! --------------------------------------------------------------------------------------------- !
                  ! Below block is generally formulated to treat the special case of 'bogbot < 0 and bogtop > 0'. !
                  ! So, even when 'OPTION.3' is selected above, below block itself can treat all the cases in a   !
                  ! most reasonable way. So, the CIN structure ( other than resolving LCL explicitly ) can be     !
                  ! resolved in a most reasonable way.                                                            !
                  ! Mar.11.2013. Add 'we_b(k)**2._r8' as the argument of 'progup_wu2' and 'compute_dp'.           !
                  ! --------------------------------------------------------------------------------------------- !

                  if( bogbot .lt. 0._r8 .and. bogtop .gt. 0._r8 ) then 
                     plfc = p_b - ( p_b - p_t ) * ( bogbot / ( bogbot - bogtop ) )
                     call progup_wu2( rdrag*eps(m) - rjet*del(m), rho_m, p_b, plfc, bogbot, 0._r8, w_au(m)**2._r8, &
                                      we_b(k)**2._r8, wu2 ) 
                     if( wu2 .ge. 0._r8 ) then
                        dpa(m) = p_b - p_t
                        call progup_wu2( rdrag*eps(m) - rjet*del(m), rho_m, p_b, p_t, bogbot, bogtop, w_au(m)**2._r8, &
                                         we_b(k)**2._r8, wu2 ) 
                        w_aut(m) = max( sqrt( max( wu2, nonzero ) ), wumin )       
                        ! w_aut(m) = min( wumax, max( sqrt( max( wu2, nonzero ) ), wumin ) )       
                     else
                        dpa(m) = compute_dp( rdrag*eps(m) - rjet*del(m), rho_m, p_b, plfc, bogbot, 0._r8, w_au(m)**2._r8, &
                                 we_b(k)**2._r8 )  ! '0 <= dpa(m) <= p_b-plfc'
                        w_aut(m) = 0._r8
                     endif
                  else
                     call progup_wu2( rdrag*eps(m) - rjet*del(m), rho_m, p_b, p_t, bogbot, bogtop, w_au(m)**2._r8, &
                                      we_b(k)**2._r8, wu2 ) 
                     if( wu2 .ge. 0._r8 ) then
                        dpa(m) = p_b - p_t
                        w_aut(m) = max( sqrt( max( wu2, nonzero ) ), wumin )       
                        ! w_aut(m) = min( wumax, max( sqrt( max( wu2, nonzero ) ), wumin ) )       
                     else
                        if( .not. ( ( bogbot .ge. 0._r8 .and. bogtop .lt. 0._r8 ) .or. &
                           ( bogbot .lt. 0._r8 .and. bogtop .le. 0._r8 ) ) ) then  
                           write(6,*) 'bogbot, bogtop = ', bogbot, bogtop
                           write(6,*) 'awk_PBL_raw, delta_thl_PBL_raw, delta_qt_PBL_raw, delta_u_PBL_raw, delta_v_PBL_raw = ', & 
                                         awk_PBL_raw, delta_thl_PBL_raw, delta_qt_PBL_raw, delta_u_PBL_raw, delta_v_PBL_raw
                           write(6,*) 'awk_PBL, delta_thl_PBL, delta_qt_PBL, delta_u_PBL, delta_v_PBL, delta_w_PBL = ', & 
                                         awk_PBL, delta_thl_PBL, delta_qt_PBL, delta_u_PBL, delta_v_PBL, delta_w_PBL
                           call endrun('UNICON : Impossible buoyancy case before compute_dp')  
                        endif
                        ! Bug fix on Apr.12.2011. (1) 'bogbot .gt. 0._r8' is changed to 'bogbot .ge. 0._r8', and
                        ! (2) w_au(m)**2._r8 is changed to 'tmp1' in the below computation of dpa(m) with the
                        ! addition of computation of 'tmp1'.
                        ! if( bogbot .gt. 0._r8 .and. bogtop .lt. 0._r8 ) then
                        if( bogbot .ge. 0._r8 .and. bogtop .lt. 0._r8 ) then 
                           ! In this case, we should compute 'plnb' ( Level of Neutral Buoyancy ) and use compute_dp from plnb 
                           ! to the top interface. This is necessary to prevent zero denominator ( slope, fs ) in compute_dp. 
                           ! The updraft is guaranteed to rise above 'plnb'.
                           ! Previously, this was the cause of CAM5 crash.
                           plnb = p_b - ( p_b - p_t ) * ( bogbot / ( bogbot - bogtop ) )
                           call progup_wu2( rdrag*eps(m) - rjet*del(m), rho_m, p_b, plnb, bogbot, 0._r8, w_au(m)**2._r8, &
                                            we_b(k)**2._r8, tmp1 )
                           dpa(m) = compute_dp( rdrag*eps(m) - rjet*del(m), rho_m, plnb, p_t, 0._r8, bogtop, tmp1, &
                                                we_b(k)**2._r8 )  ! '0 <= dpa(m) <= plnb-p_t'
                           dpa(m) = dpa(m) + ( p_b - plnb )
                        else
                           dpa(m) = compute_dp( rdrag*eps(m) - rjet*del(m), rho_m, p_b, p_t, bogbot, bogtop, w_au(m)**2._r8, &
                                                we_b(k)**2._r8 )  ! '0 <= dpa(m) <= p_b-p_t'
                        endif
                        w_aut(m) = 0._r8
                     endif
                  endif

                  !g          endif ! End of 'icridis_negbuoy' if selection sentence. 

                  dza(m)  = min( dz_m, max( 0._r8, dpa(m) / rho_m / g ) )
                  ptop(m) = p_b - dpa(m)
                  ztop(m) = z_b + dza(m)

                  ! CHECK
                  ! write(6,*)
                  ! write(6,*) 'UNICON: Comparison of bogtop'
                  ! write(6,*) 'Layer Index = ', k
                  ! write(6,*) 'bogtop(simple), bogtop(advanced)  = ', thv_t*tmp3, thv_t*bogtop
                  ! write(6,*)
                  ! CHECK

                  ! CHECK
                  ! write(6,*)
                  ! write(6,*) 'UNICON: Updraft top height'
                  ! write(6,*) 'w_au(m)**2._r8  = ', w_au(m)**2._r8
                  ! write(6,*) 'rdrag*eps(m)    = ', rdrag*eps(m) 
                  ! write(6,*) 'rho_m           = ', rho_m
                  ! write(6,*) 'p_b             = ', p_b
                  ! write(6,*) 'p_t             = ', p_t
                  ! write(6,*) 'bogbot          = ', bogbot
                  ! write(6,*) 'bogtop          = ', bogtop
                  ! write(6,*) 'dpa(m)          = ', dpa(m)
                  ! write(6,*) 'dza(m)          = ', dza(m)
                  ! write(6,*) 'ptop(m)         = ', ptop(m)
                  ! write(6,*) 'ztop(m)         = ', ztop(m)
                  ! write(6,*)
                  ! CHECK

                  ! OPTION. Should impose consistency with downdraft criteria.
                  !         It is good to impose a cmfmin criteria too.
                  ! Feb.06.2013. Always choose physically reasonable 'exp_cmf = 1' as of this day. 
            
                  if( exp_cmf .eq. 1 ) then  
                     tmp1 = cmf_au(m) * exp( dpa(m) * ( eps(m) - del(m) ) )
                  elseif( exp_cmf .eq. 2 ) then
                     tmp1 = max( 0._r8, cmf_au(m) * ( 1._r8 + dpa(m) * ( eps(m) - del(m) ) ) )
                     !           elseif( exp_cmf .eq. 3 ) then
                     !               if( eps(m) .ge. del(m) ) then
                     !                   tmp1 = max( 0._r8, cmf_au(m) * ( 1._r8 + dpa(m) * ( eps(m) - del(m) ) ) )
                     !               else
                     !                   tmp1 = cmf_au(m) * exp( dpa(m) * ( eps(m) - del(m) ) )
                     !               endif 
                  endif

                ! if( w_aut(m) .gt. nonzero .and. tmp1 .ge. cmfmin ) then   ! Include mass-flux constraint too         
                  if( w_aut(m) .gt. nonzero .and. tmp1 .ge. cmfmin .and. k .ne. mkx ) then 
                     ! if( w_aut(m) .gt. nonzero ) then   
                     ytop(m)    = 1._r8
                     if( exp_cmf .eq. 1 ) then
                        cmf_aut(m) = cmf_au(m) * exp( dp_m * ( eps(m) - del(m) ) )
                     elseif( exp_cmf .eq. 2 ) then
                        cmf_aut(m) = max( 0._r8, cmf_au(m) * ( 1._r8 + dp_m * ( eps(m) - del(m) ) ) )                
                        !               elseif( exp_cmf .eq. 3 ) then
                        !                   if( eps(m) .ge. del(m) ) then
                        !                       cmf_aut(m) = max( 0._r8, cmf_au(m) * ( 1._r8 + dp_m * ( eps(m) - del(m) ) ) )
                        !                   else
                        !                       cmf_aut(m) = cmf_au(m) * exp( dp_m * ( eps(m) - del(m) ) )
                        !                   endif
                     endif
                     a_aut(m)   = cmf_aut(m) / rho_t / w_aut(m)
                     num_aut(m) = num_au(m)
                     rad_aut(m) = sqrt( a_aut(m) / num_aut(m) /  3.141592_r8 )   ! Physical radius of updraft plume [ m ]

                     ! CHECK
                     ! write(6,*)
                     ! write(6,*) 'UNICON: Non-detached updraft at the top interface'
                     ! write(6,*) 'Layer index & m : ', k, m
                     ! write(6,*) 'w_aut(m), cmf_aut(m), a_aut(m), rad_aut(m) = ', w_aut(m), cmf_aut(m), a_aut(m), rad_aut(m)
                     ! write(6,*) 'eps0(m), eps(m), del(m) = ', eps0(m), eps(m), del(m)
                     ! write(6,*)
                     ! CHECK

                     ! CHECK
                     ! if( get_nstep() .eq. 248 .and. k .eq. 6 ) then
                     !     write(6,*)
                     !     write(6,*) 'UNICON: Evolution of Updraft Vertical Momentum and Mass Flux that reaches to the top interface'
                     !     write(6,*) 'Time Step and Layer Index    = ', get_nstep(), k
                     !     write(6,*) 'w_au(m), w_aut(m)            = ', w_au(m), w_aut(m)
                     !     write(6,*) 'rdrag*eps(m)                 = ', rdrag*eps(m) 
                     !     write(6,*) 'rho_m                        = ', rho_m
                     !     write(6,*) 'p_b                          = ', p_b
                     !     write(6,*) 'p_t                          = ', p_t
                     !     write(6,*) 'bogbot                       = ', bogbot
                     !     write(6,*) 'bogtop                       = ', bogtop
                     !     write(6,*) 'thvbot, thv_b                = ', thvbot, thv_b
                     !     write(6,*) 'thvtop, thv_t, thv0bot(k+1)  = ', thvtop, thv_t, thv0bot(k+1)
                     !     write(6,*) 'xc(m), eeps(m), ddel(m)      = ', xc(m), eeps(m), ddel(m)
                     !     write(6,*) 'eps0(m), eps(m), del(m)      = ', eps0(m), eps(m), del(m)
                     !     write(6,*) 'w_au(m), w_aut(m)            = ', w_au(m), w_aut(m)
                     !     write(6,*) 'cmf_au(m), cmf_aut(m)        = ', cmf_au(m), cmf_aut(m)
                     !     write(6,*) 'a_au(m), a_aut(m)            = ', a_au(m), a_aut(m)
                     !     write(6,*) 'rad_au(m), rad_aut(m)        = ', rad_au(m), rad_aut(m)
                     !     write(6,*)
                     ! endif
                     ! CHECK

                  else

                     ! CHECK
                     ! write(6,*)
                     ! write(6,*) 'UNICON: Updraft Mass Flux at the Cumulus Top'
                     ! write(6,*) 'Layer index = ', k
                     ! write(6,*) 'dpa(m), eps0(m), eps(m), del(m)  = ', dpa(m), eps0(m), eps(m), del(m) 
                     ! write(6,*) 'w_aut(m), cmf_aut(m) = ', w_aut(m), cmf_au(m)*exp(dpa(m)*(eps(m)-del(m)))
                     ! write(6,*) 
                     ! CHECK

                     ytop(m)    = 0._r8
                     w_aut(m)   = 0._r8

                     ! Feb.06.2013. Always choose physically reasonable 'exp_cmf = 1' as of this day. 

                     if( exp_cmf .eq. 1 ) then
                        cmf_aut(m) = cmf_au(m) * exp( dpa(m) * ( eps(m) - del(m) ) ) ! For the purpose of computing diabatic forcing later, retain this.
                     elseif( exp_cmf .eq. 2 ) then
                        cmf_aut(m) = max( 0._r8, cmf_au(m) * ( 1._r8 + dpa(m) * ( eps(m) - del(m) ) ) )
                        !               elseif( exp_cmf .eq. 3 ) then
                        !                   if( eps(m) .ge. del(m) ) then
                        !                       cmf_aut(m) = max( 0._r8, cmf_au(m) * ( 1._r8 + dpa(m) * ( eps(m) - del(m) ) ) )
                        !                   else
                        !                       cmf_aut(m) = cmf_au(m) * exp( dpa(m) * ( eps(m) - del(m) ) )
                        !                   endif
                     endif

                     ! Apr.21.2011. In order to get more precise diagnostic output considering partial fill in vertical, 
                     !              insert non-zero values ( values at the base interface )
                     !              to 'a_aut(m)','num_aut(m)','rad_aut(m)' below. Since all the updraft grid-mean values at the
                     !              top interfaces are computed using 'ytop(m)=1', below modification does not change simulation
                     !              answers and are fully compatible with the other parts of the code.
                     !              Of course, below new code is also approximation since it should be 'a --> infinite' at the
                     !              cumulus top if vertical velocity is zero with finite updraft mass flux.
                     !              The idea is that updraft plume is detrained in the infinitesimally thin zone near cloud
                     !              top, which is served as the source of downdraft. Until it is detrained, we assume that
                     !              a_aut(m),num_aut(m),rad_aut(m) are preserved up to the cloud top, and cmf_aut(m)
                     !              changes with height only by lateral entrainment-detrainment. All sudden changes 
                     !              occurs at the very thin transition zone. 

                     a_aut(m)   = a_au(m)
                     num_aut(m) = num_au(m)
                     rad_aut(m) = rad_au(m)

                     ! a_aut(m)   = 0._r8
                     ! num_aut(m) = 0._r8
                     ! rad_aut(m) = 0._r8

                     ! CHECK
                     ! write(6,*)
                     ! write(6,*) 'UNICON: Updraft Mass Flux at the Cumulus Top'
                     ! write(6,*) 'Layer index = ', k
                     ! write(6,*) 'cmf_au(m), cmf_aut(m)   = ', cmf_au(m), cmf_aut(m)
                     ! write(6,*) 'dpa(m), eps0(m), eps(m), del(m)  = ', dpa(m), eps0(m), eps(m), del(m) 
                     ! write(6,*)
                     ! CHECK

                  endif

                  ! ------------------------------------------------------------------ !
                  ! fmix(m) * dpa(m) * eps0(m) * cmf_au(m) :                           !
                  ! The amount of updraft mass involved in the buoyancy sorting mixing !
                  ! Oct.05.2010. This 'fmix' can be enormously large ( e.g., 500 ),    !
                  ! causing CAM5 crash. Thus, I used the discrete value of 1 by        !
                  ! commenting out the below 'if' block. This was the biggest bug.     !
                  ! Jan.30.2013. With a new constraint on eps0(m) on this day,         !
                  !              we don't need to use 'fmix_max' constraint in the     ! 
                  !              below case of 'exp_cmf .eq. 1'. So, I commented out   !
                  !              corresponding line.                                   !           
                  ! ------------------------------------------------------------------ !

                  ! Feb.06.2013. Always choose 'exp_cmf .eq. 1' which is physically reasonable.

                  if( exp_cmf .eq. 1 ) then
                     if( dpa(m) * abs( eps(m) - del(m) ) .ge. 1.e-3_r8 ) then
                        fmix(m) = ( exp( dpa(m) * ( eps(m) - del(m) ) ) - 1._r8 ) / ( dpa(m) * ( eps(m) - del(m) ) )
                     else
                        fmix(m) = 1._r8
                     endif
                     ! fmix(m) = min( fmix(m), fmix_max )
                  elseif( exp_cmf .eq. 2 ) then
                     fmix(m) = 1._r8
                     !           elseif( exp_cmf .eq. 3 ) then
                     !               if( eps(m) .ge. del(m) ) then
                     !                   fmix(m) = 1._r8
                     !               else  
                     !                   if( dpa(m) * abs( eps(m) - del(m) ) .ge. 1.e-3_r8 ) then
                     !                       fmix(m) = ( exp( dpa(m) * ( eps(m) - del(m) ) ) - 1._r8 ) / ( dpa(m) * ( eps(m) - del(m) ) )
                     !                   else
                     !                       fmix(m) = 1._r8
                     !                   endif
                     !                   fmix(m) = min( fmix(m), fmix_max )
                     !               endif
                  endif

                  ! Aug.02.2012. Temporary test
                  ! fmix(m) = 1._r8
                  ! Aug.02.2012. Temporary test

                  ! ------------------------------------------------------------------------ !
                  ! Adiabatic Vertical Prognostic Equation                                   !
                  !  1. This should not include diabatic forcing.                            !
                  !  2. This should use the organized 'thle_m' not the 'thl_m'.              !
                  !  3. We are performing vertical integration upto the cloud top, not the   !
                  !     top interface. Thus, this is performed for all updraft plumes        !
                  !     including detached as well as non-detached updrafts.                 ! 
                  !  4. Also compute cloud condensate.                                       !
                  ! Apr.17.2012. In order to remove ambiguity due to variable use, I define  !
                  !             'thl_meu, qt_meu, u_meu, v_meu, ql_meu, qi_meu, tr_met(mt)'  !
                  !              similar to 'thl_med,...' for use in the below blocks.       !  
                  ! Nov.28.2012. In order to clarify adiabatic and diabatic processes,       !
                  !              any droplet activation due to lateral mixing SHOULD NOT be  !
                  !              treated in the 'progup_thlqt' below even though this        !
                  !              subroutine has a functionality to handle this by using      !
                  !              additional 'dia' input argument as the second argument.     !
                  !              In fact, we can handle diabatic process of 'nl,ni' in below !
                  !              but for that case, we should apply twice 'progup_thlqt' for ! 
                  !              each of the 'tr_au(m,ixnumliq)' and 'tr_au(m,ixnumice)',    !
                  !              first with dia = 0 and second with dia > 0 or < 0. Then by  !
                  !              subtracting the two, we should compute diabatic forcing     !
                  !              on each of 'nl,ni'.  This can be done in future.            !    
                  ! ------------------------------------------------------------------------ !

                  thl_meu = thle_b(k) + ssthle(k) * ( 0.5_r8 * ( ptop(m) + p_b ) - p_b )
                  qt_meu  = qte_b(k)  + ssqte(k)  * ( 0.5_r8 * ( ptop(m) + p_b ) - p_b )
                  u_meu   = ue_b(k)   + ssue(k)   * ( 0.5_r8 * ( ptop(m) + p_b ) - p_b )
                  v_meu   = ve_b(k)   + ssve(k)   * ( 0.5_r8 * ( ptop(m) + p_b ) - p_b )
                  ql_meu  = qle_b(k)  + ssqle(k)  * ( 0.5_r8 * ( ptop(m) + p_b ) - p_b )
                  qi_meu  = qie_b(k)  + ssqie(k)  * ( 0.5_r8 * ( ptop(m) + p_b ) - p_b )
                  do mt = 1, ncnst
                     tr_meu(mt)  = tre_b(k,mt) + sstre(k,mt) * ( 0.5_r8 * ( ptop(m) + p_b ) - p_b )
                  enddo

                  call progup_thlqt( eps(m), 0._r8, 0._r8, p_b, ptop(m), thl_meu, ssthle(k), thl_au(m), thl_aut(m) )
                  call progup_thlqt( eps(m), 0._r8, 0._r8, p_b, ptop(m), qt_meu, ssqte(k), qt_au(m), qt_aut(m) )
                  call progup_thlqt( eps(m), 0._r8, 0._r8, p_b, ptop(m), ql_meu, ssqle(k), ql_au(m), ql_aut_adi )
                  call progup_thlqt( eps(m), 0._r8, 0._r8, p_b, ptop(m), qi_meu, ssqie(k), qi_au(m), qi_aut_adi )
                  do mt = 1, ncnst
                     call progup_thlqt( eps(m), 0._r8, 0._r8, p_b, ptop(m), tr_meu(mt), sstre(k,mt), tr_au(m,mt), tr_aut(m,mt) )
                  enddo

                  ! Nov.28.2012. Impose consistency between droplet mass and droplet number.
                  !              Note that physically, droplet activation should not be performed here but
                  !              performed later in association with 'CEF' process.
                  !              In principle, I only need below two constraint lines.
                  !              However, in order to impose a constraint that in-cloud droplet radius is fixed
                  !              by the externally specified value for this version of code, I need two additional
                  !              lines further below.   

                  ! Below should be used for future generalized cloud microphysics.
                  ! if( ql_aut_adi .eq. 0._r8 ) tr_aut(m,ixnumliq) = 0._r8
                  ! if( qi_aut_adi .eq. 0._r8 ) tr_aut(m,ixnumice) = 0._r8           

                  ! Below is used instead of the above two lines to satisfy the constraint of constant in-cumulus
                  ! droplet radius. In future's generalized microphysics, above two lines should be used instead of below two lines. 
                  tr_aut(m,ixnumliq) = ql_aut_adi * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_liq**3 * density_liq )
                  tr_aut(m,ixnumice) = qi_aut_adi * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_ice**3 * density_ice )

                  ! CORRECTION
                  ! Note that the effect of PGFc is separately trested later. Thus, in order to
                  ! prevent double counting, we should set ssue = ssve = 0 below. 
                  ! Considering the case of non-constructed profile, I should definitely use the 
                  ! separate one at the top later below.   
                  ! Sep.30.2010. I restored to the original analytical formulation. The discrete
                  !              diabatic forcing will be computed later but will not added to
                  !              to below 'u_aut(m) and v_aut(m)' since diabatic forcing have 
                  !              already been included into 'u_aut(m) and v_aut(m)' by the below
                  !              full progup_uv.
                  ! Apr.11.2011. PGFc effect is computed using 'u_grd0(k),v_grd0(k)' not using 
                  !              ssue, ssve.
                  ! Apr.21.2011. In case of 'org_ent = 1', it is automatically set ssue=ssve=0.
                  !              Thus, in order to treat the case of high 'org_ent', we should
                  !              use 'u_grdPGF = u_grd0(k),v_grdPGF = v_grd0(k)' regardless of
                  !              the setting of 'islope_on_uv'. Thus, I commented out below 'if' block. 
                  ! Apr.22.2011. It turns out that the choice of 'u_grdPGF = u_grd0(k)' and 'v_grdPGF = v_grd0(k)'  
                  !              degraded the simulation of 'v' in BOMEX. In order to improve this feature and
                  !              further enhance consistency, we use 'u_grdPGF = ssu0(k)' and 'v_grdPGF = ssv0(k)'
                  !              below same as for downdraft.

                  if( islope_on_uv .eq. 0 ) then           
                     u_grdPGF = u_grd0(k)
                     v_grdPGF = v_grd0(k)
                  else
                     ! Apr.22.2011.
                     u_grdPGF = ssu0(k)
                     v_grdPGF = ssv0(k)            
                     ! u_grdPGF = ssue(k)
                     ! v_grdPGF = ssve(k)            
                  endif

                  call progup_uv( eps(m), PGFc_up, p_b, ptop(m), u_meu, ssue(k), u_grdPGF, u_au(m), u_aut(m) )
                  call progup_uv( eps(m), PGFc_up, p_b, ptop(m), v_meu, ssve(k), v_grdPGF, v_au(m), v_aut(m) )
                  call progup_uv( eps(m), 0._r8,   p_b, ptop(m), u_meu, ssue(k), u_grdPGF, u_au(m), u_aut_adi )
                  call progup_uv( eps(m), 0._r8,   p_b, ptop(m), v_meu, ssve(k), v_grdPGF, v_au(m), v_aut_adi )
                  
                  ! CHECK
                  ! if( get_nstep() .le. 10 .and. k .eq. 5 ) then 
                  !     write(6,*)
                  !     write(6,*) 'UNICON: Evolution of Updraft Conservative Scalars'
                  !     write(6,*) 'eps(m)                         = ', eps(m)
                  !     write(6,*) 'p_b                            = ', p_b
                  !     write(6,*) 'ptop(m)                        = ', ptop(m)
                  !     write(6,*) 'thl, thl_b, thl_t, ssthle      = ', thl, thle_b(k), thle_b(k) + ssthle(k) * ( ptop(m) - p_b ), ssthle(k)
                  !     write(6,*) 'qt, qt_b, qt_t, ssqte          = ', qt, qte_b(k), qte_b(k) + ssqte(k) * ( ptop(m) - p_b ), ssqte(k)
                  !     write(6,*) 'u, u_b, u_t, ssue              = ', u, ue_b(k), ue_b(k) + ssue(k) * ( ptop(m) - p_b ), ssue(k)
                  !     write(6,*) 'v, v_b, v_t, ssve              = ', v, ve_b(k), ve_b(k) + ssve(k) * ( ptop(m) - p_b ), ssve(k)
                  !     write(6,*) 'thl_au(m), thl_aut(m)          = ', thl_au(m), thl_aut(m) 
                  !     write(6,*) 'qt_au(m), qt_aut(m)            = ', qt_au(m), qt_aut(m)  
                  !     write(6,*) 'u_au(m), u_aut(m), u_aut_adi   = ', u_au(m), u_aut(m), u_aut_adi 
                  !     write(6,*) 'v_au(m), v_aut(m), v_aut_adi   = ', v_au(m), v_aut(m), v_aut_adi 
                  !     write(6,*)
                  ! endif
                  ! CHECK

                  ! -------------------------------------------------------------------- !
                  !                                                                      !
                  ! Treatment of Diabatic Forcings at the cloud top or the top interface !
                  !                                                                      !
                  ! -------------------------------------------------------------------- !

                  ! ------------------------------------------------------------------------- !
                  ! Apr.08.2013.                                                              !
                  ! Below block computing                                                     !
                  !    (1) 'exql, exqi, extr(mt)',                                            !
                  !    (2) 'evpR, evpS, evpRStr(mt)',                                         !
                  !    (3) 'eff_ql_au(m), eff_qi_au(m), eff_tr_au(m,mt)'                      ! 
                  ! are added on this day in association with fully analytical treatment      !
                  ! of precipitation fall-out within convective updraft.                      !
                  ! ------------------------------------------------------------------------- ! 

                  ! ------------------------------------------------------------------------- !
                  ! Compute 'exql,exqi' by solving analytical vertical integration of 'ql,qi' ! 
                  ! by including differential precipitation fall-out in the integration.      !
                  ! ------------------------------------------------------------------------- !

                  if( iprd_prep .eq. 5 ) then  ! Backward Analytical Method

                  call conden( ptop(m), thl_aut(m), qt_aut(m), th, qv, ql, qi, qse, id_check )
                  if( ( ql_cu + qi_cu ) .gt. criqc ) then
                     eps_dia_L = c0_ac * ( ( ql_cu + qi_cu ) - criqc ) / ( ql_cu + qi_cu )
                     eps_dia_I = c0_ac * ( ( ql_cu + qi_cu ) - criqc ) / ( ql_cu + qi_cu )
                  else
                     eps_dia_L = 0._r8
                     eps_dia_I = 0._r8
                  endif
                  call progup_thlqt( eps(m), eps_dia_L, 0._r8, p_b, ptop(m), ql_meu, ssqle(k), ql_au(m), ql_aut_adi_prp )
                  call progup_thlqt( eps(m), eps_dia_I, 0._r8, p_b, ptop(m), qi_meu, ssqie(k), qi_au(m), qi_aut_adi_prp )
                  exql = min( max( ql_aut_adi - ql_aut_adi_prp, 0._r8 ), 0.99_r8 * ql )  ! This should be guaranteed to be positive at this stage.
                  exqi = min( max( qi_aut_adi - qi_aut_adi_prp, 0._r8 ), 0.99_r8 * qi )  ! This should be guaranteed to be positive at this stage.
                  if( mclimit .eq. 1 ) then
                     tmp1 = exql + exqi
                     !prp            tmp2 = min( tmp1, max( ql_aut_adi + qi_aut_adi - criqc, 0._r8 ) ) ! To impose a continuous variation across ql_aut_adi + qi_aut_adi = criqc.
                     ! Consistent with downdraft treatment, the limiter should be imposed using 'ql,qi' computed from 
                     ! adiabatic 'thl_aut(m), qt_aut_tmp(m)' (that includes both 'mixing' and 'CEF') from direct variable
                     ! conversion using 'conden' subroutine. 
                     tmp2 = min( tmp1, max( ql + qi - criqc, 0._r8 ) )                 ! To impose a continuous variation across ql + qi = criqc.
                     exql = exql * ( tmp2 / max( tmp1, nonzero ) )
                     exqi = exqi * ( tmp2 / max( tmp1, nonzero ) )
                  endif
                  do mt = 1, ncnst
                     if( mt .eq. 1 ) then
                        extr(mt) = 0._r8
                     elseif( mt .eq. ixcldliq ) then
                        extr(mt) = exql
                     elseif( mt .eq. ixcldice ) then
                        extr(mt) = exqi
                     elseif( mt .eq. ixnumliq ) then
                        extr(mt) = exql * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_liq**3 * density_liq )
                     elseif( mt .eq. ixnumice ) then
                        extr(mt) = exqi * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_ice**3 * density_ice )
                     else
                        ! ----------------------------------------------------------------------------------------- !
                        ! Wet deposition of aerosols (both interstitial and cloud-borne) within convective updarft. !
                        ! Below is a very simple treatment which should be refined in future.                       !
                        ! ----------------------------------------------------------------------------------------- !
                        extr(mt) = tr_aut(m,mt) * ( ( exql + exqi ) / max( qt_aut(m), nonzero ) )
                        ! Nov.26.2013. Following the reviewer's comments, set 'extr(mt) = 0' since current formulation of
                        !              extr(mt) only treats auto-conversion not accretion.
                        ! extr(mt) = 0._r8 
                        ! Nov.29.2013. Following the reviewer's comments, use 'ql+qi' instead of 'qt_aut(m)' 
                        !              in computing 'extr(mt)' above.
                        extr(mt) = caer * tr_aut(m,mt) * min( 1._r8, ( ( exql + exqi ) / max( ql + qi, nonzero ) ) )
 
                     endif
                  enddo
                  ! -------------------------------------------------- !
                  ! Evaporation within Updraft.                        !
                  ! Set it to be zero, but can be refined in future.   !
                  ! -------------------------------------------------- !
                  evpR = 0._r8
                  evpS = 0._r8
                  do mt = 1, ncnst
                     evpRStr(mt) = 0._r8
                  enddo
                  ! ---------------------------------------------------------------------------------------------------------- !
                  ! Compute effective tendency of 'ql,qi' by 'CEF' process.                                                    !
                  ! In the below 'thl_tmp, qt_tmp' are the final correct updraft state variable at the top interface           !
                  ! that includes both 'mixing' and 'precipitation fall-out'.                                                  !
                  ! Note that I am using 'exn0(k)' instead of 'exnf(ptop(m))' in the below line to be consistent with          !
                  ! the other part of the code to satisfy energy-moisture conservation principle.                              ! 
                  ! IMPORTANT :                                                                                                !
                  !             In case of convective updraft when analytical integration is used as in the current code,      !
                  !             however, we should compute these 'effective CEF forcings' using the variables                  !
                  !             including 'precipitation fallout' both adiabatically and diabatically, since analytical        !
                  !             computation of precipitation fall-out will break the imposed fractional relationship           !
                  !             of 'ql / (ql + qi ) = f(T)', so that the restoration of this relationship using 'conden' and   !
                  !             associated heating-cooling process is eventually included as a part of 'CEF' forcing.          !
                  ! ---------------------------------------------------------------------------------------------------------- !
                  thl_tmp = thl_aut(m) + ( xlv / cp / exn0(k) ) * ( exql - evpR )  + ( xls / cp / exn0(k) ) * ( exqi - evpS )
                  qt_tmp  =  qt_aut(m) - exql - exqi + evpR + evpS
                  call conden( ptop(m), thl_tmp, qt_tmp, th_tmp, qv_tmp, ql_tmp, qi_tmp, qs_tmp, id_check )
                  !f          if( id_check .eq. 1 ) then
                  !f              id_exit = .true.
                  !f              go to 333
                  !f          endif
                  eff_ql_au(m) = ql_tmp - ql_aut_adi_prp
                  eff_qi_au(m) = qi_tmp - qi_aut_adi_prp
                  do mt = 1, ncnst
                     if( mt .eq. ixnumliq ) then
                        ! Nov.28.2012. Below block is the new code. Note that in order to decide whether droplet activation
                        !              process should be performed or not, we should compare 'ql' with 'ql_u(m)' not
                        !              with 'ql_aut_adi'.
                        !              Below droplet activation form is not a general formula but a specific one designed 
                        !              to satisfy the constraint of a constant in-cloud droplet size specified externally.
                        !              In future's generalized cloud microphysics, more generalized droplet activation 
                        !              form should be used. The same is true for ice.   
                        ! if( ql_au(m) .eq. 0._r8 .and. ql .gt. 0._r8 ) then ! Droplet Activation   
                        !     eff_tr_au(m,mt) = eff_ql_au(m) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_liq**3 * density_liq ) 
                        ! else
                        !   ! The second line assumes that only evaporation changes droplet number.
                        !   ! The choice of second line should be made in consistent with the one in the downdraft process.  
                        !     eff_tr_au(m,mt) =      eff_ql_au(m)          * ( tr_aut(m,mt) / max( ql_aut_adi, nonzero ) )
                        !   ! eff_tr_au(m,mt) = min( eff_ql_au(m), 0._r8 ) * ( tr_aut(m,mt) / max( ql_aut_adi, nonzero ) )
                        ! endif 
                        ! Below line is the old code.
                        eff_tr_au(m,mt) = eff_ql_au(m) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_liq**3 * density_liq ) 
                     elseif( mt .eq. ixnumice ) then 
                        ! Nov.28.2012. Below block is the new code.
                        ! if( qi_au(m) .eq. 0._r8 .and. qi .gt. 0._r8 ) then ! Crystal Nucleation   
                        !     eff_tr_au(m,mt) = eff_qi_au(m) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_ice**3 * density_ice ) 
                        ! else
                        !   ! The second line assumes that only evaporation changes droplet number.
                        !   ! The choice of second line should be made in consistent with the one in the downdraft process.  
                        !     eff_tr_au(m,mt) =      eff_qi_au(m)          * ( tr_aut(m,mt) / max( qi_aut_adi, nonzero ) )
                        !   ! eff_tr_au(m,mt) = min( eff_qi_au(m), 0._r8 ) * ( tr_aut(m,mt) / max( qi_aut_adi, nonzero ) )
                        ! endif 
                        ! Below line is the old code.
                        eff_tr_au(m,mt) = eff_qi_au(m) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_ice**3 * density_ice ) 
                     else
                        eff_tr_au(m,mt) = 0._r8
                     endif
                     ! Nov.27.2012. Impose a constraint on the diabatic forcing to prevent the onset of negative tracer during vertical motion.
                     !              This constraint is imposed by using 'tr_aut(m,mt) + eff_tr_au(m,mt) > qmin(mt)' criteria,
                     !              where 'tr_aut(m,mt)' is a tracer at the base interface before adding diabatic forcing.
                     !              Similar constraint has also been imposed on the downdraft motion.
                     eff_tr_au(m,mt) = max( eff_tr_au(m,mt), qmin(mt) - tr_aut(m,mt) )   
                  enddo

                  ! ------------------------------------------------------------------------- !
                  ! Apr.08.2013.                                                              !
                  ! Above block computing                                                     !
                  !    (1) 'exql, exqi, extr(mt)',                                            !
                  !    (2) 'evpR, evpS, evpRStr(mt)',                                         !
                  !    (3) 'eff_ql_au(m), eff_qi_au(m), eff_tr_au(m,mt)'                      ! 
                  ! are added on this day in association with fully analytical treatment      !
                  ! of precipitation fall-out within convective updraft.                      !
                  ! Note that at this stage, none of (1),(2),(3) are used to update updraft   !
                  ! state variables at the top interface, which will be done further below.   !
                  ! ------------------------------------------------------------------------- ! 

                  ! Feb.09.2013.
                  ! This evaporation is now treated within subroutine 'prod_prep_up' and the resulting
                  ! tendency will be added into precipitation production.  

                  !j          ! ------------------------------------------------------------------------------------------- !
                  !j          ! 0. Evaporation of Precipitation at the cloud top                                            !
                  !j          !    a. Since updraft is unsaturated within the PBL, this evaporation should be treated here. !
                  !j          !       This may be especially important for treating deep convection.                        !  
                  !j          !    b. I should treat only evaporation of 'convective precipitation' not the 'stratiform     !
                  !j          !       precipitation'. This is important to satisfy energy and moisture conservations.       !
                  !j          !    c. Any diabatic forcings within convective updraft and downdraft will induce the         !
                  !j          !       tendencies of environmental variables.                                                !
                  !j          !    d. Simply neglect evaporation of precipitation within convctive updraft.                 !
                  !j          ! ------------------------------------------------------------------------------------------- !
                  !j          evp_qtl_au(m)  =  0._r8
                  !j          evp_qti_au(m)  =  0._r8
                  !j        ! Sep.29.2011. To supress energy conservation error by imposing consistency with the exn0(k)
                  !j        !              used in the computation of slten_u(k) and slten_d(k), I am using exn0(k)
                  !j        !              in the below lines. However, for computing updated 'thl_aut' at the top
                  !j        !              interface, I am using the correct exner function at the top interface.
                  !j        !              this will impose a full consistency throughout the whole code. 
                  !j        ! Below is the new.
                  !j          evp_thll_au(m) =  - ( xlv / cp / exn0(k) ) * evp_qtl_au(m)
                  !j          evp_thli_au(m) =  - ( xls / cp / exn0(k) ) * evp_qti_au(m)
                  !j        ! tmp1           =  - ( xlv / cp / ( ptop(m) / p00 )**rovcp ) * evp_qtl_au(m)
                  !j        ! tmp2           =  - ( xls / cp / ( ptop(m) / p00 )**rovcp ) * evp_qti_au(m)
                  !j        ! Below is the old code.
                  !j        ! evp_thll_au(m) =  - ( xlv / cp / ( ptop(m) / p00 )**rovcp ) * evp_qtl_au(m)
                  !j        ! evp_thli_au(m) =  - ( xls / cp / ( ptop(m) / p00 )**rovcp ) * evp_qti_au(m)
                  !j          ! -------------------------------------------------------------------------------------- !
                  !j          ! TRACERS REFINEMENT NECESSARY : EVAPORATION OF CONVECTIVE PRECIPITATION WITHIN UPDRAFTA !
                  !j          ! -------------------------------------------------------------------------------------- !
                  !j          do mt = 1, ncnst
                  !j             evp_tr_au(m,mt)  =  0._r8        
                  !j           ! Nov.27.2012. Impose a constraint on the diabatic forcing to prevent the onset of negative tracer during vertical motion.
                  !j           !              This constraint is imposed by using 'tr_aut(m,mt) + evp_tr_au(m,mt) > qmin(mt)' criteria,
                  !j           !              where 'tr_aut(m,mt)' is a tracer at the base interface before adding diabatic forcing.
                  !j           !              Similar constraint has also been imposed on the downdraft motion.
                  !j             evp_tr_au(m,mt) = max( evp_tr_au(m,mt), qmin(mt) - tr_aut(m,mt) )   
                  !j          enddo
                  !j          ! -------------------------------------------------------------------------------------- !
                  !j          ! TRACERS REFINEMENT NECESSARY : EVAPORATION OF CONVECTIVE PRECIPITATION WITHIN UPDRAFTA !
                  !j          ! -------------------------------------------------------------------------------------- !
                  !j        ! Sep.29.2011. See above. Below is the new code.
                  !j        ! thl_aut(m)     =  thl_aut(m) + tmp1 + tmp2
                  !j        ! Below is the old code. 
                  !j        ! Mar.30.2011. I decided to consistently use exn0(k) because diabatic forcing is a concept of 
                  !j        !              average over the grid layer. 
                  !j          thl_aut(m)     =  thl_aut(m) + evp_thll_au(m) + evp_thli_au(m)
                  !j          qt_aut(m)      =  qt_aut(m)  +  evp_qtl_au(m) +  evp_qti_au(m)
                  !j          do mt = 1, ncnst
                  !j             tr_aut(m,mt) = tr_aut(m,mt) + evp_tr_au(m,mt)
                  !j          enddo

                  ! ------------------------------------------------------------------------------------------------- !
                  ! TRACERS REFINEMENT NECESSARY : ADIABATIC CONDENSATION-EVAPORATION-FREEZING DURING VERTICAL MOTION !
                  ! Note that this CEF does not change 'thl_aut(m),qt_aut(m)'. So, here I only update 'tr_aut(m,mt)'. !
                  ! ------------------------------------------------------------------------------------------------- !
                  do mt = 1, ncnst
                     tr_aut(m,mt) = tr_aut(m,mt) + eff_tr_au(m,mt)
                  enddo

                  else ! The others of Backward Analytical Method

                  ! ------------------------------------------------------------------------------- !
                  ! 1. Compute diabatic 'condensation-evaporation-freezing' on the cloud condensate !
                  !    In case of tracers, I temporarily set it to be zero. However, it should be   !
                  !    correctly computed later, depending on whether the tracers are cloud droplet !
                  !    number concentration or other aerosol tracers ( mass and number ).  If they  !
                  !    are droplet numbers, 'eff_tr_au' will be nonzero due to the evaporation and  !
                  !    freezing, but if they are other tracers, it is likely that 'eff_tr_au=0'.    !
                  !    Note that this 'CEF' process does not change 'thl,qt,u,v' which are          !
                  !    conserved scalars. Similarly, tracers other than 'nl,ni' are likely to be    !
                  !    invariant to this CEF process.                                               !
                  !    In the below, 'ql,qi' contains 'mixing' and 'CEF' already.                   !
                  ! Nov.28.2012. In order to correctly handle the changes of droplet numbers        !
                  !    associated with this 'CEF', we should be able to separately handle freezing  !
                  !    process. Computation of this separate freezing process is possible if we     !
                  !    think this CEF process as a seris of 'CE' --> 'F' process.                   !
                  !    In this case, eff_fz_au(m) = eff_qi_au(m). However, when there is only ice   !
                  !    not the liquid, this approach can be problematic, since we will              !
                  !    continuously generate ice crystal number by treating 'qi' increase as        !
                  !    freezing process.                                                            !    
                  !    This is a process reducing pressure without changing thl_aut(m) & qt_aut(m), !
                  !    that is, 'eff_ql_au(m) + eff_qi_au(m) > 0', so that condensate is always     !
                  !    generated. This property provides a clue for handling this process.          !
                  ! Apr.08.2013. Below block is commented-out with '!prp' since it is now being     !
                  !    computed above in association with analytical treatment of precipitation     !
                  !    fall-out within convective updraft above.                                    ! 
                  ! ------------------------------------------------------------------------------- !
                  call conden( ptop(m), thl_aut(m), qt_aut(m), th, qv, ql, qi, qse, id_check )
                  !f          if( id_check .eq. 1 ) then
                  !f              id_exit = .true.
                  !f              go to 333
                  !f          endif
                  eff_ql_au(m) = ql - ql_aut_adi
                  eff_qi_au(m) = qi - qi_aut_adi
                  ! ------------------------------------------------------------------------------------------------- !
                  ! TRACERS REFINEMENT NECESSARY : ADIABATIC CONDENSATION-EVAPORATION-FREEZING DURING VERTICAL MOTION !
                  ! ------------------------------------------------------------------------------------------------- !
                  ! Nov.08.2011. Critical bug fix. I should correctly handle the droplet number concentration in order!
                  !              to prevent generating unreasonable source of droplet number which was the case in the!
                  !              previous wrong code.                                                                 ! 
                  ! Nov.28.2012.                                                                                      !
                  ! Below treatment implies that                                                                      !
                  !   (1) Activation occurs with the specified 'droprad_liq, droprad_ice'                             !
                  !   (2) Condensation occurs on the existing liquid and ice droplets,                                !
                  !   (3) Evaporation reduces the numbers of liquid and ice droplets.                                 !
                  ! where treatment of (2) allows the growth of cloud liquid and ice crystals, so that                !
                  ! future parameterization of precipitation production as a function of droplet size                 !
                  ! will be possible.                                                                                 !
                  ! The only caveat of this approach is that when freezing occurs so that some of                     !
                  ! the existing liquid droplets are converted into the ice crystals, corresponding                   !
                  ! increase of tr_aut(m,ixnumice) cannot be treated, even though decrease of tr_aut(m,ixnumliq)      !
                  ! is treated. However, some of these processes are treated by ice nucleation process, so that       !
                  ! below treatment is not so bad. However, more complete treatment should be made in future.         !
                  ! For the time being, for consistency with previous code, let's also change droplet number when     !
                  ! condensation occurs.                                                                              ! 
                  ! Apr.08.2013. Below block is commented-out with '!prp' since it is now being                       !
                  !              computed above in association with analytical treatment of precipitation             !
                  !              fall-out within convective updraft above.                                            ! 
                  ! ------------------------------------------------------------------------------------------------- !
                  do mt = 1, ncnst
                     if( mt .eq. ixnumliq ) then
                       ! Nov.28.2012. Below block is the new code. Note that in order to decide whether droplet activation
                       !              process should be performed or not, we should compare 'ql' with 'ql_u(m)' not
                       !              with 'ql_aut_adi'.
                       !              Below droplet activation form is not a general formula but a specific one designed 
                       !              to satisfy the constraint of a constant in-cloud droplet size specified externally.
                       !              In future's generalized cloud microphysics, more generalized droplet activation 
                       !              form should be used. The same is true for ice.   
                       ! if( ql_au(m) .eq. 0._r8 .and. ql .gt. 0._r8 ) then ! Droplet Activation   
                       !     eff_tr_au(m,mt) = eff_ql_au(m) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_liq**3 * density_liq ) 
                       ! else
                       !   ! The second line assumes that only evaporation changes droplet number.
                       !   ! The choice of second line should be made in consistent with the one in the downdraft process.  
                       !     eff_tr_au(m,mt) =      eff_ql_au(m)          * ( tr_aut(m,mt) / max( ql_aut_adi, nonzero ) )
                       !   ! eff_tr_au(m,mt) = min( eff_ql_au(m), 0._r8 ) * ( tr_aut(m,mt) / max( ql_aut_adi, nonzero ) )
                       ! endif 
                       ! Below line is the old code.
                         eff_tr_au(m,mt) = eff_ql_au(m) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_liq**3 * density_liq ) 
                     elseif( mt .eq. ixnumice ) then 
                       ! Nov.28.2012. Below block is the new code.
                       ! if( qi_au(m) .eq. 0._r8 .and. qi .gt. 0._r8 ) then ! Crystal Nucleation   
                       !     eff_tr_au(m,mt) = eff_qi_au(m) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_ice**3 * density_ice ) 
                       ! else
                       !   ! The second line assumes that only evaporation changes droplet number.
                       !   ! The choice of second line should be made in consistent with the one in the downdraft process.  
                       !     eff_tr_au(m,mt) =      eff_qi_au(m)          * ( tr_aut(m,mt) / max( qi_aut_adi, nonzero ) )
                       !   ! eff_tr_au(m,mt) = min( eff_qi_au(m), 0._r8 ) * ( tr_aut(m,mt) / max( qi_aut_adi, nonzero ) )
                       ! endif 
                       ! Below line is the old code.
                         eff_tr_au(m,mt) = eff_qi_au(m) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_ice**3 * density_ice ) 
                     else
                         eff_tr_au(m,mt) = 0._r8
                     endif
                   ! Nov.27.2012. Impose a constraint on the diabatic forcing to prevent the onset of negative tracer during vertical motion.
                   !              This constraint is imposed by using 'tr_aut(m,mt) + eff_tr_au(m,mt) > qmin(mt)' criteria,
                   !              where 'tr_aut(m,mt)' is a tracer at the base interface before adding diabatic forcing.
                   !              Similar constraint has also been imposed on the downdraft motion.
                     eff_tr_au(m,mt) = max( eff_tr_au(m,mt), qmin(mt) - tr_aut(m,mt) )   
                  enddo

                  ! ------------------------------------------------------------------------------------------------- !
                  ! TRACERS REFINEMENT NECESSARY : ADIABATIC CONDENSATION-EVAPORATION-FREEZING DURING VERTICAL MOTION !
                  ! Note that this CEF does not change 'thl_aut(m),qt_aut(m)'. So, here I only update 'tr_aut(m,mt)'. !
                  ! ------------------------------------------------------------------------------------------------- !
                  do mt = 1, ncnst
                     tr_aut(m,mt) = tr_aut(m,mt) + eff_tr_au(m,mt)
                  enddo

                  ! ------------------------------------------------------------------------- !
                  ! 2. Precipitation fallout at the cloud top                                 !
                  !    a. Future refinement of microphysics only requires recomputation of    !
                  !       production of precipitation, exql, exqi.                            !
                  !    b. I used 'exn_t' for consistency with later computation of 'slten_u'. !
                  !       Apr.21.2011. Use 'exn_top' instead of 'exn_t'.                      ! 
                  !    c. In case of tracers other than droplet number concentration,         !
                  !       I temporary set 'prep_tr_au' to be zero but correct value should be ! 
                  !       calculated by mimicking the in-cloud wet scavenging routine later.  !
                  ! ------------------------------------------------------------------------- !

                  ! -------------------------------------------------------------------------------------------------------------------- !
                  ! Nov.03.2012. REFINEMENT IS NECESSARY FOR TREATING ACCRETION OF CLOUD DROPLETS.                                       !
                  ! For this refinement, I should use below quantities before any evaporation within downdraft and                       !  
                  !                      environment.                                                                                    !  
                  !         (1) flxrain_prevp_msfc(0:mkx,1:nseg) : Rain flux at each interface                                           ! 
                  !         (2) flxsnow_prevp_msfc(0:mkx,1:nseg) : Snow flux at each interface                                           ! 
                  !         (3) a_p_prevp_msfc(0:mkx,1:nseg)     : Precipitation area at each interface                                  !
                  ! defined at the interface for each updraft segment, which will be computed                                            !
                  ! at the end of updraft evolution for all segments later.                                                              !
                  ! In addition, I should use cloud overlapping structure variables of                                                   !
                  !         (3) am_u_msfc(1:mkx,1:nseg)  : Updraft fractional area               at the layer mid-point.                 !
                  !         (3) am_up_msfc(1:mkx,1:nseg) : Precipitating updraft fractional area at the layer mid-point.                 ! 
                  !         (4) am_us_msfc(1:mkx,1:nseg) : Saturated     updraft fractional area at the layer mid-point.                 !
                  !         (5) am_pu_msfc(1:mkx,1:nseg) : Overlapping area between precipitation area at the top interface and          !
                  !                                        updraft area (regardless saturated or not) at the layer mid-point.            ! 
                  ! Then, by using                                                                                                       !
                  !      'aa = flxrain_prevp_msfc(k,m)/max(a_p_prevp_msfc(k,m),nonzero)' : Precipitation flux within precipitation area, !
                  !      'bb = am_pu_msfc(k,m)'                                          : Area where accretion occurs.                  !
                  ! we can compute accretion rate within accretion area ('cc'), and the mean accretion rate                              ! 
                  ! within cumulus updraft becomes 'zz = cc * ( bb / max( 0._r8, am_u_msfc(k,m) ) )', which similar to 'exql,exqi' below,!  
                  ! should be computed in unit of 'zz = [kg/kg]'. Note that if a_p_prevp_msfc --> 0, flxrain_prevp_msfc --> 0.           !
                  ! In addition, if am_u_msfc --> 0, bb --> 0. Thus, my above computation is completely stable and correct.              !
                  ! For clear diagnostic output, it is good to compute separately 'exql_at, exqi_at' (auto-conversion) and               !
                  ! the 'exql_ac, exqi_ac' (accretion) parts with 'exql = exql_at + exql_ac, exqi = exqi_at + exqi_ac'.                  !
                  ! Corresponding change averaged within cumulus updraft 'prep_tr_au(m,mt)' can be computed.                             !
                  ! Since the area where auto-conversion occurs (am_u_msfc) differs from where accretion occurs (bb=am_pu_msfc),         !
                  ! the contribution of auto-conversion and accretion to 'prep_tr_au(m,mt)' should be separately computed.               !
                  ! The contribution of accretion averaged within cumulus updraft should be computed by                                  !
                  ! multiplying ( bb / max( 0._r8, am_u_msfc(k,m) ) ) as mentioned above.                                                !
                  ! Snow melting should be carefully treated, if necessary.                                                              !
                  ! Nov.03.2012. REFINEMENT IS NECESSARY FOR TREATING ACCRETION OF CLOUD DROPLETS.                                       !
                  ! -------------------------------------------------------------------------------------------------------------------- !

                  ! -------------------------------------------------------------------------------------------------------------------- !
                  ! Feb.07.2013.                                                                                                         ! 
                  ! Compute precipitation production rate at the cumulus top during upward motion from 'p_b(z_b)' to 'ptop(ztop)'.       !
                  ! It is possible that w_aut(m) = 0 if 'ptop' is the final cumulus top instead of the top interface.                    !
                  ! Below subroutine 'prod_prep_up' computes the amount of precipitated condensate ( exql, exqi >= 0 in [kg/kg],         !
                  ! extr(1:ncnst) >= in [#(kg)/kg] ) during 'delta_t = ( ztop(m) - z_b ) / ( 0.5 * ( w_au(m) + w_aut(m) ) )'             !
                  ! at the top interface.                                                                                                !
                  ! The final layer-mean precipitation production rate will be computed later using 'exql, exqi, extr(1:ncnst)'.         !
                  ! Note that extr(1) = 0., extr(ixcldliq) = exql, extr(ixcldice) = exqi,                                                !
                  ! extr(ixnumliq) = exql * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_liq**3 * density_liq ),                              !
                  ! extr(ixnumice) = exqi * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_ice**3 * density_ice ).                              ! 
                  ! Most importantly, 'extr(other indices)' is the wet deposition of aerosols (both interstiail and cloud-borne)         !
                  ! within cumulus updraft.                                                                                              !
                  ! Note since am_pu_msfc(k,msfc) is computed using am_us_msfc(k,msfc) not by using                                      !
                  ! am_u_msfc(k,msfc), I am using am_us_msfc(k,msfc) in the below subroutine as an input                                 !
                  ! argument. However, in association with the use of beta2 = 1 and evaporation within                                   !
                  ! PBL environment, I should come up with more satisfactory cloud overlapping structure                                 !
                  ! in future. This is always related with the treatment of wet deposition of aerosols                                   !
                  ! within unsaturated convective updraft. I should figure this out before AMWG.                                         !
                  ! Feb.09.2013.                                                                                                         !
                  ! Note that the input argument is 'am_u_msfc(k,msfc)' not 'am_us_msfc(k,msfc)' since evaporation within updraft is also! 
                  ! treated when updraft is unsaturated.                                                                                 !
                  ! Apr.08.2013. In association with fully analytical treatment precipitation fall-out within convective updraft above,  !
                  !              I commented-out below block with '!prp'. But it can be restored at any time in future.                  ! 
                  ! -------------------------------------------------------------------------------------------------------------------- ! 

                  msfc = msfc_from_m(k,m)
                  call prod_prep_up( z_b, ztop(m), p_b, ptop(m), (ptop(m)/p00)**rovcp, exn0(k),  &
                                     w_au(m), w_aut(m),                                          &
                                     thl_aut(m), qt_aut(m), ql, qi, tr_aut(m,1:ncnst),           &
                                     S_b_ql_au(m), S_b_qi_au(m), iprd_prep,                      & 
                                     ql_cu, qi_cu, eps(m),                                       &
                                     thl_meu, ssthle(k), thl_au(m), qt_meu, ssqte(k), qt_au(m),  & 
                                     ncnst, ixcldliq, ixcldice, ixnumliq, ixnumice, i, k, lchnk, &
                                     flxrain_msfc(k,msfc), flxsnow_msfc(k,msfc),                 &     
                                     a_p_msfc(k,msfc), am_u_msfc(k,msfc), am_pu_msfc(k,msfc),    &
                                     caer, criqc, c0_ac, droprad_liq, droprad_ice,               &
                                     exql, exqi, extr(1:ncnst), S_t_ql_au(m), S_t_qi_au(m),      &
                                     evpR, evpS, evpRStr(1:ncnst) )

                  ! if( msfc .eq. 1 ) then
                  !     write(6,*) 
                  !     write(6,*) 'UNICON: Check input and output precipitation rates at the base and top interfaces' 
                  !     write(6,*) 'k, S_b_ql, S_b_qi, S_t_ql, S_t_qi = ', k, S_b_ql_au(m), S_b_qi_au(m), S_t_ql_au(m), S_t_qi_au(m)
                  !     write(6,*)
                  ! endif

                  endif ! End of Backward Analytical Method

                  !h          ! ------------------------------------------------------------------------------------------------ !
                  !h          ! Note that both below microcu = 0 and microcu = 1 are vertical resolution-inseisitive computation !
                  !h          ! when microcu = 0 (1) is used upward-final (centered) differencing as in the current code.        !     
                  !h          ! ------------------------------------------------------------------------------------------------ !
                  !h          if( microcu .eq. 0 ) then
                  !h              if( ( ql + qi ) .gt. criqc ) then
                  !h                    exql = c0_ac * ( ( ql + qi ) - criqc ) * ql / ( ql + qi )
                  !h                    exqi = c0_ac * ( ( ql + qi ) - criqc ) * qi / ( ql + qi )
                  !h              else
                  !h                    exql = 0._r8
                  !h                    exqi = 0._r8 
                  !h              endif 
                  !h          elseif( microcu .eq. 1 ) then
                  !h            ! --------------------------------------------------------------------------------------- !
                  !h            ! May.25.2012. Below is the most perfect treatment fully consistent and symmetric with    !
                  !h            !              the treatment of evaporation of precipitation within convective downdraft, ! 
                  !h            !              with minimum sensitivity to the vertical resolution, and                   !
                  !h            !              with correct appropriate limiters.                                         !
                  !h            ! --------------------------------------------------------------------------------------- !
                  !h              if( ( ql + qi ) .gt. criqc ) then
                  !h                  f_Lt = ( c0_ac / ( 1._r8 ) ) * ( ( ql + qi ) - criqc ) * ( ql / ( ql + qi ) ) ! [ kg/kg/Pa ]
                  !h                  f_It = ( c0_ac / ( 1._r8 ) ) * ( ( ql + qi ) - criqc ) * ( qi / ( ql + qi ) ) ! [ kg/kg/Pa ]
                  !h              else
                  !h                  f_Lt = 0._r8
                  !h                  f_It = 0._r8
                  !h              endif                 
                  !h              if( ( ql_cu + qi_cu ) .gt. criqc ) then
                  !h                  f_Lb = ( c0_ac / ( 1._r8 ) ) * ( ( ql_cu + qi_cu ) - criqc ) * ( ql_cu / ( ql_cu + qi_cu ) )
                  !h                  f_Ib = ( c0_ac / ( 1._r8 ) ) * ( ( ql_cu + qi_cu ) - criqc ) * ( qi_cu / ( ql_cu + qi_cu ) )
                  !h              else
                  !h                  f_Lb = 0._r8
                  !h                  f_Ib = 0._r8
                  !h              endif      
                  !h              f_L  = f_Lb
                  !h              f_I  = f_Ib            
                  !h            ! f_L  = 0.5_r8 * ( f_Lt + f_Lb )
                  !h            ! f_I  = 0.5_r8 * ( f_It + f_Ib ) 
                  !h              dia_qt  =   f_L + f_I 
                  !h              dia_thl = - ( ( xlv / cp / exn0(k) ) * f_L + ( xls / cp / exn0(k) ) * f_I )
                  !h            ! Apr.18.2012. I double-checked that below 'progup_thlqt' with 'dia_thl,dia_qt' correctly work and 
                  !h            !              produces the right values with the right signs.
                  !h            !              That is, the sign of 'dia_qt,dia_thl' is correct. 
                  !h              call progup_thlqt( eps(m), dia_thl, p_b, ptop(m), thl_meu, ssthle(k), thl_au(m), tmp_thl )
                  !h              call progup_thlqt( eps(m), dia_qt,  p_b, ptop(m),  qt_meu,  ssqte(k),  qt_au(m), tmp_qt  )
                  !h              call conden( ptop(m), tmp_thl, tmp_qt, tmp_th, tmp_qv, tmp_ql, tmp_qi, qse, id_check )
                  !f              if( id_check .eq. 1 ) then
                  !f                  id_exit = .true.
                  !f                  go to 333
                  !f              endif
                  !h              exql = min( max( ql - tmp_ql, 0._r8 ), 0.99_r8 * ql )
                  !h              exqi = min( max( qi - tmp_qi, 0._r8 ), 0.99_r8 * qi )
                  !h            ! I can add below 4 lines if I want to guarantee that precipitation production
                  !h            ! does not reduce 'ql + qi' down below 'criqc'. 
                  !h              if( mclimit .eq. 1 ) then
                  !h                  tmp1 = exql + exqi
                  !h                  tmp2 = min( tmp1, max( ql + qi - criqc, 0._r8 ) ) ! To impose a continuous variation across ql + qi = criqc.
                  !h                  exql = exql * ( tmp2 / max( tmp1, nonzero ) )
                  !h                  exqi = exqi * ( tmp2 / max( tmp1, nonzero ) )
                  !h              endif
                  !h          elseif( microcu .eq. 2 ) then
                  !h              dp_sub = ( ptop(m) - p_b ) / nsub_dia
                  !h              do jj = 1, nsub_dia
                  !h                 p_ini   = p_b   + dp_sub * ( jj - 1 )
                  !h                 p_fin   = p_ini + dp_sub
                  !h                 thl_cen = thle_b(k) + ssthle(k) * ( 0.5_r8 * ( p_fin + p_ini ) - p_b )
                  !h                 qt_cen  =  qte_b(k) +  ssqte(k) * ( 0.5_r8 * ( p_fin + p_ini ) - p_b )
                  !h                 if( jj .eq. 1 ) then
                  !h                     ql_cu_ini  = ql_cu
                  !h                     qi_cu_ini  = qi_cu
                  !h                     thl_cu_ini = thl_au(m)
                  !h                     qt_cu_ini  = qt_au(m)
                  !h                 endif                      
                  !h                 if( ( ql_cu_ini + qi_cu_ini ) .gt. criqc ) then
                  !h                     f_L = ( c0_ac / ( 1._r8 ) ) * ( ( ql_cu_ini + qi_cu_ini ) - criqc ) * ( ql_cu_ini / ( ql_cu_ini + qi_cu_ini ) )
                  !h                     f_I = ( c0_ac / ( 1._r8 ) ) * ( ( ql_cu_ini + qi_cu_ini ) - criqc ) * ( qi_cu_ini / ( ql_cu_ini + qi_cu_ini ) )
                  !h                 else
                  !h                     f_L = 0._r8
                  !h                     f_I = 0._r8
                  !h                 endif  
                  !h                 dia_qt  =   f_L + f_I 
                  !h                 dia_thl = - ( ( xlv / cp / exn0(k) ) * f_L + ( xls / cp / exn0(k) ) * f_I )
                  !h               ! Apr.18.2012. I double-checked that below 'progup_thlqt' with 'dia_thl,dia_qt' correctly work and 
                  !h               !              produces the right values with the right signs.
                  !h               !              That is, the sign of 'dia_qt,dia_thl' is correct. 
                  !h                 call progup_thlqt( eps(m), dia_thl, p_ini, p_fin, thl_cen, ssthle(k), thl_cu_ini, tmp_thl )
                  !h                 call progup_thlqt( eps(m), dia_qt,  p_ini, p_fin,  qt_cen,  ssqte(k),  qt_cu_ini, tmp_qt )
                  !h                 call conden( p_fin, tmp_thl, tmp_qt, tmp_th, tmp_qv, tmp_ql, tmp_qi, qse, id_check )
                  !f                 if( id_check .eq. 1 ) then
                  !f                     id_exit = .true.
                  !f                     go to 333
                  !f                 endif
                  !h                 ql_cu_ini  = tmp_ql
                  !h                 qi_cu_ini  = tmp_qi
                  !h                 thl_cu_ini = tmp_thl
                  !h                 qt_cu_ini  = tmp_qt
                  !h              enddo
                  !h              exql = min( max( ql - tmp_ql, 0._r8 ), 0.99_r8 * ql )
                  !h              exqi = min( max( qi - tmp_qi, 0._r8 ), 0.99_r8 * qi )
                  !h            ! I can add below 4 lines if I want to guarantee that precipitation production
                  !h            ! does not reduce 'ql + qi' down below 'criqc'. 
                  !h            ! tmp1 = exql + exqi
                  !h            ! tmp2 = min( tmp1, max( ql + qi - criqc, 0._r8 ) ) ! To impose a continuous variation across ql + qi = criqc.
                  !h            ! exql = exql * ( tmp2 / max( tmp1, nonzero ) )
                  !h            ! exqi = exqi * ( tmp2 / max( tmp1, nonzero ) )
                  !h          endif

                  prep_qtl_au(m)  = - exql
                  prep_qti_au(m)  = - exqi
                  ! Sep.29.2011. To supress energy conservation error by imposing consistency with the exn0(k)
                  !              used in the computation of slten_u(k) and slten_d(k), I am using exn0(k)
                  !              in the below lines. However, for computing updated 'thl_aut' at the top
                  !              interface, I am using the correct exner function at the top interface.
                  !              this will impose a full consistency throughout the whole code. 
                  ! Below is the new.
                  prep_thll_au(m) = - ( xlv / cp / exn0(k) ) * prep_qtl_au(m)
                  prep_thli_au(m) = - ( xls / cp / exn0(k) ) * prep_qti_au(m)    
                  ! tmp1            = - ( xlv / cp / ( ptop(m) / p00 )**rovcp ) * prep_qtl_au(m)
                  ! tmp2            = - ( xls / cp / ( ptop(m) / p00 )**rovcp ) * prep_qti_au(m)
                  ! Below is the original.
                  ! prep_thll_au(m) = - ( xlv / cp / ( ptop(m) / p00 )**rovcp ) * prep_qtl_au(m)
                  ! prep_thli_au(m) = - ( xls / cp / ( ptop(m) / p00 )**rovcp ) * prep_qti_au(m)
                  ! ------------------------------------------------------------------------- !
                  ! TRACERS REFINEMENT NECESSARY : PRECIPITATION FALLOUT AT THE TOP INTERFACE !
                  ! ------------------------------------------------------------------------- !
                  ! Nov.08.2011. Critical bug fix. I should correctly handle the droplet number concentration in order
                  !              to prevent generating unreasonable source of droplet number which was the case in the
                  !              previous wrong code.
                  ! Feb.07.2013. All the below 'prep_tr_au(m,mt)' are already computed within the subroutine 'prod_prep_up'
                  !              and is printed out as 'extr(mt)' in the exactly same was as in the below code. 
                  !              Thus, I simply inserted 'prep_tr_au(m,mt) = - extr(mt)' below considering sign change. 
                  do mt = 1, ncnst
                     prep_tr_au(m,mt) = - extr(mt)
                     !h             if( mt .eq. ixnumliq ) then
                     !h               ! Nov.28.2012. Below is the new code. 
                     !h               ! prep_tr_au(m,mt) = prep_qtl_au(m) * ( tr_aut(m,mt) / max( ql, nonzero ) )
                     !h               ! Below is the old code.
                     !h                 prep_tr_au(m,mt) = prep_qtl_au(m) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_liq**3 * density_liq ) 
                     !h             elseif( mt .eq. ixnumice ) then
                     !h               ! Nov.28.2012. Below is the new code.
                     !h               ! prep_tr_au(m,mt) = prep_qti_au(m) * ( tr_aut(m,mt) / max( qi, nonzero ) )
                     !h               ! Below is the old code.
                     !h                 prep_tr_au(m,mt) = prep_qti_au(m) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_ice**3 * density_ice ) 
                     !h             else
                     !h               ! Nov.29.2012. Below is the new code. Assuming that aerosol is homogeneously distributed all over qv, ql, qi within
                     !h               ! updraft, I should use 'qt_aut(m)' instead of 'ql' in the denominator. Given that droplet size is fixed,
                     !h               ! below choice seems to be the most reasonable one. If qt_aut(m) --> 0, it becomes that 
                     !h               ! prep_qtl_au + prep_qti_au --> 0 regardless which 'microcu' option is chosen. Thus, below equation is
                     !h               ! completely stable one. Note that the sign is correct. 
                     !h               ! In future, below formulation can be further refined in association with detailed treatment of droplet 
                     !h               ! number concentration within convective updraft.   
                     !h               ! Nov.03.2012 : 
                     !h               ! Note that currently, below is the wet scavenging of aerosols by the production of precipitation by 
                     !h               ! auto-conversion in each layer (i.e., scavenging of aerosols within cloud droplet by auto-conversion precipitation
                     !h               ! production process) simply assuming that there is no precipitation flux falling into the current layer.
                     !h               ! If precipitation flux falls into the current later, two additional scavenging of aerosols can occur :
                     !h               ! (1) scavenging of aerosols within the cloud droplet of cumulus updrafts by the accretion of cloud droplet, and 
                     !h               ! (2) scavenging of interstitial aerosols by the precipitation flux falling into the cumulus updraft in the current layer.
                     !h               ! It is very important that 'scavenging of interstitial aerosols in the non-cumulus portion by precipitation flux falling
                     !h               ! into the current layer' will be treated later in association with scavenging of aerosols within environment. 
                     !h               ! This portion should only treat scavenging of aerosols within cumulus updraft in each layer, since by doing that, 
                     !h               ! we can compute realistic cumulus updraft properties in each layer as updraft plume rises.
                     !h               ! Feb.05.2013. In future, when wet deposition of interstitial aerosols are corrected treated in the further below block,
                     !h               !              below part should be revised such that it only treats wet deposition of cloud-borne aerosols probably using
                     !h               !               'prep_tr_au(m,mt) = tr_aut_cb(m,mt) * ( ( prep_qtl_au(m) + prep_qti_au(m) ) / max( ql_aut(m), nonzero ) )' 
                     !h               !              where 'tr_aut_cb(m,mt)' is grid-mean concentration of cloud-borne aerosols and 'ql_aut(m)' is LWC
                     !h               !              within convective updraft. 
                     !h                 prep_tr_au(m,mt) = tr_aut(m,mt) * ( ( prep_qtl_au(m) + prep_qti_au(m) ) / max( qt_aut(m), nonzero ) )
                     !h               ! Below is the old code.
                     !h               ! prep_tr_au(m,mt) = 0._r8
                     !h             endif
                     ! Nov.27.2012. Impose a constraint on the diabatic forcing to prevent the onset of negative tracer during vertical motion.
                     !              This constraint is imposed by using 'tr_aut(m,mt) + prep_tr_au(m,mt) > qmin(mt)' criteria,
                     !              where 'tr_aut(m,mt)' is a tracer at the base interface before adding diabatic forcing.
                     !              Similar constraint has also been imposed on the downdraft motion.
                     prep_tr_au(m,mt) = max( prep_tr_au(m,mt), qmin(mt) - tr_aut(m,mt) )   
                  enddo
                  ! ------------------------------------------------------------------------- !
                  ! TRACERS REFINEMENT NECESSARY : PRECIPITATION FALLOUT AT THE TOP INTERFACE !
                  ! ------------------------------------------------------------------------- !
                  ! ------------------------------------------------------------------------------------------- !
                  ! Evaporation of Precipitation at the cloud top                                               !
                  ! ------------------------------------------------------------------------------------------- !    
                  evp_qtl_au(m)  =  evpR
                  evp_qti_au(m)  =  evpS
                  ! Sep.29.2011. To supress energy conservation error by imposing consistency with the exn0(k)
                  !              used in the computation of slten_u(k) and slten_d(k), I am using exn0(k)
                  !              in the below lines. However, for computing updated 'thl_aut' at the top
                  !              interface, I am using the correct exner function at the top interface.
                  !              this will impose a full consistency throughout the whole code. 
                  ! Below is the new.
                  evp_thll_au(m) =  - ( xlv / cp / exn0(k) ) * evp_qtl_au(m)
                  evp_thli_au(m) =  - ( xls / cp / exn0(k) ) * evp_qti_au(m)
                  ! tmp1           =  - ( xlv / cp / ( ptop(m) / p00 )**rovcp ) * evp_qtl_au(m)
                  ! tmp2           =  - ( xls / cp / ( ptop(m) / p00 )**rovcp ) * evp_qti_au(m)
                  ! Below is the old code.
                  ! evp_thll_au(m) =  - ( xlv / cp / ( ptop(m) / p00 )**rovcp ) * evp_qtl_au(m)
                  ! evp_thli_au(m) =  - ( xls / cp / ( ptop(m) / p00 )**rovcp ) * evp_qti_au(m)
                  ! -------------------------------------------------------------------------------------- !
                  ! TRACERS REFINEMENT NECESSARY : EVAPORATION OF CONVECTIVE PRECIPITATION WITHIN UPDRAFTA !
                  ! -------------------------------------------------------------------------------------- !
                  do mt = 1, ncnst
                     evp_tr_au(m,mt)  =  evpRStr(mt)
                     ! Nov.27.2012. Impose a constraint on the diabatic forcing to prevent the onset of negative tracer during vertical motion.
                     !              This constraint is imposed by using 'tr_aut(m,mt) + evp_tr_au(m,mt) > qmin(mt)' criteria,
                     !              where 'tr_aut(m,mt)' is a tracer at the base interface before adding diabatic forcing.
                     !              Similar constraint has also been imposed on the downdraft motion.
                     !h             evp_tr_au(m,mt) = max( evp_tr_au(m,mt), qmin(mt) - tr_aut(m,mt) )   
                  enddo
                  ! ------------------------------------------------------------------------------------------- !
                  ! 0. Evaporation of Precipitation at the cloud top                                            !
                  !    a. Since updraft is unsaturated within the PBL, this evaporation should be treated here. !
                  !       This may be especially important for treating deep convection.                        !  
                  !    b. I should treat only evaporation of 'convective precipitation' not the 'stratiform     !
                  !       precipitation'. This is important to satisfy energy and moisture conservations.       !
                  !    c. Any diabatic forcings within convective updraft and downdraft will induce the         !
                  !       tendencies of environmental variables.                                                !
                  !    d. Simply neglect evaporation of precipitation within convctive updraft.                 !
                  ! ------------------------------------------------------------------------------------------- !
                  ! Sep.29.2011. See above. Below is the new code.
                  ! thl_aut(m)      = thl_aut(m) + tmp1 + tmp2
                  ! Below is the original code.
                  ! Mar.30.2011. I decided to consistently use exn0(k) because diabatic forcing is a concept of 
                  !              average over the grid layer. 
                  ! Jun.15.2012. I must check that whether below updated 'thl_aut(m),qt_aut(m)' are the same
                  !              as the 'tmp_thl,tmp_qt' computed above when microcu = 1 or 2 above.
                  !              They should be identical.
                  !              Because of limiter, they are not necessarily the same, which is not a problem
                  !              at all. If there is no limiter, they will be indenticalto each other by 
                  !              construction.
                  ! Feb.09.2013. Add evaporation contribution of rain and snow.
                  thl_aut(m)      = thl_aut(m) + prep_thll_au(m) + prep_thli_au(m) + evp_thll_au(m) + evp_thli_au(m) 
                  qt_aut(m)       = qt_aut(m)  +  prep_qtl_au(m) +  prep_qti_au(m) +  evp_qtl_au(m) +  evp_qti_au(m)
                  ! TEST
                  ! if( microcu .eq. 1 .or. microcu .eq. 2 ) then
                  !     if( abs(thl_aut(m) - tmp_thl) .gt. 1.e-3_r8 .or. abs(qt_aut(m) - tmp_qt) .gt. 1.e-6_r8 ) then
                  !         write(6,*)
                  !         write(6,*) 'UNICON: thl_aut (qt_aut) and tmp_thl (tmp_qt) significantly differs'
                  !         write(6,*) 'thl_aut, tmp_thl, qt_aut, tmp_qt = ', thl_aut(m), tmp_thl, qt_aut(m), tmp_qt
                  !         write(6,*)
                  !     endif
                  ! endif
                  ! TEST
                  do mt = 1, ncnst
                     tr_aut(m,mt) = tr_aut(m,mt) + prep_tr_au(m,mt) + evp_tr_au(m,mt)
                  enddo
                  ! --------------------------------------------------------------------------------------------------------- !
                  ! TRACERS REFINEMENT NECESSARY : WET DEPOSITION OF TRACERS BY PRECIPITATION FALLING INTO CONVECTIVE UPDRAFT !
                  ! Feb.05.2013. This should be correctly formulated in future. This only influences tracer concentrations    !
                  !              not the cumulus condensate.                                                                  !
                  !              Note also that this should only treat wet deposition of interstitial aerosols within cumulus !
                  !              updraft not cloud-borne aerosols, since wet deposition of cloud-borne aerosols are already   !
                  !              been treated in the above prep_tr_au(m,mt).                                                  !
                  ! Feb.06.2013. Below 'wdep_tr_au' is not necessary since wet deposition of aerosols (both interstitial and  !
                  !              cloud-borne) will be computed as a part of 'prep_tr_au'.                                     !
                  ! --------------------------------------------------------------------------------------------------------- !
                  !           do mt = 1, ncnst
                  !              if( mt .eq. 1 .or. mt .eq. ixcldliq .or. mt .eq. ixcldice .or. mt .eq. ixnumliq .or. mt .eq. ixnumice ) then
                  !                  wdep_tr_au(m,mt) = 0._r8
                  !              else
                  !                  wdep_tr_au(m,mt) = 0._r8
                  !              endif
                  !              wdep_tr_au(m,mt) = max( wdep_tr_au(m,mt), qmin(mt) - tr_aut(m,mt) )   
                  !           enddo
                  !           do mt = 1, ncnst
                  !              tr_aut(m,mt) = tr_aut(m,mt) + wdep_tr_au(m,mt)
                  !           enddo
                  ! ----------------------------------------------------- !
                  ! 3. Horizontal PGF at the cloud top                    !
                  !    a. Instead of using the gradient within the layer, !
                  !       I should use the gradient between the layers.   !
                  ! ----------------------------------------------------- !
                  ! Apr.21.2011. Comment-out below block of 'u_grd,v_grd' computation since
                  !              u_grd,v_grd are not used hereafter.
                  ! if( k .eq. 1 ) then
                  !     u_grd = ( u0(k+1) -   u0(1) ) / ( p0(k+1) - p0(k) ) 
                  !     v_grd = ( v0(k+1) -   v0(1) ) / ( p0(k+1) - p0(k) ) 
                  ! elseif( k .eq. mkx ) then
                  !     u_grd = ( u0(mkx) - u0(k-1) ) / ( p0(mkx) - p0(k-1) )
                  !     v_grd = ( v0(mkx) - v0(k-1) ) / ( p0(mkx) - p0(k-1) )
                  ! else
                  !     u_grd = ( u0(k+1) - u0(k-1) ) / ( p0(k+1) - p0(k-1) ) 
                  !     v_grd = ( v0(k+1) - v0(k-1) ) / ( p0(k+1) - p0(k-1) ) 
                  ! endif
                  ! if( islope_on_uv .eq. 1 ) then
                  !     u_grd = ssue
                  !     v_grd = ssve
                  ! endif
                  ! Sep.30.2010. Similar to 'eff_ql_au(m) = ql - ql_aut_adi', compute using the 
                  !              analytically integrated PGFc in the above 'progup_uv' equation.
                  ! Below 4 lines are original discrete.
                  ! PGF_u_au(m) = PGFc * u_grd * ( ptop(m) - p_b )
                  ! PGF_v_au(m) = PGFc * v_grd * ( ptop(m) - p_b )
                  ! u_aut(m)    = u_aut(m) + PGF_u_au(m)
                  ! v_aut(m)    = v_aut(m) + PGF_v_au(m)
                  ! Below two lines are new analytical. Note that in this case, u_aut(m) and
                  ! v_aut(m) have already been updated. So, we only need to compute
                  ! PGF_u_au(m) and PGF_v_au(m). Above block to compute u_grd, v_grd can be
                  ! commented out to save computation time too.

                  PGF_u_au(m) = u_aut(m) - u_aut_adi
                  PGF_v_au(m) = v_aut(m) - v_aut_adi

                  ! ----------------------------------------------------------------------------------- !
                  ! Computation of 'ql_aut(m)' and 'qi_aut(m)'                                          !
                  ! Note that this is done using a fully updated final 'thl_aut, qt_aut' which          !
                  ! includes all the effect of 'mixing, precipitation fallout, evaporation.             !
                  ! Mar.15.2015. Add 'frac_ice = qi - exqi / (ql + qi - exql - exqi)' as an optional    !
                  !              argument for subroutine 'conden' below. This optional argument is used !
                  !              only when we priori know 'frac_ice' before doing 'conden'. This input  !
                  !              frac_ice is used in subroutine 'conden' instead of using T-dependent   !
                  !              function. This optional argument should be used                        !
                  !              when we used subroutine 'conden' after precipitation production.       !      
                  !              By doing this, subroutine 'prod_prep_up' does not need to maintain the !
                  !              same fraction of 'qi/(ql+qi)': that is, we can use much more general   !
                  !              formulation for precipitation production in future.                    ! 
                  ! Mar.15.2015. Note also that un principle, input 'ql,qi' should be identical to the  !
                  !              output 'ql,qi' from the subroutine 'conden'. I should check this.      ! 
                  ! ----------------------------------------------------------------------------------- ! 
             !ice frac_ice_aut(m) = ( qi - exqi ) / max( ql + qi - exql - exqi, nonzero ) 
             !ice frac_ice_aut(m) = max( 0._r8, min( 1._r8, frac_ice_aut(m) ) )
             !ice frac_ice = frac_ice_aut(m)
             !ice call conden( ptop(m), thl_aut(m), qt_aut(m), th, qv, ql, qi, qse, id_check, frac_ice = frac_ice )
                  call conden( ptop(m), thl_aut(m), qt_aut(m), th, qv, ql, qi, qse, id_check )
                  ql_aut(m)  = ql
                  qi_aut(m)  = qi
                  thv_aut(m) = th * ( 1._r8 + zvir * qv - ql - qi )
                  ! Nov.28.2012. Impose final consistency between droplet mass and droplet number
                  !              before moving to the next layer above.
                  !              In fact, at this stage, below constraint should be automatically satisfied. 
                  !              However, for clear safety, I am imposing below constraint again.
                  if( ql_aut(m) .eq. 0._r8 ) tr_aut(m,ixnumliq) = 0._r8
                  if( qi_aut(m) .eq. 0._r8 ) tr_aut(m,ixnumice) = 0._r8
 
                  ! ----------------------------------------------------------------------- !
                  ! Downdraft Sorting Parameter of Individual Updraft Segment               !
                  ! Hypothetically check whether individual updraft at each cloud top after !
                  ! all diabatic forcings will be converted into downdraft                  !
                  !   0 : ramain in the layer, 1 : converted into downdraft                 !
                  ! Also compute 'ql_aut(m)' and 'qi_aut(m)'.                               !
                  ! ----------------------------------------------------------------------- !

                  ! Apr.21.2011. Comment-out below two lines since they are not used hereafter
                  !              because of commenting-out of next below block.
                  ! thvl_aut  = thl_aut(m) * ( 1._r8 + zvir * qt_aut(m) )
                  ! thv_aut   = th * ( 1._r8 + zvir * qv - ql - qi )
                  
                  ! Jul.15.2010. Set 'ybot(m)=1' regardless of 'thvl_aut' and let it be tested
                  ! by downdraft dynamics. This is necessary since detrained updraft airs either
                  ! at the cumulus top or at the top interface by area constraint can be 
                  ! influenced by diabatic forcing during journey down to the base interface. 
                  ! if( ithv_minE .eq. -1 ) then
                  !     if( thvl_aut .lt. thvl_minE ) ybot(m) = 1._r8
                  ! else
                  !     if( thv_aut  .lt. thv_minE  ) ybot(m) = 1._r8
                  ! endif

                  ! Apr.21.2011. Remove explicit dependency on 'ybot(m)=1' to save computation time.
                  ! ybot(m) = 1._r8

                  ! ------------------------------------------------------------------------ !
                  ! Save cloud top height in each layer for each segment for future use.     !
                  ! Here, 'k' is defined as a layer mid-point index, not the base interface. !                
                  ! ------------------------------------------------------------------------ !

                  ptops(k,m) = ptop(m)
                  ztops(k,m) = ztop(m)

                  ! -------------------------------------------------------------------------------- !
                  ! Diagnostic Output : As of Jul.26.2011, these can be also used in the actual      !
                  ! as mentioned later below.                                                        !
                  ! Individual updraft segment ( 'msfc' ) properties                                 ! 
                  ! Mean downdraft properties for individual updraft segment will be computed later. !
                  ! Jul.26.2011. Below part of convective updraft properties at each interface are   !
                  !              moved into later part further below with additional inclusion of    !
                  !              non-zero cumulus updraft properties at the cumulus top.             !
                  ! -------------------------------------------------------------------------------- !
   
                  msfc = msfc_from_m(k,m)

                  ! thl_u_msfc(km,msfc)      = thl_au(m)
                  ! qt_u_msfc(km,msfc)       = qt_au(m)       
                  ! u_u_msfc(km,msfc)        = u_au(m)       
                  ! v_u_msfc(km,msfc)        = v_au(m)       
                  ! w_u_msfc(km,msfc)        = w_au(m)       
                  ! ql_u_msfc(km,msfc)       = ql_au(m)
                  ! qi_u_msfc(km,msfc)       = qi_au(m)
                  ! do mt = 1, ncnst
                  !    tr_u_msfc(km,msfc,mt) = tr_au(m,mt)
                  ! enddo
                  ! cmf_u_msfc(km,msfc)      = cmf_au(m)
                  ! a_u_msfc(km,msfc)        = a_au(m)
                  ! num_u_msfc(km,msfc)      = num_au(m)
                  ! rad_u_msfc(km,msfc)      = rad_au(m)

                  eps0_u_msfc(km,msfc)     = eps0(m)
                  eps_u_msfc(km,msfc)      = eps(m)
                  del_u_msfc(km,msfc)      = del(m)                   
                  eeps_u_msfc(km,msfc)     = eeps(m)                   
                  ddel_u_msfc(km,msfc)     = ddel(m)
                  xc_u_msfc(km,msfc)       = xc(m)
                  xs_u_msfc(km,msfc)       = xs(m)
                  xemin_u_msfc(km,msfc)    = xe_min(m)
                  xemax_u_msfc(km,msfc)    = xe_max(m)                   
                  cridis_u_msfc(km,msfc)   = cridis                   
                  thvcuenv_u_msfc(km,msfc) = thv_cu - thv_env
                  thvegenv_u_msfc(km,msfc) = thv_eg - thv_env                   
                  thvxsenv_u_msfc(km,msfc) = thv_xs - thv_env
                  fmix_u_msfc(km,msfc)     = fmix(m)
                  cmfumix_u_msfc(km,msfc)  = fmix(m) * dpa(m) * eps0(m) * cmf_au(m)

                  ! ----------------- !
                  ! Diagnostic Output ! 
                  ! ----------------- !

               enddo  ! End of updraft segment 'm' loop

               ! ------------------------------------------------------------------------ !
               ! Number of detached and non-detached updraft segments                     ! 
               ! Also compute original ( at surface ) updraft segment index in each layer !
               ! Also compute the 'top layer index','top height in pressure and height'   !
               ! of the original updraft segment at surface.                              !  
               ! ------------------------------------------------------------------------ !

               nseg_nondet  = 0                      ! # of non-detached updraft segments
               do m = 1, N_up(km)
                  if( ytop(m) .gt. 0.5_r8 ) then
                     nseg_nondet = nseg_nondet + 1         
                     msfc_from_m(k+1,nseg_nondet) = msfc_from_m(k,m)
                  else 
                     ktop_msfc(msfc_from_m(k,m)) = k
                     ptop_msfc(msfc_from_m(k,m)) = ptops(k,m)
                     ztop_msfc(msfc_from_m(k,m)) = ztops(k,m)
                  endif
                  m_from_msfc(k,msfc_from_m(k,m)) = m
               enddo
               nseg_det = N_up(km) - nseg_nondet     ! # of detached updraft segments

               ! -------------------------------------------------------------------------- !
               ! Apply the constraint of updraft vertical velocity for each updraft segment !
               ! and compute the mass of the 3rd type of detrained airs.                    !
               ! Note that 'ybot(m)=1' always.                                              !
               ! -------------------------------------------------------------------------- !

               do m = 1, N_up(km)
                  if( ytop(m) .gt. 0.5_r8 .and. w_aut(m) .gt. wumax ) then
                     f_wu(m)        = ( 1._r8 - wumax / w_aut(m) )
                     ! Apr.21.2011. Remove explicit dependency on 'ybot(m)=1' to save computation time.
                     ! f_srcds(k,m,3) =           ybot(m)   * f_wu(m) * cmf_aut(m) / cmf_u(km)
                     ! f_srcrs(k,m,3) = ( 1._r8 - ybot(m) ) * f_wu(m) * cmf_aut(m) / cmf_u(km)
                     f_srcds(k,m,3) = f_wu(m) * cmf_aut(m) / cmf_u(km)
                     f_srcrs(k,m,3) = 0._r8                     
                     f_srcrs2(k,m,3) = 0._r8                     
                     cmf_aut(m)     = cmf_aut(m) * ( 1._r8 - f_wu(m) )
                     w_aut(m)       =   w_aut(m) * ( 1._r8 - f_wu(m) )
                  endif
               enddo

               ! ------------------------------------------------------------------------ !
               ! Apply the constraint of updraft fractional area for each updraft segment !
               ! and compute the mass of the 3rd type of detrained airs.                  !
               ! Note that 'ybot(m)=1' always.                                            !
               ! ------------------------------------------------------------------------ !

               cmf_tent = 0._r8
               au_tent  = 0._r8 
               if( nseg_nondet .gt. 0.5_r8 ) then
                  do m = 1, N_up(km)
                     if( ytop(m) .gt. 0.5_r8 ) then
                        cmf_tent  = cmf_tent  + cmf_aut(m)
                        au_tent   = au_tent   +   a_aut(m)
                     endif
                  enddo
               endif

               ! OPTION 
               ! f_nu = max( 0._r8, cmf_tent * ( 1._r8 - a_u(km) / au_tent ) ) / cmf_tent
               ! if( au_tent .gt. a_u(km) ) then
               ! OPTION

               ! f_nu = max( 0._r8, cmf_tent * ( 1._r8 - au_max / au_tent ) ) / cmf_tent
               f_nu = max( 0._r8, 1._r8 - au_max / max( nonzero, au_tent ) ) 

               if( au_tent .gt. au_max ) then
                  do m = 1, N_up(km)
                     if( ytop(m) .gt. 0.5_r8 ) then
                        ! Apr.21.2011. Remove explicit dependency on 'ybot(m)=1' to save computation time.
                        ! f_srcds(k,m,3) = f_srcds(k,m,3) +           ybot(m)   * f_nu * cmf_aut(m) / cmf_u(km)
                        ! f_srcrs(k,m,3) = f_srcrs(k,m,3) + ( 1._r8 - ybot(m) ) * f_nu * cmf_aut(m) / cmf_u(km)
                        f_srcds(k,m,3) = f_srcds(k,m,3) + f_nu * cmf_aut(m) / cmf_u(km)
                        ! f_srcrs(k,m,3) = f_srcrs(k,m,3) + 0._r8
                        ! 05.Aug.2010 : Note that 'num_aut' is not changed.
                        cmf_aut(m) = cmf_aut(m) * ( 1._r8 - f_nu )
                        a_aut(m)   =   a_aut(m) * ( 1._r8 - f_nu )
                        rad_aut(m) = sqrt( a_aut(m) / num_aut(m) /  3.141592_r8 )   ! Physical radius of updraft plume [ m ]
                     endif
                  enddo
               endif

               ! ---------------------------------------------------------------------- !
               ! Mass-flux weighted mean or net updraft properties at the top interface !
               ! These are computed only using non-detached updrafts.                   !
               ! ---------------------------------------------------------------------- !

               if( nseg_nondet .gt. 0.5_r8 ) then

                  ! CHECK
                  ! if( get_nstep() .ge. 0 .and. get_nstep() .lt. 20000 ) then 
                  !     write(6,*)
                  !     write(6,*) 'UNICON: Computation of decomposition of various qnantities'
                  !     write(6,*)
                  !     write(6,*) 'Time step & Layer Index: ', get_nstep(),  k
                  !     write(6,*) 'Org. & sin(Org) for R = ', org_rad, 0.5_r8 * ( 1._r8 + sin( 3.141592_r8 * ( org_rad - 0.5_r8 ) ) )
                  !     write(6,*) 'rho_b, fmix_frac, dp_m, p0(k) = ', rho_b, fmix_frac, dp_m, p0(k) 
                  !     write(6,*) 'd_alpha, delta_w_PBL = ', d_alpha, delta_w_PBL
                  !     write(6,*)
                  !     if( k .eq. 1 ) then
                  !     write(6,*) '  alpha(1),   alpha(2),   alpha(3),   alpha(4),   alpha(5) = ', &
                  !                   alpha(1),   alpha(2),   alpha(3),   alpha(4),   alpha(5)
                  !     write(6,*) ' cmf_au(1),  cmf_au(2),  cmf_au(3),  cmf_au(4),  cmf_au(5) = ', &
                  !                  cmf_au(1),  cmf_au(2),  cmf_au(3),  cmf_au(4),  cmf_au(5)
                  !     write(6,*) '   a_au(1),    a_au(2),    a_au(3),    a_au(4),    a_au(5) = ', &
                  !                    a_au(1),    a_au(2),    a_au(3),    a_au(4),    a_au(5)
                  !     write(6,*) '   w_au(1),    w_au(2),    w_au(3),    w_au(4),    w_au(5) = ', &
                  !                    w_au(1),    w_au(2),    w_au(3),    w_au(4),    w_au(5)
                  !     write(6,*) ' rad_au(1),  rad_au(2),  rad_au(3),  rad_au(4),  rad_au(5) = ', &
                  !                  rad_au(1),  rad_au(2),  rad_au(3),  rad_au(4),  rad_au(5)
                  !     write(6,*) ' num_au(1),  num_au(2),  num_au(3),  num_au(4),  num_au(5) = ', &
                  !                  num_au(1),  num_au(2),  num_au(3),  num_au(4),  num_au(5)
                  !     write(6,*) '  ql_au(1),   ql_au(2),   ql_au(3),   ql_au(4),   ql_au(5) = ', &
                  !                   ql_au(1),   ql_au(2),   ql_au(3),   ql_au(4),   ql_au(5)
                  !     write(6,*) '  qi_au(1),   qi_au(2),   qi_au(3),   qi_au(4),   qi_au(5) = ', &
                  !                   qi_au(1),   qi_au(2),   qi_au(3),   qi_au(4),   qi_au(5)
                  !     write(6,*)
                  !     endif
                  !     write(6,*) 'cmf_aut(1), cmf_aut(2), cmf_aut(3), cmf_aut(4), cmf_aut(5) = ', &
                  !                 cmf_aut(1), cmf_aut(2), cmf_aut(3), cmf_aut(4), cmf_aut(5)
                  !     write(6,*) '  a_aut(1),   a_aut(2),   a_aut(3),   a_aut(4),   a_aut(5) = ', &
                  !                   a_aut(1),   a_aut(2),   a_aut(3),   a_aut(4),   a_aut(5)
                  !     write(6,*) '  w_aut(1),   w_aut(2),   w_aut(3),   w_aut(4),   w_aut(5) = ', &
                  !                   w_aut(1),   w_aut(2),   w_aut(3),   w_aut(4),   w_aut(5)
                  !     write(6,*) 'rad_aut(1), rad_aut(2), rad_aut(3), rad_aut(4), rad_aut(5) = ', &
                  !                 rad_aut(1), rad_aut(2), rad_aut(3), rad_aut(4), rad_aut(5)
                  !     write(6,*) 'num_aut(1), num_aut(2), num_aut(3), num_aut(4), num_aut(5) = ', &
                  !                 num_aut(1), num_aut(2), num_aut(3), num_aut(4), num_aut(5)
                  !     write(6,*) ' ql_aut(1),  ql_aut(2),  ql_aut(3),  ql_aut(4),  ql_aut(5) = ', &
                  !                  ql_aut(1),  ql_aut(2),  ql_aut(3),  ql_aut(4),  ql_aut(5)
                  !     write(6,*) ' qi_aut(1),  qi_aut(2),  qi_aut(3),  qi_aut(4),  qi_aut(5) = ', &
                  !                  qi_aut(1),  qi_aut(2),  qi_aut(3),  qi_aut(4),  qi_aut(5)
                  !     write(6,*) 'eps0org(1), eps0org(2), eps0org(3), eps0org(4), eps0org(5) = ', &
                  !                 eps0org(1), eps0org(2), eps0org(3), eps0org(4), eps0org(5)
                  !     write(6,*) '   eps0(1),    eps0(2),    eps0(3),    eps0(4),    eps0(5) = ', &
                  !                    eps0(1),    eps0(2),    eps0(3),    eps0(4),    eps0(5)
                  !     write(6,*) '    eps(1),     eps(2),     eps(3),     eps(4),     eps(5) = ', &
                  !                     eps(1),     eps(2),     eps(3),     eps(4),     eps(5)
                  !     write(6,*) '    del(1),     del(2),     del(3),     del(4),     del(5) = ', &
                  !                     del(1),     del(2),     del(3),     del(4),     del(5)
                  !     write(6,*) '     xc(1),      xc(2),      xc(3),      xc(4),      xc(5) = ', &
                  !                      xc(1),      xc(2),      xc(3),      xc(4),      xc(5)
                  !     write(6,*) ' xc_tmp(1),  xc_tmp(2),  xc_tmp(3),  xc_tmp(4),  xc_tmp(5) = ', &
                  !                  xc_tmp(1),  xc_tmp(2),  xc_tmp(3),  xc_tmp(4),  xc_tmp(5)
                  ! endif
                  ! CHECK

                  do m = 1, N_up(km)
                     if( ytop(m) .gt. 0.5_r8 ) then
                        cmf_u(k)  = cmf_u(k)  + cmf_aut(m)
                        num_u(k)  = num_u(k)  + num_aut(m)
                        a_u(k)    = a_u(k)    +   a_aut(m)
                        rad_u(k)  = rad_u(k)  + num_aut(m) * rad_aut(m)**2._r8
                        thl_u(k)  = thl_u(k)  + thl_aut(m) * cmf_aut(m)
                        qt_u(k)   = qt_u(k)   +  qt_aut(m) * cmf_aut(m)
                        u_u(k)    = u_u(k)    +   u_aut(m) * cmf_aut(m)
                        v_u(k)    = v_u(k)    +   v_aut(m) * cmf_aut(m)
                        w_u(k)    = w_u(k)    +   w_aut(m) * cmf_aut(m)
                        wa_u(k)   = wa_u(k)   +   w_aut(m) *   a_aut(m)
                        ! Apr.21.2011. Comment-out below block since 'ql_aut(m),qi_aut(m)' for all updrafts ( both detached 
                        !              and non-detached ) have already been computed above.  
                        ! call conden( p_t, thl_aut(m), qt_aut(m), th, qv, ql, qi, qse, id_check )
                        ! if( id_check .eq. 1 ) then
                        !     id_exit = .true.
                        !     go to 333
                        ! endif
                        ql_u(k)   = ql_u(k)   +  ql_aut(m) * cmf_aut(m)  
                        qi_u(k)   = qi_u(k)   +  qi_aut(m) * cmf_aut(m)  
                        do mt = 1, ncnst
                           tr_u(k,mt) = tr_u(k,mt) + tr_aut(m,mt) * cmf_aut(m)  
                        enddo
                        qla_u(k)  = qla_u(k)  +  ql_aut(m) *   a_aut(m)  
                        qia_u(k)  = qia_u(k)  +  qi_aut(m) *   a_aut(m)  
                        ! Mar.07.2013. Add below line for use in the computation of the evolution of vertical velocity
                        !              of convective updraft and downdraft later for developing more complete scale-adaptive scheme.  
                        thva_u(k) =thva_u(k)  + thv_aut(m) *   a_aut(m)  
                     endif
                  enddo
                  rad_u(k)  = sqrt( rad_u(k) / num_u(k) )                 ! Effective plume radius [ m ]
                  thl_u(k)  = thl_u(k) / cmf_u(k)
                  qt_u(k)   = qt_u(k)  / cmf_u(k)
                  u_u(k)    = u_u(k)   / cmf_u(k)
                  v_u(k)    = v_u(k)   / cmf_u(k)
                  w_u(k)    = w_u(k)   / cmf_u(k)
                  wa_u(k)   = wa_u(k)  / a_u(k)
                  gamw_u(k) = w_u(k)   / wa_u(k)
                  ql_u(k)   = ql_u(k)  / cmf_u(k)                         ! Mass-flux weighted average of in-cloud liquid condensate   
                  qi_u(k)   = qi_u(k)  / cmf_u(k)                         ! Mass-flux weighted average of in-cloud liquid condensate
                  do mt = 1, ncnst
                     tr_u(k,mt) = tr_u(k,mt)  / cmf_u(k)             
                  enddo
                  qla_u(k)  = qla_u(k) / a_u(k)                           ! Area-weighting average of in-cloud liquid condensate   
                  qia_u(k)  = qia_u(k) / a_u(k)                           ! Area-weighting average of in-cloud liquid condensate
                  thva_u(k) =thva_u(k) / a_u(k)                           ! Area-weighting average of updraft buoyancy
               endif

               ! CHECK
               ! write(6,*)
               ! write(6,*) 'UNICON: Mean convective updraft properties at the top interface in each layer'
               ! write(6,*) 'Layer index  = ', k 
               ! write(6,*) 'cmf_u(k)     = ', cmf_u(k)
               ! write(6,*) 'a_u(k)       = ', a_u(k)
               ! write(6,*) 'num_u(k)     = ', num_u(k)
               ! write(6,*) 'rad_u(k)     = ', rad_u(k)
               ! write(6,*) 'thl_u(k)     = ', thl_u(k)
               ! write(6,*) 'qt_u(k)      = ', qt_u(k)
               ! write(6,*) 'u_u(k)       = ', u_u(k)
               ! write(6,*) 'v_u(k)       = ', v_u(k)
               ! write(6,*) 'w_u(k)       = ', w_u(k)
               ! write(6,*) 'wa_u(k)      = ', wa_u(k)
               ! write(6,*) 'ql_u(k)      = ', ql_u(k)
               ! write(6,*) 'qi_u(k)      = ', qi_u(k)
               ! write(6,*) 'qla_u(k)     = ', qla_u(k)
               ! write(6,*) 'qia_u(k)     = ', qia_u(k)
               ! write(6,*) 'gamw_u(k)    = ', gamw_u(k)
               ! write(6,*) 'thva_u(k)    = ', thva_u(k)
               ! write(6,*) 'nseg_nondet  = ', nseg_nondet
               ! write(6,*)
               ! CHECK

               ! ----------------------------------------------------------------------------- !
               ! Mass-flux weighted diabatic change of conservative scalars at each cloud top. !
               ! This will be used for computing environmental tendency later.                 ! 
               ! We separately define cmf_u_dia(k) as well as cmf_u(k) to take into account of !
               ! non-zero updraft mass flux at just below the cloud top of each detached       !
               ! updraft for the purpose of treating diabatic forcing at the cloud top.        !
               ! ----------------------------------------------------------------------------- !

               do m = 1, N_up(km)
                  ! ------------------------------------------------------------------------- !
                  ! There are 4 possible options to set fac :                                 !
                  ! (1) fac = cmf_au(m)                                                       !
                  ! (2) fac = cmf_aut(m) > 0                                                  !
                  ! (3) fac = 0.5_r8 * ( cmf_au(m) + cmf_aut(m) ) where cmf_aut(m) > 0.       !
                  ! (4) fac = 0.5_r8 * ( cmf_au(m) + cmf_aut(m) ) where cmf_aut(m) = 0.       !
                  ! Here, I choose (3) in consistent with UW shallow convection scheme.       !
                  ! Downdraft diabatic forcing should be consistently treated as this updraft !
                  ! diabatic forcing.                                                         !
                  ! 05.Aug.2010. When updraft did not reach to the top interface, cmf_aut(m)  !
                  ! is still non-zero but updraft area constraint ( au_max ) is not applied.  !
                  ! Even when updraft segment reaches to the top interface, 'cmf_aut(m)' for  !
                  ! diabatic forcing should be defined WITHOUT updraft area constraint.       ! 
                  ! 01.Sep.2010. The 'fac' must be defined using 'cmf_aut' and 0.5 must be    !
                  ! additionally multiplied in order to consider zero diabatic forcing at the !
                  ! base interface.                                                           !   
                  ! ------------------------------------------------------------------------- !
                  ! CORRECTION : For convective updraft, diabatic forcing occurs at the top 
                  !              interface of each layer, including horizontal PGF. 
                  !              Correct formula should be '0.5 * ( prep_qtl_bot * cmf_au + prep_qtl_top * cmf_aut )'.
                  !              Since 'prep_qtl_bot = 0' in each layer ( since diabatic forcing is computed at the top interface ),
                  !              my below new formula of 'fac = 0.5_r8 * ( 0._r8 + cmf_aut(m) )' is exactly correct.   
                  ! Below two lines are privious wrong.
                  ! fac            = 0.5_r8 * ( cmf_au(m) + cmf_aut(m) )
                  ! if( ytop(m) .gt. 0.5_r8 ) fac = 0.5_r8 * ( cmf_au(m) + cmf_aut(m) / ( 1._r8 - f_nu ) / ( 1._r8 - f_wu(m) ) )
                  ! Below two lines are new correct.
                  ! Apr.21.2011. Multiply 'dpa(m)/dp_m' to 'fac' in order to fully take into account of 
                  !              partial vertical fillness of convective updraft plumes in the cloud top layer.
                  !              This correction makes the treatment perfect. 
                  ! fac            = 0.5_r8 * ( 0._r8     + cmf_aut(m) ) * ( dpa(m) / dp_m )
                  ! if( ytop(m) .gt. 0.5_r8 ) fac = 0.5_r8 * ( 0._r8     + cmf_aut(m) / ( 1._r8 - f_nu ) / ( 1._r8 - f_wu(m) ) )
                  ! Nov.07.2011. Critical bug fix. We must use below formula in order not to generate unreasonable
                  !              diabatic source in each layer for fac.
                  !              From the consideration of idealized case, I clearly checked that below new formula is
                  !              absolutely correct and also is fully consistent with CAM5 shallow convection scheme.
                  fac            = 0.5_r8 * ( cmf_au(m) + cmf_aut(m) ) * ( dpa(m) / dp_m )
                  if( ytop(m) .gt. 0.5_r8 ) fac = 0.5_r8 * ( cmf_au(m) + cmf_aut(m) / ( 1._r8 - f_nu ) / ( 1._r8 - f_wu(m) ) )
                  cmf_u_dia(k)   = cmf_u_dia(k)   +                    fac
                  evp_thll_u(k)  = evp_thll_u(k)  +   evp_thll_au(m) * fac
                  evp_qtl_u(k)   = evp_qtl_u(k)   +    evp_qtl_au(m) * fac
                  evp_thli_u(k)  = evp_thli_u(k)  +   evp_thli_au(m) * fac
                  evp_qti_u(k)   = evp_qti_u(k)   +    evp_qti_au(m) * fac
                  prep_thll_u(k) = prep_thll_u(k) +  prep_thll_au(m) * fac
                  prep_qtl_u(k)  = prep_qtl_u(k)  +   prep_qtl_au(m) * fac
                  prep_thli_u(k) = prep_thli_u(k) +  prep_thli_au(m) * fac
                  prep_qti_u(k)  = prep_qti_u(k)  +   prep_qti_au(m) * fac
                  PGF_u_u(k)     = PGF_u_u(k)     +      PGF_u_au(m) * fac
                  PGF_v_u(k)     = PGF_v_u(k)     +      PGF_v_au(m) * fac
                  eff_ql_u(k)    = eff_ql_u(k)    +     eff_ql_au(m) * fac
                  eff_qi_u(k)    = eff_qi_u(k)    +     eff_qi_au(m) * fac
                  do mt = 1, ncnst
                     evp_tr_u(k,mt)  =  evp_tr_u(k,mt) +   evp_tr_au(m,mt) * fac
                     prep_tr_u(k,mt) = prep_tr_u(k,mt) +  prep_tr_au(m,mt) * fac
                     !              wdep_tr_u(k,mt) = wdep_tr_u(k,mt) +  wdep_tr_au(m,mt) * fac
                     eff_tr_u(k,mt)  =  eff_tr_u(k,mt) +   eff_tr_au(m,mt) * fac
                  enddo
                  cmf_u_mix(k)   = cmf_u_mix(k)   + fmix(m) * dpa(m) * eps0(m) * cmf_au(m)
                  ! ---------------------------------------------------------------------------- !
                  ! Compute individual segment's rain and snow production tendency by convective !
                  ! updrafts. Corresponding tendency by convective downdraft will be computed    !
                  ! later.                                                                       !  
                  ! ---------------------------------------------------------------------------- !
                  msfc = msfc_from_m(k,m)
                  qrten_u_msfc(k,msfc) = - ( g / dp0(k) ) * ( prep_qtl_au(m) + evp_qtl_au(m) ) * fac   ! >= 0
                  qsten_u_msfc(k,msfc) = - ( g / dp0(k) ) * ( prep_qti_au(m) + evp_qti_au(m) ) * fac   ! >= 0
                  ! --------------------------------------------------------------------------------------------------------- !
                  ! Nov.29.2012. I can compute corresponding 'trrsten_u_msfc(k,msfc,mt)' of tracers associated with           !
                  ! precipitation by adding ( prep_tr_au(m,mt) + evp_tr_au(m,mt) ) * fac'. This information will be used      !
                  ! to trace aerosol concentration within precipitation flux, which will be used to compute the increase of   !
                  ! aerosol concentration within convective downdraft and environment when precipitation is evaporated within !
                  ! convective downdraft and environment. Eventually, this will be used for computing aerosol wet scavenging  !
                  ! process associated with convective precipitation process instead of performing within wetdepa.            !
                  ! Note that I should use 'dptr0(k,mt)' instead of 'dp0(k)' for tracers.                                     !
                  ! Dec.01.2012. It should be emphasized that in contrast to the other tracers in 'mt > 3', there is no       !
                  !              direct association in the conversion process of 'droplet number' between cloud droplet       !
                  !              and precipitation droplet. In the below line, all of 'prep_tr_au(m,mt), evp_tr_au(m,mt)'     !
                  !              were computed for computing droplet number change within convective updraft and downdraft,   !
                  !              NOT within precipitation. Thus, for 'mt = ixnumliq, ixnumice', below computation of number   !
                  !              sources of precipitation droplet is not correct. For clearness, for the time being, similar  !
                  !              to the treatment of droplet number concentration, let's assume a certain specified size of   !
                  !              precipitation droplet.                                                                       !
                  ! Dec.13.2012. Add separate treatment of 'ixcldliq,ixcldice' in the below 'trrsten' variables.              !
                  ! Feb.06.2013. Note that wet deposition of aerosol within convetcive updraft (both cloud-borne and          !
                  !              interstitial) will be treated as a part of prep_tr_au(m,mt).                                 !
                  !              So, I don't need to use wdep_tr_au(m,mt) in the below trrsten_u_msfc().                      ! 
                  ! --------------------------------------------------------------------------------------------------------- !
                  do mt = 1, ncnst
                     if( mt .eq. ixcldliq ) then
                        trrsten_u_msfc(k,msfc,mt) = qrten_u_msfc(k,msfc)
                     elseif( mt .eq. ixcldice ) then
                        trrsten_u_msfc(k,msfc,mt) = qsten_u_msfc(k,msfc)
                     elseif( mt .eq. ixnumliq ) then
                        trrsten_u_msfc(k,msfc,mt) = qrten_u_msfc(k,msfc) * 3._r8 / &
                                                    ( 4._r8 * 3.141592_r8 * droprad_rain**3 * density_rain )                    
                     elseif( mt .eq. ixnumice ) then 
                        trrsten_u_msfc(k,msfc,mt) = qsten_u_msfc(k,msfc) * 3._r8 / &
                                                    ( 4._r8 * 3.141592_r8 * droprad_snow**3 * density_snow )                    
                     else
                        trrsten_u_msfc(k,msfc,mt) = - ( g / dptr0(k,mt) ) * ( prep_tr_au(m,mt) + evp_tr_au(m,mt) ) * fac   ! >= 0
                        ! trrsten_u_msfc(k,msfc,mt) = - ( g / dptr0(k,mt) ) * ( prep_tr_au(m,mt) + evp_tr_au(m,mt) + wdep_tr_au(m,mt) ) * fac   ! >= 0
                     endif
                  enddo
                  ! ---------------------------------------------------------------------------- !
                  !                                                                              !  
                  ! ---------------------------------------------------------------------------- !
               enddo
               if( cmf_u_dia(k) .gt. nonzero ) then
                  evp_thll_u(k)  = evp_thll_u(k)  / cmf_u_dia(k)
                  evp_qtl_u(k)   = evp_qtl_u(k)   / cmf_u_dia(k)
                  evp_thli_u(k)  = evp_thli_u(k)  / cmf_u_dia(k)
                  evp_qti_u(k)   = evp_qti_u(k)   / cmf_u_dia(k)
                  prep_thll_u(k) = prep_thll_u(k) / cmf_u_dia(k)
                  prep_qtl_u(k)  = prep_qtl_u(k)  / cmf_u_dia(k)
                  prep_thli_u(k) = prep_thli_u(k) / cmf_u_dia(k)
                  prep_qti_u(k)  = prep_qti_u(k)  / cmf_u_dia(k)
                  eff_ql_u(k)    = eff_ql_u(k)    / cmf_u_dia(k)
                  eff_qi_u(k)    = eff_qi_u(k)    / cmf_u_dia(k)
                  PGF_u_u(k)     = PGF_u_u(k)     / cmf_u_dia(k)
                  PGF_v_u(k)     = PGF_v_u(k)     / cmf_u_dia(k)
                  do mt = 1, ncnst
                     evp_tr_u(k,mt)  =  evp_tr_u(k,mt) / cmf_u_dia(k)
                     prep_tr_u(k,mt) = prep_tr_u(k,mt) / cmf_u_dia(k)
                     ! wdep_tr_u(k,mt) = wdep_tr_u(k,mt) / cmf_u_dia(k)
                     eff_tr_u(k,mt)  =  eff_tr_u(k,mt) / cmf_u_dia(k)
                  enddo
               else
                  cmf_u_dia(k)   = 0._r8
                  evp_thll_u(k)  = 0._r8
                  evp_qtl_u(k)   = 0._r8
                  evp_thli_u(k)  = 0._r8
                  evp_qti_u(k)   = 0._r8
                  prep_thll_u(k) = 0._r8
                  prep_qtl_u(k)  = 0._r8
                  prep_thli_u(k) = 0._r8
                  prep_qti_u(k)  = 0._r8
                  eff_ql_u(k)    = 0._r8
                  eff_qi_u(k)    = 0._r8
                  PGF_u_u(k)     = 0._r8
                  PGF_v_u(k)     = 0._r8
                  do mt = 1, ncnst
                     evp_tr_u(k,mt)  = 0._r8
                     prep_tr_u(k,mt) = 0._r8
                     ! wdep_tr_u(k,mt) = 0._r8
                     eff_tr_u(k,mt)  = 0._r8
                  enddo
               endif

               ! CHECK
               ! write(6,*)
               ! write(6,*) 'UNICON: Mean diabatic forcing experienced by convective updraft'
               ! write(6,*) 'Layer index  = ', k 
               ! write(6,*) 'cmf_u_dia(k)     = ', cmf_u_dia(k)
               ! write(6,*) 'evp_thll_u(k)    = ', evp_thll_u(k)
               ! write(6,*) 'evp_qtl_u(k)     = ', evp_qtl_u(k)
               ! write(6,*) 'evp_thli_u(k)    = ', evp_thli_u(k)
               ! write(6,*) 'evp_qti_u(k)     = ', evp_qti_u(k)
               ! write(6,*) 'prep_thll_u(k)   = ', prep_thll_u(k)
               ! write(6,*) 'prep_qtl_u(k)    = ', prep_qtl_u(k)
               ! write(6,*) 'prep_thli_u(k)   = ', prep_thli_u(k)
               ! write(6,*) 'prep_qti_u(k)    = ', prep_qti_u(k)
               ! write(6,*) 'PGF_u_u(k)       = ', PGF_u_u(k)
               ! write(6,*) 'PGF_v_u(k)       = ', PGF_v_u(k)
               ! write(6,*)
               ! CHECK

               ! ----------------------------------------------------------------------------- !
               !                                                                               !
               ! 3 sources of downdrafts and 1 source of detrained air from each segment level !
               !                                                                               !
               ! ----------------------------------------------------------------------------- !

               ! ------------------------------------------------------------------------------------- !                 
               ! 1. Mixing Downdraft + Detrained Updraft                                               !
               !    This is a lateral detrainment after updraft buoyancy sorting at the base interface !       
               ! ------------------------------------------------------------------------------------- !

               do m = 1, N_up(km)
                  ! ---------------------------------------------------------------------------- !
                  ! 1. Since updraft buoyancy sorting was performed at the base interface,       !
                  !    we should use 'thl_au(m)' not 'thl_aut(m)'.                               !
                  ! 2. For consistent treatment of buoyancy sorting with organized environmental ! 
                  !    airs, we should use 'thl_eg' not 'thl_b'.                                 !
                  ! 3. Since 'compute_PDF' sets 'zmass = 0' when 'xe_min(m) = xe_max(m)',        !  
                  !    below computation is correct in general case.                             !
                  ! ---------------------------------------------------------------------------- !
                  ! ---------------- !
                  ! Mixing Downdraft !
                  ! ---------------- !
                  ! ------------------------------------------------------------------ !
                  ! fmix(m) * dpa(m) * eps0(m) * cmf_au(m) :                           !
                  ! The amount of updraft mass involved in the buoyancy sorting mixing !
                  ! ------------------------------------------------------------------ !
                  
                  call compute_PDF( 'PDFbsQ', xe_min(m), xe_max(m), zbar, zmass, zmass_up )
                  f_srcds(k,m,1)   =    zmass * fmix(m) * dpa(m) * eps0(m) * 2._r8 * cmf_au(m) / cmf_u(km)
                  thl_srcds(k,m,1) = ( thl_au(m) + zbar * ( thl_eg - thl_au(m) ) )
                  qt_srcds(k,m,1)  = ( qt_au(m)  + zbar * ( qt_eg  -  qt_au(m) ) )
                  u_srcds(k,m,1)   = ( u_au(m)   + zbar * ( u_eg   -   u_au(m) ) )
                  v_srcds(k,m,1)   = ( v_au(m)   + zbar * ( v_eg   -   v_au(m) ) )
                  do mt = 1, ncnst
                     tr_srcds(k,m,1,mt) = ( tr_au(m,mt) + zbar * ( tr_eg(mt) - tr_au(m,mt) ) )
                  enddo
                  ! -------------------------------------------------------------------------------------------------- !
                  ! Nov.28.2012. Impose consistency between droplet mass and droplet number.                           !
                  !              Note that this should be computed here since it involves the use of 'zbar'.           ! 
                  !              Mixing downdraft is generated at the base interface which will be the source level of !
                  !              mixing downdraft layer. Thus, I am using 'ps0(km)' in the below 'conden' subroutine.  !
                  ! -------------------------------------------------------------------------------------------------- !
                  tmp_l            = ( ql_au(m)  + zbar * ( qle_b(k)  -  ql_au(m) ) )
                  tmp_i            = ( qi_au(m)  + zbar * ( qie_b(k)  -  qi_au(m) ) )
             !ice if( ipartition_fice .eq. 0 ) then ! Temperature-dependent ice fraction
             !ice     if( k .gt. (kiss + 1) .and. zbar .eq. 0._r8 ) then 
             !ice         frac_ice = frac_ice_au(m)
             !ice         call conden( ps0(km), thl_srcds(k,m,1), qt_srcds(k,m,1), & 
             !ice                      tmp_th, tmp_qv, tmp_ql, tmp_qi, tmp_qse, id_check, frac_ice = frac_ice )
             !ice     else
                          call conden( ps0(km), thl_srcds(k,m,1), qt_srcds(k,m,1), & 
                                       tmp_th, tmp_qv, tmp_ql, tmp_qi, tmp_qse, id_check )
             !ice     endif
             !ice else ! Explicitly averaged ice fraction between updraft and environment
             !ice     if( k .eq. kiss + 1 ) then
             !ice         call conden( ps0(km), thl_srcds(k,m,1), qt_srcds(k,m,1), & 
             !ice                      tmp_th, tmp_qv, tmp_ql, tmp_qi, tmp_qse, id_check )
             !ice     else
             !ice         frac_ice_eg = qie_b(k) / max( qle_b(k) + qie_b(k), nonzero )
             !ice         frac_ice = frac_ice_au(m) + zbar * ( frac_ice_eg - frac_ice_au(m) )
             !ice         call conden( ps0(km), thl_srcds(k,m,1), qt_srcds(k,m,1), & 
             !ice                      tmp_th, tmp_qv, tmp_ql, tmp_qi, tmp_qse, id_check, frac_ice = frac_ice )
             !ice     endif
             !ice endif
                  !f          if( id_check .eq. 1 ) then
                  !f              id_exit = .true.
                  !f              go to 333
                  !f          endif
                  ql_srcds(k,m,1)  = tmp_ql
                  qi_srcds(k,m,1)  = tmp_qi
                  ! Below is designed for considering the effect of homogenized mixing of all mixtures after buoyancy sorting 
                  ! on the droplet number concentration. Note that while the droplet size within cumulus updraft should be fixed
                  ! as the externally specified value, its mixture with the environmental airs, and so convective downdraft may
                  ! have different droplet size. Thus below treatment is completely correct and can be used both in the current
                  ! specific code and generalized future microphysics.    
                  ! Nov.29.2012. Below is problematic if 'tmp_l = 0' and 'tmp_ql > 0' which can happen due to the curvature of saturation
                  ! vapor pressure line. In this case, regardless whether tr_srcds(k,m,1,ixnumliq) is zero or positive, problem happens.
                  ! Thus, I return to the original formulation of fixed droplet radius as further below.    
                  ! tr_srcds(k,m,1,ixnumliq) = tr_srcds(k,m,1,ixnumliq) + ( tmp_ql - tmp_l ) * ( tr_srcds(k,m,1,ixnumliq) / max( tmp_l, nonzero ) )
                  ! tr_srcds(k,m,1,ixnumliq) = max( 0._r8, tr_srcds(k,m,1,ixnumliq) )
                  ! tr_srcds(k,m,1,ixnumice) = tr_srcds(k,m,1,ixnumice) + ( tmp_qi - tmp_i ) * ( tr_srcds(k,m,1,ixnumice) / max( tmp_i, nonzero ) )
                  ! tr_srcds(k,m,1,ixnumice) = max( 0._r8, tr_srcds(k,m,1,ixnumice) )
                  tr_srcds(k,m,1,ixnumliq) = ql_srcds(k,m,1) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_liq**3 * density_liq )
                  tr_srcds(k,m,1,ixnumice) = qi_srcds(k,m,1) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_ice**3 * density_ice )

                  ! CHECK
                  ! if( get_nstep() .eq. 3 .and. k .eq. 5 ) then
                  !     write(6,*)
                  !     write(6,*) 'UNICON: Computation of downdraft properties at the base of ambiguous layer'
                  !     write(6,*) 'Time step & Layer & Segment Index: ', get_nstep(), k, m
                  !     write(6,*) 'eps0(m), eeps(m), ddel(m), eps(m), del(m) =', eps0(m), eeps(m), ddel(m), eps(m), del(m)
                  !     write(6,*) 'cmf_u(km), cmf_au(m) =', cmf_u(km), cmf_au(m)
                  !     write(6,*) 'zmass, fmix(m), dpa(m), dp_m = ', zmass, fmix(m), dpa(m), dp_m  
                  !     write(6,*) 'f_srcds(k,m,1) * cmf_au(m), cmf_au(m) * 2 = ', f_srcds(k,m,1) * cmf_au(m), cmf_au(m) * 2 
                  !     write(6,*) 'zbar, thl_au(m), thl_eg, thl_srcds(k,m,1) =', zbar, thl_au(m), thl_eg, thl_srcds(k,m,1) 
                  !     write(6,*) 'thvl_au(m), thvl0(k) =', thl_au(m) * ( 1._r8 + zvir * qt_au(m) ), thvl0(k)
                  !     write(6,*)
                  ! endif
                  ! CHECK

                  ! ----------------- !
                  ! Detrained Updraft !
                  ! ----------------- !
                  call compute_PDF( 'PDFbsQ', xc(m),    xe_min(m), zbar1, zmass1, zmass_up1 )
                  call compute_PDF( 'PDFbsQ', xe_max(m),    1._r8, zbar2, zmass2, zmass_up2 )
                  zmass_up = zmass_up1 + zmass_up2
                  zmass = zmass1 + zmass2
                  zbar  = 0._r8
                  if( zmass .gt. nonzero ) zbar = ( zbar1 * zmass1 + zbar2 * zmass2 ) / zmass
                  f_srcrs(k,m,1)   =    zmass * fmix(m) * dpa(m) * eps0(m) * 2._r8 * cmf_au(m) / cmf_u(km)
                  thl_srcrs(k,m,1) = ( thl_au(m) + zbar * ( thl_eg - thl_au(m) ) )
                  qt_srcrs(k,m,1)  = ( qt_au(m)  + zbar * ( qt_eg  -  qt_au(m) ) )
                  u_srcrs(k,m,1)   = ( u_au(m)   + zbar * ( u_eg   -   u_au(m) ) )
                  v_srcrs(k,m,1)   = ( v_au(m)   + zbar * ( v_eg   -   v_au(m) ) )
                  do mt = 1, ncnst
                     tr_srcrs(k,m,1,mt) = ( tr_au(m,mt) + zbar * ( tr_eg(mt) - tr_au(m,mt) ) )
                  enddo
                  ! -------------------------------------------------------------------------------------------------- !
                  ! Nov.28.2012. Impose consistency between droplet mass and droplet number.                           !
                  !              Note that this should be computed here since it involves the use of 'zbar'.           ! 
                  !              Detrained downdraft will be eventually detrained at the layer mid-point as has been   !
                  !              assumed in the previous code later.                                                   !
                  !              Thus, I am using 'p0(k)' in the below 'conden' subroutine.                            !
                  ! -------------------------------------------------------------------------------------------------- !
                  tmp_l            = ( ql_au(m)  + zbar * ( qle_b(k)  -  ql_au(m) ) )
                  tmp_i            = ( qi_au(m)  + zbar * ( qie_b(k)  -  qi_au(m) ) )
             !ice if( ipartition_fice .eq. 0 ) then ! Temperature-dependent ice fraction
             !ice     if( k .gt. (kiss + 1) .and. zbar .eq. 0._r8 ) then 
             !ice         frac_ice = frac_ice_au(m)
             !ice         call conden( p0(k), thl_srcrs(k,m,1), qt_srcrs(k,m,1), & 
             !ice                      tmp_th, tmp_qv, tmp_ql, tmp_qi, tmp_qse, id_check, frac_ice = frac_ice )
             !ice     else
                          call conden( p0(k), thl_srcrs(k,m,1), qt_srcrs(k,m,1), & 
                                       tmp_th, tmp_qv, tmp_ql, tmp_qi, tmp_qse, id_check )
             !ice     endif
             !ice else ! Explicitly averaged ice fraction between updraft and environment.
             !ice     if( k .eq. kiss + 1 ) then
             !ice         call conden( p0(k), thl_srcrs(k,m,1), qt_srcrs(k,m,1), & 
             !ice                      tmp_th, tmp_qv, tmp_ql, tmp_qi, tmp_qse, id_check )
             !ice     else
             !ice         frac_ice_eg = qie_b(k) / max( qle_b(k) + qie_b(k), nonzero )
             !ice         frac_ice = frac_ice_au(m) + zbar * ( frac_ice_eg - frac_ice_au(m) )
             !ice         call conden( p0(k), thl_srcrs(k,m,1), qt_srcrs(k,m,1), & 
             !ice                      tmp_th, tmp_qv, tmp_ql, tmp_qi, tmp_qse, id_check, frac_ice = frac_ice )
             !ice     endif
             !ice endif
                  !f          if( id_check .eq. 1 ) then
                  !f              id_exit = .true.
                  !f              go to 333
                  !f          endif
                  ql_srcrs(k,m,1)  = tmp_ql
                  qi_srcrs(k,m,1)  = tmp_qi
                  ! Below is designed for considering the effect of homogenized mixing of all mixtures after buoyancy sorting 
                  ! on the droplet number concentration. Note that while the droplet size within cumulus updraft should be fixed
                  ! as the externally specified value, its mixture with the environmental airs, and so convective downdraft may
                  ! have different droplet size. Thus below treatment is completely correct and can be used both in the current
                  ! specific code and generalized future microphysics.    
                  ! Nov.29.2012. Below is problematic if 'tmp_l = 0' and 'tmp_ql > 0' which can happen due to the curvature of saturation
                  ! vapor pressure line. In this case, regardless whether tr_srcds(k,m,1,ixnumliq) is zero or positive, problem happens.
                  ! Thus, I return to the original formulation of fixed droplet radius as further below.    
                  ! tr_srcrs(k,m,1,ixnumliq) = tr_srcrs(k,m,1,ixnumliq) + ( tmp_ql - tmp_l ) * ( tr_srcrs(k,m,1,ixnumliq) / max( tmp_l, nonzero ) )
                  ! tr_srcrs(k,m,1,ixnumliq) = max( 0._r8, tr_srcrs(k,m,1,ixnumliq) )
                  ! tr_srcrs(k,m,1,ixnumice) = tr_srcrs(k,m,1,ixnumice) + ( tmp_qi - tmp_i ) * ( tr_srcrs(k,m,1,ixnumice) / max( tmp_i, nonzero ) )
                  ! tr_srcrs(k,m,1,ixnumice) = max( 0._r8, tr_srcrs(k,m,1,ixnumice) )
                  tr_srcrs(k,m,1,ixnumliq) = ql_srcrs(k,m,1) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_liq**3 * density_liq )
                  tr_srcrs(k,m,1,ixnumice) = qi_srcrs(k,m,1) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_ice**3 * density_ice )

                  ! -------------------------------------------------------------- !
                  ! Treatment of detrained airs purely from the convective updraft !
                  ! -------------------------------------------------------------- !
                  f_srcrs2(k,m,1)   =   zmass_up * fmix(m) * dpa(m) * eps0(m) * 2._r8 * cmf_au(m) / cmf_u(km)
                  thl_srcrs2(k,m,1) =   thl_au(m)
                  qt_srcrs2(k,m,1)  =   qt_au(m) 
                  u_srcrs2(k,m,1)   =   u_au(m)  
                  v_srcrs2(k,m,1)   =   v_au(m)  
                  do mt = 1, ncnst
                     tr_srcrs2(k,m,1,mt) = tr_au(m,mt)
                  enddo
                  ql_srcrs2(k,m,1)  = ql_au(m)
                  qi_srcrs2(k,m,1)  = qi_au(m)
                  tr_srcrs2(k,m,1,ixnumliq) = ql_srcrs2(k,m,1) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_liq**3 * density_liq )
                  tr_srcrs2(k,m,1,ixnumice) = qi_srcrs2(k,m,1) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_ice**3 * density_ice )

                  ! CHECK
                  ! if( get_nstep() .eq. 618 .and. k .eq. 1 ) then
                  !     write(6,*)
                  !     write(6,*) 'SUNGSU CHECK'
                  !     write(6,*) 'm, qt_au(m), qt_eg, zbar = ', m, qt_au(m), qt_eg, zbar
                  !     write(6,*) 'qt_au(m), qt_b, sigma_qt, alpha(m), org_src, cu_qtr(1) =', qt_au(m), qt_b, sigma_qt, alpha(m), org_src, cu_qtr(1)   
                  !     write(6,*) 'sigma_qt, sigfac, qflx, rho_b, sigma_w, sigfac * qflx  / ( rho_b * sigma_w ) =' , sigma_qt, sigfac, qflx, rho_b, sigma_w 
                  !     write(6,*)
                  ! endif
                  ! CHECK

                  ! OPTION
                  ! 1. All the non-entrained UPDRAFT airs are converted into downdraft.
                  ! 2. The properties of downdraft airs are identical to the updraft airs.
                  ! 3. Environmental airs involved in the buoyancy sorting is not converted either downdraft or detrained airs.
                  ! f_srcds(k,m,1)   =   0.5_r8 * ddel(m) * fmix(m) * dpa(m) * eps0(m) * 2._r8 * cmf_au(m) / cmf_u(km)
                  ! thl_srcds(k,m,1) =   thl_au(m)
                  ! qt_srcds(k,m,1)  =   qt_au(m)
                  ! u_srcds(k,m,1)   =   u_au(m) 
                  ! v_srcds(k,m,1)   =   v_au(m) 
                  ! f_srcrs(k,m,1)   =   0._r8
                  ! thl_srcrs(k,m,1) =   thl_au(m)
                  ! qt_srcrs(k,m,1)  =   qt_au(m)
                  ! u_srcrs(k,m,1)   =   u_au(m) 
                  ! v_srcrs(k,m,1)   =   v_au(m) 
                  ! OPTION

               enddo

               ! ---------------- !
               ! 2. Top Downdraft !
               ! ---------------- !

               ! Jul.26.2010. Since we set ybot(m)=1, this is not the source of detrained airs
               ! but only the source of top downdraft.   
               ! Apr.21.2011. Remove explicit dependency on 'ybot(m)=1' to save computation time.
               ! Nov.28.2012. Compute 'ql_srcds(k,m,2),qi_srcds(k,m,2)'.   
               !              Note that I already computed 'ql_aut(m),qi_aut(m)' with an imposement of
               !              the full consistency with the droplet number. Thus, I don't need to use
               !              subroutine conden here, which is good since I save time.

               if( nseg_det .gt. 0.5_r8 ) then
                  do m = 1, N_up(km)
                     if( ytop(m) .lt. 0.5_r8 ) then
                        ! Apr.21.2011. Remove explicit dependency on 'ybot(m)=1' to save computation time.
                        ! f_srcds(k,m,2)   =    ybot(m) * cmf_aut(m) / cmf_u(km)
                        f_srcds(k,m,2)   = cmf_aut(m) / cmf_u(km)
                        thl_srcds(k,m,2) = thl_aut(m)
                        qt_srcds(k,m,2)  =  qt_aut(m)
                        u_srcds(k,m,2)   =   u_aut(m)
                        v_srcds(k,m,2)   =   v_aut(m)
                        do mt = 1, ncnst
                           tr_srcds(k,m,2,mt) = tr_aut(m,mt)
                        enddo
                        ! Nov.28.2012. Add below two lines.
                        ql_srcds(k,m,2)  =  ql_aut(m)
                        qi_srcds(k,m,2)  =  qi_aut(m)
                        ! Apr.21.2011. Remove explicit dependency on 'ybot(m)=1' to save computation time.
                        ! f_srcrs(k,m,2)   = ( 1._r8 - ybot(m) ) * cmf_aut(m) / cmf_u(km)
                        ! thl_srcrs(k,m,2) = thl_aut(m)
                        ! qt_srcrs(k,m,2)  =  qt_aut(m)
                        ! u_srcrs(k,m,2)   =   u_aut(m)
                        ! v_srcrs(k,m,2)   =   v_aut(m)
                        ! do mt = 1, ncnst
                        !    tr_srcrs(k,m,2,mt) = tr_aut(m,mt)
                        ! enddo
                     endif
                  enddo
               endif

               ! ----------------- !
               ! 3. Area downdraft !
               ! ----------------- !

               ! Jul.26.2010. Since we set ybot(m)=1, this is not the source of detrained airs
               ! but the source of convective downdraft.   
               ! Nov.28.2012. Compute 'ql_srcds(k,m,3),qi_srcds(k,m,3)'.   
               !              Note that I already computed 'ql_aut(m),qi_aut(m)' with an imposement of
               !              the full consistency with the droplet number. Thus, I don't need to use
               !              subroutine conden here, which is good since I save time.

               if( nseg_nondet .gt. 0.5_r8 ) then

                  ! 05.Aug.2010 : Below block is commented out because it has already been 
                  ! treated above.
                  ! f_nu = max( 0._r8, cmf_u(k) * ( 1._r8 - au_max / a_u(k) ) ) / cmf_u(k)
                  ! if( a_u(k) .gt. au_max ) then
                  !     a_u(k) = min( a_u(k), au_max )
                  !     cmf_u(k) = cmf_u(k) * ( 1._r8 - f_nu )
                  !     cmf_u_dia(k) = cmf_u_dia(k) * ( 1._r8 - f_nu )   
                  ! endif

                  do m = 1, N_up(km)
                     if( ytop(m) .gt. 0.5_r8 ) then
                        ! 05.Aug.2010 : Below line f_srcds(k,m,3) is commented out 
                        ! because it has already been computed above.
                        ! f_srcds(k,m,3)   = ybot(m) * f_nu * cmf_aut(m) / cmf_u(km)  
                        thl_srcds(k,m,3) = thl_aut(m)
                        qt_srcds(k,m,3)  =  qt_aut(m)
                        u_srcds(k,m,3)   =   u_aut(m)
                        v_srcds(k,m,3)   =   v_aut(m)
                        do mt = 1, ncnst
                           tr_srcds(k,m,3,mt) = tr_aut(m,mt)
                        enddo
                        ! Nov.28.2012. Add below two lines.
                        ql_srcds(k,m,3)  =  ql_aut(m)
                        qi_srcds(k,m,3)  =  qi_aut(m)
                        ! 05.Aug.2010 : Below line f_srcrs(k,m,3) is commented out 
                        ! because it has already been computed above.
                        ! Apr.21.2011. Also, remove explicit dependency on 'ybot(m)=1' to save computation time.
                        ! f_srcrs(k,m,3)   = ( 1._r8 - ybot(m) ) * f_nu * cmf_aut(m) / cmf_u(km)
                        ! thl_srcrs(k,m,3) = thl_aut(m)
                        ! qt_srcrs(k,m,3)  =  qt_aut(m)
                        ! u_srcrs(k,m,3)   =   u_aut(m)
                        ! v_srcrs(k,m,3)   =   v_aut(m)
                        ! do mt = 1, ncnst
                        !    tr_srcrs(k,m,3,mt) = tr_aut(m,mt)
                        ! enddo                     
                     endif
                  enddo
               endif

               ! ----------------------------------------------------------------------- !
               ! Mass-flux weighted average of 3 sources of downdraft and 1 detrained    !
               ! airs originated from the convective updrafts.                           !
               ! Jul.15.2010. Since I set ybot(m)=1, only ids=1 has non-zero mass flux   !
               ! of detrained remaining airs.                                            !
               ! ----------------------------------------------------------------------- !

               do m = 1, N_up(km)
                  do ids = 1, 3
                     if( f_srcds(k,m,ids) .gt. nonzero ) then
                        f_srcd(k)   =   f_srcd(k) + f_srcds(k,m,ids) 
                        thl_srcd(k) = thl_srcd(k) + f_srcds(k,m,ids) * thl_srcds(k,m,ids)
                        qt_srcd(k)  =  qt_srcd(k) + f_srcds(k,m,ids) *  qt_srcds(k,m,ids)
                        u_srcd(k)   =   u_srcd(k) + f_srcds(k,m,ids) *   u_srcds(k,m,ids)
                        v_srcd(k)   =   v_srcd(k) + f_srcds(k,m,ids) *   v_srcds(k,m,ids)
                        do mt = 1, ncnst
                           tr_srcd(k,mt) = tr_srcd(k,mt) + f_srcds(k,m,ids) * tr_srcds(k,m,ids,mt) 
                        enddo
                        ! Nov.28.2012. Add below two lines. Note that all individual 'ql_srcds' is fully consistent with the
                        !              corresponding droplet number at this stage. The same is true for ice.
                        ql_srcd(k)  =  ql_srcd(k) + f_srcds(k,m,ids) *  ql_srcds(k,m,ids)
                        qi_srcd(k)  =  qi_srcd(k) + f_srcds(k,m,ids) *  qi_srcds(k,m,ids)
                     endif
                     if( f_srcrs(k,m,ids) .gt. nonzero ) then
                        f_srcr(k)   =   f_srcr(k) + f_srcrs(k,m,ids) 
                        thl_srcr(k) = thl_srcr(k) + f_srcrs(k,m,ids) * thl_srcrs(k,m,ids)
                        qt_srcr(k)  =  qt_srcr(k) + f_srcrs(k,m,ids) *  qt_srcrs(k,m,ids)
                        u_srcr(k)   =   u_srcr(k) + f_srcrs(k,m,ids) *   u_srcrs(k,m,ids)
                        v_srcr(k)   =   v_srcr(k) + f_srcrs(k,m,ids) *   v_srcrs(k,m,ids)
                        ! Apr.21.2011. While mixing detrainment of updraft occurs at the base interface, it is good to relocate
                        !              the detrained condensate to the layer mid-point since for organization at the next time
                        !              step, we are assuming that all detrained airs are layer-mean values. Note also that
                        !              my curent approach considering individual 'ql,qi' from individual detrained airs
                        !              explicitly consider inhomogeneity of detrained airs, which is good.
                        !              So, I changed 'ps0(km)' to 'p0(k)' in the below 'conden' subroutine. 
                        !              This modification is exactly consistent with corresponding modification of downdraft.  
                        ! Nov.28.2012. All of 'ql_srcrs, qi_srcrs, tr_srcrs(k,m,ids,ixnumliq),tr_srcrs(k,m,ids,ixnumice)' are
                        !              computed in a fully consisteny way above for detrained updraft, i.e., ids = 1. 
                        !              For the other cases of 'ids = 2,3' this block is not performed due to the condition of
                        !              of 'if( f_srcrs(k,m,ids) .gt. nonzero )'. Thus, I commented out 'call conden' in the
                        !              below and used 'ql_srcrs(k,m,ids),qi_srcrs(k,m,ids)' instead of 'ql,qi'.
                        !! call conden( ps0(km), thl_srcrs(k,m,ids), qt_srcrs(k,m,ids), th, qv, ql, qi, qse, id_check )
                        ! call conden( p0(k),   thl_srcrs(k,m,ids), qt_srcrs(k,m,ids), th, qv, ql, qi, qse, id_check )
                        ! if( id_check .eq. 1 ) then
                        !     id_exit = .true.
                        !     go to 333
                        ! endif
                        ql_srcr(k)  =  ql_srcr(k) + f_srcrs(k,m,ids) * ql_srcrs(k,m,ids)
                        qi_srcr(k)  =  qi_srcr(k) + f_srcrs(k,m,ids) * qi_srcrs(k,m,ids)
                        do mt = 1, ncnst
                           tr_srcr(k,mt) = tr_srcr(k,mt) + f_srcrs(k,m,ids) * tr_srcrs(k,m,ids,mt)
                        enddo
                     endif
                     ! --------------------------------------------------------------- !
                     ! Treatment of detrained airs purely from the convective updrafts !
                     ! --------------------------------------------------------------- !
                     if( f_srcrs2(k,m,ids) .gt. nonzero ) then
                        f_srcr2(k)   =   f_srcr2(k) + f_srcrs2(k,m,ids) 
                        thl_srcr2(k) = thl_srcr2(k) + f_srcrs2(k,m,ids) * thl_srcrs2(k,m,ids)
                        qt_srcr2(k)  =  qt_srcr2(k) + f_srcrs2(k,m,ids) *  qt_srcrs2(k,m,ids)
                        u_srcr2(k)   =   u_srcr2(k) + f_srcrs2(k,m,ids) *   u_srcrs2(k,m,ids)
                        v_srcr2(k)   =   v_srcr2(k) + f_srcrs2(k,m,ids) *   v_srcrs2(k,m,ids)
                        ql_srcr2(k)  =  ql_srcr2(k) + f_srcrs2(k,m,ids) *  ql_srcrs2(k,m,ids)
                        qi_srcr2(k)  =  qi_srcr2(k) + f_srcrs2(k,m,ids) *  qi_srcrs2(k,m,ids)
                        do mt = 1, ncnst
                           tr_srcr2(k,mt) = tr_srcr2(k,mt) + f_srcrs2(k,m,ids) * tr_srcrs2(k,m,ids,mt)
                        enddo
                     endif
                  enddo

                  ! CHECK
                  ! write(6,*)
                  ! write(6,*) 'UNICON: 3 Sources of Convective Downdrafts in Each Layer'
                  ! write(6,*) 'Layer and Segment Indices : ', k, m
                  ! write(6,*) 'f_srcds(k,m,1), f_srcds(k,m,2), f_srcds(k,m,3) * cmf_u(km) = ', 
                  !             f_srcds(k,m,1) * cmf_u(km), f_srcds(k,m,2) * cmf_u(km), f_srcds(k,m,3) * cmf_u(km)
                  ! write(6,*) 'thl_srcds(k,m,1), thl_srcds(k,m,2), thl_srcds(k,m,3) = ', 
                  !             thl_srcds(k,m,1), thl_srcds(k,m,2), thl_srcds(k,m,3)
                  ! write(6,*) 'qt_srcds(k,m,1), qt_srcds(k,m,2), qt_srcds(k,m,3) = ', 
                  !             qt_srcds(k,m,1), qt_srcds(k,m,2), qt_srcds(k,m,3)
                  ! write(6,*) 'u_srcds(k,m,1), u_srcds(k,m,2), u_srcds(k,m,3) = ', 
                  !             u_srcds(k,m,1), u_srcds(k,m,2), u_srcds(k,m,3)
                  ! write(6,*) 'v_srcds(k,m,1), v_srcds(k,m,2), v_srcds(k,m,3) = ', 
                  !             v_srcds(k,m,1), v_srcds(k,m,2), v_srcds(k,m,3)
                  ! write(6,*)
                  ! CHECK

               enddo

               ! Nov.28.2012. Add 'ql_srcd,qi_srcd' in the below blocks.

               if( f_srcd(k) .gt. nonzero ) then  
                  thl_srcd(k) = thl_srcd(k) / f_srcd(k)
                  qt_srcd(k)  =  qt_srcd(k) / f_srcd(k)
                  u_srcd(k)   =   u_srcd(k) / f_srcd(k)
                  v_srcd(k)   =   v_srcd(k) / f_srcd(k)
                  do mt = 1, ncnst
                     tr_srcd(k,mt) = tr_srcd(k,mt) / f_srcd(k)
                  enddo
                  ql_srcd(k)  =  ql_srcd(k) / f_srcd(k)
                  qi_srcd(k)  =  qi_srcd(k) / f_srcd(k)
               else
                  f_srcd(k)   = 0._r8
                  thl_srcd(k) = 0._r8
                  qt_srcd(k)  = 0._r8
                  u_srcd(k)   = 0._r8
                  v_srcd(k)   = 0._r8
                  do mt = 1, ncnst
                     tr_srcd(k,mt) = 0._r8
                  enddo
                  ql_srcd(k)  = 0._r8
                  qi_srcd(k)  = 0._r8
               endif
               if( f_srcr(k) .gt. nonzero ) then  
                  thl_srcr(k) =  thl_srcr(k) / f_srcr(k)
                  qt_srcr(k)  =   qt_srcr(k) / f_srcr(k)
                  u_srcr(k)   =    u_srcr(k) / f_srcr(k)
                  v_srcr(k)   =    v_srcr(k) / f_srcr(k)
                  ql_srcr(k)  =   ql_srcr(k) / f_srcr(k)
                  qi_srcr(k)  =   qi_srcr(k) / f_srcr(k)
                  do mt = 1, ncnst
                     tr_srcr(k,mt) = tr_srcr(k,mt) / f_srcr(k)
                  enddo
               else
                  f_srcr(k)   = 0._r8
                  thl_srcr(k) = 0._r8
                  qt_srcr(k)  = 0._r8
                  u_srcr(k)   = 0._r8
                  v_srcr(k)   = 0._r8
                  ql_srcr(k)  = 0._r8
                  qi_srcr(k)  = 0._r8
                  do mt = 1, ncnst
                     tr_srcr(k,mt) = 0._r8
                  enddo
               endif
               ! ------------------------------------------------------------- !
               ! Treatment of detrained air purely from the convective updraft !
               ! ------------------------------------------------------------- !
               if( f_srcr2(k) .gt. nonzero ) then  
                  thl_srcr2(k) =  thl_srcr2(k) / f_srcr2(k)
                  qt_srcr2(k)  =   qt_srcr2(k) / f_srcr2(k)
                  u_srcr2(k)   =    u_srcr2(k) / f_srcr2(k)
                  v_srcr2(k)   =    v_srcr2(k) / f_srcr2(k)
                  ql_srcr2(k)  =   ql_srcr2(k) / f_srcr2(k)
                  qi_srcr2(k)  =   qi_srcr2(k) / f_srcr2(k)
                  do mt = 1, ncnst
                     tr_srcr2(k,mt) = tr_srcr2(k,mt) / f_srcr2(k)
                  enddo
               else
                  f_srcr2(k)   = 0._r8
                  thl_srcr2(k) = 0._r8
                  qt_srcr2(k)  = 0._r8
                  u_srcr2(k)   = 0._r8
                  v_srcr2(k)   = 0._r8
                  ql_srcr2(k)  = 0._r8
                  qi_srcr2(k)  = 0._r8
                  do mt = 1, ncnst
                     tr_srcr2(k,mt) = 0._r8
                  enddo
               endif

               ! CHECK
               ! write(6,*)
               ! write(6,*) 'UNICON: Mean Properties of 3 Sources of Convective Downdrafts and 1 Detrained Air in Each Layer'
               ! write(6,*) 'Layer Index : ', k
               ! write(6,*) 'f_srcd(k) * cmf_u(km),  f_srcr(k) * cmf_u(km) = ', 
               !             f_srcd(k) * cmf_u(km),  f_srcr(k) * cmf_u(km)
               ! write(6,*) 'thl_srcd(k),  thl_srcr(k)  = ', 
               !             thl_srcd(k),  thl_srcr(k)
               ! write(6,*) 'qt_srcd(k),  qt_srcr(k)  = ', 
               !             qt_srcd(k),  qt_srcr(k)
               ! write(6,*) 'u_srcd(k),  u_srcr(k)  = ', 
               !             u_srcd(k),  u_srcr(k)
               ! write(6,*) 'v_srcd(k),  v_srcr(k)  = ', 
               !             v_srcd(k),  v_srcr(k)
               ! write(6,*) 'ql_srcr(k),  qi_srcr(k)  = ', 
               !             ql_srcr(k),  qi_srcr(k)
               ! write(6,*)
               ! CHECK

               ! --------------------------------------------------------------------------- !
               ! Allocation of detrained source airs from convective updraft into new arrays !
               ! --------------------------------------------------------------------------- !

               cmf_ru(k)  =     f_srcr(k) * cmf_u(km)
               thl_ru(k)  =   thl_srcr(k)
               qt_ru(k)   =    qt_srcr(k)
               u_ru(k)    =     u_srcr(k)
               v_ru(k)    =     v_srcr(k)
               ql_ru(k)   =    ql_srcr(k)  
               qi_ru(k)   =    qi_srcr(k)
               do mt = 1, ncnst
                  tr_ru(k,mt) = tr_srcr(k,mt)           
               enddo

               ! ------------------------------------------------------------- !
               ! Treatment of detrained air purely from the convective updraft !
               ! ------------------------------------------------------------- !

               cmf_ru2(k)  =     f_srcr2(k) * cmf_u(km)
               thl_ru2(k)  =   thl_srcr2(k)
               qt_ru2(k)   =    qt_srcr2(k)
               u_ru2(k)    =     u_srcr2(k)
               v_ru2(k)    =     v_srcr2(k)
               ql_ru2(k)   =    ql_srcr2(k)  
               qi_ru2(k)   =    qi_srcr2(k)
               do mt = 1, ncnst
                  tr_ru2(k,mt) = tr_srcr2(k,mt)           
               enddo
               
               ! CHECK
               ! if( get_nstep() .ge. 13 .and. get_nstep() .le. 15 .and. k .eq. 4  ) then
               !     write(6,*)
               !     write(6,*) 'UNICON: Mean properties of detrained airs from updraft in each layer'
               !     write(6,*) 'Time and Layer index = ', get_nstep(), k
               !     write(6,*) 'cmf_ru   = ', cmf_ru(k)
               !     write(6,*) 'nl_ru = ', 0.000001_r8*tr_ru(k,ixnumliq)
               !     write(6,*)
               ! endif
               ! CHECK 

               ! CHECK
               ! write(6,*)
               ! write(6,*) 'UNICON: Mean properties of detrained air from updraft in each layer'
               ! write(6,*) 'Cumulus Top and Layer index = ', ktop, k
               ! write(6,*) 'cmf_ru   = ', cmf_ru(k)
               ! write(6,*) 'thl_ru   = ', thl_ru(k)
               ! write(6,*) 'qt_ru    = ', qt_ru(k)
               ! write(6,*) 'u_ru     = ', u_ru(k) 
               ! write(6,*) 'v_ru     = ', v_ru(k)
               ! write(6,*) 'ql_ru    = ', ql_ru(k)
               ! write(6,*) 'qi_ru    = ', qi_ru(k)
               ! write(6,*)
               ! CHECK

               ! ----- !
               ! Debug !
               ! ----- ! 

               ! if( get_nstep() .eq. 845 .and. lchnk .eq. 557 .and. ( i .eq. 11 .or. i .eq. 12 ) .and. ( k .eq. 10 .or. k .eq. 11 .or. k .eq. 12 ) ) then
               !     write(6,*)  
               !     write(6,*) 'DEBUG UNICON -DOWNDRAFT, i, k = ', i, k
               !     write(6,*)
               !     do m = 1, N_up(km)         
               !        write(6,*) ' k, m, f_srcds(k,m,1), f_srcds(k,m,2), f_srcds(k,m,3)           = ', k, m, f_srcds(k,m,1), f_srcds(k,m,2), f_srcds(k,m,3) 
               !        write(6,*) ' k, m, eps(m), del(m), dpa(m) * abs( eps(m) - del(m) ), fmix(m) = ', k, m, eps(m), del(m), dpa(m) * abs( eps(m) - del(m) ), fmix(m)  
               !        write(6,*) ' k, m, ybot(m), f_nu, f_wu(m), cmf_aut(m), cmf_u(km)            = ', k, m, ybot(m), f_nu, f_wu(m), cmf_aut(m), cmf_u(km)
               !        write(6,*) ' k, m, zmass, fmix(m), dpa(m), eps0(m),  cmf_au(m)              = ', k, m, zmass, fmix(m), dpa(m), eps0(m),  cmf_au(m)
               !        write(6,*) ' k, m, dp0(k), rho_b                                            = ', k, m, dp0(k), rho_b 
               !     enddo
               ! endif

               ! ----- !
               ! Debug !
               ! ----- ! 

               ! ---------------------------------------------------------------------- !
               ! Compute 'cloud fraction' and 'in-cloud LWC,IWC' at the layer mid-point !
               ! for individual updraft segment.                                        ! 
               ! Note that 'ktop_msfc', 'ptop_msfc', 'ztop_msfc' should be printed out  !
               ! at the output side of vertical 'k' loop - that is, it should be        !
               ! printed-out where 'cushavg' is computed.                               !
               ! Sep.15.2011. All the other conservative scalars too for defining       !
               !              mixing environmental airs associated organization later.  !
               ! ---------------------------------------------------------------------- !
 
               ! Apr.21.2011. Below 'am_u,qlm_u,qim_u' are used in the radiation scheme.
               !              In addition, 'am_u' is used for computing evaporation of 
               !              convective precipitation within environment. 
               !              So, I precisely computed them, especially with consideration of 
               !              vertical partial fillness of cumulus in the cumulus top layer by
               !              multiplying 'dpa(m)/dp_m'.

               do m = 1, N_up(km)
                  msfc = msfc_from_m(k,m)
                  am_u_msfc(k,msfc)         =  0.5_r8 * (     a_au(m) +     a_aut(m) ) * ( dpa(m) / dp_m )
                  qlm_u_msfc(k,msfc)        =  0.5_r8 * (    ql_au(m) +    ql_aut(m) ) * ( dpa(m) / dp_m )
                  qim_u_msfc(k,msfc)        =  0.5_r8 * (    qi_au(m) +    qi_aut(m) ) * ( dpa(m) / dp_m )
                  thlm_u_msfc(k,msfc)       =  0.5_r8 * (   thl_au(m) +   thl_aut(m) ) * ( dpa(m) / dp_m )
                  qtm_u_msfc(k,msfc)        =  0.5_r8 * (    qt_au(m) +    qt_aut(m) ) * ( dpa(m) / dp_m )
                  um_u_msfc(k,msfc)         =  0.5_r8 * (     u_au(m) +     u_aut(m) ) * ( dpa(m) / dp_m )
                  vm_u_msfc(k,msfc)         =  0.5_r8 * (     v_au(m) +     v_aut(m) ) * ( dpa(m) / dp_m )
                  do mt = 1, ncnst
                     trm_u_msfc(k,msfc,mt)  =  0.5_r8 * ( tr_au(m,mt) + tr_aut(m,mt) ) * ( dpa(m) / dp_m )
                  enddo
                  am_u(k)        =     am_u(k) +  am_u_msfc(k,msfc)
                  qlm_u(k)       =    qlm_u(k) +  am_u_msfc(k,msfc) *    qlm_u_msfc(k,msfc)
                  qim_u(k)       =    qim_u(k) +  am_u_msfc(k,msfc) *    qim_u_msfc(k,msfc)
                  thlm_u(k)      =   thlm_u(k) +  am_u_msfc(k,msfc) *   thlm_u_msfc(k,msfc)
                  qtm_u(k)       =    qtm_u(k) +  am_u_msfc(k,msfc) *    qtm_u_msfc(k,msfc)
                  um_u(k)        =     um_u(k) +  am_u_msfc(k,msfc) *     um_u_msfc(k,msfc)
                  vm_u(k)        =     vm_u(k) +  am_u_msfc(k,msfc) *     vm_u_msfc(k,msfc)
                  do mt = 1, ncnst
                     trm_u(k,mt) = trm_u(k,mt) +  am_u_msfc(k,msfc) * trm_u_msfc(k,msfc,mt)
                  enddo
               enddo
               if( am_u(k) .gt. nonzero ) then
                  qlm_u(k)       =    qlm_u(k) / am_u(k)
                  qim_u(k)       =    qim_u(k) / am_u(k)
                  thlm_u(k)      =   thlm_u(k) / am_u(k)
                  qtm_u(k)       =    qtm_u(k) / am_u(k)
                  um_u(k)        =     um_u(k) / am_u(k)
                  vm_u(k)        =     vm_u(k) / am_u(k)
                  do mt = 1, ncnst
                     trm_u(k,mt) = trm_u(k,mt) / am_u(k)
                  enddo
               else
                  ! Sep.16.2011. Below is not anomaly but total field. Thus, in order to reduce any 
                  !              potential bias grow later, I entered grid-mean value instead of zero.
                  qlm_u(k)       =      0._r8 
                  qim_u(k)       =      0._r8 
                  thlm_u(k)      =    thl0(k)
                  qtm_u(k)       =     qt0(k) 
                  um_u(k)        =      u0(k) 
                  vm_u(k)        =      v0(k)
                  do mt = 1, ncnst
                     trm_u(k,mt) =  tr0(k,mt)
                  enddo
               endif

               ! ----------------------------------------------------------------------------- !
               ! Jul.26.2011.                                                                  !
               ! Save all the convective updraft properties at each model interface and at the ! 
               ! cumulus top ( i.e., in the cumulus top layer in each 'm' segment, the value   !
               ! at the cumulus top not the value at the top interface of cumulus top layer is !
               ! saved ) for future use. For example, this can be used as alternative mixing   !
               ! environmental value for convective downdraft.                                 !
               ! Note that at the cumulus top, I set 'w_aut(m)=0, cmf_aut(m)>0' and            !
               ! 'a_aut(m) = a_au(m), num_aut(m) = num_au(m), rad_aut(m) = rad_au(m)'.         !  
               ! ----------------------------------------------------------------------------- !

               do m = 1, N_up(km)
                  msfc = msfc_from_m(k,m)
                  thl_u_msfc(k,msfc)           =   thl_aut(m)
                  qt_u_msfc(k,msfc)            =    qt_aut(m)       
                  u_u_msfc(k,msfc)             =     u_aut(m)       
                  v_u_msfc(k,msfc)             =     v_aut(m)       
                  w_u_msfc(k,msfc)             =     w_aut(m)       
                  ql_u_msfc(k,msfc)            =    ql_aut(m)
                  qi_u_msfc(k,msfc)            =    qi_aut(m)
                  do mt = 1, ncnst
                     tr_u_msfc(k,msfc,mt)      = tr_aut(m,mt)
                  enddo
                  cmf_u_msfc(k,msfc)           =   cmf_aut(m)
                  a_u_msfc(k,msfc)             =     a_aut(m)
                  num_u_msfc(k,msfc)           =   num_aut(m)
                  rad_u_msfc(k,msfc)           =   rad_aut(m)
                  if( k .eq. 1 ) then
                     thl_u_msfc(km,msfc)      =    thl_au(m)
                     qt_u_msfc(km,msfc)       =     qt_au(m)       
                     u_u_msfc(km,msfc)        =      u_au(m)       
                     v_u_msfc(km,msfc)        =      v_au(m)       
                     w_u_msfc(km,msfc)        =      w_au(m)       
                     ql_u_msfc(km,msfc)       =     ql_au(m)
                     qi_u_msfc(km,msfc)       =     qi_au(m)
                     do mt = 1, ncnst
                        tr_u_msfc(km,msfc,mt) =  tr_au(m,mt)
                     enddo
                     cmf_u_msfc(km,msfc)      =    cmf_au(m)
                     a_u_msfc(km,msfc)        =      a_au(m)
                     num_u_msfc(km,msfc)      =    num_au(m)
                     rad_u_msfc(km,msfc)      =    rad_au(m)
                  endif
               enddo

               ! -------------------------------------------------------------------- !
               ! Re-allocate updraft segment values for computation in the next layer !
               ! Assign the array only to the non-detached updraft.                   !
               ! Mar.12.2013. Add 'S_b_ql_au(mm),S_b_qi_au(mm)' parts.                ! 
               ! -------------------------------------------------------------------- !

               mm = 0 
               do m = 1, N_up(km)
                  if( ytop(m) .gt. 0.5_r8 ) then
                     mm = mm + 1
                     cmf_au(mm) = cmf_aut(m)
                     a_au(mm)   =   a_aut(m)
                     num_au(mm) = num_aut(m)
                     rad_au(mm) = rad_aut(m)
                     thl_au(mm) = thl_aut(m)
                     qt_au(mm)  =  qt_aut(m)
                     u_au(mm)   =   u_aut(m)
                     v_au(mm)   =   v_aut(m)
                     w_au(mm)   =   w_aut(m)
                     ql_au(mm)  =  ql_aut(m)
                     qi_au(mm)  =  qi_aut(m)
                     thv_au(mm) = thv_aut(m)
                     do mt = 1, ncnst
                        tr_au(mm,mt) = tr_aut(m,mt)    
                     enddo
                     S_b_ql_au(mm) =  S_t_ql_au(m)
                     S_b_qi_au(mm) =  S_t_qi_au(m)
                !ice frac_ice_au(mm) = frac_ice_aut(m) 
                  endif
               enddo

               ! -------------------------------------------------- !
               ! Save updraft buoyancy sorting level for future use !
               ! -------------------------------------------------- !

               pes(k) = pe

               ! -------------------------- !
               ! Identify Cumulus Top Layer !
               ! -------------------------- !

               if( nseg_nondet .lt. 0.5_r8 ) then
                  ktop = k
                  cnt  = real(k,r8)
                  ! --------------------------------------------------------------------------------- !
                  ! Aug.02.2011. It seems to be more reasonable to set cnb  = real(0,r8) instead of 1 !
                  !              This should be done later.                                           !
                  ! --------------------------------------------------------------------------------- ! 
                  cnb  = real(1,r8)
                  cush_mxen(iter) = pblhz 
                  do mm = 1, N_up(ktop-1)
                     cush_mxen(iter) = max( cush_mxen(iter), ztops(ktop,mm) )
                  enddo
                  goto 50
               endif

            enddo ! k = 1, mkx - 1. Here, 'k' is a layer index.

50          continue

            ! ------------------------------------------------------ !
            ! Assign updraft top layer index to 'ktop_mxen' variable !
            ! ------------------------------------------------------ !

            ktop_mxen(iter) = ktop

            ! --------------------------------------------------------------------- !
            ! Compute mean-cumulus top height weighted by updraft mass flux         !
            ! at surface. This quantity will be used for computing cridis_in        !
            ! at the next time step instead of cush.                                !
            ! Sep.22.2011. Note that 'Pmu(m)' does not include the 'delta_w_PBL'.   !
            !              However, since 'delta_w_PBL' is added uniformly all over !
            !              the 'm' segments, below computation of 'cushavg_mxen' is !
            !              completely correct. Note that below block is the only    !
            !              part of the whole program to explicitly use the 'Pmu'    !
            !              except the computation of 'cmf_au(m)' at surface.        !  
            ! Sep.21.2011. Now, by re-defining 'Pmu(m)' above, below computation of !
            !              cushavg_mxen is perfectly correct                        !
            !              without any modification.                                !
            ! --------------------------------------------------------------------- !

            tmp1                  = 0._r8 
            cushavg_mxen(iter)    = 0._r8
            do m = 1, nseg
               tmp1               = tmp1               + Pmu(m)
               cushavg_mxen(iter) = cushavg_mxen(iter) + ztop_msfc(m) * Pmu(m)
            enddo
            cushavg_mxen(iter)    = max( cushavg_mxen(iter) / tmp1, pblhz )
                    
            ! CHECK
            ! write(6,*)
            ! write(6,*) 'UNICON: Cumulus Top Layer, cush, cushavg'
            ! write(6,*) 'Top Layer Index : ', ktop, cush_out, cushavg_out 
            ! write(6,*)
            ! CHECK

            ! ------------------------------------------------------------------------------------------------------ !
            ! Apr.25.2012.                                                                                           !
            ! Compute the location (x_um_msfc(k,msfc),y_um_msfc(k,msfc) in unit of [m]) of convective updraft center ! 
            ! at the layer mid-point relative to the convective updraft center at surface                            !
            ! using the profiles of (u,v,w) of convective updraft.                                                   !
            ! Note that 'u_u_msfc, v_u_msfc, w_u_msfc' in the k = ktop_msfc is defined at the cumulus                !
            ! top not at the top interface. Thus, my below computation is perfectly correct.                         !
            ! ------------------------------------------------------------------------------------------------------ ! 

            !? Below block is computed later, so that this is not necessary anymore here.
            !? Note that the parts using 'x_um_msfc(k,msfc), y_um_msfc(k,msfc)' will be computed later, too
            !? so that removing below block is completely OK.

            !?    do msfc = 1, nseg
            !?       tmpx_bot = 0._r8
            !?       tmpy_bot = 0._r8
            !?    do k = 1, ktop_msfc(msfc)  ! This is a layer index 
            !?       km = k - 1
            !?       if( k .eq. ktop_msfc(msfc) ) then
            !?           tmp3 = ztop_msfc(msfc) - zs0(km)
            !?       else
            !?           tmp3 = dz0(k)
            !?       endif
            !?       tmp1 = tmp3 / ( 0.5_r8 * ( w_u_msfc(k,msfc) + w_u_msfc(km,msfc) ) )
            !?       tmpx_top = tmpx_bot + 0.5_r8 * ( u_u_msfc(k,msfc) - u_u_msfc(km,msfc) ) * tmp1
            !?       tmpy_top = tmpy_bot + 0.5_r8 * ( v_u_msfc(k,msfc) - v_u_msfc(km,msfc) ) * tmp1 
            !?       x_um_msfc(k,msfc) = 0.5_r8 * ( tmpx_bot + tmpx_top )
            !?       y_um_msfc(k,msfc) = 0.5_r8 * ( tmpy_bot + tmpy_top )
            !?       tmpx_bot = tmpx_top
            !?       tmpy_bot = tmpy_top
            !?    end do
            !?    end do

            ! --------------------------------------------------------------------- !
            ! Compute precipitation flux at the model interface before evaporations !
            ! within downdraft and environment.                                     !
            ! Also compute precipitation area at each interface for use to compute  !
            ! evaporation within downdraft later.                                   !                 
            ! The best way is to include snow melting here such that evaporation    !
            ! within downdraft as well as environment is performed on the melted    !
            ! precipitation. Thus, I perform snow melting here. Once snow melting   !
            ! is performed here, we don't need to perform snow melting later -      !
            ! snow melting later will not do anything: it will be redundant but no  !
            ! harm.                                                                 !           
            ! --------------------------------------------------------------------- ! 

            !? Below block is computed later, so that this is not necessary anymore here.
            !? Note that we unify all precipitation flux variables into a single 'flxrain_msfc(km,msfc),flxsnow_msfc(km,msfc)'
            !? and the other precipitation flux variables are not used any more.
            !? Thus, without any problem, I can clearly remove entire below block.
            !? Note also that corresponding tracer flux computation is also fully upgraded later into the
            !? computation of flxtrrs_bot_upee(mt). 

            !?      do msfc = 1, nseg
            !?         rainflx = 0._r8
            !?         snowflx = 0._r8
            !?         do mt = 1, ncnst
            !?            trrsflx(mt) = 0._r8
            !?         enddo
            !?       ! Apr.25.2012.
            !?         tmpx = 0._r8
            !?         tmpy = 0._r8
            !?         tmpw = 0._r8
            !?       ! Apr.25.2012.
            !?      do k = ktop_msfc(msfc), 1, -1  ! This is a layer index 
            !?         km = k - 1
            !?       ! m = m_from_msfc(k,msfc)
            !?         tmp1 = ( dp0(k) / g ) * qrten_u_msfc(k,msfc)
            !?         tmp2 = ( dp0(k) / g ) * qsten_u_msfc(k,msfc)
            !?       ! Apr.25.2012.
            !?       ! Note that 'x_um_msfc, y_um_msfc' are defined at the layer mid-point except in the 'ktop' layer
            !?       ! where it is defined at the mid-height of cumulus updraft.
            !?       ! The location of precipitation area at the base interface in each layer is assumed to be identical 
            !?       ! to the location of cumulus updraft at the layer mid-point since precipitation flux at the base 
            !?       ! interface is the sum of precipitation production in the layer.
            !?         if( k .eq. ktop_msfc(msfc) ) then
            !?             tmp3 = ztop_msfc(msfc) - zs0(km)
            !?         else
            !?             tmp3 = dz0(k)
            !?         endif
            !?         tmpx = tmpx * exp( -dz0(k) / zscale_evap ) + ( tmp1 + tmp2 ) * exp( -tmp3 / zscale_evap ) * x_um_msfc(k,msfc)
            !?         tmpy = tmpy * exp( -dz0(k) / zscale_evap ) + ( tmp1 + tmp2 ) * exp( -tmp3 / zscale_evap ) * y_um_msfc(k,msfc)
            !?         tmpw = tmpw * exp( -dz0(k) / zscale_evap ) + ( tmp1 + tmp2 ) * exp( -tmp3 / zscale_evap )
            !?       ! Apr.25.2012.
            !?         rainflx = rainflx + tmp1
            !?         snowflx = snowflx + tmp2
            !?       ! Nov.29.2012. Using below two lines, I can compute tracer concentration within precipitation flux at the base interface
            !?       !              before evaporation, i.e., 'flxrain_prevp_msfc(km,msfc), flxsnow_prevp_msfc(km,msfc)'. This information of
            !?       !              tracer concentration within precipitation flux will be used to compute the increase of tracer concentration
            !?       !              within convective downdraft during the evaporation of precipitation within convective downdraft later.     
            !?       !              Note that I should use 'dptr0(k,mt)' instead of 'dp0(k)' for tracers.
            !?       ! Dec.01.2012. Number concentration of precipitating droplets are treated separately using the specified droplet size.
            !?       !              Below do block is commented out since it will be computed below after snow melting. 
            !?       !              This is OK since snow melting does not change tracer concentration within precipitation other than droplet number.
            !?       ! do mt = 1, ncnst
            !?       !    if( mt .eq. ixnumliq ) then
            !?       !        trrsflx(mt) = rainflx * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_rain**3 * density_rain )                    
            !?       !     elseif( mt .eq. ixnumice ) then
            !?       !        trrsflx(mt) = snowflx * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_snow**3 * density_snow )                    
            !?       !    else
            !?       !        trrsflx(mt) = trrsflx(mt) + ( dptr0(k,mt) / g ) * trrsten_u_msfc(k,msfc,mt)
            !?       !    endif
            !?       ! enddo
            !?       ! Use environmental mean temperature t0(k) instead of downdraft temperature
            !?       ! for simplicity. This is a totally reasonable treatment.
            !?       ! Note that below formula assumes that 'unity'[%] of downward snowflx is converted into
            !?       ! rainflx at the base interface. In fact, we can use any number between 0 and 1
            !?       ! instead of 'unity' below.
            !?       ! Apr.26.2011. Add option to treat snow melting (1) before evaporation within downdraft ( default )
            !?       !              or (2) after evaporation within downdraft. 
            !?       !              Note that the shortage of 'i_snowmlt .eq. 0' does not allow evaporation of snwo within downdraft,
            !?       !              while 'i_snowmlt .eq. 1' can generate non-zero snow flux at surface even though temperature is
            !?       !              large. Thus, the first default option seems to be more attractable, but I am keeping both 
            !?       !              functionality available as an option. 
            !?         if( t0(k) .ge. 273.15_r8 ) then
            !?             if( i_snowmlt .eq. 0 ) then
            !?                 snowmlt_e_msfc(k,msfc) = max( 0._r8, unity * snowflx * g / dp0(k) )
            !?             else
            !?                 snowmlt_e_msfc(k,msfc) = 0._r8
            !?             endif
            !?           ! Mar.01.2011. Below two are new, correct preventing negative precipitation. 
            !?             rainflx      = max( 0._r8, rainflx + snowmlt_e_msfc(k,msfc) * dp0(k) / g )
            !?             snowflx      = max( 0._r8, snowflx - snowmlt_e_msfc(k,msfc) * dp0(k) / g )
            !?           ! Below two are previous incomplete, producing negative precipitation, rain.
            !?           ! rainflx      = rainflx + snowflx
            !?           ! snowflx      = 0._r8  
            !?         else
            !?             snowmlt_e_msfc(k,msfc) = 0._r8
            !?         endif
            !?         flxrain_prevp_msfc(km,msfc) = rainflx
            !?         flxsnow_prevp_msfc(km,msfc) = snowflx
            !?         flxrain_ava_msfc(km,msfc)   = flxrain_prevp_msfc(km,msfc)
            !?         flxsnow_ava_msfc(km,msfc)   = flxsnow_prevp_msfc(km,msfc)
            !?       ! Nov.29.2012. Dec.01.2012. Since snow melting changes droplet number within precipitation, I should perform updated 
            !?       !              computation of droplet number.
            !?       ! Dec.13.2012. Add separate treatment of 'ixcldliq,ixcldice' in the below 'trrsflx' variables.
            !?         do mt = 1, ncnst
            !?            if( mt .eq. ixcldliq ) then
            !?                trrsflx(mt) = rainflx
            !?            elseif( mt .eq. ixcldice ) then
            !?                trrsflx(mt) = snowflx
            !?            elseif( mt .eq. ixnumliq ) then
            !?                trrsflx(mt) = rainflx * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_rain**3 * density_rain )                    
            !?            elseif( mt .eq. ixnumice ) then
            !?                trrsflx(mt) = snowflx * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_snow**3 * density_snow )                    
            !?            else
            !?                trrsflx(mt) = trrsflx(mt) + ( dptr0(k,mt) / g ) * trrsten_u_msfc(k,msfc,mt)
            !?            endif
            !?            flxtrrs_prevp_msfc(km,msfc,mt) = trrsflx(mt)
            !?            flxtrrs_ava_msfc(km,msfc,mt)   = flxtrrs_prevp_msfc(km,msfc,mt)
            !?         enddo
            !?       ! Aug.15.2011. I checked that positive rainflx and snowflx are always guaranteed except
            !?       !              very rare snowflx ~ -1.e-300. So, I removed below if block which is
            !?       !              completely safe.  
            !?       ! if( rainflx .lt. 0._r8 .or. snowflx .lt. 0._r8 ) then
            !?       !     write(6,*)  k, msfc, flxrain_prevp_msfc(km,msfc), flxsnow_prevp_msfc(km,msfc)
            !?       !     call endrun('UNICON : Negative premitive precipitation flux for a certain updraft segment before evp. within downdraft')
            !?       ! endif 
            !?         ! ---------------------------------------------------------------------------- !
            !?         ! Compute 'various updraft fractional areas at the layer mid-point' and        !
            !?         ! the 'precipitation area at each interface' for each original updraft segment ! 
            !?         ! before evaporation within downdraft and environment.                         !
            !?         ! ---------------------------------------------------------------------------- !
            !?         am_up_msfc(k,msfc) = am_u_msfc(k,msfc)
            !?         am_us_msfc(k,msfc) = am_u_msfc(k,msfc)
            !?         if( ( qrten_u_msfc(k,msfc) + qsten_u_msfc(k,msfc) ) .le. 0._r8 ) am_up_msfc(k,msfc) = 0._r8
            !?         if( ( qlm_u_msfc(k,msfc)   +   qim_u_msfc(k,msfc) ) .le. 0._r8 ) am_us_msfc(k,msfc) = 0._r8
            !?         if( i_ovp .eq. 0 ) then
            !?             a_ovp    = ( 1._r8 - beta1 ) * min( a_p_prevp_msfc(k,msfc),  am_up_msfc(k,msfc) ) + & 
            !?                                  beta1   * max( a_p_prevp_msfc(k,msfc) + am_up_msfc(k,msfc) - 1._r8, 0._r8 )
            !?         elseif( i_ovp .eq. 1 ) then         
            !?           ! Apr.25.2012.
            !?           ! Compute overlapping area between precipitation area at the top interace and 
            !?           ! precipitating updraft fractional area at the layer mid-point.
            !?           ! Note that 'num_u_msfc(km,msfc)' is height-independent constant from the surface to the cumulus top.
            !?             a_ovp = area_overlap( x_p_msfc(k,msfc),  y_p_msfc(k,msfc),  a_p_prevp_msfc(k,msfc), & 
            !?                                   x_um_msfc(k,msfc), y_um_msfc(k,msfc), am_up_msfc(k,msfc),     &
            !?                                   num_u_msfc(0,msfc) )
            !?         endif
            !?         a_p_prevp_msfc(km,msfc) = a_p_prevp_msfc(k,msfc) + am_up_msfc(k,msfc) - a_ovp
            !?         a_p_prevp_msfc(km,msfc) = max( 0._r8, min( 1._r8, a_p_prevp_msfc(km,msfc) ) )

            !?       ! Apr.25.2012.
            !?       ! Compute the center location of ensemble precipitation areas at the base interface.
            !?       ! Note that 'x_p_msfc,y_p_msfc' are defined at the model interface.
            !?       ! If there is no precipitation at all (i.e., tmpw = 0, tmpx = 0, tmpy = 0), it becomes
            !?       ! that x_p_msfc(km,msfc) = y_p_msfc(km,msfc) = 0 and they are perfectly OK since for
            !?       ! this case, precipitation area becomes zero from the above equation. 
            !?         x_p_msfc(km,msfc) = tmpx / max( nonzero, tmpw )
            !?         y_p_msfc(km,msfc) = tmpy / max( nonzero, tmpw )
            !?       ! Apr.25.2012.

            !?       ! CHECK
            !?       ! write(6,*)
            !?       ! write(6,*) 'UNICON: Precipitation flux at the base interface before evaporation within downdraft'
            !?       ! write(6,*) 'Cumulus Top Layer and Layer Index = ', ktop, k
            !?       ! write(6,*) 'flxrain_prevp_msfc(',km,msfc,')  = ', flxrain_prevp_msfc(km,msfc)
            !?       ! write(6,*) 'flxsnow_prevp_msfc(',km,msfc,')  = ', flxsnow_prevp_msfc(km,msfc) 
            !?       ! write(6,*)
            !?       ! CHECK

            !?      end do
            !?      end do

            ! -------------------------------------------------------------------------------------------------------------------- !
            ! Nov.03.2012. REFINEMENT IS NECESSARY FOR TREATING ACCRETION OF CLOUD DROPLETS.                                       !
            !              The iteration loop for computing accretion of cloud droplet will end here.                              !
            ! -------------------------------------------------------------------------------------------------------------------- !

            ! ------------------------------------------- !
            ! Compute segment-summed grid-mean quantities !
            ! ------------------------------------------- !

            !?    do msfc = 1, nseg

            !?       do k = ktop_msfc(msfc), 1, -1                           ! This is a layer index 
            !?          snowmlt_e(k) = snowmlt_e(k) + snowmlt_e_msfc(k,msfc)
            !?          am_up(k)     = am_up(k)     + am_up_msfc(k,msfc)
            !?          am_us(k)     = am_us(k)     + am_us_msfc(k,msfc)
            !?       enddo

            !?       do k = ktop_msfc(msfc), 0, -1                           ! This is an interface index 
            !?          flxrain_prevp(k) = flxrain_prevp(k) + flxrain_prevp_msfc(k,msfc) 
            !?          flxsnow_prevp(k) = flxsnow_prevp(k) + flxsnow_prevp_msfc(k,msfc) 
            !?          a_p_prevp(k)     = a_p_prevp(k)     + a_p_prevp_msfc(k,msfc)
            !?        ! Nov.29.2012
            !?          do mt = 1, ncnst
            !?             flxtrrs_prevp(k,mt) = flxtrrs_prevp(k,mt) + flxtrrs_prevp_msfc(k,msfc,mt) 
            !?          enddo
            !?       enddo
            
            !?    enddo

            ! ------------------------------------------- !
            !                                             !
            ! Vertical Evolution of Individual Downdrafts !
            !                                             !
            ! ------------------------------------------- !                

            ! Jul.13.2011. Below 'rbuoy_dn = rbuoy_max' assumes that downdraft plume radius is small, which is
            !              fully consistent with somewhat large setting of 'epsz_dn = delz_dn' of convective
            !              downdraft, which is critical to obtain reasonable properties of detrained downdraft
            !              airs ( e.g., cu_qtr > 0, cu_thlr < 0 ) in the lowest model layer.   

            rbuoy_dn = 0.5_r8 * ( rbuoy_min + rbuoy_max ) 
            ! rbuoy_dn = rbuoy_max 

            do msfc = 1, nseg                         ! This 'msfc' is updraft segment index at surface.

               ! -------------------------------------------------------------------------- !
               ! Initialization of Downdraft Sources in Each Layer for Each Updraft Segment !
               ! Mar.11.2013. Add initialization of evaporation rate at the top interface.  ! 
               ! -------------------------------------------------------------------------- !
  
               cmf_d_src(1:mkx,1:3)        = 0._r8
               thl_d_src(1:mkx,1:3)        = 0._r8
               qt_d_src(1:mkx,1:3)         = 0._r8
               u_d_src(1:mkx,1:3)          = 0._r8
               v_d_src(1:mkx,1:3)          = 0._r8
               w_d_src(1:mkx,1:3)          = 0._r8
               tr_d_src(1:mkx,1:3,1:ncnst) = 0._r8
               ql_d_src(1:mkx,1:3)         = 0._r8 
               qi_d_src(1:mkx,1:3)         = 0._r8
               fevp1_t_rate_src(1:mkx,1:3) = 0._r8
               fevp2_t_rate_src(1:mkx,1:3) = 0._r8
               ix_d_src(1:mkx,1:3)         = 0

               ! ------------------------------------------------------------------------- !
               ! Initialization to compute evaporation of precipitation within environment !
               ! ------------------------------------------------------------------------- !
               !?       evpint_rain = 0._r8
               !?       evpint_snow = 0._r8
               !?       do mt = 1, ncnst
               !?          evpint_trrs(mt) = 0._r8
               !?       enddo
               ! ------------------------------------------------------------------------------------------ !
               ! Initialization to compute the center location of precipitation area at the base interface. !
               ! ------------------------------------------------------------------------------------------ !
               !o       tmpx = 0._r8
               !o       tmpy = 0._r8
               !o       tmpw = 0._r8
               ! ------------------------------------------------------------------------------------------------------- !
               ! Compute the location (x_um_msfc(k,msfc),y_um_msfc(k,msfc) in unit of [m]) of convective updraft center  !
               ! at the layer mid-point relative to the convective updraft center at surface                             !
               ! using the profiles of (u,v,w) of convective updraft.                                                    !
               ! Note that 'u_u_msfc, v_u_msfc, w_u_msfc' in the k = ktop_msfc is defined at the cumulus                 !
               ! top not at the top interface. Thus, my below computation is perfectly correct.                          !
               ! Note that this computation goes from the bottom to the cumulus top layer, so that I should use separate !
               ! vertical loop here from the lowest to the cumulus top layer.                                            !
               ! ------------------------------------------------------------------------------------------------------- !
               tmpx_bot = 0._r8
               tmpy_bot = 0._r8
               do k = 1, ktop_msfc(msfc)  ! This is a layer index
                  km = k - 1
                  if( k .eq. ktop_msfc(msfc) ) then
                     tmp3 = ztop_msfc(msfc) - zs0(km)
                  else
                     tmp3 = dz0(k)
                  endif
                  tmp1 = tmp3 / ( 0.5_r8 * ( w_u_msfc(k,msfc) + w_u_msfc(km,msfc) ) )
                  tmpx_top = tmpx_bot + 0.5_r8 * ( u_u_msfc(k,msfc) - u_u_msfc(km,msfc) ) * tmp1
                  tmpy_top = tmpy_bot + 0.5_r8 * ( v_u_msfc(k,msfc) - v_u_msfc(km,msfc) ) * tmp1
                  x_um_msfc(k,msfc) = 0.5_r8 * ( tmpx_bot + tmpx_top )
                  y_um_msfc(k,msfc) = 0.5_r8 * ( tmpy_bot + tmpy_top )
                  tmpx_bot = tmpx_top
                  tmpy_bot = tmpy_top
               end do

               ! --------------------------------------------------- !
               !                                                     ! 
               ! Start of Downdraft Vertical Evolution in Each Layer !
               !                                                     !
               ! --------------------------------------------------- !  

               do k   =  ktop_msfc(msfc), 1, -1                     ! This 'k' is a layer index where vertical evolution of downdraft is computed.

                  km  =  k - 1

                  ! ---------------------------------------------------------------------------------------------------- !
                  ! Define non-array 'rain/snow/tracer fluxes at the top interface for use in various computations below !
                  ! both for 'grid-mean' and 'in-precipitation-area' values.                                             !
                  ! ---------------------------------------------------------------------------------------------------- !

                  flxrain_top    = flxrain_msfc(k,msfc)
                  flxsnow_top    = flxsnow_msfc(k,msfc)
                  flxrasn_top    = flxrain_top + flxsnow_top

                  flxrain_top_in = flxrain_top / max( nonzero, a_p_msfc(k,msfc) )
                  flxsnow_top_in = flxsnow_top / max( nonzero, a_p_msfc(k,msfc) )
                  flxrasn_top_in = flxrain_top_in + flxsnow_top_in

                  do mt = 1, ncnst
                     if( mt .eq. ixcldliq ) then
                        flxtrrs_top(mt) = flxrain_top
                     elseif( mt .eq. ixcldice ) then
                        flxtrrs_top(mt) = flxsnow_top
                     elseif( mt .eq. ixnumliq ) then
                        flxtrrs_top(mt) = flxrain_top * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_rain**3 * density_rain )
                     elseif( mt .eq. ixnumice ) then
                        flxtrrs_top(mt) = flxsnow_top * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_snow**3 * density_snow )
                     else
                        flxtrrs_top(mt) = flxtrrs_msfc(k,msfc,mt)
                     endif
                     flxtrrs_top_in(mt) = flxtrrs_top(mt) / max( nonzero, a_p_msfc(k,msfc) )
                  enddo

                  ! -------------------------------------------------------------------------------------------- !
                  ! Compute various areas to compute                                                             !
                  !  1. Production  of convective precipitation by accretion within convective updraft           !
                  !  2. Evaporation of convective precipitation within environment                               !
                  ! Below simply assumes that downdraft fractional area is zero for this purpose ( a_pd = 0. ).  !
                  ! In order to compute accretion rate, we should use                                            ! 
                  !       (a) a_pu : Overlapping area between precipitation area ( a_p_msfc(k,msfc) ) and        !
                  !                  saturated updraft fractional area ( am_us_msfc(k,msfc) ),                   !
                  !       (b) flxrain_top_in, flxsnow_top_in : Precipitation flux averaged over the              !
                  !                  precipitation area (not the grid-mean) at the top interface,                !
                  !       (c) qlm_u_msfc(k,msfc), qim_u_msfc(k,msfc), trm_u_msfc(k,msfc,mt) :                    !
                  !                  In-cumulus properties.                                                      !
                  ! Note 'a_p = a_pu + a_pd + a_pr + a_ps' and independent precipitation approximation is used,  !
                  ! so that in computing these overlapping areas, we really don't need to worry about the other  !
                  ! cumulus updraft segment' contribution.                                                       !     
                  !                                                                                              !
                  ! Feb.09.2013. In computing 'a_pu' below, change 'am_us_msfc' to 'am_u_msfc' since evaporation !
                  !              of precipitation is computed within the subroutine 'prod_prep_up' above.        !
                  !              Thus, here, we should only consider what is happening within environment and    !
                  !              downdraft, not within updraft regardless whether updraft is saturated or not.   !                                              
                  ! -------------------------------------------------------------------------------------------- !

                  am_e(k) = 1._r8 - am_u(k)
                  am_s(k) = ast0(k)
                  if( ( am_u(k) + ast0(k) ) .gt. 1._r8 ) am_s(k) = 1._r8 - am_u(k)
                  am_r(k) = 1._r8 - am_u(k) - am_s(k)

                  am_us_msfc(k,msfc) = am_u_msfc(k,msfc)
                  if( ( qlm_u_msfc(k,msfc) + qim_u_msfc(k,msfc) ) .le. 0._r8 ) am_us_msfc(k,msfc) = 0._r8

                  a_pu  = area_overlap( x_p_msfc(k,msfc),  y_p_msfc(k,msfc),  a_p_msfc(k,msfc),   &
                     !j   x_um_msfc(k,msfc), y_um_msfc(k,msfc), am_u_msfc(k,msfc),  &
                          x_um_msfc(k,msfc), y_um_msfc(k,msfc), am_us_msfc(k,msfc), &
                          num_u_msfc(0,msfc) )
                  a_pd  = 0._r8
                  a_pr  = ( a_p_msfc(k,msfc) - a_pu - a_pd ) * am_r(k) / ( am_r(k) + am_s(k) )    ! Advanced.
                  a_ps  = ( a_p_msfc(k,msfc) - a_pu - a_pd ) * am_s(k) / ( am_r(k) + am_s(k) )    ! Advanced.
                  a_evp = a_pr

                  am_evp_msfc(k,msfc) = a_evp
                  am_pu_msfc(k,msfc)  = a_pu
                  am_pd_msfc(k,msfc)  = a_pd
                  am_pr_msfc(k,msfc)  = a_pr
                  am_ps_msfc(k,msfc)  = a_ps

                  ! --------------------------------------------------------------------------------------------------------------------- !
                  ! Compute                                                                                                               !
                  ! Precipitation flux at the base interface by adding precipitation production and evaporation within updraft.           !
                  ! Note that until the full 2-moment microphysics are implemented, I will assume a fixed droplet size of rain and snow.  !
                  ! Note that evaporation within updraft may cause negative precipitation flux. Thus, in order to prevent negative        !
                  ! precipitation flux, I should add corrective precipitation production tendency here.                                   ! 
                  ! --------------------------------------------------------------------------------------------------------------------- !

                  !j       flxrain_bot_up = flxrain_top + qrten_u_msfc(k,msfc) * ( dp0(k) / g )
                  !j       flxsnow_bot_up = flxsnow_top + qsten_u_msfc(k,msfc) * ( dp0(k) / g )

                  !j       do mt = 1, ncnst
                  !j          if( mt .eq. ixcldliq ) then
                  !j              flxtrrs_bot_up(mt) = flxrain_bot_up
                  !j          elseif( mt .eq. ixcldice ) then
                  !j              flxtrrs_bot_up(mt) = flxsnow_bot_up
                  !j          elseif( mt .eq. ixnumliq ) then
                  !j              flxtrrs_bot_up(mt) = flxrain_bot_up * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_rain**3 * density_rain )
                  !j          elseif( mt .eq. ixnumice ) then
                  !j              flxtrrs_bot_up(mt) = flxsnow_bot_up * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_snow**3 * density_snow )
                  !j          else
                  !j              flxtrrs_bot_up(mt) = flxtrrs_top(mt) + trrsten_u_msfc(k,msfc,mt) * ( dptr0(k,mt) / g )
                  !j          endif
                  !j       enddo

                  ! ------------------------------------------------------------------------------------ !
                  ! Feb.09.2013.                                                                         !
                  ! If 'flxrain_bot < 0', add corrective precipitation production tendency in that layer !
                  ! by directly converting grid-mean water vapor into precipitation production in that   !
                  ! layer.                                                                               !
                  ! ------------------------------------------------------------------------------------ !

                  !j       if( flxrain_bot_up .lt. 0._r8 ) then 
                  !j           cvp_rainprd_msfc(k,msfc) = - flxrain_bot_up * ( g / dp0(k) ) ! [ kg / kg / s ]
                  !j           flxrain_bot_up           = 0._r8
                  !j       endif
                  !j       if( flxsnow_bot_up .lt. 0._r8 ) then 
                  !j           cvp_snowprd_msfc(k,msfc) = - flxsnow_bot_up * ( g / dp0(k) ) ! [ kg / kg / s ]
                  !j           flxsnow_bot_up           = 0._r8
                  !j       endif
                  !j       do mt = 1, ncnst
                  !j          if( flxtrrs_bot_up(mt) .lt. 0._r8 ) then 
                  !j              cvp_trrsprd_msfc(k,msfc,mt) = - flxtrrs_bot_up(mt) * ( g / dp0(k) ) ! [ # / kg / s, kg / kg / s ]
                  !j              flxtrrs_bot_up(mt)          = 0._r8
                  !j          endif           
                  !j       enddo

                  ! ------------------------------------------------------------------------------------------------------------------------------------- !
                  ! Compute 'rain/snow production rate within updraft by accretion ( qrten_acc_u_msfc(k,msfc), qsten_acc_u_msfc(k,msfc) >= 0. [kg/kg/s] ) !
                  ! Note that this will change in-cumulus properties ( qlm_u_msfc(k,msfc), qim_u_msfc(k,msfc), trm_u_msfc(k,msfc,mt) ), which so should   !
                  ! be updated after accretion computation below as is done below.                                                                        !
                  ! Note that production rate by auto-conversion ( qrten_acc_u_msfc(k,msfc), qsten_acc_u_msfc(k,msfc) >= 0. [kg/kg/s] ) have              !
                  ! already been computed.                                                                                                                !
                  ! Note that below 'trrsten_u_acc_msfc(k,msfc,mt)' only treats the scavenging of in-cumulus aerosols.                                    !
                  ! Scavenging of 'interstitial aerosols' should be treated by separate 'wdeptrrs' tendencies later.                                      !
                  ! Note that in-cumulus variables should be updated after accretion as shown below in the argument.                                      !
                  ! Note also that this accrestion process does not change cumulus updraft fraction area - i.e., implicitly it is assumed that it does    !
                  ! not completely remove pre-existing (after auto-conversion) in-cumulus condensate, which is completely OK.                             ! 
                  !                                                                                                                                       !
                  ! EXTREME CAUTION : Computing accretion in this way is not complete since convective updraft does not feel the effect of accretion      !
                  !                   during upward motion. Below approach will result in the conversation error. The best way is to compute accretion    !
                  !                   rate as below, and do additional computation of convective updraft using another iteration method. This iterative   !
                  !                   approach will produce the correct abd best result without conservation error. However, I will do this in future.    !
                  !                   Thus below part of accretion is simply commented out (slthough they are perfectly well and correctly coded).        ! 
                  !                                                                                                                                       !
                  ! Feb.05.2013. In order to ensure conservation of energy and moisture, accrestion rate should not be computed here but should be done   !
                  !              in the convective updraft part using the iteration. By doing that, vertical evolution of convective updraft becomes      !
                  !              exactly matches with precipitation production and precipitation flux, preserving energy and moisture. Thus, I should     !
                  !              not do anything here associated with accretion. Ths accretion should be included as a part of auto-conversion process    !
                  !              within the updraft iteration loop. However, precipitation flux generated by 'auto-conversion + accretion' will be used   !
                  !              in computing both the evaporation within the environment and convective downdrafts, which are already being done in the  !
                  !              current code without any problem.                                                                                        !
                  ! ------------------------------------------------------------------------------------------------------------------------------------- !

                  ! ---------------------------------------------------------------------------------------------------------------------- !
                  ! Compute evaporation of rain/snow within environment ( evprain_e_msfc(k,msfc), evpsnow_e_msfc(k,msfc) >= 0. [kg/kg/s] ) !
                  ! ---------------------------------------------------------------------------------------------------------------------- !

                ! Apr.15.2014. Recalculate 'qv_clr' using the normalized stratus fraction instead of using
                !              the below original formula based on physical stratus fraction.
                  call qsat( t0(k), p0(k), es, qs )
                  tmp1         = am_s(k) / ( 1._r8 - am_u(k) )
                  qv_clr       = max( nonzero, qv0(k) - tmp1 * qs ) / max( nonzero, 1._r8 - tmp1 )
                ! qv_clr       = max( nonzero, qv0(k) - am_s(k) * qs ) / max( nonzero, 1._r8 - am_s(k) )
                  qv_clr       = min( min( qv_clr, qv0(k) ), qs )
                  subsat_clr   = min( 1._r8, max( 0._r8, 1._r8 - qv_clr / max( qs, nonzero ) ) )
                  call findsp_single( qv_clr, t0(k), p0(k), tw, qw_clr, i, k, lchnk )
                  evplimit_clr = max( 0._r8, ( qw_clr - qv_clr ) / dt )

                  evprain_clr  = kevp_rain * subsat_clr * sqrt( max( 0._r8, flxrain_top_in ) )
                  evpsnow_clr  = kevp_snow * subsat_clr * sqrt( max( 0._r8, flxsnow_top_in ) )         

                  evplimit_clr_rain = flxrain_top_in * g / dp0(k) ! New. Perfect.
                  evplimit_clr_snow = flxsnow_top_in * g / dp0(k) ! New. Perfect.

                  evprain_clr       = min(  evprain_clr, evplimit_clr_rain )
                  evpsnow_clr       = min(  evpsnow_clr, evplimit_clr_snow )
                  if( ( evprain_clr + evpsnow_clr ) .lt. ( - qv0(k) / dt / max( nonzero, a_evp ) ) ) then
                     call endrun('UNICON : Impossible correction of precipitation generation')
                  endif
                  if( ( evprain_clr + evpsnow_clr ) .gt. evplimit_clr ) then
                     if( evprain_clr .ge. 0._r8 .and. evpsnow_clr .ge. 0._r8 ) then
                        tmp1 = evprain_clr * evplimit_clr / ( evprain_clr + evpsnow_clr )
                        tmp2 = evpsnow_clr * evplimit_clr / ( evprain_clr + evpsnow_clr )
                        evprain_clr = tmp1
                        evpsnow_clr = tmp2
                     elseif( evprain_clr .lt. 0._r8 ) then
                        evpsnow_clr = evplimit_clr - evprain_clr
                     elseif( evpsnow_clr .lt. 0._r8 ) then
                        evprain_clr = evplimit_clr - evpsnow_clr
                     else
                        call endrun('UNICON : Impossible case in Limit 1a')
                     endif
                  endif

                  evprain_e_msfc(k,msfc)  = evprain_clr * a_evp
                  evpsnow_e_msfc(k,msfc)  = evpsnow_clr * a_evp
                  do mt = 1, ncnst
                     if( mt .eq. ixcldliq ) then
                        evptrrs_e_msfc(k,msfc,mt) = - evprain_e_msfc(k,msfc)
                     elseif( mt .eq. ixcldice ) then
                        evptrrs_e_msfc(k,msfc,mt) = - evpsnow_e_msfc(k,msfc)
                     elseif( mt .eq. ixnumliq ) then
                        evptrrs_e_msfc(k,msfc,mt) = - evprain_e_msfc(k,msfc) * 3._r8 / &
                                                    ( 4._r8 * 3.141592_r8 * droprad_rain**3 * density_rain )
                     elseif( mt .eq. ixnumice ) then
                        evptrrs_e_msfc(k,msfc,mt) = - evpsnow_e_msfc(k,msfc) * 3._r8 / &
                                                    ( 4._r8 * 3.141592_r8 * droprad_snow**3 * density_snow )
                     else
                        evptrrs_e_msfc(k,msfc,mt) = - flxtrrs_top(mt) * ( ( evprain_e_msfc(k,msfc) + &
                                                    evpsnow_e_msfc(k,msfc) ) / max( flxrasn_top, nonzero ) )
                     endif
                  enddo

                  ! ------------------------------------------------------------------------------------ !
                  ! Compute wet deposition of aerosols within denvironment.                              ! 
                  ! Feb.05.2013. Below wet deposition tendency within updraft should be updated later    !
                  !              possibly, in combination with the treatment of accretion process.       !
                  !              Note that wet deposition only influences tracers not cloud condensate.  !
                  !              If I turn-on this in future, wet deposition by convective precipitation !
                  !              in the separate wet deposition routine should be turned-off.            !
                  ! ------------------------------------------------------------------------------------ !

                  do mt = 1, ncnst
                     if( mt .eq. 1 .or. mt .eq. ixcldliq .or. mt .eq. ixcldice .or. mt .eq. ixnumliq .or. mt .eq. ixnumice ) then
                        wdeptrrs_e_msfc(k,msfc,mt) = 0._r8
                     else
                        wdeptrrs_e_msfc(k,msfc,mt) = 0._r8
                     endif
                  enddo

                  ! --------------------------------------------------------------------------------- !
                  ! Compute                                                                           !
                  ! Precipitation flux at the base interface by adding evaporation within environment !
                  ! Note that until the full 2-moment microphysics are implemented, I will            !
                  ! assume a fixed droplet size of rain and snow.                                     !
                  ! Note that wet deposition does not affect condensate but only influences tracers.  !
                  ! Mar.05.2013. For computing the location of precipitation area (x_p, y_p) at the   ! 
                  !              base interface and for diagnostic purpose, compute                   !
                  !              the 'flxrain(snow)_bot_up' and 'flxrain(snow)_bot_ee'.               !   
                  !              Note that it is guaranteed that 'flxrain(snow)_bot_ee >= 0'          !
                  !              since 'evprain(snow)_e_msfc' were computed from 'flxrain_top_in'     !
                  !              which is perfectly good.                                             ! 
                  ! --------------------------------------------------------------------------------- !

                  !k       flxrain_bot_upee = flxrain_bot_up - evprain_e_msfc(k,msfc) * ( dp0(k) / g )
                  !k       flxsnow_bot_upee = flxsnow_bot_up - evpsnow_e_msfc(k,msfc) * ( dp0(k) / g )

                  flxrain_bot_up   = flxrain_top +   qrten_u_msfc(k,msfc) * ( dp0(k) / g )
                  flxsnow_bot_up   = flxsnow_top +   qsten_u_msfc(k,msfc) * ( dp0(k) / g )

                  flxrain_bot_ee   = flxrain_top - evprain_e_msfc(k,msfc) * ( dp0(k) / g )
                  flxsnow_bot_ee   = flxsnow_top - evpsnow_e_msfc(k,msfc) * ( dp0(k) / g )

                  flxrain_bot_upee = flxrain_top + ( qrten_u_msfc(k,msfc) - evprain_e_msfc(k,msfc) ) * ( dp0(k) / g )
                  flxsnow_bot_upee = flxsnow_top + ( qsten_u_msfc(k,msfc) - evpsnow_e_msfc(k,msfc) ) * ( dp0(k) / g )

                  do mt = 1, ncnst
                     if( mt .eq. ixcldliq ) then
                        flxtrrs_bot_upee(mt) = flxrain_bot_upee
                     elseif( mt .eq. ixcldice ) then
                        flxtrrs_bot_upee(mt) = flxsnow_bot_upee
                     elseif( mt .eq. ixnumliq ) then
                        flxtrrs_bot_upee(mt) = flxrain_bot_upee * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_rain**3 * density_rain )
                     elseif( mt .eq. ixnumice ) then
                        flxtrrs_bot_upee(mt) = flxsnow_bot_upee * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_snow**3 * density_snow )
                     else
                        !k              flxtrrs_bot_upee(mt) = flxtrrs_bot_up(mt) + ( evptrrs_e_msfc(k,msfc,mt) + wdeptrrs_e_msfc(k,msfc,mt) ) * ( dptr0(k,mt) / g )
                        flxtrrs_bot_upee(mt) = flxtrrs_top(mt) + ( trrsten_u_msfc(k,msfc,mt) + evptrrs_e_msfc(k,msfc,mt) + &
                                               wdeptrrs_e_msfc(k,msfc,mt) ) * ( dptr0(k,mt) / g )
                     endif
                  enddo

                  ! ------------------------------------------------------------------------------------------------------- !
                  ! Snow Melting at the Base Interface ( snowmlt_e_msfc(k,msfc) >= 0. [kg/kg/s] )                           !
                  ! Since snow melting changes droplet number within precipitation, I should perform updated computation of ! 
                  ! droplet numbers and mass of precipitation.                                                              !
                  ! Note that below assume that snow melting does not change the other tracers concentration as expected.   !
                  ! ------------------------------------------------------------------------------------------------------- !

                  if( t0(k) .ge. 273.15_r8 ) then
                     snowmlt_e_msfc(k,msfc) = max( 0._r8, unity * flxsnow_bot_upee * g / dp0(k) )
                  else
                     snowmlt_e_msfc(k,msfc) = 0._r8
                  endif
                  do mt = 1, ncnst
                     if( mt .eq. ixcldliq ) then
                        smlttrrs_e_msfc(k,msfc,mt) =   snowmlt_e_msfc(k,msfc)
                     elseif( mt .eq. ixcldice ) then
                        smlttrrs_e_msfc(k,msfc,mt) = - snowmlt_e_msfc(k,msfc)
                     elseif( mt .eq. ixnumliq ) then
                        smlttrrs_e_msfc(k,msfc,mt) =   snowmlt_e_msfc(k,msfc) * 3._r8 / ( 4._r8 * 3.141592_r8 * &
                                                       droprad_rain**3 * density_rain )
                     elseif( mt .eq. ixnumice ) then
                        smlttrrs_e_msfc(k,msfc,mt) = - snowmlt_e_msfc(k,msfc) * 3._r8 / ( 4._r8 * 3.141592_r8 * &
                                                       droprad_snow**3 * density_snow )
                     else
                        smlttrrs_e_msfc(k,msfc,mt) = 0._r8
                     endif
                  enddo
                  flxrain_bot_upeesm = max( 0._r8, flxrain_bot_upee + snowmlt_e_msfc(k,msfc) * dp0(k) / g )
                  flxsnow_bot_upeesm = max( 0._r8, flxsnow_bot_upee - snowmlt_e_msfc(k,msfc) * dp0(k) / g )
                  do mt = 1, ncnst
                     if( mt .eq. ixcldliq ) then
                        flxtrrs_bot_upeesm(mt) = flxrain_bot_upeesm
                     elseif( mt .eq. ixcldice ) then
                        flxtrrs_bot_upeesm(mt) = flxsnow_bot_upeesm
                     elseif( mt .eq. ixnumliq ) then
                        flxtrrs_bot_upeesm(mt) = flxrain_bot_upeesm * 3._r8 / ( 4._r8 * 3.141592_r8 * &
                                                 droprad_rain**3 * density_rain )
                     elseif( mt .eq. ixnumice ) then
                        flxtrrs_bot_upeesm(mt) = flxsnow_bot_upeesm * 3._r8 / ( 4._r8 * 3.141592_r8 * &
                                                 droprad_snow**3 * density_snow )
                     else
                        flxtrrs_bot_upeesm(mt) = flxtrrs_bot_upee(mt) 
                     endif
                  enddo

                  ! ---------------------------------------------------------------------------------------------------------------------- !
                  ! Compute precipitation area at the base interface ( a_p_msfc(km,msfc) )                                                 !
                  ! While 'the location of the center of precipitation area ( x_p_msfc(km,msfc), y_p_msfc(km,msfc) )' are computed later   !
                  ! after doing evaporation of precipitation within downdraft, I should compute 'a_p_msfc(km,msfc)' here before            !
                  ! computing evaporation of precipitation within downdraft since that computation requires                                !
                  ! the use of 'a_p_msfc(km,msfc)'. This is completely correct approach assuming that evaporation                          !
                  ! within downdraft at the base interface does not completely evaporate 'flxrain_bot_upeesm', which is                    !
                  ! grauanteed by setting 'eta2' smaller than 1.                                                                           !
                  ! ---------------------------------------------------------------------------------------------------------------------- !

                  am_up_msfc(k,msfc) = am_u_msfc(k,msfc)
                  if( ( qrten_u_msfc(k,msfc) + qsten_u_msfc(k,msfc) ) .le. 0._r8 ) am_up_msfc(k,msfc) = 0._r8
                  a_ovp = area_overlap( x_p_msfc(k,msfc),  y_p_msfc(k,msfc),  a_p_msfc(k,msfc),   &
                     x_um_msfc(k,msfc), y_um_msfc(k,msfc), am_up_msfc(k,msfc), &
                     num_u_msfc(0,msfc) )
                  if( ( flxrasn_top_in - nonzero ) .le. ( evprain_clr + evpsnow_clr ) * dp0(k) / g ) then
                     a_p_msfc(km,msfc) = a_p_msfc(k,msfc) - a_evp + am_up_msfc(k,msfc) - a_ovp
                  else
                     a_p_msfc(km,msfc) = a_p_msfc(k,msfc) + am_up_msfc(k,msfc) - a_ovp
                  endif
                  if( ( flxrain_bot_upeesm + flxsnow_bot_upeesm ) .le. 0._r8 ) a_p_msfc(km,msfc) = 0._r8
                  a_p_msfc(km,msfc) = max( 0._r8, min( 1._r8, a_p_msfc(km,msfc) ) )

                  !k       n_prep : # of precipitation segment at the top interface.
                  !k       a_ovp = 0._r8
                  !k       do i_prep = n_prep
                  !k          a_ovp = a_ovp + area_overlap( x_pi_msfc(i_prep,k,msfc), y_pi_msfc(i_prep,k,msfc), & 
                  !k                                        a_pi_msfc(i_prep,k,msfc), r_pi_msfc(i_prep,k,msfc), &
                  !k                                               x_um_msfc(k,msfc),        y_um_msfc(k,msfc), &
                  !k                                              am_up_msfc(k,msfc),       num_u_msfc(0,msfc) )
                  !k       enddo

                  ! ---------------------------------------------------------------------------------------------- !
                  ! Initialize                                                                                     !
                  !                                                                                                !
                  !    flxrain_bot = flxrain_bot_upeesm                                                            !   
                  !    flxsnow_bot = flxsnow_bot_upeesm                                                            !
                  !                                                                                                ! 
                  ! where the final precipitation fluxes ( flxrain_bot, flxsnow_bot ) will be continuously updated !
                  ! within the individual downdraft loop ( do ks = ktop, k, -1, do ids = 1, 3 ) below, eventually  !
                  ! getting the final precipitation flux at the bottom interface.                                  ! 
                  ! ---------------------------------------------------------------------------------------------- !

                  flxrain_bot = flxrain_bot_upeesm
                  flxsnow_bot = flxsnow_bot_upeesm
                  do mt = 1, ncnst
                     flxtrrs_bot(mt) = flxtrrs_bot_upeesm(mt) 
                  enddo

                  ! ------------------------------------------------------- !
                  ! Define downdraft sources generated in the current layer !
                  ! ------------------------------------------------------- !

                  do ids  = 1, 3   ! This 'ids' is the type of downdraft source ( 1 : Mixing downdraft, 2 : Top downdraft, 3 : Constraint downdraft )
                     ! ----------------------------------------------------------------------------------------------------------------- !
                     ! m_from_msfc(k,msfc) : Convert updraft segment index at surface into shortened-updraft segment index in each layer !
                     !                       Since computation is done from k = 'ktop = ktop_msfc(msfc)' to 'k = 1' for each 'msfc',     !
                     !                       it is always grauanteed that 'm' is a positive integer ( m > 0 ). Thus, below computation   !
                     !                       is perfectly OK - if not, it will stop due to indexing error.                               !
                     ! Be careful : I should use index 'k' not 'ks' in the below block since in this case index 'k' denotes source layer !
                     ! ----------------------------------------------------------------------------------------------------------------- !
                     m                = m_from_msfc(k,msfc)
                     ix_d_src(k,ids)  = 1  
                     cmf_d_src(k,ids) = f_srcds(k,m,ids) * cmf_u(km)
                     thl_d_src(k,ids) = thl_srcds(k,m,ids)
                     qt_d_src(k,ids)  = qt_srcds(k,m,ids) 
                     u_d_src(k,ids)   = u_srcds(k,m,ids) 
                     v_d_src(k,ids)   = v_srcds(k,m,ids) 
                     w_d_src(k,ids)   = 0._r8
                     do mt = 1, ncnst
                        tr_d_src(k,ids,mt) = tr_srcds(k,m,ids,mt) 
                     enddo
                     ql_d_src(k,ids)  = ql_srcds(k,m,ids) 
                     qi_d_src(k,ids)  = qi_srcds(k,m,ids) 
                     ! ---------------------------------------------------------------------------------------------- !
                     ! Mar.11.2013. Add initialization of evaporation rate at the top interface                       !
                     !              Since below two variables are already initialized to zero above,                  !
                     !              below initialization is redundant. However, for clearness of the model structure, ! 
                     !              let's initialize again - it is no harm at all.                                    !
                     ! ---------------------------------------------------------------------------------------------- !
                     fevp1_t_rate_src(k,ids) = 0._r8
                     fevp2_t_rate_src(k,ids) = 0._r8
                     ! Note that I am using 'nonzero=1.e-20' instead of 'cmfmin=1.e-5' below, since downdraft sources generated 
                     ! in the current layer should go through vertical downward evolution and detrainment at the base interface
                     ! by the detrainment criteria. If I use 'cmfmin' here, those downdraft source with 'cmf_d_src < cmfmin'
                     ! cannot be detrained. 
                     if( cmf_d_src(k,ids) .lt. nonzero ) then ! No downdraft source in this layer
                        ix_d_src(k,ids)  = 0  
                        cmf_d_src(k,ids) = 0._r8
                     endif
                  enddo

                  ! ---------------------------------------------------------------------------------------------------------------- !
                  ! Compute total number of downdrafts (ndb_evp) that will be used for computating                                   !
                  ! evaporation of convective precipitation at the base interface of current layer.                                  !
                  ! Although mixing downdraft generated in the current layer ( cmf_d_src(k,1) ) will not evaporate convective        !
                  ! precipitation due to zero displacement diatance (i.e., the source level of mixing downdraft in the current layer !
                  ! is pt = ps0(km) ), I am including this contribution in computing 'ndb_evp >= 0'.                                 !
                  ! Note that ndb_evp = 0 is also possible, for example in the lowest model layer. However, in that case,            !
                  ! below constraint of 'goto 20 if ix_d_src(ks,ids) .eq. 0' will prevent division by zero within the main           !
                  ! computation part later. Thus, it is completely OK.                                                               !
                  ! Mar.18.2013. Do not perform evaporation of precipitation within 'constraint' downdraft which is a numerical not  !
                  !              physical downdraft. This removal of 'constraint' downdraft in treating evaporation may also help to !
                  !              reduce sensitivity to vertical resolution. Also neglect evaporation within 'top downdraft' since    !
                  !              geometrically, convective precipitation is below top downdraft.                                     !
                  !              removing these 'constraint' and 'top' downdrafts in doing evaporation of precipitation will also    !
                  !              help to reduce PREH20, which is extremely good.                                                     !
                  ! Mar.18.2013. In order to remove the contribution of mixing downdraft generated in the current layer, I changed   !
                  !              I changed  'do ks   = ktop_msfc(msfc), k, -1' to ' do ks   = ktop_msfc(msfc), k + 1, -1', which     !
                  !              should not do anything when 'ktop_msfc(msfc) = k' by construction.                                  ! 
                  ! ---------------------------------------------------------------------------------------------------------------- !
    
                  !y       ndb_evp = 0
                  !y       do ks   = ktop_msfc(msfc), k, -1   ! This 'ks'  is a layer index where downdraft sources are generated.
                  !y       do ids  = 1, 3                     ! This 'ids' is the type of downdraft source ( 1 : Mixing downdraft, 2 : Top downdraft, 3 : Constraint downdraft )                   
                  !y          if( ix_d_src(ks,ids) .eq. 1 ) then
                  !y              ndb_evp = ndb_evp + 1
                  !y          endif
                  !y       enddo
                  !y       enddo 

                ! Mar.17.2014. Since 'cmf_d_src(ks,1)' is the mass flux at the top interface of current 'k' layer, while
                !              the limitation of of evaporation within downdraft with 'evap_prep_dn' is imposed at the
                !              base interface, I multiplied 'tmp3' to the 'cmf_d_src(ks,1)' to compute downdraft mass
                !              flux at the base interface of curent layer, 'k'.
                !              Also note that I decided to exclude the mixing downdraft generated in the current layer 'k'
                !              by using 'ks = ktop_msfc(msfc), k + 1, -1' instead of 'ks = ktop_msfc(msfc), k, -1' since
                !              evaporation does not occur in the mixing downdraft generated in the 'k' layer. Note that
                !              this 'cmfdb_evp, ndb_evp' are used as ONLY THE LIMITER not for computing the actual 
                !              evaporation rate within the downdraft. Thus below my computation is completely correct.
                !              Note that we should only treat 'mixing downdraft', not 'top, constrained' downdrafts for
                !              treating evaporation of precipitation within downdraft. If we want to include 'top, constrained
                !              downdrafts, some portion of the codes (i.e., dz and dp in the below, and 'evap_prep_dn') should
                !              be consistently modified. 

                  ndb_evp = 0
                  cmfdb_evp = 0._r8
                  rho = 0.5_r8 * ( rho0top(k) + rho0bot(k) )
                  dz  = zs0(k) - zs0(km)
                  dp  = ps0(km) - ps0(k)
                  eps_dn = epsz_dn / ( rho * g )
                  del_dn = delz_dn / ( rho * g )
                  if( exp_cmf .eq. 1 ) then
                      tmp1 = eps_dn - del_dn
                      tmp2 = min( tmp1, log( 1._r8 + epsz0_max * dz ) / max( dp, nonzero ) )
                      if( abs( tmp2 - tmp1 ) .ge. nonzero ) then ! Constraint is imposed.
                          eps_dn = eps_dn * ( tmp2 / tmp1 ) 
                          del_dn = del_dn * ( tmp2 / tmp1 ) 
                      endif
                      tmp3 = exp( dp * ( eps_dn - del_dn ) )
                  elseif( exp_cmf .eq. 2 ) then
                      tmp3 = max( 0._r8, 1._r8 + dp * ( eps_dn - del_dn ) )
                  endif     
                  do ks   = ktop_msfc(msfc), k + 1, -1   ! This 'ks'  is a layer index where downdraft sources are generated.
                     if( ix_d_src(ks,1) .eq. 1 ) then
                         ndb_evp = ndb_evp + 1
                         cmfdb_evp = cmfdb_evp + cmf_d_src(ks,1) * tmp3
                     endif
                  enddo 

                  ! if( k .eq. ktop_msfc(msfc) .and. ndb_evp .ne. 0 ) then 
                  !     write(6,*) 
                  !     write(6,*) 'UNICON : Critical bug in computing ndb_evp'
                  !     write(6,*) 'ktop_msfc(msfc), k, ndb_evp = ', ktop_msfc(msfc), k, ndb_evp 
                  !     write(6,*)
                  ! endif 

                  ! ---------------------------------------------------------------------------------------------------- !
                  ! Compute vertical evolution of individual downdraft from the top interface (or top of each downdraft) !
                  ! to the base interface within the given layer.                                                        !
                  ! ---------------------------------------------------------------------------------------------------- !

                  do ks = ktop_msfc(msfc), k, -1        ! This 'ks'  is a layer index where downdraft sources are generated.

                     ksm  = ks - 1

                     ! ------------------------------------------------------------------------------------------- !
                     ! Convert updraft segment index at surface into shortened-updraft segment index in each layer !
                     ! ------------------------------------------------------------------------------------------- !

                     m = m_from_msfc(ks,msfc)

                     do ids = 1, 3      ! This 'ids' is the type of downdraft source ( 1 : Mixing downdraft, 2 : Top downdraft, 3 : Constraint downdraft )                   

                        ! ----------------------------------------------------------------------------------------- !
                        ! Define downdraft properties at the downdraft 'top'.                                       !
                        ! Perform downward evolution only for the surviving (existing) downdraft                    ! 
                        ! in the current layer.                                                                     !
                        ! Be careful : I should use index 'ks' not 'k' in the below block since all the source      !
                        ! variables of downdraft ( cmf_d_src(ks,ids), thl_d_src(ks,ids), ... ) are defined with the !
                        ! layer index of 'origination layer' ( 'ks' ), whose values however are continuously        !
                        ! updated in each layer as downdraft moves down into the layers below.                      !
                        ! ----------------------------------------------------------------------------------------- !
                        if( ix_d_src(ks,ids) .eq. 1 ) then
                           cmf_dt = cmf_d_src(ks,ids)
                           thl_dt = thl_d_src(ks,ids)
                           qt_dt  =  qt_d_src(ks,ids)
                           u_dt   =   u_d_src(ks,ids)
                           v_dt   =   v_d_src(ks,ids)
                           w_dt   =   w_d_src(ks,ids)
                           do mt = 1, ncnst
                              tr_dt(mt) = tr_d_src(ks,ids,mt)
                           enddo
                           ql_dt  =  ql_d_src(ks,ids)
                           qi_dt  =  qi_d_src(ks,ids)
                           ! ------------------------------------------------------------------------ !
                           ! Mar.11.2013. Add initialization of evaporation rate at the top interface ! 
                           ! ------------------------------------------------------------------------ !
                           fevp1_t_rate = fevp1_t_rate_src(ks,ids)
                           fevp2_t_rate = fevp2_t_rate_src(ks,ids)
                        else
                           cmf_d_src(ks,ids) = 0._r8
                           ix_d_src(ks,ids)  = 0
                           goto 20
                        endif
                        ! ------------------------------------------------------------------------------ !
                        ! Define mean properties at the downdraft 'top'                                  !
                        ! Here, 'top' is defined as the level where downdraft starts its downward motion !
                        ! in each layer. When 'k = ks', 'top' is defined in a different way depending on !
                        ! whether the source of downdraft is 'mixing downdraft', 'top downdraft'         !
                        ! and 'area downdraft'.                                                          !
                        ! Mar.07.2013. Define 'thv_mean_t' and 'thv_mean_b' by including updraft as well !
                        !              as environment for use in computing vertical evolution of         !
                        !              downdraft vertical velocity, simular to convective updraft.       !
                        !              Note that we are simply assuming that downdraft fractional area   !
                        !              is zero, so that only updraft information is included in          !
                        !              computing 'thv_mean_t' and 'thv_mean_b' below.                    !       
                        !              This is for developing scale-adaptive parameterization even for   !
                        !              prognostic convection scheme in future.                           !
                        !              Note we don't compute 'rho_mean_t, rho_mean_b' for simplicity.    ! 
                        ! ------------------------------------------------------------------------------ ! 
                        p_t   =     ps0(k)
                        p_b   =    ps0(km)
                        z_t   =     zs0(k)     
                        z_b   =    zs0(km)
                        thv_t = thv0top(k)
                        thv_b = thv0bot(k)
                        rho_t = rho0top(k)
                        rho_b = rho0bot(k)
                        thv_mean_t =  a_u(k) *  thva_u(k) + ( 1._r8 -  a_u(k) ) * thv0top(k)
                        thv_mean_b = a_u(km) * thva_u(km) + ( 1._r8 - a_u(km) ) * thv0bot(k)
                        !?        ! Initialization of downdraft sources generated in the current layer k. 
                        if( ks .eq. k ) then
                           if( ids .eq. 1 ) then      ! Mixing Downdraft
                              p_t = ps0(km)
                              z_t = zs0(km)
                           elseif( ids .eq. 2 ) then  ! Top Downdraft                 
                              p_t = ptops(k,m)
                              z_t = ztops(k,m)
                           else                       ! Constraint Downdraft
                              p_t = ps0(k)   
                              z_t = zs0(k)
                           endif
                           p_t = min( p_t, ps0(km) )
                           z_t = max( z_t, zs0(km) )
                           thv_t = thv0bot(k) + ( p_t - ps0(km) ) * ( thv0top(k) - thv0bot(k) ) / ( ps0(k) - ps0(km) )
                           rho_t = rho0bot(k) + ( p_t - ps0(km) ) * ( rho0top(k) - rho0bot(k) ) / ( ps0(k) - ps0(km) )
                           thv_mean_t = thv_mean_b + ( p_t - ps0(km) ) * ( thv_mean_t - thv_mean_b ) / ( ps0(k) - ps0(km) )
                           ! May.23.2012. Below 'subsat_dt' is added for initialization to compute resolution-insensitive
                           !              average evaporation rate within convective downdraft.
                           !              Initializating to zero is the perfect choice.
                           !?            ! subsat_dt is not used anymore in the new codw which uses i_evpdown = 0 always.
                           !?              subsat_dt = 0._r8
                           ! Apr.21.2011. Below block is added for complete diagnostic output including the 
                           !              downdraft information at the origination level.
                           !              Note that below 'a_ad' at the origination level is not used at all for
                           !              actual computation - it is purely diagnostic output. 
                           !              Note also that 'ql_ad(k,ks,m,ids),qi_ad(k,ks,m,ids)' are computed
                           !              right below in order to avoid twice application of 'conden', so that
                           !              we can save computation time. 
                           ! Jul.13.2011. Note that fractional area is set to zero at the source level, which is
                           !              good for computing 'tkePBLorg = wa_d(0,it=1)' in the lowest model layer.
                           !              Also, vertical velocity is set to zero in the source level, which is
                           !              also good.
                           cmf_ad(k,ks,m,ids)      =    cmf_dt
                           thl_ad(k,ks,m,ids)      =    thl_dt
                           qt_ad(k,ks,m,ids)       =     qt_dt 
                           u_ad(k,ks,m,ids)        =      u_dt 
                           v_ad(k,ks,m,ids)        =      v_dt 
                           w_ad(k,ks,m,ids)        =      w_dt
                           a_ad(k,ks,m,ids)        =     0._r8
                           do mt = 1, ncnst
                              tr_ad(k,ks,m,ids,mt) = tr_dt(mt)
                           enddo
                           ! Nov.28.2012. Define here instead of at below since 'ql_dt, qi_dt' are already defined above.
                           ql_ad(k,ks,m,ids)       =     ql_dt
                           qi_ad(k,ks,m,ids)       =     qi_dt
                        endif

                        !? This denotes commented-out lines from the previous codes.
                        !? 
                        !?   do ids  = 1, 3                            ! This 'ids' is the type of downdraft source ( 1 : mixing downdraft, 2 : top downdraft, 3 : area downdraft )
                        !?       if( ids .eq. 1 ) then
                        !?           ks_top = ktop_msfc(msfc)
                        !?           ks_bot = kiss + 1
                        !?       elseif( ids .eq. 2 ) then
                        !?           ks_top = ktop_msfc(msfc)
                        !?           ks_bot = ks_top
                        !?       elseif( ids .eq. 3 ) then
                        !?           ks_top = ktop_msfc(msfc) - 1
                        !?           ks_bot = kiss + 1
                        !?       endif 
                        !?    do ks   = ks_top, ks_bot, -1   ! This 'ks'   is a layer index where downdraft sources are generated.
                        !?       ksm  = ks - 1
                        !?       ! ------------------------------------------------------------------------------------------- !
                        !?       ! Convert updraft segment index at surface into shortened-updraft segment index in each layer !
                        !?       ! ------------------------------------------------------------------------------------------- !
                        !?       m = m_from_msfc(ks,msfc)
                        !?       do k = ks, 1, -1            ! This 'k'   is a layer index from the source layer to the 1st (not 2nd) layer. 
                        !?          km = k - 1               ! This 'km'  is a base interface index
                        !?          ! ------------------------------------------------------------------------------ !
                        !?          ! Here, 'top' is defined as the level where downdraft starts its downward motion !
                        !?          ! in each layer. When 'k = ks', 'top' is defined in a different way depending on !
                        !?          ! whether the source of downdraft is 'mixing downdraft', 'top downdraft'         !
                        !?          ! and 'area downdraft'.                                                          !
                        !?          ! ------------------------------------------------------------------------------ ! 
                        !?          p_t   =     ps0(k)
                        !?          p_b   =    ps0(km)
                        !?          z_t   =     zs0(k)     
                        !?          z_b   =    zs0(km)
                        !?          thv_t = thv0top(k)
                        !?          thv_b = thv0bot(k)
                        !?          rho_t = rho0top(k)
                        !?          rho_b = rho0bot(k)
                        !?          if( k .eq. ks ) then
                        !?              if( ids .eq. 1 ) then      ! Mixing Downdraft
                        !?                  p_t = ps0(ksm)
                        !?                  z_t = zs0(ksm)
                        !?              elseif( ids .eq. 2 ) then  ! Top Downdraft                 
                        !?                  p_t = ptops(ks,m)
                        !?                  z_t = ztops(ks,m)
                        !?              else                       ! Area Downdraft
                        !?                  p_t = ps0(ks)   
                        !?                  z_t = zs0(ks)
                        !?              endif
                        !?            ! p_t = min( p_t, ps0(ksm) - 1._r8 )
                        !?            ! z_t = max( z_t, zs0(ksm) + 1._r8 / rho_t / g )
                        !?              p_t = min( p_t, ps0(ksm) )
                        !?              z_t = max( z_t, zs0(ksm) )
                        !?              thv_t = thv0bot(k) + ( p_t - ps0(ksm) ) * ( thv0top(k) - thv0bot(k) ) / ( ps0(k) - ps0(ksm) )
                        !?              rho_t = rho0bot(k) + ( p_t - ps0(ksm) ) * ( rho0top(k) - rho0bot(k) ) / ( ps0(k) - ps0(ksm) )
                        !?              cmf_dt = f_srcds(ks,m,ids) * cmf_u(ksm)
                        !?              thl_dt = thl_srcds(ks,m,ids)
                        !?              qt_dt  = qt_srcds(ks,m,ids) 
                        !?              u_dt   = u_srcds(ks,m,ids) 
                        !?              v_dt   = v_srcds(ks,m,ids) 
                        !?              w_dt   = 0._r8
                        !?              do mt = 1, ncnst
                        !?                 tr_dt(mt) = tr_srcds(ks,m,ids,mt) 
                        !?              enddo
                        !?            ! Nov.28.2012. Define here instead of at below since we have already
                        !?            !              computed 'ql_srcds(ks,m,ids),qi_srcds(ks,m,ids)' in the process of imposing consistency
                        !?            !              with droplet numbers.
                        !?              ql_dt  = ql_srcds(ks,m,ids) 
                        !?              qi_dt  = qi_srcds(ks,m,ids) 
                        !?            ! May.23.2012. Below 'subsat_dt' is added for initialization to compute resolution-insensitive
                        !?            !              average evaporation rate within convective downdraft.
                        !?            !              Initializating to zero is the perfect choice.
                        !?              subsat_dt = 0._r8
                        !?            ! Apr.21.2011. Below block is added for complete diagnostic output including the 
                        !?            !              downdraft information at the origination level.
                        !?            !              Note that below 'a_ad' at the origination level is not used at all for
                        !?            !              actual computation - it is purely diagnostic output. 
                        !?            !              Note also that 'ql_ad(k,ks,m,ids),qi_ad(k,ks,m,ids)' are computed
                        !?            !              right below in order to avoid twice application of 'conden', so that
                        !?            !              we can save computation time. 
                        !?            ! Jul.13.2011. Note that fractional area is set to zero at the source level, which is
                        !?            !              good for computing 'tkePBLorg = wa_d(0,it=1)' in the lowest model layer.
                        !?            !              Also, vertical velocity is set to zero in the source level, which is
                        !?            !              also good.
                        !?              cmf_ad(k,ks,m,ids)      =    cmf_dt
                        !?              thl_ad(k,ks,m,ids)      =    thl_dt
                        !?              qt_ad(k,ks,m,ids)       =     qt_dt 
                        !?              u_ad(k,ks,m,ids)        =      u_dt 
                        !?              v_ad(k,ks,m,ids)        =      v_dt 
                        !?              w_ad(k,ks,m,ids)        =      w_dt
                        !?              a_ad(k,ks,m,ids)        =     0._r8
                        !?              do mt = 1, ncnst
                        !?                 tr_ad(k,ks,m,ids,mt) = tr_dt(mt)
                        !?              enddo
                        !?            ! Nov.28.2012. Define here instead of at below since 'ql_dt, qi_dt' are already defined above.
                        !?              ql_ad(k,ks,m,ids)       =     ql_dt
                        !?              qi_ad(k,ks,m,ids)       =     qi_dt
                        !?          endif    

                        ! Jun.29.2011. Compute rain ( qrain ) and snow ( qsnow ) mixing ratio within precipitation area ( not the grid mean ) 
                        !              by using the assumed fall-speed of rain ( vfall_rain ) and snow ( vfall_snow ). 
                        !              This 'qrain' and 'qsnow' are only used for including condensate-loading effect to the buoyancy ( thv )
                        !              of convective downdraft in downdraft vertical momentum equation.

                        !?          qrain_t = ( flxrain_ava_msfc(k,msfc)  / max( a_p_prevp_msfc(k,msfc),  nonzero ) ) / ( rho_t * vfall_rain )
                        !?          qsnow_t = ( flxsnow_ava_msfc(k,msfc)  / max( a_p_prevp_msfc(k,msfc),  nonzero ) ) / ( rho_t * vfall_snow )
                        
                        !?          qrain_b = ( flxrain_ava_msfc(km,msfc) / max( a_p_prevp_msfc(km,msfc), nonzero ) ) / ( rho_b * vfall_rain )
                        !?          qsnow_b = ( flxsnow_ava_msfc(km,msfc) / max( a_p_prevp_msfc(km,msfc), nonzero ) ) / ( rho_b * vfall_snow )

                        qrain_t = ( flxrain_top  / max( a_p_msfc(k,msfc),  nonzero ) ) / ( rho_t * vfall_rain )
                        qsnow_t = ( flxsnow_top  / max( a_p_msfc(k,msfc),  nonzero ) ) / ( rho_t * vfall_snow )
                        
                        qrain_b = ( flxrain_bot_upeesm / max( a_p_msfc(km,msfc), nonzero ) ) / ( rho_b * vfall_rain )
                        qsnow_b = ( flxsnow_bot_upeesm / max( a_p_msfc(km,msfc), nonzero ) ) / ( rho_b * vfall_snow )

                        ! Apr.21.2011. We compute 'thv_dt','bogtop','ql_dt','qi_dt' here to save computation time
                        !              without changing simulation answer.
                        ! Nov.28.2012. Regardless of the above modifications made on Nov.28.2012, I should keep below
                        !              call conden block since it is used not only for 'k .eq. ks' but also in all the
                        !              other layers. 
                        call conden( p_t, thl_dt, qt_dt, th, qv, ql, qi, qse, id_check )
                        !f          if( id_check .eq. 1 ) then
                        !f              id_exit = .true.
                        !f              go to 333
                        !f          endif
                        th_dt  = th
                        qs_dt  = qse
                        qv_dt  = qv
                        ql_dt  = ql
                        qi_dt  = qi
                        thv_dt = th * ( 1._r8 + zvir * qv - ql - qi )
                        if( i_downloading .eq. 1 ) thv_dt = th * ( 1._r8 + zvir * qv - ql - qi - qrain_t - qsnow_t )
                        ! Mar.07.2013. For scale-adaptive parameterization, use 'thv_mean_t' instead of 'thv_t'
                        !              in computing 'bogtop' below.
                        bogtop = rbuoy_dn * ( 1._r8 - thv_dt / thv_mean_t )
                        ! bogtop = rbuoy_dn * ( 1._r8 - thv_dt / thv_t )
                        ! Nov.28.2012. Remove below block since it is defined above already.
                        ! if( k .eq. ks ) then
                        !     ql_ad(k,ks,m,ids) = ql
                        !     qi_ad(k,ks,m,ids) = qi
                        ! endif

                        ! CHECK
                        ! if( get_nstep() .eq. 3 .and. ks .eq. 5 .and. ids .eq. 1 .and. k .eq. 5) then
                        !     write(6,*)
                        !     write(6,*) 'UNICON: Downdraft sorting at the base of ambiguous layer before diabatic forcing'
                        !     write(6,*) 'Time step & Layer & Segment Index: ', get_nstep(), k
                        !     write(6,*) 'cmf_dt, thl_dt, qt_dt, thvl_dt = ', cmf_dt, thl_dt, qt_dt, thl_dt * ( 1._r8 + zvir * qt_dt )
                        !     write(6,*)
                        ! endif
                        ! CHECK

                        ! OPTION
                        ! if( thl_dt .lt. 1._r8   ) then ! No downdraft source in this layer
                        !?        ! Below block is not necessary any more in the new unified treatment of evaporation since
                        !?        ! this criteria has already been treated above.
                        !?          if( cmf_dt .lt. nonzero ) then ! No downdraft source in this layer
                        !?              cmf_dt = 0._r8
                        !?              goto 20
                        !?          endif
                        dp         = p_b - p_t
                        dz         = z_t - z_b
                        ! Apr.21.2011. Save 'dpad' for later use.
                        dpad(k,ks,m,ids) = dp
                        rho        = 0.5_r8 * ( rho_t + rho_b )
                        exn_b      = exns0(km)
                        if( k .gt. 1 ) then
                           ! ----------------------------------- !
                           ! Use different mu for each downdraft !
                           ! ----------------------------------- !
                           if( ids .eq. 1 ) then
                              mu = mu_mix
                           elseif( ids .eq. 2 ) then                    
                              mu = mu_top
                           elseif( ids .eq. 3 ) then
                              mu = mu_area
                           endif
                           tmp1 = ( 1._r8 - mu ) * thvl0top(km) + mu * thvl0bot(k)
                           tmp2 = ( 1._r8 - mu ) * thv0top(km)  + mu * thv0bot(k)
                           thvl_minE  = min( min( thvl0bot(k), thvl0top(k) ), tmp1 ) 
                           thv_minE   = min( min( thv0bot(k),  thv0top(k)  ), tmp2 ) 
                         ! Apr.15.2014. Modified formula for thv_minE to obtain a reasonable solution when the mean inversion exists.
                           thv_minE  = max( thv0top(km), tmp2 ) 
                         ! Apr.15.2014. Modified formula for thv_minE
                           thvl_minE  = thvl_minE + offset_minE
                           thv_minE   = thv_minE  + offset_minE
                         ! Mar.15.2014. For continuous buoyancy sorting in order to impose a stability in the code 
                         !              and in order to minimize perturbation growth.
                           thv_max    = max( thv0top(km), thv0bot(k) )
                           thv_min    = min( thv0top(km), thv0bot(k) )
                        else
                           thvl_minE  = -1.e8_r8 ! Always detrain downdraft in the lowest model layer after all diabatic forcings
                           thv_minE   = -1.e8_r8 ! Always detrain downdraft in the lowest model layer after all diabatic forcings
                         ! Mar.15.2014. Below two lines are just a place holder.
                           thv_max    = -1.e8_r8
                           thv_min    = -1.e8_r8
                        endif
                        ! ------------------------------------------------------------------------------------ !
                        ! Convert the unit of downdraft entrainment and detrainment rates from [1/z] to [1/Pa] !
                        ! Jan.30.2013. Following the treatment of convective updraft, impose similar advanced  !
                        !              constraint on convective downdraft below.                               !
                        ! Feb.06.2013. Always choose physically reasonable exp_cmf = 1 as of this day.         !
                        ! Nov.18.2013. Impose perfectly physical consistent limit. Only impose a upper limit   !
                        !              since we don't need to sorry about the decrease of downdraft mass flux  !
                        !              as downdraft moves down : we only need to worry about extremely huge    !
                        !              increase when downdraft moves down.                                     !
                        ! ------------------------------------------------------------------------------------ !
                        eps_dn = epsz_dn / ( rho * g )
                        del_dn = delz_dn / ( rho * g )
                        if( exp_cmf .eq. 1 ) then
                           tmp1 = eps_dn - del_dn
                           ! Below is a new treatment after Jan.30.2013 but before Nov.18.2013. 
                           ! tmp2 = min( max( tmp1, - fmix_frac / max( dp, nonzero ) ), fmix_frac / max( dp, nonzero ) )
                           ! Below is a new treatment on Nov.19.2013. 
                           !       Since 'epsz0_max' is specified in unit of [1/m], I should multiply 'dz' in the below tmp2,
                           !       where 'dz' is already-well defined above.
                           tmp2 = min( tmp1, log( 1._r8 + epsz0_max * dz ) / max( dp, nonzero ) )
                           if( abs( tmp2 - tmp1 ) .ge. nonzero ) then ! Constraint is imposed.
                              eps_dn = eps_dn * ( tmp2 / tmp1 ) 
                              del_dn = del_dn * ( tmp2 / tmp1 ) 
                           endif
                           ! Below is a old treatment before Jan.30.2013.
                           ! if( eps_dn .gt. del_dn ) then
                           !     tmp1 = eps_dn
                           !     eps_dn = min( eps_dn, log(0.9_r8*dp/g/dt/cmf_dt+1._r8)/max(dp,nonzero) + del_dn )   
                           !     if( eps_dn .lt. tmp1 ) then
                           !         write(6,*) 'WARNING IN UNICON : eps_dn is adjusted !'
                           !     endif
                           ! endif                                                               
                        endif

                        ! -------------------------------------------------------------------- ! 
                        ! Update 'w_db' by adiabatic buoyancy forcing                          !
                        ! without including evaporation of precipitation at the base interface.!
                        ! -------------------------------------------------------------------- !
                        ! Apr.21.2011. Remove below 'if' block and 'ibogtopd' option completely
                        !              since it is not necessary. Note that 'w_db' is not used
                        !              until it is computed later below. Som removing below 
                        !              block is completely OK. 
                        ! if( ibogtopd .eq. 0 ) then
                        !     call conden( p_t, thl_dt, qt_dt, th, qv, ql, qi, qse, id_check )
                        !     if( id_check .eq. 1 ) then
                        !         id_exit = .true.
                        !         go to 333
                        !     endif
                        !     thv_dt = th * ( 1._r8 + zvir * qv - ql - qi )
                        !     call conden( p_b, thl_dt, qt_dt, th, qv, ql, qi, qse, id_check )
                        !     if( id_check .eq. 1 ) then
                        !         id_exit = .true.
                        !         go to 333
                        !     endif
                        !     thv_db = th * ( 1._r8 + zvir * qv - ql - qi )
                        !     bogbot = rbuoy_dn * ( 1._r8 - thv_db / thv_b )
                        !     bogtop = rbuoy_dn * ( 1._r8 - thv_dt / thv_t )
                        !     w_db   = w_dt**2._r8 + dp * ( bogbot + bogtop ) / rho
                        !     w_db   = max( wdmin, sqrt( max( w_db, nonzero ) ) )
                        !   ! w_db   = min( wdmax, max( wdmin, sqrt( max( w_db, nonzero ) ) ) ) ! This is not a problem at all since downdraft buoyancy sorting is done using thv(l)_minE
                        ! endif
                        ! ------------------------------------------------ !
                        ! Update downdraft mass flux at the base interface !
                        ! ------------------------------------------------ !
                        ! Below line is with entrainment dilution.
                        ! Feb.06.2013. Always choose physically reasonable exp_cmf = 1 as of this day.
                        if( exp_cmf .eq. 1 ) then
                           cmf_db  = cmf_dt * exp( dp * ( eps_dn - del_dn ) )
                        elseif( exp_cmf .eq. 2 ) then
                           cmf_db  = max( 0._r8, cmf_dt * ( 1._r8 + dp * ( eps_dn - del_dn ) ) )
                           !           elseif( exp_cmf .eq. 3 ) then
                           !               if( eps_dn .ge. del_dn ) then
                           !                   cmf_db  = max( 0._r8, cmf_dt * ( 1._r8 + dp * ( eps_dn - del_dn ) ) )
                           !               else
                           !                   cmf_db  = cmf_dt * exp( dp * ( eps_dn - del_dn ) )
                           !               endif 
                        endif
                        ! Below line is the original line without dilution.
                        ! cmf_db  = cmf_dt
                        cmf_dbt = 0.5_r8 * ( cmf_dt + cmf_db )
                        ! ----------------------------------------------- !
                        ! Update 'u_db,v_db' by diabatic horizontal PGF   !
                        ! Instead of using the gradient within the layer, ! 
                        ! I should use the gradient between the layers.   !
                        ! ----------------------------------------------- !

                        ! Below is the original block without dilution. 

                        ! if( k .eq. 1 ) then
                        !     u_grd = ( u0(k+1) -   u0(1) ) / ( p0(k+1) - p0(k) ) 
                        !     v_grd = ( v0(k+1) -   v0(1) ) / ( p0(k+1) - p0(k) ) 
                        ! elseif( k .eq. mkx ) then
                        !     u_grd = ( u0(mkx) - u0(k-1) ) / ( p0(mkx) - p0(k-1) )
                        !     v_grd = ( v0(mkx) - v0(k-1) ) / ( p0(mkx) - p0(k-1) )
                        ! else
                        !     u_grd = ( u0(k+1) - u0(k-1) ) / ( p0(k+1) - p0(k-1) ) 
                        !     v_grd = ( v0(k+1) - v0(k-1) ) / ( p0(k+1) - p0(k-1) ) 
                        ! endif
                        ! if( islope_on_uv .eq. 1 ) then
                        !     u_grd = ssu0(k)
                        !     v_grd = ssv0(k)
                        ! endif
                        ! PGF_u = - PGFc * u_grd * ( p_t - p_b )
                        ! PGF_v = - PGFc * v_grd * ( p_t - p_b )
                        ! if( idias_off .eq. 1 .and. k .eq. ks ) then
                        !     PGF_u = 0._r8
                        !     PGF_v = 0._r8
                        ! endif
                        ! u_db = u_dt + PGF_u
                        ! v_db = v_dt + PGF_v

                        ! Below block is with entrainment dilution.
                        ! Apr.11.2011. Why using mean-environmental wind without organized environmental airs 
                        !              in contrast to the treatment of convective updraft ?
                        ! Apr.21.2011. In case of 'org_ent = 1', it is automatically set ssue=ssve=0.
                        !              Thus, in order to treat the case of high 'org_ent', we should
                        !              use 'u_grdPGF = u_grd0(k),v_grdPGF = v_grd0(k)' regardless of
                        !              the setting of 'islope_on_uv'. Thus, I commented out below 'if' block. 
                        ! Apr.22.2011. It turns out that the choice of 'u_grdPGF = u_grd0(k)' and 'v_grdPGF = v_grd0(k)'  
                        !              degraded the simulation of 'v' in BOMEX. In order to improve this feature and
                        !              further enhance consistency, we use 'u_grdPGF = ssu0(k)' and 'v_grdPGF = ssv0(k)'
                        !              below same as for updraft.
                        ! Jul.25.2011. The issue of 'Apr.11.2011' is addressed today.
                        !              Without the concept of convective organization, simply assume that
                        !              convective downdraft entrains updraft airs at the current time step.
                        !              Note that 'p_b = ps0(km)' but 'p_t' changes depending on the type of
                        !              convective downdraft especially in the source layer.          
                        ! Jul.28.2011. I included the second option of mixing with detrained airs at the previous time step to
                        !              impose a full consistency with the mixing treatment of convective updraft.
                        !              Since 'ue_b(k), ssue(k)' etc. are computed using 'org_ent' that considers the amount of
                        !              airs that updraft will be involved, the use of 'ue_b(k), ssue(k)' for convective downdraft 
                        !              is not perfectly correct.
                        !              However, since the the amount of airs involved in the mixing is likely to be smaller than
                        !              the amount of detrained airs ( so that org_ent = cuorg ), this inevitable approximation is 
                        !              likely to be almost perfectly OK. 
                        ! Aug.31.2011. In consistent with the wake parameterization, I added the option 3 for 'i_dnmixing' :
                        !              In the layers above the PBL top, downdraft is mixed with the same mixing environmental airs with convective updraft.
                        !              In the layers below the PBL top, downdraft is mixed with 'wake' properties.
                        !              Similar to the critics on Jul.28.2011, this does not consider the amount of available mixing environmental airs both
                        !              within PBL and above PBL layers. So, there is a possible conceptual inconsistency.
                        !              However, I added this option since this is likely to what is happening in real nature.   
                        !              Note that 'wake_ratio = ( 1 - aw ) / aw' can be related with cuorg since we are viewing 'aw' as roughly 'cuorg'.
                        !              This may be implemented in future.  
                        ! Apr.17.2012. In order to avoid confusion in the variable notation and in order to consistently treat the analytical
                        !              evaporation option within convective downdraft, I define 'u_med, v_med, thl_med, qt_med, ql_med, ql_med, tr_med(mt)'
                        !              in defining the value of mixing environmental airs for convective downdraft below. 

                        if( i_dnmixing .eq. 0 ) then
                           ssu_tmp = ssu0(k)
                           ssv_tmp = ssv0(k)
                           u_med   = u0bot(k) + ssu_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                           v_med   = v0bot(k) + ssv_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                        elseif( i_dnmixing .eq. 1 ) then
                           ssu_tmp = ssue(k)
                           ssv_tmp = ssve(k)
                           u_med   = ue_b(k) + ssu_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                           v_med   = ve_b(k) + ssv_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                        elseif( i_dnmixing .eq. 2 ) then
                           if( k .ne. ktop_msfc(msfc) ) then
                              ssu_tmp = ( u_u_msfc(k,msfc) - u_u_msfc(km,msfc) ) / ( ps0(k) - p_b )
                              ssv_tmp = ( v_u_msfc(k,msfc) - v_u_msfc(km,msfc) ) / ( ps0(k) - p_b )
                           else
                              ssu_tmp = ( u_u_msfc(k,msfc) - u_u_msfc(km,msfc) ) / min( ptop_msfc(msfc) - p_b, -nonzero )
                              ssv_tmp = ( v_u_msfc(k,msfc) - v_u_msfc(km,msfc) ) / min( ptop_msfc(msfc) - p_b, -nonzero )
                           endif
                           u_med   = u_u_msfc(km,msfc) + ssu_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                           v_med   = v_u_msfc(km,msfc) + ssv_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                        elseif( i_dnmixing .eq. 3 ) then
                           ! Note that ssue(k) = ssu0(k) in the layers below PBL top.
                           ssu_tmp = ssue(k)
                           ssv_tmp = ssve(k)
                           if( k .lt. kpblh ) then
                              u_med   = ue_b(k) - ( 1._r8 + ( 1._r8 - awk_PBL ) / max( nonzero, awk_PBL ) ) * delta_u_PBL + &
                                        ssu_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                              v_med   = ve_b(k) - ( 1._r8 + ( 1._r8 - awk_PBL ) / max( nonzero, awk_PBL ) ) * delta_v_PBL + &
                                        ssv_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                           else
                              u_med   = ue_b(k) + ssu_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                              v_med   = ve_b(k) + ssv_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                           endif
                        endif

                        ! u_med   = u0bot(k) + ssu0(k) * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                        ! v_med   = v0bot(k) + ssv0(k) * ( 0.5_r8 * ( p_t + p_b ) - p_b )

                        if( islope_on_uv .eq. 0 ) then           
                           u_grdPGF = u_grd0(k)
                           v_grdPGF = v_grd0(k)
                        else
                           ! Aug.03.2011. Note that I use 'ssu0(k)' instead of 'ssu_tmp' here to
                           !              use more representative values of environmental profiles.
                           u_grdPGF = ssu0(k)
                           v_grdPGF = ssv0(k)            
                        endif
                        
                        call progup_uv( -eps_dn, PGFc_dn, p_t, p_b, u_med, ssu_tmp, u_grdPGF, u_dt, u_db )
                        call progup_uv( -eps_dn, PGFc_dn, p_t, p_b, v_med, ssv_tmp, v_grdPGF, v_dt, v_db )

                        ! CHECK
                        ! if( get_nstep() .le. 10 .and. k .eq. 5 ) then
                        !     write(6,*)
                        !     write(6,*) 'UNICON: Check of prognostics equation of downdraft u,v with PGFc_dn'
                        !     write(6,*) 'eps_dn, PGFc_dn, p_t, p_b, u_med, u_t, u_b, ssu0(k), u_dt, u_db = '
                        !     write(6,*)  eps_dn, PGFc_dn, p_t, p_b, u_med, &
                        !                 u0bot(k) + ssu0(k) * ( p_t - p_b ), &
                        !                 u0bot(k),  ssu0(k), u_dt, u_db
                        !     write(6,*)
                        ! endif
                        ! CHECK

                        call progup_uv( -eps_dn,   0._r8, p_t, p_b, u_med, ssu_tmp, u_grdPGF, u_dt, u_db_adi )
                        call progup_uv( -eps_dn,   0._r8, p_t, p_b, v_med, ssv_tmp, v_grdPGF, v_dt, v_db_adi )

                        ! CHECK
                        ! if( get_nstep() .le. 10 .and. k .eq. 5 ) then
                        !     write(6,*)
                        !     write(6,*) 'UNICON: Check of prognostics equation of downdraft u,v with PGFc_dn = 0'
                        !     write(6,*) 'eps_dn, p_t, p_b, u_med, u_t, u_b, ssu0(k), u_dt, u_db_adi = '
                        !     write(6,*)  eps_dn, p_t, p_b, u_med, &
                        !                 u0bot(k) + ssu0(k) * ( p_t - p_b ), &
                        !                 u0bot(k), ssu0(k), u_dt, u_db_adi
                        !     write(6,*)
                        ! endif
                        ! CHECK

                        PGF_u = u_db - u_db_adi 
                        PGF_v = v_db - v_db_adi 

                        ! -------------------------------------------------------------------------- !
                        !                                                                            !
                        ! Update 'thl_db,qt_db' by diabatic evaporation of precipitation at the base !
                        !                                                                            ! 
                        ! -------------------------------------------------------------------------- !  
                        ! ----------------------------------------------------------------------- !
                        ! 1. Evaporation of Precipitation                                         !
                        !    Also compute effective diabatic forcing before evaporation of precip !
                        !    The effective forcing for tracers should be refined later by         !
                        !    considering 'evaporation-melting' especially for droplet numbers.    !  
                        ! ----------------------------------------------------------------------- !  

                        ! Below block is with entrainment dilution.
                        ! Apr.11.2011. Why using mean-environmental air without organized environmental airs 
                        !              in contrast to the treatment of convective updraft ?
                        ! Jul.25.2011. This is done today. 
                        !              Without the concept of convective organization, simply assume that
                        !              convective downdraft entrains updraft airs at the current time step.
                        !              Note that 'p_b = ps0(km)' but 'p_t' changes depending on the type of
                        !              convective downdraft especially in the source layer. 
                        ! Apr.17.2012. In order to avoid confusion in the variable notation and in order to consistently treat the analytical
                        !              evaporation option within convective downdraft, I define 'u_med, v_med, thl_med, qt_med, ql_med, ql_med, tr_med(mt)'
                        !              in defining the value of mixing environmental airs for convective downdraft below. 

                        if( i_dnmixing .eq. 0 ) then
                           ssthl_tmp = ssthl0(k)
                           ssqt_tmp  =  ssqt0(k)
                           ssql_tmp  =  ssql0(k)
                           ssqi_tmp  =  ssqi0(k)
                           do mt = 1, ncnst
                              sstr_tmp(mt) = sstr0(k,mt)
                           enddo
                           thl_med   = thl0bot(k) + ssthl_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                           qt_med    = qt0bot(k)  +  ssqt_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                           ql_med    = ql0bot(k)  +  ssql_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                           qi_med    = qi0bot(k)  +  ssqi_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                           do mt = 1, ncnst
                              tr_med(mt)  = tr0bot(k,mt) + sstr_tmp(mt) * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                           enddo
                        elseif( i_dnmixing .eq. 1 ) then
                           ssthl_tmp = ssthle(k)
                           ssqt_tmp  =  ssqte(k)
                           ssql_tmp  =  ssqle(k)
                           ssqi_tmp  =  ssqie(k)
                           do mt = 1, ncnst
                              sstr_tmp(mt) = sstre(k,mt)
                           enddo
                           thl_med   = thle_b(k) + ssthl_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                           qt_med    = qte_b(k)  +  ssqt_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                           ql_med    = qle_b(k)  +  ssql_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                           qi_med    = qie_b(k)  +  ssqi_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                           do mt = 1, ncnst
                              tr_med(mt)  = tre_b(k,mt) + sstr_tmp(mt) * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                           enddo
                        elseif( i_dnmixing .eq. 2 ) then
                           if( k .ne. ktop_msfc(msfc) ) then
                              ssthl_tmp = ( thl_u_msfc(k,msfc) - thl_u_msfc(km,msfc) ) / ( ps0(k) - p_b )
                              ssqt_tmp  = (  qt_u_msfc(k,msfc) -  qt_u_msfc(km,msfc) ) / ( ps0(k) - p_b )
                              ssql_tmp  = (  ql_u_msfc(k,msfc) -  ql_u_msfc(km,msfc) ) / ( ps0(k) - p_b )
                              ssqi_tmp  = (  qi_u_msfc(k,msfc) -  qi_u_msfc(km,msfc) ) / ( ps0(k) - p_b )
                              do mt = 1, ncnst
                                 sstr_tmp(mt) = ( tr_u_msfc(k,msfc,mt) - tr_u_msfc(km,msfc,mt) ) / ( ps0(k) - p_b )
                              enddo
                           else
                              ssthl_tmp = ( thl_u_msfc(k,msfc) - thl_u_msfc(km,msfc) ) / min( ptop_msfc(msfc) - p_b, -nonzero )
                              ssqt_tmp  = (  qt_u_msfc(k,msfc) -  qt_u_msfc(km,msfc) ) / min( ptop_msfc(msfc) - p_b, -nonzero )
                              ssql_tmp  = (  ql_u_msfc(k,msfc) -  ql_u_msfc(km,msfc) ) / min( ptop_msfc(msfc) - p_b, -nonzero )
                              ssqi_tmp  = (  qi_u_msfc(k,msfc) -  qi_u_msfc(km,msfc) ) / min( ptop_msfc(msfc) - p_b, -nonzero )
                              do mt = 1, ncnst
                                 sstr_tmp(mt) = ( tr_u_msfc(k,msfc,mt) - tr_u_msfc(km,msfc,mt) ) / &
                                                min ( ptop_msfc(msfc) - p_b, -nonzero )
                              enddo
                           endif
                           thl_med   = thl_u_msfc(km,msfc) + ssthl_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                           qt_med    = qt_u_msfc(km,msfc)  +  ssqt_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                           ql_med    = ql_u_msfc(km,msfc)  +  ssql_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                           qi_med    = qi_u_msfc(km,msfc)  +  ssqi_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                           do mt = 1, ncnst
                              tr_med(mt)  = tr_u_msfc(km,msfc,mt) + sstr_tmp(mt) * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                           enddo
                        elseif( i_dnmixing .eq. 3 ) then
                           ! Note that ssthle(k) = ssthl0(k) in the layers below PBL top.
                           ssthl_tmp = ssthle(k)
                           ssqt_tmp  =  ssqte(k)
                           ssql_tmp  =  ssqle(k)
                           ssqi_tmp  =  ssqie(k)
                           do mt = 1, ncnst
                              sstr_tmp(mt) = sstre(k,mt)
                           enddo
                           if( k .lt. kpblh ) then
                              thl_med   = thle_b(k) - ( 1._r8 + ( 1._r8 - awk_PBL ) / max( nonzero, awk_PBL ) ) * &
                                          delta_thl_PBL + ssthl_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                              qt_med    = qte_b(k)  - ( 1._r8 + ( 1._r8 - awk_PBL ) / max( nonzero, awk_PBL ) ) * &
                                          delta_qt_PBL +  ssqt_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                              ql_med    = qle_b(k)  - ( 1._r8 + ( 1._r8 - awk_PBL ) / max( nonzero, awk_PBL ) ) * &
                                          0._r8 +  ssql_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                              qi_med    = qie_b(k)  - ( 1._r8 + ( 1._r8 - awk_PBL ) / max( nonzero, awk_PBL ) ) * &
                                          0._r8 +  ssqi_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                              do mt = 1, ncnst
                                 tr_med(mt)  = tre_b(k,mt) - ( 1._r8 + ( 1._r8 - awk_PBL ) / max( nonzero, awk_PBL ) ) * &
                                               delta_tr_PBL(mt) + sstr_tmp(mt) * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                              enddo
                           else
                              thl_med   = thle_b(k) + ssthl_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                              qt_med    = qte_b(k)  +  ssqt_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                              ql_med    = qle_b(k)  +  ssql_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                              qi_med    = qie_b(k)  +  ssqi_tmp * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                              do mt = 1, ncnst
                                 tr_med(mt)  = tre_b(k,mt) + sstr_tmp(mt) * ( 0.5_r8 * ( p_t + p_b ) - p_b )
                              enddo
                           endif
                        endif

                        ! Apr.21.2011. Comment-out below block since it has already been computed above.
                        !              In addition, this comment-out solve critical error of using
                        !              wrong 'ql,qi' in the following 'call progup_thlqt' subroutine.

                        ! call conden( p_t, thl_dt, qt_dt, th, qv, ql, qi, qse, id_check )
                        ! if( id_check .eq. 1 ) then
                        !     id_exit = .true.
                        !     go to 333
                        ! endif
                        ! ql_dt = ql
                        ! qi_dt = qi

                        ! Jul.26.2011. It may be important to force convective downdraft to be mixed with
                        !              convective updraft properties not with mean environmental airs.
                        !              This will help to maintain moist detrained airs. 
                        ! Jul.27.2011. ssthl0(k) is replaced by 'ssthl_tmp' and also for the other variables
                        !              to handle 'i_dnmixing' option.

                        call progup_thlqt( -eps_dn, 0._r8, 0._r8, p_t, p_b, thl_med, ssthl_tmp, thl_dt, thl_db    )
                        call progup_thlqt( -eps_dn, 0._r8, 0._r8, p_t, p_b, qt_med,  ssqt_tmp,  qt_dt,  qt_db     )
                        call progup_thlqt( -eps_dn, 0._r8, 0._r8, p_t, p_b, ql_med,  ssql_tmp,  ql_dt,  ql_db_adi )
                        call progup_thlqt( -eps_dn, 0._r8, 0._r8, p_t, p_b, qi_med,  ssqi_tmp,  qi_dt,  qi_db_adi )
                        do mt = 1, ncnst
                           call progup_thlqt( -eps_dn, 0._r8, 0._r8, p_t, p_b, tr_med(mt), sstr_tmp(mt), tr_dt(mt), tr_db(mt) )
                        enddo

                        ! Nov.28.2012. Impose consistency between droplet mass and droplet number.
                        !              In contrast to updraft process, droplet activation is not performed
                        !              which is a reasonable assumption. 
                        !              Note that for the downdraft, I don't need to use the specified 'droprad_liq' since
                        !              mixing downdraft, for example, is generated by mixture with the environment, so that
                        !              downdraft can have different droplet size.
                        !              However, I already imposed a full consistency between droplet mass and droplet number
                        !              into the mixing downdraft using specified droplet radius above. 
                        ! Dec.09.2012. I may need to impose a full consistency between droplet mass and droplet number using 
                        !              the specified droplet radius for the full consistency until the full 2-moment microphysics
                        !              microphysics is developed for convection. 
                        !              If I impose a consistency here using the specified droplet radius, a full consistency 
                        !              can be maintained between droplet mass and droplet number.
                        !              Since the same consistency will be imposed on the 'eff_tr,prep_tr', I should
                        !              impose a consistency here too.
                        
                        ! Dec.09.2012. Below is a new consistent code.
                        tr_db(ixnumliq) = ql_db_adi * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_liq**3 * density_liq ) 
                        tr_db(ixnumice) = qi_db_adi * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_ice**3 * density_ice ) 

                        ! Dec.09.2012. Below is a previous code   
                        ! if( ql_db_adi .eq. 0._r8 ) tr_db(ixnumliq) = 0._r8
                        ! if( qi_db_adi .eq. 0._r8 ) tr_db(ixnumice) = 0._r8

                        ! CHECK : Vertical Evolution Test of Convective Updraft and Downdraft with All Component. 
                        ! It must be (1) tmp1 < 30, (2) tmp2 < tmp1, (3) tmp3 > 10, (4) tmp4 > tmp3 
                        !  if( get_nstep() .eq. 5 .and. i .eq. 10 .and. k .eq. 1 ) then
                        !      call progup_thlqt(  0.00005_r8,     0._r8, 100000._r8,  80000._r8, 20._r8, 0.001_r8, 30._r8, tmp1 ) ! Updraft. Only mixing and gradient
                        !      call progup_thlqt(  0.00005_r8, 0.0001_r8, 100000._r8,  80000._r8, 20._r8, 0.001_r8, 30._r8, tmp2 ) ! Updraft. Additional Precipitation Fall Out
                        !      call progup_thlqt( -0.00005_r8,     0._r8,  80000._r8, 100000._r8, 20._r8, 0.001_r8, 10._r8, tmp3 ) ! Downdraft. Only mixing and gradient
                        !      call progup_thlqt( -0.00005_r8, 0.0001_r8,  80000._r8, 100000._r8, 20._r8, 0.001_r8, 10._r8, tmp4 ) ! Downdraft. Additional Evaporation of Precipitation
                        !      write(6,*)
                        !      write(6,*) 'UNICON : Vertical Evolution Test'
                        !      write(6,*) 'tmp1, tmp2, tmp3, tmp4 = ', tmp1, tmp2, tmp3, tmp4
                        !      write(6,*)
                        !  endif
                        ! CHECK : Vertical Evolution Test of Convective Updraft and Downdraft with All Component. 

                        ! call progup_thlqt( -eps_dn, 0._r8, p_t, p_b, thl_med, ssthl0(k), thl_dt, thl_db    )
                        ! call progup_thlqt( -eps_dn, 0._r8, p_t, p_b, qt_med,  ssqt0(k),  qt_dt,  qt_db     )
                        ! call progup_thlqt( -eps_dn, 0._r8, p_t, p_b, ql_med,  ssql0(k),  ql_dt,  ql_db_adi )
                        ! call progup_thlqt( -eps_dn, 0._r8, p_t, p_b, qi_med,  ssqi0(k),  qi_dt,  qi_db_adi )
                        ! do mt = 1, ncnst
                        !    call progup_thlqt( -eps_dn, 0._r8, p_t, p_b, tr_med(mt), sstr0(k,mt), tr_dt(mt), tr_db(mt) )
                        ! enddo 
                        
                        ! CHECK
                        !  if( get_nstep() .eq. 616 ) then
                        !      write(6,*)
                        !      write(6,*) 'UNICON : Vertical Evolution of Convective Downdraft'
                        !      write(6,*) 'k, msfc, ids, ks = ', k, msfc, ids, ks
                        !      write(6,*) 'eps_dn, p_t, p_b, qt,  ssqt0(k),  qt_dt,  qt_db, abs(eps_dn*(p_t-p_b))  = ', k, eps_dn, p_t, p_b, qt,  ssqt0(k),  qt_dt,  qt_db, abs(eps_dn*(p_t-p_b)) 
                        !      write(6,*)
                        !  endif
                        ! CHECK

                        call conden( p_b, thl_db, qt_db, th, qv, ql, qi, qse, id_check )
                        !f          if( id_check .eq. 1 ) then
                        !f              id_exit = .true.
                        !f              go to 333
                        !f          endif
                        th_db = th 
                        qs_db = qse
                        qv_db = qv
                        ql_db = ql
                        qi_db = qi
                        eff_ql = ql_db - ql_db_adi
                        eff_qi = qi_db - qi_db_adi 

                        ! Apr.17.2012. Below block computing 'w_ab_adi' is moved further below to handle the option of 
                        !              analytical integration of evaporation of precipitation within convective downdraft.
                        !              Note that this moving of below block does not change the answer of the previous
                        !              default computation of discrete computation of evaporation within convective downdraft.
                        !              For clearness, I changed 'th' to 'th_db' and later too by defining 'th_db' above.
                        
                        ! ! Apr.21.2010. Also compute provisional ( without evaporation of precipitation at the base interface ) 
                        ! !              downdraft vertical velocity at the base interface for use in computing 'dt_evpd' later.      
                        !   thv_db  = th_db * ( 1._r8 + zvir * qv_db - ql_db - qi_db )
                        !   if( i_downloading .eq. 1 ) thv_db  = th_db * ( 1._r8 + zvir * qv_db - ql_db - qi_db - qrain_b - qsnow_b )
                        ! ! July.07.2011. I added (-) sign in front of 'bogbot' and 'bogtop' arguments for downdraft.
                        ! !               This was the reason why downdraft is so weak in UNICON. 
                        ! !               This was clearly a bug. 
                        ! !               Given this correction, I can do more reasonable computation for convective organization.
                        !   bogbot  = rbuoy_dn * ( 1._r8 - thv_db / thv_b )
                        !   call progup_wu2( -( rdrag*eps_dn - rjet*del_dn ), rho, p_t, p_b, -bogtop, -bogbot, w_dt**2._r8, 0._r8, wd2 )
                        !   w_db_adi = max( wdmin, sqrt( max( wd2, nonzero ) ) )             

                        ! ------------------------------------------------------------------------------------------------ !
                        ! TRACERS REFINEMENT NECESSARY : ADIABATIC CONDENSATION-EVAPORATION-MELTING DURING VERTICAL MOTION !
                        ! ------------------------------------------------------------------------------------------------ !
                        ! Nov.08.2011. Critical bug fix. I should correctly handle the droplet number concentration in order
                        !              to prevent generating unreasonable source of droplet number which was the case in the
                        !              previous wrong code.
                        ! Nov.28.2012. In contrast to updraft, activation is neglected since it is likely that activation
                        !              will not occur in the downdraft process. For the simplification of the proces, this
                        !              non-activation assumption within downdraft is quite useful.
                        do mt = 1, ncnst
                           if( mt .eq. ixnumliq ) then
                              ! Below is the new code. The second line assumes that only evaporation changes droplet number.
                              ! The choice of second line should be made in consistent with the one in the updraft process.  
                              ! Nov.29.2012. Below is problematic if 'ql_db_adi = tr_db = 0' but eff_ql > 0', in which case
                              ! below formula produces eff_tr = 0 even though it should be positive by activation. Thus,
                              ! I return to the original formula. 
                              ! eff_tr(mt) =      eff_ql          * ( tr_db(mt) / max( ql_db_adi, nonzero ) )
                              ! eff_tr(mt) = min( eff_ql, 0._r8 ) * ( tr_db(mt) / max( ql_db_adi, nonzero ) )
                              ! Below is the old code. 
                              ! In fact, below is wrong since downdraft can have droplet radius different from 'droprad_liq'.
                              ! However, let's assume that downdraft also have the specified droprad_liq as the updraft.
                              eff_tr(mt) = eff_ql * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_liq**3 * density_liq ) 
                           elseif( mt .eq. ixnumice ) then 
                              ! Below is the new code. The second line assumes that only evaporation changes droplet number.
                              ! The choice of second line should be made in consistent with the one in the updraft process.  
                              ! Nov.29.2012. Below is problematic if 'ql_db_adi = tr_db = 0' but eff_ql > 0', in which case
                              ! below formula produces eff_tr = 0 even though it should be positive by activation. Thus,
                              ! I return to the original formula. 
                              ! eff_tr(mt) =      eff_qi          * ( tr_db(mt) / max( qi_db_adi, nonzero ) )
                              ! eff_tr(mt) = min( eff_qi, 0._r8 ) * ( tr_db(mt) / max( qi_db_adi, nonzero ) )
                              ! Below is the old code.
                              ! In fact, below is wrong since downdraft can have droplet radius different from 'droprad_ice'.
                              ! However, let's assume that downdraft also have the specified droprad_liq as the updraft.
                              eff_tr(mt) = eff_qi * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_ice**3 * density_ice ) 
                           else
                              eff_tr(mt) = 0._r8
                           endif
                           ! Nov.27.2012. Impose a constraint on the diabatic forcing to prevent the onset of negative tracer during downward motion.
                           !              This can happen, for example, by the effective diabatic process eff_tr.
                           !              This constraint is imposed by using 'tr_db(mt) + eff_tr(mt) > qmin(mt)' criteria,
                           !              where 'tr_db(mt)' is a tracer at the base interface before adding diabatic forcing.
                           !              Similar constraint has also been imposed on the updraft motion.
                           eff_tr(mt) = max( eff_tr(mt), qmin(mt) - tr_db(mt) )   
                        enddo
                        ! ------------------------------------------------------------------------------------------------ !
                        ! TRACERS REFINEMENT NECESSARY : ADIABATIC CONDENSATION-EVAPORATION-MELTING DURING VERTICAL MOTION !
                        ! ------------------------------------------------------------------------------------------------ !
                        ! 1.May.2011. I added below block for full conceptual consistency.
                        do mt = 1, ncnst
                           tr_db(mt) = tr_db(mt) + eff_tr(mt)               
                        enddo

                        ! CHECK
                        ! if( get_nstep() .le. 10 .and. k .eq. 5 ) then
                        !     write(6,*)
                        !     write(6,*) 'UNICON: Check of prognostics equation of downdraft thl'
                        !     write(6,*) 'eps_dn, p_t, p_b, thl, ssthl0(k), thl_dt, thl_db = '
                        !     write(6,*)  eps_dn, p_t, p_b, thl, ssthl0(k), thl_dt, thl_db
                        !     write(6,*)
                        ! endif
                        ! CHECK

                        ! Below block is the original.

                        ! call conden( p_t, thl_dt, qt_dt, th, qv, ql, qi, qse, id_check )
                        ! if( id_check .eq. 1 ) then
                        !     id_exit = .true.
                        !     go to 333
                        ! endif
                        ! tmp1 = ql
                        ! tmp2 = qi
                        ! call conden( p_b, thl_dt, qt_dt, th, qv, ql, qi, qse, id_check )
                        ! if( id_check .eq. 1 ) then
                        !     id_exit = .true.
                        !     go to 333
                        ! endif
                        ! eff_ql = ql - tmp1
                        ! eff_qi = qi - tmp2 
                        ! do mt = 1, ncnst
                        !    eff_tr(mt) = 0._r8
                        ! enddo

                        ! CHECK
                        ! if( get_nstep() .eq. 3 .and. ks .eq. 5 .and. ids .eq. 1 .and. k .eq. 5 ) then
                        !     write(6,*)
                        !     write(6,*) 'UNICON: eff_ql, eff_qi'
                        !     write(6,*) 'Time step & Layer & Segment Index: ', get_nstep(), k
                        !     write(6,*) 'eff_ql, ql, tmp1 = ', eff_ql, ql, tmp1 
                        !     write(6,*) 'eff_qi, qi, tmp2 = ', eff_qi, qi, tmp2 
                        !     write(6,*) 'p_t, thl_dt, qt_dt =', p_t, thl_dt, qt_dt
                        !     write(6,*) 'p_b, thl_dt, qt_dt =', p_b, thl_dt, qt_dt
                        !     write(6,*)
                        ! endif
                        ! CHECK

                        ! -------------------------------------------------------------------------------------------------------------------- !
                        ! Apr.17.2012.                                                                                                         !
                        ! Computation of (0) discrete numerical computation at the base interface or                                           !
                        !                (1) continuous analytical computation from the top to the base of convective downdraft in each layer, !
                        ! of evaporation of convective precipitation within convective downdraft.                                              !
                        ! Note that the entire goal of below if block is to compute separate (numerical or analytical) 'evp_qtl' and 'evp_qti' !
                        ! which are the resulting change of qt at the base interface [kg/kg] by the evaporation of convective rain and snow    !
                        ! within convective downdraft.                                                                                         !
                        ! -------------------------------------------------------------------------------------------------------------------- !

                        ! ------------------------------------------------------------------------------------- !
                        ! Here, 'eta1 = residence time ratio * ovc(a_p,a_d)/a_d' and 'eta2 = ovc(a_p,a_d)/a_p'. !
                        ! If we do two iterations by setting niter = 2, we can use the explicitly               !
                        ! computed 'eta1' and 'eta2' from the first iteration instead of specifying them.       !
                        ! ------------------------------------------------------------------------------------- !
                        ! if( iter .eq. 1 ) then
                        !     eta11 = eta1
                        !     eta22 = eta2
                        ! else
                        !     eta11 = eta1_a(k) 
                        !     eta22 = eta2_a(k) 
                        ! endif

                        ! May25.2012. I moved below block out of the '(i_evpdown .eq. 0)' loop since
                        !             below will be used both for 'i_evpdown=0' and 'i_evpdown=1' cases.
                        !             Note that I already computed 'subsat_dt' in the above.

                        !q          call findsp_single( qv_db, th_db*exnf(p_b), p_b, tw_db, qw_db, i, k, lchnk )
                        !q          subsat_db = min( 1._r8, max( 0._r8, 1._r8 - qv_db / max( qs_db, nonzero ) ) )

                        ! Apr.21.2010. Also compute provisional ( without evaporation of precipitation at the base interface ) 
                        !              downdraft vertical velocity at the base interface for use in computing 'dt_evpd' later.      
                        !q          thv_db  = th_db * ( 1._r8 + zvir * qv_db - ql_db - qi_db )
                        !q          if( i_downloading .eq. 1 ) thv_db  = th_db * ( 1._r8 + zvir * qv_db - ql_db - qi_db - qrain_b - qsnow_b )
                        ! July.07.2011. I added (-) sign in front of 'bogbot' and 'bogtop' arguments for downdraft.
                        !               This was the reason why downdraft is so weak in UNICON. 
                        !               This was clearly a bug. 
                        !               Given this correction, I can do more reasonable computation for convective organization.
                        ! Mar.07.2013. For scale-adaptive parameterization, use 'thv_mean_b' instead of 'thv_b'
                        !              in computing 'bogbot' below.
                        ! Mar.11.2013. Note that 'we_b(k)' should be used for convective updraft only.
                        !q          bogbot  = rbuoy_dn * ( 1._r8 - thv_db / thv_mean_b )
                        ! bogbot  = rbuoy_dn * ( 1._r8 - thv_db / thv_b )
                        !q          call progup_wu2( -( rdrag*eps_dn - rjet*del_dn ), rho, p_t, p_b, -bogtop, -bogbot, w_dt**2._r8, 0._r8, wd2 )
                        !q          w_db = max( wdmin, sqrt( max( wd2, nonzero ) ) )             

                        ! ------------------------------------------------------------------------ !            
                        ! Dec.18.2012. Start of 'w_db' iteration loop for computing evaporation of !
                        !              convective precipitation within convective downdraft.       !
                        !              Since 'thl_db,qt_db,tr_db(mt)' are continuously updated and !
                        !              changed within the iteration loop, I should save original   !
                        !              variables before updating.                                  !       
                        !              Note that 'niter_w_db => 2' and with larger niter_w_db, we  !
                        !              can obtain more convergent solution.                        !
                        !              The setting of 'niter_w_db = 1' will exactly reproduce the  !
                        !              previous code without iteration loop.                       ! 
                        !              I think this iteration loop does not take much computation  !
                        !              time.                                                       ! 
                        !              In fact, I can define 'w_db_prov = w_dt' instead of         !
                        !              'w_db_prov = w_db_ori' in the below if block. Then, I       !
                        !              don't need to compute 'w_db_ori' above, and so save some    !
                        !              computation time.                                           !
                        ! Dec.19.2012. I don't define 'qv_db_ori, thv_db_ori..' in the below block !
                        !              since these are not changed in the iteration loop.          !             
                        ! Dec.19.2012. I checked that below exactly reporduces the previous result !
                        !              without iteration when niter_w_db = 1.                      !
                        ! ------------------------------------------------------------------------ !

                        ! ------------------------------------------------------------------------------------------ !
                        ! Mar.15.2013. All materials computing 'evp_qtl, evp_qtr' are incorporated into              !
                        !              the below subroutines of 'evap_prep_dn'.                                      !
                        ! Mar.18.2013. Perform evaporation only for 'mixing' downdraft.                              !
                        ! Apr.09.2013. Add a switch to do an analytical integration of evaporation within downdraft  !
                        !              with 'iprpback = -1'.                                                         !  
                        ! ------------------------------------------------------------------------------------------ !

                        if( ids .eq. 1 ) then

                           if( ievp_prep .ne. -5 ) then
                
                              call evap_prep_dn( z_b, z_t, p_b, p_t, w_dt, bogtop,                                             &
                                       th_db, qv_db, ql_db, qi_db, qs_db, tr_db(1:ncnst), qmin(1:ncnst),                       &
                                       i_downloading, qrain_b, qsnow_b,                                                        &
                                       fevp1_t_rate, fevp2_t_rate, ievp_prep,                                                  &
                                       flxrain_bot_upeesm, flxsnow_bot_upeesm, flxtrrs_bot_upeesm(1:ncnst), a_p_msfc(km,msfc), &
                                       ncnst, ixcldliq, ixcldice, ixnumliq, ixnumice, ndb_evp, cmfdb_evp, i, k, ks, lchnk,     &
                                       rho, thv_mean_b, cmf_db, eps_dn, del_dn,                                                &
                                       kevp_rain_dn, kevp_snow_dn, eta2, rbuoy_dn, rdrag, rjet, nonzero, wdmin,                &
                                       evp_qtl, evp_qti, evp_tr(1:ncnst), fevp1_b_rate, fevp2_b_rate, w_db )

                              ! if( msfc .eq. 1 .and. ks .eq. 15 ) then
                              !     write(6,*) 
                              !     write(6,*) 'UNICON: Check input and output evaporation rates at the top and base interfaces' 
                              !     write(6,*) 'ks, k, fevp1_t_rate, fevp2_t_rate, fevp1_b_rate, fevp2_b_rate   = ', ks, k, fevp1_t_rate, fevp2_t_rate, fevp1_b_rate, fevp2_b_rate
                              !     write(6,*) 'ks, k, flxrain_bot_up, flxsnow_bot_up                           = ', ks, k, flxrain_bot_up, flxsnow_bot_up
                              !     write(6,*) 'ks, k, flxrain_bot_upee, flxsnow_bot_upee                       = ', ks, k, flxrain_bot_upee, flxsnow_bot_upee
                              !     write(6,*) 'ks, k, flxrain_bot_upeesm, flxsnow_bot_upeesm, RH, ql_db, qi_db = ', ks, k, flxrain_bot_upeesm, flxsnow_bot_upeesm, qv_db/qs_db, ql_db, qi_db 
                              !     write(6,*) 'ks, k, p_t, p_b, w_dt, bogtop, w_db, bogbot                     = ', ks, k, p_t, p_b, w_dt, bogtop, w_db, bogbot
                              !     write(6,*)
                              ! endif

                           else

                              ! ---------------------------------------------------------------------------------------------------------  !
                              ! Analytical treatment of evaporation within downdraft                                                       !
                              ! Note that in order to prevent ambiguity due to snow melting, below uses 'flxrain(snow)_bot_upeesm'         !
                              ! instead of 'flxrain(snow)_top' in computing 'f_R,f_S', although the use of 'flxrain(snow)_bot_upeesm'      !
                              ! is still possible since the limiter is imposed based on 'flxrain(snow)_bot_upeesm'.                        !
                              ! IMPORTANT : Due to the constraint of 'evp_max = max( qw_db - qv_db, 0._r8 )', evaporation does not occur   !
                              !             when 'ql_db,qi_qb > 0'. If downdraft is unsaturated at the base interface ( evp_max > 0 ),     !
                              !             evaporation occurs only until it is saturated without generating condensate.                   !
                              !             Thus, the imposed fractional relationship of 'ql / (ql + qi ) = f(T)' from 'conden' is not     !
                              !             broken by the evaporation within downdraft.  Thus, computating 'eff_ql = ql_db - ql_db_adi'    !
                              !             and 'eff_qi = qi_db - qi_db_adi' without considering evaporation within downdraft is correct.  !
                              !             In case of convective updraft when analytical integration is used as in the current code,      !
                              !             however, we should compute these 'effective CEF forcings' using the variables                  !
                              !             including 'precipitation fallout' both adiabatically and diabatically, since analytical        !
                              !             computation of precipitation fall-out will break the imposed fractional relationship           !
                              !             of 'ql / (ql + qi ) = f(T)', so that the restoration of this relationship using 'conden' and   !
                              !             associated heating-cooling process is eventually included as a part of 'CEF' forcing.          !
                              ! ---------------------------------------------------------------------------------------------------------- !

                              call qsat(th_dt*exnf(p_t), p_t, es, qs)
                              f_R       = kevp_rain_dn * sqrt( max( 0._r8, flxrain_bot_upeesm / max( a_p_msfc(km,msfc),nonzero)))
                              f_S       = kevp_snow_dn * sqrt( max( 0._r8, flxsnow_bot_upeesm / max( a_p_msfc(km,msfc),nonzero)))
                              srcg_V    = ( f_R + f_S ) / ( rho * g * max( w_dt, wdmin ) )
                              eps_dia_V = ( f_R + f_S ) / ( rho * g * max( w_dt, wdmin ) * max( qs, nonzero ) ) 
                              qv_med    = qt_med - ql_med - qi_med
                              ssqv_tmp  = ssqt_tmp - ssql_tmp - ssqi_tmp 
                              call progup_thlqt( -eps_dn, -eps_dia_V, srcg_V, p_t, p_b, qv_med, ssqv_tmp, qv_dt, qv_db_adi_evp )
                              qv_db_adi = qt_db - ql_db_adi - qi_db_adi 
                              evp_qt    = max( 0._r8, qv_db_adi_evp - qv_db_adi )
                              evp_qtl   = evp_qt * ( f_R / max( f_R + f_S, nonzero ) )
                              evp_qti   = evp_qt * ( f_S / max( f_R + f_S, nonzero ) )
                              ! ---------------------------------------------------------------------------------- !
                              ! Limiter should be imposed using the thermodynamic properties at the base interface !
                              ! with entrainment dilution but without evaporation effect.                          !
                              ! ---------------------------------------------------------------------------------- !
                            ! evp_qtl   = max( 0._r8, min( evp_qtl, eta2 * flxrain_bot_upeesm / max( nonzero, cmf_db ) / &
                            !             max( 1._r8, real(ndb_evp,r8) ) ) )
                            ! evp_qti   = max( 0._r8, min( evp_qti, eta2 * flxsnow_bot_upeesm / max( nonzero, cmf_db ) / &
                            !             max( 1._r8, real(ndb_evp,r8) ) ) )
                              evp_qtl   = max( 0._r8, min( evp_qtl, eta2 * flxrain_bot_upeesm / max( nonzero, cmfdb_evp ) ) )
                              evp_qti   = max( 0._r8, min( evp_qti, eta2 * flxsnow_bot_upeesm / max( nonzero, cmfdb_evp ) ) )
                              call findsp_single( qv_db, th_db*exnf(p_b), p_b, tw_db, qw_db, i, k, lchnk )
                              evp_max   = max( qw_db - qv_db, 0._r8 )
                              if( ( evp_qtl + evp_qti ) .gt. evp_max ) then
                                 tmp1 = evp_qtl * evp_max / ( evp_qtl + evp_qti )
                                 tmp2 = evp_qti * evp_max / ( evp_qtl + evp_qti )
                                 evp_qtl = tmp1
                                 evp_qti = tmp2
                              endif
                              ! ------------------------------ !
                              ! Treatment of In-Cumulus Tracer !
                              ! ------------------------------ !
                              do mt = 1, ncnst
                                 if( mt .eq. 1 ) then
                                    evp_tr(mt) = evp_qtl + evp_qti
                                 elseif( mt .eq. ixcldliq .or. mt .eq. ixcldice .or. mt .eq. ixnumliq .or. mt .eq. ixnumice ) then
                                    evp_tr(mt) = 0._r8
                                 else
                                    evp_tr(mt) = flxtrrs_bot_upeesm(mt) * ( evp_qtl + evp_qti ) / max( ( flxrain_bot_upeesm + &
                                                 flxsnow_bot_upeesm ) , nonzero )
                                 endif
                                 evp_tr(mt) = max( evp_tr(mt), qmin(mt) - tr_db(mt) )
                              enddo
                              ! ----------------------------------------------------------------------- !
                              ! Compute 'w_db' at the base interface                                    !   
                              ! In the below block, I simply neglect the reduction of 'qrain_b,qsnow_b' !
                              ! due to the evaporation of precipitation within downdraft.               !
                              ! ----------------------------------------------------------------------- !
                              t_tmp     = th_db*exnf(p_b) - ( xlv / cp ) * evp_qtl - ( xls / cp ) * evp_qti
                              qv_tmp    = qv_db + evp_qtl + evp_qti
                              th_tmp    = t_tmp / exnf(p_b)
                              thv_tmp   = th_tmp * ( 1._r8 + zvir * qv_tmp - ql_db - qi_db )
                              if( i_downloading .eq. 1 ) thv_tmp = th_tmp * ( 1._r8 + zvir * qv_tmp - ql_db - qi_db - qrain_b - &
                                                                   qsnow_b )
                              bogbot    = rbuoy_dn * ( 1._r8 - thv_tmp / thv_mean_b )
                              call progup_wu2( -( rdrag*eps_dn - rjet*del_dn ), rho, p_t, p_b, -bogtop, -bogbot, w_dt**2._r8, &
                                               0._r8, wd2 )
                              w_db      = max( wdmin, sqrt( max( wd2, nonzero ) ) )
                              ! ------------------------------------------ !
                              ! Define the values of other null variables. !
                              ! ------------------------------------------ !
                              fevp1_b_rate    = 0._r8 
                              fevp2_b_rate    = 0._r8

                           endif

                        else

                           evp_qtl         = 0._r8 
                           evp_qti         = 0._r8
                           evp_tr(1:ncnst) = 0._r8 
                           fevp1_b_rate    = 0._r8 
                           fevp2_b_rate    = 0._r8

                        endif

                        ! --------------------------------------------------------------------------------------------------- !
                        ! Mar.12.2013.                                                                                        !
                        ! Save the 'original downdraft properties at the base interface' before adding the effect of          !
                        ! evaporation of precipitation (but with the effect of adiabatic mixing with environment from the top ! 
                        ! to the base interface by epsz_dn, delz_dn) into the '_ori' array. This is necessary before doing    !
                        ! iterative computation within downdraft since all the limiters should be imposed on this 'original   !
                        ! downdraft properties at the base interface.                                                         !
                        ! Note that 'w_db_ori' is already computed above.                                                     !
                        ! --------------------------------------------------------------------------------------------------- !       
                        
                        !q        thl_db_ori        =    thl_db
                        !q        qt_db_ori         =     qt_db
                        !q        do mt = 1, ncnst
                        !q           tr_db_ori(mt)  =     tr_db(mt)
                        !q        enddo
                        !q        th_db_ori         =     th_db 
                        !q        qs_db_ori         =     qs_db
                        !q        qv_db_ori         =     qv_db
                        !q        ql_db_ori         =     ql_db
                        !q        qi_db_ori         =     qi_db
                        !q        qw_db_ori         =     qw_db 
                        !q        tw_db_ori         =     tw_db 
                        !q        subsat_db_ori     = subsat_db
                        !q        w_db_ori          =      w_db 

                        !q        do iter_w_db = 1, niter_w_db

                        ! ---------------------------------------------------------------------------------------------------- !
                        ! Note that both below i_evpdown = 0 and i_evpdown = 1 are vertical resolution-insensitive computation !
                        ! when i_evpdown = 0 (1) is used upward-final (centered) differencing as in the current code.          !     
                        ! ---------------------------------------------------------------------------------------------------- !

                        !? In the new code, I will always use 'i_evpdown = 0'. 
                        !? So, in order to save computation time, I commented out below if sentence.
                        
                        !?        if( i_evpdown .eq. 0 )  then

                        ! -------------------------------------------------------------------- !
                        ! Note that 'qw' is computed at the base interface of each layer since !
                        ! evaporation is assumed to occur at the base interface.               !
                        ! -------------------------------------------------------------------- !

                        ! CHECK
                        ! if( get_nstep() .eq. 1 .and. lchnk .eq. 105 .and. i .eq. 8 .and. k .eq. 8 ) then
                        !     write(6,*)
                        !     write(6,*) 'UNICON: Input to findsp_single'
                        !     write(6,*) 'Time step & Column & Layer & Chunk Index: ', get_nstep(), i, k, lchnk
                        !     write(6,*) 'qv, t, p_b = ', qv, th*exnf(p_b), p_b
                        !     write(6,*) 'p_b, thl_dt, qt_dt =', p_b, thl_dt, qt_dt
                        !     write(6,*)
                        ! endif
                        ! CHECK

                        ! May.25.2012. I commented out below block since it is located outside 
                        !              of if block now as above.

                        ! call findsp_single( qv_db, th_db*exnf(p_b), p_b, tw, qw, i, k, lchnk )

                        ! subsat_db = min( 1._r8, max( 0._r8, 1._r8 - qv_db / max( qs_db, nonzero ) ) )

                        !! Apr.21.2010. Also compute provisional ( without evaporation of precipitation at the base interface ) 
                        !!              downdraft vertical velocity at the base interface for use in computing 'dt_evpd' later.      
                        ! thv_db  = th_db * ( 1._r8 + zvir * qv_db - ql_db - qi_db )
                        ! if( i_downloading .eq. 1 ) thv_db  = th_db * ( 1._r8 + zvir * qv_db - ql_db - qi_db - qrain_b - qsnow_b )
                        !! July.07.2011. I added (-) sign in front of 'bogbot' and 'bogtop' arguments for downdraft.
                        !!               This was the reason why downdraft is so weak in UNICON. 
                        !!               This was clearly a bug.
                        !!               Given this correction, I can do more reasonable computation for convective organization.
                        ! bogbot  = rbuoy_dn * ( 1._r8 - thv_db / thv_b )
                        ! call progup_wu2( -( rdrag*eps_dn - rjet*del_dn ), rho, p_t, p_b, -bogtop, -bogbot, w_dt**2._r8, 0._r8, wd2 )
                        ! w_db_adi = max( wdmin, sqrt( max( wd2, nonzero ) ) )             

                        ! -------------------------------------------------------------------------- !
                        ! In order to prevent negative precipitation fluxes at all interfaces below, !
                        ! I should use 'flxrain_min' instead of 'flxrain_ava(k)' in the below.       ! 
                        ! -------------------------------------------------------------------------- !

                        ! Apr.21.2011. As dercribed in the text, evaporation is compute using precipitation flux at
                        !              the base interface, not at the top interface. This will enhance consistency and
                        !              increase evaporation within downdraft, so that downdraft vertical velocity will 
                        !              further increase. For this, we change 'k' to 'km' in the following 4 parts at the
                        !              same time. This change is enough with full consistency without contradiction with
                        !              the other parts of the code.
                        !              (1) 'do kk = 0, k' --> 'do kk = 0, km'
                        !              (2)-(4) in computing tmp1 below, replace 3 'k' by 'km'

                        ! Apr.26.2011. With the improved treatment of evaporation within downdraft with corrective precipitation
                        !              production tendency, we don't need 'flxrain_min,flxsnow_min' anymore. Thus, I removed
                        !              below block. This will additionally save computation time which is good.  

                        ! flxrain_min = 1.e8_r8
                        ! flxsnow_min = 1.e8_r8
                        !! Apr.21.2011. Mod.(1).
                        !! do kk = k,  0, -1
                        ! do kk = km, 0, -1
                        !    flxrain_min = min( flxrain_min, unity * flxrain_ava_msfc(kk,msfc) ) 
                        !    flxsnow_min = min( flxsnow_min, unity * flxsnow_ava_msfc(kk,msfc) ) 
                        ! end do 
                        ! if( flxrain_min .lt. 0._r8 .or. flxsnow_min .lt. 0._r8 ) then
                        !     write(6,*)  flxrain_min, flxsnow_min, kk, msfc
                        !     call endrun('UNICON : Negative flxrain_min and flxsnow_min in treating evaporation of precip within downdraft')
                        ! endif 

                        ! fevp           = ( flxrain_min + flxsnow_min ) / max( nonzero, max( 0._r8, qw - qv_db ) * cmf_dbt )
                        !! fevp           =   eta * min( 1._r8, max( 0._r8, fevp ) )
                        ! fevp           =         min(    1, eta * max( 0._r8, fevp ) )
                        ! evp_qtl        =   fevp * max( 0._r8, qw - qv_db ) * min( 1._r8, flxrain_min / max( nonzero, flxrain_min + flxsnow_min ) )
                        ! evp_qtl        =   evp_qtl * ( p_b - p_t ) / dp0(k)  
                        ! evp_qti        =   fevp * max( 0._r8, qw - qv_db ) * min( 1._r8, flxsnow_min / max( nonzero, flxrain_min + flxsnow_min ) )
                        ! evp_qti        =   evp_qti * ( p_b - p_t ) / dp0(k)  
                        ! Aug.08.2010. Below is the new code.
                        ! Note that I multiplied 0.5_r8, implying that maximally, 50% of precipitation flux can be used for 
                        ! evaporation of precipitation within downdraft. 

                        ! ------------------------------------------------------------------------------------- !
                        ! Here, 'eta1 = residence time ratio * ovc(a_p,a_d)/a_d' and 'eta2 = ovc(a_p,a_d)/a_p'. !
                        ! If we do two iterations by setting niter = 2, we can use the explicitly               !
                        ! computed 'eta1' and 'eta2' from the first iteration instead of specifying them.       !
                        ! Below block is relocated outside of 'if (i_evpdown)' block since it is commonly used. !                          
                        ! ------------------------------------------------------------------------------------- !
                        !! if( iter .eq. 1 ) then
                        !      eta11 = eta1
                        !      eta22 = eta2
                        !! else
                        !!     eta11 = eta1_a(k) 
                        !!     eta22 = eta2_a(k) 
                        !! endif

                        ! I am using 'cmf_db' instead of 'cmf_dbt' for consistency with the 
                        ! computation of 'cmf_ad_dia(k,ks,m,ids)' below. However, since 'cmf_dbt = cmf_db',
                        ! the results will be the same here.            
                        ! As mentioned above, evaporation is assumed to occur at the base interface.
                        ! Below new method using 'tmp1' is the most physical one consistent with the treatment of evaporation of 
                        ! precipitation within environment later. 
                        ! Mar.24.2011. It seems that I should use 'dz / ( 0.5_r8 * ( w_db + w_dt ) )' instead of 'dt'
                        !              as the evaporation time scale. Accordingly, 'fevp' should be revised without the factor
                        !              of '( p_b - p_t ) / dp0(k)'. Since 'w_db' has not been computed at this stage yet, use
                        !              use 'w_dt' for simplicity. Impose a lower limit on the denominator.
                        ! Apr.21.2011. In order to impose consistency as possible as can be, compute 'w_db' without evaporation of
                        !              precipitation at the base, and use '0.5*(w_db+w_dt)' instead of 'w_dt' in computing 'dt_evpd' below.
                        !              The provisional 'w_db' without evaporation of precipitation at the base interface has already been
                        !              computed above. The final 'w_db' including evaporation of precipitation at the base interface will
                        !              be updated later.

                        ! dt_evpd        =   dz / max( 0.5_r8 * ( w_db_adi + w_dt ), wdmin )
                        !! dt_evpd        =   dz / max( w_dt, wdmin )
                        !! dt_evpd        =   dz / ( 0.5_r8 * ( w_db_adi + w_dt ) )
                        !! dt_evpd        =   dt

                        !! Apr.21.2011. Mod.(2)-(4).
                        !! tmp1           =   min( qw - qv_db, dt_evpd * kevp * subsat_db * &
                        !!                         sqrt( max( 0._r8, ( flxrain_ava_msfc(k,msfc) + flxsnow_ava_msfc(k,msfc) ) / max( a_p_prevp_msfc(k,msfc), nonzero ) ) ) )
                        ! tmp1           =   min( qw - qv_db, dt_evpd * kevp * subsat_db * &
                        !                         sqrt( max( 0._r8, ( flxrain_ava_msfc(km,msfc) + flxsnow_ava_msfc(km,msfc) ) / max( a_p_prevp_msfc(km,msfc), nonzero ) ) ) )
                        !! fevp           =   min( eta11 * ( qw - qv_db ), eta22 * ( flxrain_min + flxsnow_min ) / max( nonzero, cmf_db ) ) * ( p_b - p_t ) / dp0(k)   ! Original, non-physical
                        !! fevp           =   min( eta11 * tmp1,           eta22 * ( flxrain_min + flxsnow_min ) / max( nonzero, cmf_db ) ) * ( p_b - p_t ) / dp0(k)   ! Revised , physical.
                        !! Apr.26.2011. In the below 3 equations, I replace 'flxrain_min --> flxrain_ava_msfc(km,msfc)' and 
                        !!             'flxsnow_min --> flxsnow_ava_msfc(km,msfc)' since evaporation within downdraft is more
                        !!              elegantly treated with corrective precipitation production tendency.   
                        ! fevp           =   min( eta11 * tmp1,           eta22 * ( flxrain_ava_msfc(km,msfc) + flxsnow_ava_msfc(km,msfc) ) / max( nonzero, cmf_db ) )   
                        ! evp_qtl        =   fevp * min( 1._r8, flxrain_ava_msfc(km,msfc) / max( nonzero, flxrain_ava_msfc(km,msfc) + flxsnow_ava_msfc(km,msfc) ) )
                        ! evp_qti        =   fevp * min( 1._r8, flxsnow_ava_msfc(km,msfc) / max( nonzero, flxrain_ava_msfc(km,msfc) + flxsnow_ava_msfc(km,msfc) ) )
                        !! Below 3 lines are the old code of the above.
                        !! fevp           =   min( eta11 * tmp1,           eta22 * ( flxrain_min + flxsnow_min ) / max( nonzero, cmf_db ) )                            ! Mar.24.2011 with new 'dt_evpd'.
                        !! evp_qtl        =   fevp * min( 1._r8, flxrain_min / max( nonzero, flxrain_min + flxsnow_min ) )
                        !! evp_qti        =   fevp * min( 1._r8, flxsnow_min / max( nonzero, flxrain_min + flxsnow_min ) )

                        ! Apr.27.2011. Now evaporation of rain and snow are separately treated similar to the evaporation within
                        !              environment. This imposes a full consistency. The whole above block is commented out and
                        !              is re-written here. Also, separately specify 'kevp_rain' and 'kevp_snow'. 
                        !              Similar separate specification is made for evaporation within downdraft.
                        ! May.21.2011. It is still not clear whether I should use 'dt_evpd = dt' or 'dt_evpd = dz / max( 0.5_r8 * ( w_db_adi + w_dt ), wdmin )'.
                        !              We should (1) remove the sensitivity to vertical resolution, and (2) obtain reasonable deep convective activity as well as
                        !              diurnal cycle of precipitation. In case of buosorts_UW, the use of 'cridis=dz_m' was the source of problem inducing
                        !              resolution sensitivity. Similarly, I should use 'dt_evpd = dt' since we are using 'stead-plume' approximation ?
                        !              I should perform sensitivity test on this. Thus, I added another switch 'idt_evpd' below.
                        ! May.22.2011. Comparing with diabatic forcing for convective updraft and from the criteria of
                        !              resolution-insensitive 'S_d(thl),S_d(qt)', it is definitely clear that
                        !              I must use 'idt_evpd = 1 ( dt_evpd = dz / max( 0.5_r8 * ( w_db_adi + w_dt ), wdmin ) )' 
                        !              in order to remove the sensitivity to vertical resolution. 
                        ! Jul.18.2011. It seems that below computation of 'dz / max( 0.5_r8 * ( w_db_adi + w_dt ), wdmin )' imposes a strong
                        !              negative feedback on the amount of evaporation within downdraft. For example, if I increase 'kevp_rain_dn', 
                        !              w_dt increases, which decreases dt_evpd and overall evaporation rate.
                        !              Thus, we may need to appropriately increase ASRG.  
                        ! Apr.10.2012. Add an option to se a fixed downdraft vertical velocity scale for evaporation of precipitation 
                        !              within convective downdraft.
                        ! Mar.11.2013. Below 'dt_evpd' is not used any more since I am using 'fevp1_b_rate, fevp2_b_rate' directly.
                        !              Thus, comment-out below block computing 'dt_evpd'.
                        !              In addition, remove the parameter of 'idt_evpd'. 
                        !p          if( idt_evpd .eq. 0 ) then
                        !p              dt_evpd    =   dt 
                        !p          elseif( idt_evpd .eq. 1 ) then 
                        !p            ! Dec.18.2012. Replace 'w_db_ori' by 'w_db_prov' in the below since I am using iteration loop on this day. 
                        !p            ! dt_evpd    =   dz / max( 0.5_r8 * ( w_db_ori  + w_dt ), wdmin )
                        !p              dt_evpd    =   dz / max( 0.5_r8 * ( w_db_prov + w_dt ), wdmin )
                        !p          elseif( idt_evpd .eq. 2 ) then 
                        !p              dt_evpd    =   dz / wd_evpd
                        !p          endif
                        ! Mar.11.2013. Below limiter of 'fevp0' should be imposed on the original thermodynamic scalar 
                        !              scalar 'qw_db_ori, qv_db_ori', not the iteratively updated scalar 'qv_db'. 
                        !              The same consistent limiter is imposed on the precipitation production within
                        !              convective updraft.
                        !q          fevp0          =   max( qw_db_ori - qv_db_ori, 0._r8 )
                        !?          fevp1          =   dt_evpd * kevp_rain_dn * subsat_db * &
                        !?                             sqrt( max( 0._r8, flxrain_ava_msfc(km,msfc) / max( a_p_prevp_msfc(km,msfc), nonzero ) ) ) 
                        !?          fevp2          =   dt_evpd * kevp_snow_dn * subsat_db * &
                        !?                             sqrt( max( 0._r8, flxsnow_ava_msfc(km,msfc) / max( a_p_prevp_msfc(km,msfc), nonzero ) ) ) 
                        !p          fevp1          =   dt_evpd * kevp_rain_dn * subsat_db * sqrt( max( 0._r8, flxrain_bot_upeesm / max( a_p_msfc(km,msfc), nonzero ) ) ) 
                        !p          fevp2          =   dt_evpd * kevp_snow_dn * subsat_db * sqrt( max( 0._r8, flxsnow_bot_upeesm / max( a_p_msfc(km,msfc), nonzero ) ) ) 
                        ! ------------------------------------------------------------------------------------------------------------------------------------- !
                        ! Mar.11.2013. Below rate computation of 'fevp1_b_rate, fevp2_b_rate' should be done on the updated thermodynamic state variables       !
                        !              at the base interface, i.e., 'subsat_db, w_db' should be computed using the updated state variables.                     !
                        !              With a fairly good programic justification, however, keep 'flxrain_bot_upeesm / max( a_p_msfc(km,msfc)' unchanged during !
                        !              the iterative computation.                                                                                               !
                        ! Units : 'fevp1_b_rate, fevp2_b_rate' [(kg/kg)/Pa] >= 0.                                                                               !
                        !         'fevp1_rate, fevp2_rate'     [(kg/kg)/Pa] >= 0.                                                                               !
                        !         'fevp1, fevp2'               [(kg/kg)]    >= 0.                                                                               !
                        ! Note that at the source level, we have initialized 'fevp1_t_rate = 0. , fevp2_t_rate = 0.' for all 3 different downdraft sources.     !
                        ! This is perfectly reasonable for ids = 2 (top downdraft) since no precipitation flux exists there.                                    !
                        ! In case of ids = 1 (mixing downdraft), this initialization is also perfectly OK since 'fevp1 = fevp2 = 0' due to 'dp = 0' regardless  !
                        ! of how 'fevp1_t_rate, fevp2_t_rate' are initialized. In this case, 'fevp1_b_rate, fevp2_b_rate' are correctly computed and will be    !
                        ! used in the computation from the next layer below.                                                                                    !
                        ! In case of ids = 3 (constraint downdraft), this zero initialization will result in the computation to half of the desirable value     !
                        ! in the source layer. However, since constraint downdraft is numerical downdraft, this underestimation to half in the source layer     !   
                        ! should not be  aproblem at all.                                                                                                       ! 
                        ! ------------------------------------------------------------------------------------------------------------------------------------- !        
                        !q          fevp1_b_rate  =  ( 1._r8 / ( rho * g ) / max( w_db, wdmin ) ) * kevp_rain_dn * subsat_db * sqrt( max( 0._r8, flxrain_bot_upeesm / max( a_p_msfc(km,msfc), nonzero ) ) ) 
                        !q          fevp2_b_rate  =  ( 1._r8 / ( rho * g ) / max( w_db, wdmin ) ) * kevp_snow_dn * subsat_db * sqrt( max( 0._r8, flxsnow_bot_upeesm / max( a_p_msfc(km,msfc), nonzero ) ) ) 
                        !q          fevp1_rate    =    0.5_r8 * ( fevp1_t_rate + fevp1_b_rate )    
                        !q          fevp2_rate    =    0.5_r8 * ( fevp2_t_rate + fevp2_b_rate )   
                        !q          fevp1         =    fevp1_rate * dp
                        !q          fevp2         =    fevp2_rate * dp
                        ! Jul.10.2011. Constraints associated with 'fevp0' is imposed in the following block below. 
                        !              Thus, below two lines are modified without fevp0 and eta11. 
                        !              In addition, 'eta11' is multiplied to 'fevp0' in the following below block.
                        ! Below two lines are original. 
                        ! evp_qtl        =   max( 0._r8, min( eta11 * min( fevp0, fevp1 ), eta22 * flxrain_ava_msfc(km,msfc) / max( nonzero, cmf_db ) ) )
                        ! evp_qti        =   max( 0._r8, min( eta11 * min( fevp0, fevp2 ), eta22 * flxsnow_ava_msfc(km,msfc) / max( nonzero, cmf_db ) ) )
                        ! Below two lines are new made on Jul.10.2011.
                        !?          evp_qtl        =   max( 0._r8, min( fevp1, eta2 * flxrain_ava_msfc(km,msfc) / max( nonzero, cmf_db ) ) )
                        !?          evp_qti        =   max( 0._r8, min( fevp2, eta2 * flxsnow_ava_msfc(km,msfc) / max( nonzero, cmf_db ) ) )
                        !?        ! Note that this stage, ndb_evp > 0. So, below two lines should be OK. 
                        ! Mar.11.2013. Below limiter of 'evp_qtl, evp_qti' should be imposed on the original thermodynamic scalar 
                        !              not the iteratively updated scalar.
                        !              It seems that below 'evp_qtl,evp_qti' already satisfy this requirement.
                        !q          evp_qtl        =   max( 0._r8, min( fevp1, eta2 * flxrain_bot_upeesm / max( nonzero, cmf_db ) / ndb_evp ) )
                        !q          evp_qti        =   max( 0._r8, min( fevp2, eta2 * flxsnow_bot_upeesm / max( nonzero, cmf_db ) / ndb_evp ) )
                        !q!q        evp_qtl        =   max( 0._r8, min( fevp1, eta2 * flxrain_bot_upeesm / max( nonzero, cmfdb_evp ) ) )
                        !q!q        evp_qti        =   max( 0._r8, min( fevp2, eta2 * flxsnow_bot_upeesm / max( nonzero, cmfdb_evp ) ) )
                        ! Jun.10.2011. In order to ensure 'cu_qtr' to be larger than 'qt_b' in the lowest model layer, I can use below
                        !              maximum evaporation formula within convective downdraft. Below two lines should 
                        !              replace the above two lines.
                        !              Note that constraint associated with 'eta11 * fevp0' is made in the separate below block.
                        ! evp_qtl        =   max( 0._r8, eta22 * flxrain_ava_msfc(km,msfc) / max( nonzero, cmf_db ) )
                        ! evp_qti        =   max( 0._r8, eta22 * flxsnow_ava_msfc(km,msfc) / max( nonzero, cmf_db ) )
                        ! ---------------------------------------------------------------------------- !
                        ! Impose final consistency limit similar to the evaporation within environment ! 
                        ! ---------------------------------------------------------------------------- !
                        ! Jul.10.2011.
                        ! Consistent with the above modifications, I multiplied 'eta11' to the 'fevp0' in the below block.
                        ! Feb.06.2013. From today, 'eta11' is always set to be 1, i.e., simply remove eta11. 
                        !q          if( ( evp_qtl + evp_qti ) .gt. fevp0 ) then
                        !q              if( evp_qtl .ge. 0._r8 .and. evp_qti .ge. 0._r8 ) then
                        !q                  tmp1 = evp_qtl * fevp0 / ( evp_qtl + evp_qti )
                        !q                  tmp2 = evp_qti * fevp0 / ( evp_qtl + evp_qti )
                        !q                  evp_qtl = tmp1
                        !q                  evp_qti = tmp2
                        !q              elseif( evp_qtl .lt. 0._r8 ) then
                        !q                  evp_qti = fevp0 - evp_qtl
                        !q              elseif( evp_qti .lt. 0._r8 ) then
                        !q                  evp_qtl = fevp0 - evp_qti
                        !q              else
                        !q                  call endrun('UNICON : Impossible case in Limit 1a of evaporation within downdraft')  
                        !q              endif
                        !q          endif
                        ! ----------------------------------------------------------------------------------------------------- !
                        ! Mar.11.2013.                                                                                          !
                        ! Recompute 'fevp1_rate,fevp2_rate' and 'fevp1_b_rate,fevp2_b_rate' using the limited 'evp_qtl,evp_qti' !
                        ! for use in the next layer below.                                                                      !
                        ! ----------------------------------------------------------------------------------------------------- ! 
                        !q          fevp1_rate   = evp_qtl / max( dp, nonzero )
                        !q          fevp2_rate   = evp_qti / max( dp, nonzero )
                        !q          fevp1_b_rate = 2._r8 * fevp1_rate - fevp1_t_rate
                        !q          fevp2_b_rate = 2._r8 * fevp2_rate - fevp2_t_rate

                        !?
                        !? With the new code, evaporation will be always performed at the base interface.
                        !? So, to save computation time, I commented out below entire block.
                        !?

                        !?        elseif( i_evpdown .eq. 1 ) then

                        ! -------------------------------------------------------------------------------------------------- !
                        ! Continuous analytical treatment of evaporation of precipitation within convective downdraft.       !
                        ! This treatment is exactly consistent with the revised treatment of production rate of convective   !
                        ! precipitation within convective updraft.                                                           !
                        !                                                                                                    !
                        ! 1. Evaporation within convective downdraft is assumed to occur continuously from the top           !
                        !    to the base interface of individual layer.                                                      !
                        ! 2. However, a fractional evaporation rate [kg/kg/s/m] within each layer is assumed to be           !
                        !    a constant given at the top interface (or cumulus top) of individual layer.                     !
                        ! 3. Diabatic tendency of condensate due to EEM ( evaporation due to adiabatic warming and           !  
                        !    lateral mixing, and melting : eff_ql, eff_qi, eff_tr(t=ixnumliq, ixnumice) ) is                 !
                        !    computed by subtracting the values of 'ql,qi' of convective downdraft at the base               !
                        !    interface between 'adiabatic downward variation of thl,qt without evaporation' and              !
                        !    and 'adiabatic downward variation of ql,qi without evaporation'. This computation has           !
                        !    already been done in the default common code above.                                             !
                        ! 4.                                                                                                 !
                        !    Finally, the only thing I should do is that after vertical integration, I should compute        !
                        !    the 'evp_qtl, evp_qti' which is computed by differencing 'prognosed thl,qt from the top         !
                        !    to the base interface only with entrainment mixing' and 'prognozed thl,qt from the top          !
                        !    to the base interface with both entrainment mixing and evaporation of precipitation'.           !
                        !    From the difference of prognosed 'thl,qt' at the base interface, we can only                    !
                        !    compute the sum of 'evp_qt = evp_qtl + evp_qti' and 'evp_thl = evp_thll + evp_thli',            !
                        !    not the individual component. However, by using the following relationship of                   !
                        !       1.  evp_thll       = - ( xlv / cp / exn0(k) ) * evp_qtl                                      !
                        !       2.  evp_thli       = - ( xls / cp / exn0(k) ) * evp_qti                                      !
                        !       3.  evp_thl        = evp_thll + evp_thli                                                     !
                        !       4.  evp_qt         = evp_qtl  + evp_qti                                                      !
                        ! we can extract all the required quantities in a fully consistent and deterministic way.            !
                        ! That is, we can use the below drived formula for the full consistency:                             !
                        !       tmp1 = 1._r8 / ( ( xls / cp / exn0(k) ) - ( xlv / cp / exn0(k) ) )                           ! 
                        !       evp_qtl =   tmp1 * ( evp_thl + ( xlv / cp / exn0(k) ) * evp_qt )                             !
                        !       evp_qti = - tmp1 * ( evp_thl + ( xls / cp / exn0(k) ) * evp_qt )                             !
                        ! I checked that the above 3 equations of 'tmp1, evp_qtl, evp_qti' exactly satisfies the             !
                        ! the above 4 relations of 1-4.                                                                      ! 
                        !                                                                                                    !
                        ! Important : In order to be consstent with the original discrete computation of evaporation         !
                        !             within convective downdraft, 'thl_db,qt_db,tr_db(mt)' after this block should          ! 
                        !             be defined as the ones NOT containing 'evp_qtl,evp_qti,evp_thll,evp_thli,evp_tr(mt)'   !
                        !             since these evaporation effects will be added in the next below block.                 !
                        !             In other word, 'thl_db,qt_db,tr_db(mt)' at the end of below block should only          !
                        !             contain the adiabatic mixing effect and 'EEM' effect (eff_ql,eff_qi,eff_tr(mt))'       !
                        !             which have already been computed in the above common block.                            !
                        ! In summary, what I should do in this entire block is to cimply compute 'evp_qt, evp_thl'           !
                        ! and corresponding 'evl_qtl,'evp_qti' and passed them into the next block below.                    !
                        ! -------------------------------------------------------------------------------------------------- ! 

                        ! ---------------------------------------------------------------------------------------- !
                        ! Compute analytical integration from the top to the bottom of convective downdraft        !
                        ! in each layer.                                                                           !
                        ! Note that resulting 'evp_qt > 0, evp_thl < 0' and 'evp_qtl,evp_qti' should be positive.  !
                        ! In order to minimize the possibility of condensate generation, I need both above and     !
                        ! below constraints on 'evp_qtl,evp_qti'.                                                  !
                        ! However, I may not need the above constraints on 'fevp0, eta22' since 'eta22' is treated !
                        ! below while 'fevp0' is not really necessary since downdraft is moving down instead of    !
                        ! being stationary at one spot.                                                            !
                        ! Note that I used '0.5_r8 * ( cmf_dt + cmf_db )' in the below final computation of        !
                        ! evp_qtl and evp_qti in order to impose a consistency with the computation of cmf_ad_dia  !
                        ! which is defined as '0.5_r8 * ( cmf_dt + cmf_db )' later.                                !
                        ! I should think more about on what is the best way to impose a constraint on the evp_qtl  !
                        ! and evp_qti.                                                                             ! 
                        ! In order to minimize sensitivity to vertical resolution, I can use twice iteration loop  !
                        ! similar to the treatment of precipitation production in the convective updraft.          !
                        ! For ceoceptual clarity and consistent with the updraft of precipitation flux at all      !
                        ! interfaces later, I should use 'flxrain_ava_msfc(km,msfc) and a_p_prevp_msfc(km,msfc)'   !
                        ! not at the '(k,msfc)' interface, even though this matches with the computation of        !
                        ! subsat at the top interface at jj=1.                                                     !                                        
                        ! ---------------------------------------------------------------------------------------- !

                        ! May.25.2012. Below is the most perfect treatment fully consistent and symmetric with the
                        !              treatment of precipitation production within convective updraft, 
                        !              with minimum sensitivity to the vertical resolution, and
                        !              with correct appropriate limiters.
                        ! Dec.18.2012. Replace 'w_db_adi' by 'w_db_prov' in the below 'f_Rb, f_Sb' since 
                        !              I am using an iteration loop on this day. 

                        !?          f_Rt    =  ( 1._r8 / ( max( w_dt, wdmin ) * rho * g ) ) * kevp_rain_dn * subsat_dt * &
                        !?                       sqrt( max( 0._r8, flxrain_ava_msfc(k,msfc) / max( a_p_prevp_msfc(k,msfc), nonzero ) ) ) ! [ kg/kg/Pa ]
                        !?          f_St    =  ( 1._r8 / ( max( w_dt, wdmin ) * rho * g ) ) * kevp_snow_dn * subsat_dt * &
                        !?                       sqrt( max( 0._r8, flxsnow_ava_msfc(k,msfc) / max( a_p_prevp_msfc(k,msfc), nonzero ) ) ) ! [ kg/kg/Pa ]
                        
                        !?          f_Rb    =  ( 1._r8 / ( max( w_db_prov, wdmin ) * rho * g ) ) * kevp_rain_dn * subsat_db * &
                        !?                       sqrt( max( 0._r8, flxrain_ava_msfc(km,msfc) / max( a_p_prevp_msfc(km,msfc), nonzero ) ) ) ! [ kg/kg/Pa ]
                        !?          f_Sb    =  ( 1._r8 / ( max( w_db_prov, wdmin ) * rho * g ) ) * kevp_snow_dn * subsat_db * &
                        !?                       sqrt( max( 0._r8, flxsnow_ava_msfc(km,msfc) / max( a_p_prevp_msfc(km,msfc), nonzero ) ) ) ! [ kg/kg/Pa ]
                        
                        !?        ! f_Rb    =  ( 1._r8 / ( max( w_db_adi, wdmin ) * rho * g ) ) * kevp_rain_dn * subsat_db * &
                        !?        !              sqrt( max( 0._r8, flxrain_ava_msfc(km,msfc) / max( a_p_prevp_msfc(km,msfc), nonzero ) ) ) ! [ kg/kg/Pa ]
                        !?        ! f_Sb    =  ( 1._r8 / ( max( w_db_adi, wdmin ) * rho * g ) ) * kevp_snow_dn * subsat_db * &
                        !?        !              sqrt( max( 0._r8, flxsnow_ava_msfc(km,msfc) / max( a_p_prevp_msfc(km,msfc), nonzero ) ) ) ! [ kg/kg/Pa ]
                        
                        !?          f_Rt    =  ( 1._r8 / ( max( w_dt, wdmin ) * rho * g ) ) * kevp_rain_dn * subsat_dt * &
                        !?                       sqrt( max( 0._r8, flxrain_top / max( a_p_msfc(k,msfc), nonzero ) ) ) ! [ kg/kg/Pa ]
                        !?          f_St    =  ( 1._r8 / ( max( w_dt, wdmin ) * rho * g ) ) * kevp_snow_dn * subsat_dt * &
                        !?                       sqrt( max( 0._r8, flxsnow_top / max( a_p_msfc(k,msfc), nonzero ) ) ) ! [ kg/kg/Pa ]
                        
                        !?          f_Rb    =  ( 1._r8 / ( max( w_db_prov, wdmin ) * rho * g ) ) * kevp_rain_dn * subsat_db * &
                        !?                       sqrt( max( 0._r8, flxrain_bot_upeesm / max( a_p_msfc(km,msfc), nonzero ) ) ) ! [ kg/kg/Pa ]
                        !?          f_Sb    =  ( 1._r8 / ( max( w_db_prov, wdmin ) * rho * g ) ) * kevp_snow_dn * subsat_db * &
                        !?                       sqrt( max( 0._r8, flxsnow_bot_upeesm / max( a_p_msfc(km,msfc), nonzero ) ) ) ! [ kg/kg/Pa ]

                        !?        ! f_Rb    =  ( 1._r8 / ( max( w_db_adi, wdmin ) * rho * g ) ) * kevp_rain_dn * subsat_db * &
                        !?        !              sqrt( max( 0._r8, flxrain_bot_upeesm / max( a_p_msfc(km,msfc), nonzero ) ) ) ! [ kg/kg/Pa ]
                        !?        ! f_Sb    =  ( 1._r8 / ( max( w_db_adi, wdmin ) * rho * g ) ) * kevp_snow_dn * subsat_db * &
                        !?        !              sqrt( max( 0._r8, flxsnow_bot_upeesm / max( a_p_msfc(km,msfc), nonzero ) ) ) ! [ kg/kg/Pa ]
                        
                        ! Below choice of 'f_R,f_S' should go with the corresponding choice of 'evp_qtl,evp_qti'.  
                        !?          f_R     =  f_Rt
                        !?          f_S     =  f_St
                        !?        ! f_R     =  0.5_r8 * ( f_Rt + f_Rb ) 
                        !?        ! f_S     =  0.5_r8 * ( f_St + f_Sb ) 

                        !?          dia_qt  =   f_R + f_S
                        !?          dia_thl = - ( ( xlv / cp / exn0(k) ) * f_R + ( xls / cp / exn0(k) ) * f_S ) 
                        
                        ! Apr.18.2012. I double-checked that below 'progup_thlqt' with 'dia_thl,dia_qt' correctly work and 
                        !              produces the right values with the right signs.
                        !              That is, the sign of 'dia_qt,dia_thl' is correct. 
                        ! Nov.15.2012. Change 'qt_db' into 'qt_db_ori' in the below two lines pf tmp1.
                        !              ? Shouldn't I use 'qv_db' in the second tmp1 instead ?

                        !?          call progup_thlqt( -eps_dn, dia_thl, p_t, p_b, thl_med, ssthl_tmp, thl_dt, tmp_thl )
                        !?          call progup_thlqt( -eps_dn, dia_qt,  p_t, p_b, qt_med,  ssqt_tmp,  qt_dt,  tmp_qt  )
                        !?          tmp1 = max( tmp_qt - qt_db_ori, 0._r8)                        ! This should be positive by construction. I should check this. 
                        !?          tmp1 = min( tmp1, max( qw - qt_db_ori, 0._r8 ) )              ! To impose a continuous variation across qt_db = qw.
                        !?          evp_qtl = tmp1 * ( f_R / max( f_R + f_S, nonzero ) ) 
                        !?          evp_qti = tmp1 * ( f_S / max( f_R + f_S, nonzero ) ) 

                        ! Below choice of 'evp_qtl,evp_qti' should go with the corresponding choice of 'f_R,f_S'.  

                        !?          evp_qtl = max( 0._r8, min( evp_qtl, eta22 * ( flxrain_ava_msfc(k,msfc) / max( nonzero, cmf_dt ) ) ) )
                        !?          evp_qti = max( 0._r8, min( evp_qti, eta22 * ( flxsnow_ava_msfc(k,msfc) / max( nonzero, cmf_dt ) ) ) )
                        !?        ! evp_qtl = max( 0._r8, min( evp_qtl, eta22 * ( ( flxrain_ava_msfc(k,msfc) + flxrain_ava_msfc(km,msfc) ) / max( nonzero, cmf_dt + cmf_db ) ) ) )
                        !?        ! evp_qti = max( 0._r8, min( evp_qti, eta22 * ( ( flxsnow_ava_msfc(k,msfc) + flxsnow_ava_msfc(km,msfc) ) / max( nonzero, cmf_dt + cmf_db ) ) ) )
                        
                        !?          evp_qtl = max( 0._r8, min( evp_qtl, eta22 * ( flxrain_top / max( nonzero, cmf_dt ) ) ) )
                        !?          evp_qti = max( 0._r8, min( evp_qti, eta22 * ( flxsnow_top / max( nonzero, cmf_dt ) ) ) )
                        !?        ! evp_qtl = max( 0._r8, min( evp_qtl, eta22 * ( ( flxrain_top + flxrain_bot_upeesm ) / max( nonzero, cmf_dt + cmf_db ) ) ) )
                        !?        ! evp_qti = max( 0._r8, min( evp_qti, eta22 * ( ( flxsnow_top + flxsnow_bot_upeesm ) / max( nonzero, cmf_dt + cmf_db ) ) ) )

                        ! Previous 2. Below is the new.
                        
                        ! do jj = 1, 1
                        !    if( jj .eq. 1 ) then
                        !        subsat = min( 1._r8, max( 0._r8, 1._r8 - qv_dt / max( qs_dt, nonzero ) ) )
                        !    else
                        !        call conden( p_b, tmp1, tmp2, th, qv, ql, qi, qse, id_check )
                        !        if( id_check .eq. 1 ) then
                        !            id_exit = .true.
                        !            go to 333
                        !        endif
                        !        subsat = 0.5_r8 * ( subsat + min( 1._r8, max( 0._r8, 1._r8 - qv / max( qse, nonzero ) ) ) )
                        !    endif
                        !    tmp_l   =  ( 1._r8 / ( max( w_dt, wdmin ) * rho * g ) ) * kevp_rain_dn * subsat * &
                        !               sqrt( max( 0._r8, flxrain_ava_msfc(km,msfc) / max( a_p_prevp_msfc(km,msfc), nonzero ) ) ) ! [ kg/kg/Pa ]
                        !    tmp_i   =  ( 1._r8 / ( max( w_dt, wdmin ) * rho * g ) ) * kevp_snow_dn * subsat * &
                        !               sqrt( max( 0._r8, flxsnow_ava_msfc(km,msfc) / max( a_p_prevp_msfc(km,msfc), nonzero ) ) ) ! [ kg/kg/Pa ]
                        !    dia_qt  =   tmp_l + tmp_i
                        !    dia_thl = - ( ( xlv / cp / exn0(k) ) * tmp_l + ( xls / cp / exn0(k) ) * tmp_i ) 
                        !  ! Apr.18.2012. I double-checked that below 'progup_thlqt' with 'dia_thl,dia_qt' correctly work and produces right values. with right sign.
                        !  !              that is, the sign of 'dia_qt,dia_thl' is correct. 
                        !    call progup_thlqt( -eps_dn, dia_thl, p_t, p_b, thl_med, ssthl_tmp, thl_dt, tmp1 )
                        !    call progup_thlqt( -eps_dn, dia_qt,  p_t, p_b, qt_med,  ssqt_tmp,  qt_dt,  tmp2 )
                        ! enddo

                        ! Previous 1. Below is the previous old.

                        ! if( idt_evpd .eq. 0 ) then
                        !     dt_evpd    =   dt 
                        ! elseif( idt_evpd .eq. 1 ) then 
                        !     dt_evpd    =   dz / max( w_dt, wdmin )
                        ! elseif( idt_evpd .eq. 2 ) then 
                        !     dt_evpd    =   dz / wd_evpd
                        ! endif
                        ! do jj = 1, 1
                        !    if( jj .eq. 1 ) then
                        !        call findsp_single( qv_dt, th_dt*exnf(p_t), p_t, tw, qw, i, k, lchnk )
                        !        subsat = min( 1._r8, max( 0._r8, 1._r8 - qv_dt / max( qs_dt, nonzero ) ) )
                        !        fevp0  = max( qw - qv_dt, 0._r8 )
                        !    else
                        !        call conden( p_b, tmp1, tmp2, th, qv, ql, qi, qse, id_check )
                        !        if( id_check .eq. 1 ) then
                        !            id_exit = .true.
                        !            go to 333
                        !        endif
                        !        call findsp_single( qv, th*exnf(p_b), p_b, tw, qw, i, k, lchnk )
                        !        subsat = 0.5_r8 * ( subsat + min( 1._r8, max( 0._r8, 1._r8 - qv / max( qse, nonzero ) ) ) )
                        !        fevp0  = 0.5_r8 * ( fevp0 + max( qw - qv, 0._r8 ) )
                        !    endif
                        !    fevp1   =  dt_evpd * kevp_rain_dn * subsat * &
                        !               sqrt( max( 0._r8, flxrain_ava_msfc(km,msfc) / max( a_p_prevp_msfc(km,msfc), nonzero ) ) ) 
                        !    fevp2   =  dt_evpd * kevp_snow_dn * subsat * &
                        !               sqrt( max( 0._r8, flxsnow_ava_msfc(km,msfc) / max( a_p_prevp_msfc(km,msfc), nonzero ) ) ) 
                        !    evp_qtl =  max( 0._r8, min( fevp1, eta22 * flxrain_ava_msfc(km,msfc) / max( nonzero, 0.5_r8 * ( cmf_dt + cmf_db ) ) ) )
                        !    evp_qti =  max( 0._r8, min( fevp2, eta22 * flxsnow_ava_msfc(km,msfc) / max( nonzero, 0.5_r8 * ( cmf_dt + cmf_db ) ) ) )
                        !    if( ( evp_qtl + evp_qti ) .gt. eta11 * fevp0 ) then
                        !        if( evp_qtl .ge. 0._r8 .and. evp_qti .ge. 0._r8 ) then
                        !            tmp1 = evp_qtl * eta11 * fevp0 / ( evp_qtl + evp_qti )
                        !            tmp2 = evp_qti * eta11 * fevp0 / ( evp_qtl + evp_qti )
                        !            evp_qtl = tmp1
                        !            evp_qti = tmp2
                        !        elseif( evp_qtl .lt. 0._r8 ) then
                        !            evp_qti = eta11 * fevp0 - evp_qtl
                        !        elseif( evp_qti .lt. 0._r8 ) then
                        !            evp_qtl = eta11 * fevp0 - evp_qti
                        !        else
                        !            call endrun('UNICON : Impossible case in Limit 1a of evaporation within downdraft')  
                        !        endif
                        !    endif
                        !    dia_qt  =   ( evp_qtl + evp_qti ) / max( dp, nonzero )
                        !    dia_thl = - ( ( xlv / cp / exn0(k) ) * evp_qtl + ( xls / cp / exn0(k) ) * evp_qti ) / max( dp, nonzero )
                        !  ! Apr.18.2012. I double-checked that below 'progup_thlqt' with 'dia_thl,dia_qt' correctly work and produces right values. with right sign.
                        !  !              that is, the sign of 'dia_qt,dia_thl' is correct. 
                        !    call progup_thlqt( -eps_dn, dia_thl, p_t, p_b, thl_med, ssthl_tmp, thl_dt, tmp1 )
                        !    call progup_thlqt( -eps_dn, dia_qt,  p_t, p_b, qt_med,  ssqt_tmp,  qt_dt,  tmp2 )
                        ! enddo

                        ! ------------------------------------------------------------------------------------------------- !  
                        ! If everything is correct it should be 'evp_qt > 0, evp_thl < 0', which however is not guaranteed. !
                        ! Thus, inevitably, I should impose a limit.                                                        !
                        ! In the below, 'thl_db,qt_db' contains 'mixing' and 'EEM', but not the evaporation of convective   !
                        ! precipitation.                                                                                    !
                        ! I should carefully check whether my below limiters reasonably work.                               !
                        ! I don't have a full confidence on my method to extract 'evp_qtl,evp_qti' from 'evp_qt,evp_thl'.   !
                        ! I can test alternative option below.                                                              !
                        ! ------------------------------------------------------------------------------------------------- !
                        ! evp_thl = min( 0._r8, tmp1 - thl_db )
                        ! evp_qt  = max( 0._r8, tmp2 -  qt_db )
                        ! evp_qt  = min( evp_qt, eta22 * ( flxrain_ava_msfc(km,msfc) + flxsnow_ava_msfc(km,msfc) ) / max( nonzero, 0.5_r8 * ( cmf_dt + cmf_db ) ) )
                        !! OPTION.1.
                        !! tmp3    =   1._r8 / ( ( xls / cp / exn0(k) ) - ( xlv / cp / exn0(k) ) )  
                        !! evp_qtl =   tmp3 * ( evp_thl + ( xls / cp / exn0(k) ) * evp_qt )
                        !! evp_qti = - tmp3 * ( evp_thl + ( xlv / cp / exn0(k) ) * evp_qt )
                        !! OPTION.2.
                        ! evp_qtl =   evp_qt * max ( 0._r8, sqrt(flxrain_ava_msfc(km,msfc)) / max( nonzero, sqrt(flxrain_ava_msfc(km,msfc)) + sqrt(flxsnow_ava_msfc(km,msfc)) ) )   
                        ! evp_qti =   evp_qt * max ( 0._r8, sqrt(flxsnow_ava_msfc(km,msfc)) / max( nonzero, sqrt(flxrain_ava_msfc(km,msfc)) + sqrt(flxsnow_ava_msfc(km,msfc)) ) )   
                        !! END OF OPTIONS. 
                        ! evp_qtl =   max( 0._r8, min( evp_qtl, eta22 * flxrain_ava_msfc(km,msfc) / max( nonzero, 0.5_r8 * ( cmf_dt + cmf_db ) ) ) )
                        ! evp_qti =   max( 0._r8, min( evp_qti, eta22 * flxsnow_ava_msfc(km,msfc) / max( nonzero, 0.5_r8 * ( cmf_dt + cmf_db ) ) ) )
                        ! CHECK
                        ! if( evp_qt .lt. 0._r8 .or. evp_thl .gt. 0._r8 .or. evp_qtl .lt. 0._r8 .or. evp_qti .lt. 0._r8  ) then
                        !     write(6,*)
                        !     write(6,*) 'UNICON: Negative evaporation within convective downdraft'
                        !     write(6,*) 'Time step, Colume, Layer Index = ', get_nstep(), i, k
                        !     write(6,*) 'evp_qt, evp_thl, evp_qtl, evp_qti = ', evp_qt, evp_thl, evp_qtl, evp_qti
                        !     write(6,*)
                        ! endif
                        ! CHECK

                        !?        endif ! End of 'i_evpdown' option.

                        ! ------------------------------------------------------------------------------------------------------ !
                        ! Aug.04.2012.                                                                                           !
                        ! Only perform evaporation within mixing downdraft (1) since area downdraft is not a physical downdraft, !
                        ! (2) top downdraft is likely to be saturated if precipitation exist,                                    !
                        ! (3) to provide more evaporation source to the physical mixing downdraft.                               ! 
                        ! In future, in order to save computation time, this can be located outside of 'if (i_evpdown)' block    !
                        ! as another outer if block, which should be done later.                                                 ! 
                        ! ------------------------------------------------------------------------------------------------------ !

                        ! if( ids .eq. 2 .or. ids .eq. 3 ) then
                        !     evp_qtl = 0._r8
                        !     evp_qti = 0._r8
                        ! endif

                        ! --------------------------------------------------------------------------------------- !
                        ! TRACERS REFINEMENT NECESSARY : EVAPORATION OF CONVECTIVE PRECIPITATION WITHIN DOWNDRAFT !
                        ! --------------------------------------------------------------------------------------- !
                        !q          do mt = 1, ncnst 
                        ! Nov.29.2012. Below should be treated with appropriate non-zero. For this, we need information on the
                        !              tracer concentration within precipitation flux, not within convective downdraft. So, we
                        !              should track tracer concentration within precipitation flux.
                        !              Strictly speaking, below is valid only when 'i_evpdown = 0' since below formula is using precipitation
                        !              flux defined at the base interface, k = km. When precipitation flux becomes zero at the base interface,
                        !              evp_qtl + evp_qti also becomes zero. Thus, below formula is perfectly correct.
                        !              Note that similar proportional formula is used in computing evaporation of precipitation within 
                        !              environment.
                        ! Dec.01.2012. Note that below 'evp_tr' similar to other variable (e.g., prep_tr) is for computing the properties within
                        !              downdraft not within precipitation. For precipitation, evaporation can also change the number concentration
                        !              of precipitation droplet, which will be computed separately using the specified droplet radius of rain and
                        !              snow without using 'evp_tr(ixnumliq,ixnumice)=0' computed below.
                        ! Dec.13.2012. For more clearness, add separate treatment for 'mt = 1, ixcldliq, ixcldice', which however, does not
                        !              change any simulation since tracers corresponding to 'mt = 1, ixcldliq, ixcldice' are already treated
                        !              as a separate variables.   
                        !              I can also change the other part of the code for conceptual clearness although it does not change
                        !              simulation answers.
                        !q             if( mt .eq. 1 ) then
                        !q                 evp_tr(mt) = evp_qtl + evp_qti 
                        !q             elseif( mt .eq. ixcldliq .or. mt .eq. ixcldice .or. mt .eq. ixnumliq .or. mt .eq. ixnumice ) then
                        !q                 evp_tr(mt) = 0._r8
                        !q             else
                        !?                 evp_tr(mt) = flxtrrs_ava_msfc(km,msfc,mt) * ( evp_qtl + evp_qti ) / max( ( flxrain_ava_msfc(km,msfc) + flxsnow_ava_msfc(km,msfc) ) , nonzero ) 
                        !q                 evp_tr(mt) = flxtrrs_bot_upeesm(mt) * ( evp_qtl + evp_qti ) / max( ( flxrain_bot_upeesm + flxsnow_bot_upeesm ) , nonzero ) 
                        !q             endif
                        ! Below is original old code.
                        ! evp_tr(mt) = 0._r8
                        ! Nov.27.2012. Impose a constraint on the diabatic forcing to prevent the onset of negative tracer during downward motion.
                        !              This constraint is imposed by using 'tr_db(mt) + evp_tr(mt) > qmin(mt)' criteria,
                        !              where 'tr_db(mt)' is a tracer at the base interface before adding diabatic forcing.
                        !              Note that evaporation of precipitation that happens until downdraft is saturated does not change
                        !              droplet mass and droplet number. 
                        ! Dec.18.2012. In association with the use of 'iter_w_db' loop, I replaced 'tr_db' by 'tr_db_ori'
                        !              in the below line.
                        !q             evp_tr(mt) = max( evp_tr(mt), qmin(mt) - tr_db_ori(mt) )   
                        ! evp_tr(mt) = max( evp_tr(mt), qmin(mt) - tr_db(mt) )   
                        !q          enddo
                        ! --------------------------------------------------------------------------------------- !
                        ! TRACERS REFINEMENT NECESSARY : EVAPORATION OF CONVECTIVE PRECIPITATION WITHIN DOWNDRAFT !
                        ! --------------------------------------------------------------------------------------- !
                        ! Apr.21.2011. Remove below block and 'idias_off' switch since it should be always 'idias_off .eq. 0'.
                        ! if( idias_off .eq. 1 .and. k .eq. ks ) then
                        !     evp_qtl = 0._r8
                        !     evp_qti = 0._r8
                        !     do mt = 1, ncnst 
                        !        evp_tr(mt) = 0._r8
                        !     enddo
                        ! endif
                        ! Sep.29.2011. To supress energy conservation error by imposing consistency with the exn0(k)
                        !              used in the computation of slten_u(k) and slten_d(k), I am using exn0(k)
                        !              in the below lines. However, for computing updated 'thl_aut' at the top
                        !              interface, I am using the correct exner function at the top interface.
                        !              this will impose a full consistency throughout the whole code. 
                        ! Mar.22.2013. However, below use of 'exn0(k)' causes slight mismatch between the 'w_db' computed from
                        !              the subroutine 'evap_prep_dn' and 'w_db' computed from further below for mixing downdraft.
                        !              While this is not a big issue, we can impose a more cleaner consistency. 
                        ! Below is the new code.
                        evp_thll       = - ( xlv / cp / exn0(k) ) * evp_qtl
                        evp_thli       = - ( xls / cp / exn0(k) ) * evp_qti
                        ! tmp1           = - ( xlv / cp / exn_b ) * evp_qtl
                        ! tmp2           = - ( xls / cp / exn_b ) * evp_qti
                        ! Below is the old code.
                        ! evp_thll       = - ( xlv / cp / exn_b ) * evp_qtl
                        ! evp_thli       = - ( xls / cp / exn_b ) * evp_qti
                        ! Sep.30.2010. On the R.H.S. of the below block, '_dt' is changed to '_db'.
                        !              since I have computed '_dt' above by considering entrainment
                        !              dilution on the downdraft.
                        ! Sep.29.2011. See above. Below is the new code.
                        ! thl_db         =   thl_db + tmp1 + tmp2
                        ! Below is the old code.
                        ! Mar.30.2011. I decided to consistently use exn0(k) because diabatic forcing is a concept of 
                        !              average over the grid layer. 
                        ! ---------------------------------------------------------------------------------- !
                        ! Jun.15.2012. I must check that whether below updated 'thl_db,qt_db' are the same   !
                        !              as the 'tmp_thl,tmp_qt' computed above when 'i_evpdown .eq. 1' is     !
                        !              chosen above. It should be identical since there are conservative     !
                        !              scalars.                                                              !
                        !              Because of limiter of 'tmp1 = min( tmp1, max( qw - qt_db, 0._r8 ) )'  !
                        !              they may be different which is not a problem at all. If no limiter    !
                        !              is applied, they will be identical by construction.                   !
                        ! Dec.18.2012. In association with the use of 'iter_w_db' loop, 'thl_db,qt_db,tr_db' !
                        !              in the below block is replaced by 'thl_db_ori,....'.                  !
                        !              Note that only modification in the below block is enough.             !
                        ! Mar.15.2013. Restore to non-_'ori' variables since subroutine 'evap_prep_dn' now   !
                        !              handle evaporation within downdraft.                                  !     
                        ! ---------------------------------------------------------------------------------- !
                        ! thl_db         =   thl_db_ori + evp_thll + evp_thli
                        ! qt_db          =   qt_db_ori  +  evp_qtl +  evp_qti
                        ! do mt = 1, ncnst
                        !    tr_db(mt)   =   tr_db_ori(mt) + evp_tr(mt)
                        ! enddo 
                        ! Below is the old code before Dec.18.2012 before 'iter_w_db' iteration loop.
                        thl_db         =   thl_db + evp_thll + evp_thli
                        qt_db          =   qt_db  +  evp_qtl +  evp_qti
                        do mt = 1, ncnst
                           tr_db(mt)   =   tr_db(mt) + evp_tr(mt)
                        enddo
                        ! TEST
                        ! if( i_evpdown .eq. 1 ) then
                        !     if( abs(thl_db - tmp_thl) .gt. 1.e-3_r8 .or. abs(qt_db - tmp_qt) .gt. 1.e-6_r8 ) then
                        !         write(6,*)
                        !         write(6,*) 'UNICON: thl_db (qt_db) and tmp_thl (tmp_qt) significantly differs'
                        !         write(6,*) 'thl_db, tmp_thl, qt_db, tmp_qt = ', thl_db, tmp_thl, qt_db, tmp_qt
                        !         write(6,*)
                        !     endif
                        ! endif
                        ! TEST

                        ! ----------------------------------------------------------------------------------------------- !
                        ! Mar.11.2013. The 'w_db' iteration loop can be ended here since we are only treating evaporation !
                        !              not precipitation within downdraft. However, since precipitation production within !
                        !              downdraft is neglected, it does not matter.                                        !
                        ! ----------------------------------------------------------------------------------------------- !

                        ! ----------------------------------------------------- !
                        ! 2. Precipitation Fallout : Neglected in the downdraft !
                        ! ----------------------------------------------------- !
                        prep_qtl  = 0._r8
                        prep_qti  = 0._r8
                        ! Sep.29.2011. To supress energy conservation error by imposing consistency with the exn0(k)
                        !              used in the computation of slten_u(k) and slten_d(k), I am using exn0(k)
                        !              in the below lines. However, for computing updated 'thl_aut' at the top
                        !              interface, I am using the correct exner function at the top interface.
                        !              this will impose a full consistency throughout the whole code. 
                        ! Below is the new code.
                        prep_thll = - ( xlv / cp / exn0(k) ) * prep_qtl
                        prep_thli = - ( xls / cp / exn0(k) ) * prep_qti
                        ! tmp1      = - ( xlv / cp / exn_b ) * prep_qtl
                        ! tmp2      = - ( xls / cp / exn_b ) * prep_qti
                        ! Below is the old code.
                        ! prep_thll = - ( xlv / cp / exn_b ) * prep_qtl
                        ! prep_thli = - ( xls / cp / exn_b ) * prep_qti
                        ! -------------------------------------------------------------------------- !
                        ! TRACERS REFINEMENT NECESSARY : PRECIPITATION FALLOUT AT THE BASE INTERFACE !
                        ! -------------------------------------------------------------------------- !
                        ! Nov.08.2011. Critical bug fix. I should correctly handle the droplet number concentration in order
                        !              to prevent generating unreasonable source of droplet number which was the case in the
                        !              previous wrong code.
                        ! Nov.28.2012. Since precipitation is simply neglected within downdraft, keeping previous old
                        !              code is not a problem at all. But in future, even without precipitation fallout
                        !              within downdraft, below can be refined in a more clear form.
                        !              However, since downdraft can have droplet radius differeent from 'droprad_liq',
                        !              below formula is wrong, although it does not influence simulation results. 
                        !              For clearness, I commented out below 6 lines in the if block.
                        ! Nov.29.2012. Let's keep below entire if block since a specified droprad is assumed both within updraft and downdraft.
                        ! Dec.13.2012. For more clearness, add separate treatment for 'mt = 1, ixcldliq, ixcldice', which however, does not
                        !              change any simulation since tracers corresponding to 'mt = 1, ixcldliq, ixcldice' are already treated
                        !              as a separate variables.   
                        ! Feb.06.2013. In future, I should include wet deposition of aerosols (both interstitial and cloud-borne) 
                        !              within convective downdraft into the below prep_tr(mt) 

                        do mt = 1, ncnst
                           if( mt .eq. 1 ) then
                              prep_tr(mt) = 0._r8
                           elseif( mt .eq. ixcldliq ) then
                              prep_tr(mt) = prep_qtl
                           elseif( mt .eq. ixcldice ) then 
                              prep_tr(mt) = prep_qti
                           elseif( mt .eq. ixnumliq ) then
                              prep_tr(mt) = prep_qtl * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_liq**3 * density_liq ) 
                           elseif( mt .eq. ixnumice ) then 
                              prep_tr(mt) = prep_qti * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_ice**3 * density_ice ) 
                           else
                              prep_tr(mt) = tr_db(mt) * ( ( prep_qtl + prep_qti ) / max( qt_db, nonzero ) )
                           endif
                           ! Nov.27.2012. Impose a constraint on the diabatic forcing to prevent the onset of negative tracer during downward motion.
                           !              This constraint is imposed by using 'tr_db(mt) + prep_tr(mt) > qmin(mt)' criteria,
                           !              where 'tr_db(mt)' is a tracer at the base interface before adding diabatic forcing.
                           ! Dec.18.2012. In association with the use of 'iter_w_db' loop, I don't need to replace 'tr_db' by 'tr_db_ori'
                           !              in the below line since 'tr_db' is already updated from 'tr_db_ori' within the 
                           !              iteration loop.
                           !              The same is true for the above computation of prep_tr(mt). 
                           prep_tr(mt) = max( prep_tr(mt), qmin(mt) - tr_db(mt) )   
                        enddo
                        ! -------------------------------------------------------------------------- !
                        ! TRACERS REFINEMENT NECESSARY : PRECIPITATION FALLOUT AT THE BASE INTERFACE !
                        ! -------------------------------------------------------------------------- !
                        ! Sep.29.2011. See above. Below is the new code. 
                        ! thl_db    = thl_db + tmp1 + tmp2
                        ! Below is the old code.
                        ! Mar.30.2011. I decided to consistently use exn0(k) because diabatic forcing is a concept of 
                        !              average over the grid layer.
                        ! Dec.18.2012. I don't need to change below part in association with the use 'iter_w_db'.
                        !              since 'thl_db,...' on the RHS is updated from 'thl_db_ori' within the
                        !              iteration loop. 
                        thl_db    = thl_db + prep_thll + prep_thli
                        qt_db     =  qt_db +  prep_qtl +  prep_qti
                        do mt = 1, ncnst
                           tr_db(mt) = tr_db(mt) + prep_tr(mt)               
                        enddo
                        ! ------------------------------------------------------------------------------------------ !
                        ! TRACERS REFINEMENT NECESSARY : WET DEPOSITION BY PRECIPITATION FLUX FALLING INTO DOWNDRAFT !
                        ! Feb.05.2012. This should be refined in future.                                             !
                        ! Feb.06.2013. I don't need below block since in future, as mentioned above, I will include  !
                        !              wet deposition of aerosols (both interstitial and cloud-borne) within         !
                        !              convective downdraft into the below prep_tr(mt).                              ! 
                        ! ------------------------------------------------------------------------------------------ !
                        !           do mt = 1, ncnst 
                        !              if( mt .eq. 1 ) then
                        !                  wdep_tr(mt) = 0._r8
                        !              elseif( mt .eq. ixcldliq .or. mt .eq. ixcldice .or. mt .eq. ixnumliq .or. mt .eq. ixnumice ) then
                        !                  wdep_tr(mt) = 0._r8
                        !              else
                        !                  wdep_tr(mt) = 0._r8
                        !              endif
                        !              wdep_tr(mt) = max( wdep_tr(mt), qmin(mt) - tr_db(mt) )   
                        !           enddo
                        !           do mt = 1, ncnst
                        !              tr_db(mt) = tr_db(mt) + wdep_tr(mt)               
                        !           enddo
                        ! ------------------------------------------------------------------ ! 
                        ! Update 'w_db' by diabatic buoyancy forcing                         !
                        ! with including evaporation of precipitation at the base interface. !
                        ! ------------------------------------------------------------------ !
                        ! Apr.21.2011. Remove 'ibogtopd' option and always use below block.
                        !              block is completely OK. 
                        !              Note that 'thv_dt' and 'bogtop' has already been computed above, so that
                        !              we don't need to compute them here again. So, I commented them out.
                        !              Also, 'thvl_db' is computed here to save computation time. 
                        !              Note that 'thvl_db,thv_db' are used for downdraft buoyancy sorting further below.
                        !              Thus, it should be computed here below within the iteration loop.  
                        ! Nov.28.2012. Below 'conde' subroutine is also designed for computing 'ql_db,qi_db'
                        !              and imposing consistency with droplet number concentration.
                        ! Mar.11.2013. From below 'conden' subroutine, replace 'th,qv,ql,qi,qse' into the '_db'
                        !              variables.
                        !              Also update 'subsat_db' using the updated downdraft variable at the base interface.              

                        ! if( ibogtopd .eq. 1 ) then
                        ! call conden( p_t, thl_dt, qt_dt, th, qv, ql, qi, qse, id_check )
                        ! if( id_check .eq. 1 ) then
                        !     id_exit = .true.
                        !     go to 333
                        ! endif
                        ! thv_dt = th * ( 1._r8 + zvir * qv - ql - qi )
                        ! bogtop = rbuoy_dn * ( 1._r8 - thv_dt / thv_t )
                        
                        call conden( p_b, thl_db, qt_db, th_db, qv_db, ql_db, qi_db, qs_db, id_check )
                        !f          if( id_check .eq. 1 ) then
                        !f              id_exit = .true.
                        !f              go to 333
                        !f          endif        
                        !q          subsat_db = min( 1._r8, max( 0._r8, 1._r8 - qv_db / max( qs_db, nonzero ) ) )
                        thvl_db = thl_db * ( 1._r8 + zvir * qt_db )
                        thv_db  =  th_db * ( 1._r8 + zvir * qv_db - ql_db - qi_db )
                        if( i_downloading .eq. 1 ) thv_db  = th_db * ( 1._r8 + zvir * qv_db - ql_db - qi_db - qrain_b - qsnow_b )
                        ! Mar.07.2013. For scale-adaptive parameterization, use 'thv_mean_b' instead of 'thv_b'
                        !              in computing 'bogbot' below.
                        ! Mar.22.2013. Since 'w_db' is computed as the output of subroutine 'evap_prep_dn', I commented out below
                        !              3 lines of 'bogbot, call progup_wu2, w_db' with '!z' which are not used in any part further below.  
                        !              However, only mixing downdraft (ids .eq. 1) is treated within downdraft. Thus, compute below part 
                        !              for non-mixing downdraft. 
                        if( ids .ne. 1 ) then
                           bogbot  = rbuoy_dn * ( 1._r8 - thv_db / thv_mean_b )
                           ! bogbot  = rbuoy_dn * ( 1._r8 - thv_db / thv_b )
                           ! Compute final velocity at the base interface with all diabatic forcings.
                           ! Below block is with entrainment dilution.
                           ! Jul.07.2011. I added (-) sign in computing 'bogbot' and 'bogtop' for downdraft.
                           !              This was the reason why downdraft is so weak in UNICON. 
                           !              This was clearly a bug. 
                           !              Given this correction, I can do more reasonable computation for convective organization.
                           ! Mar.11.2013. Note that 'we_b(k)' should be used for convective updraft only. 
                           call progup_wu2( -( rdrag*eps_dn - rjet*del_dn ), rho, p_t, p_b, -bogtop, -bogbot, w_dt**2._r8, &
                                            0._r8, wd2 )
                           w_db   = max( wdmin, sqrt( max( wd2, nonzero ) ) )             
                           ! Dec.18.2012. Update provisional vertical velocity within the iteration loop.
                           ! Mar.11.2013. Comment-out below line since 'w_db_prov' is not used anymore.
                           ! w_db_prov = w_db
                        endif

                        !q        end do ! End of iteration computing downdraft vertical velocity.

                        ! ---------------------------------------------------------------------- !
                        ! Dec.18.2012. End of 'w_db' iteration loop for computing evaporation of ! 
                        !              convective precipitation within convective downdraft.     !
                        ! ---------------------------------------------------------------------- ! 

                        ! ----------------------------------------------------------------------------- !
                        ! Nov.28.2012. Impose final consistency between droplet mass and droplet number !
                        !              before moving to the next layer below.                           !
                        ! Mar.11.2013. Comment-out below two lines computing 'ql_db,qi_db' since they   !
                        !              have already been computed within the above iteration loop.      !  
                        ! ----------------------------------------------------------------------------- !
                        !p          ql_db = ql
                        !p          qi_db = qi
                        if( ql_db .eq. 0._r8 ) tr_db(ixnumliq) = 0._r8
                        if( qi_db .eq. 0._r8 ) tr_db(ixnumice) = 0._r8

                        ! CHECK
                        !  if( get_nstep() .eq. 616 ) then
                        !      write(6,*)
                        !      write(6,*) 'UNICON : RH of Convective Downdraft at the base interface after evaporation'
                        !      write(6,*) 'k, msfc, ids, ks = ', k, msfc, ids, ks
                        !      write(6,*) 'dt_evpd, subsat_db, fevp0, fevp1, fevp2, fevp_rain, fevp_snow, evp_qtl, evp_qti  = ', dt_evpd, subsat_db, fevp0, fevp1, fevp2, &
                        !                  flxrain_ava_msfc(km,msfc) / max( nonzero, cmf_db ), flxsnow_ava_msfc(km,msfc) / max( nonzero, cmf_db ), evp_qtl, evp_qti
                        !      write(6,*) 'qt_db, qv_db, qse, RH =', qt_db, qv, qse, qv / qse
                        !      write(6,*)
                        !  endif
                        ! CHECK

                        ! CHECK
                        ! write(6,*)
                        ! write(6,*) 'UNICON: The arguments of progup_wu2'
                        ! write(6,*) 'eps_dn, rho, p_t, p_b, bogtop, bogbot, w_dt, wd2 = ', eps_dn, rho, p_t, p_b, bogtop, bogbot, w_dt, wd2
                        ! write(6,*)
                        ! CHECK

                        ! Below is the original block.
                        ! w_db   = w_dt**2._r8 + dp * ( bogbot + bogtop ) / rho
                        ! w_db   = max( wdmin, sqrt( max( w_db, nonzero ) ) )
                        !! w_db   = min( wdmax, max( wdmin, sqrt( max( w_db, nonzero ) ) ) ) ! This is not a problem at all since downdraft buoyancy sorting is done using thv(l)_minE
                        ! endif
                        ! -------------------------------------------------------------------------- !
                        ! Allocate diabatic forcings at the base interface into the array variable.  !
                        ! Diabatic forcing is always computed using the mean mass flux within        !
                        ! each layer, and with non-zero mass flux at the base interface of           !
                        ! detrainment layer.                                                         !
                        ! (3) 0.5_r8 * ( cmf_dt + cmf_db ) where cmf_db > 0.                         !
                        ! -------------------------------------------------------------------------- !
                        ! CORRECTION : For downdraft, diabatic forcing occurs at the base interface of
                        !              individual layer, including horizontal PGF.  
                        !              Correct formula should be '0.5 * ( evp_qtl_top * cmf_dt + evp_qtl_bot * cmf_db )'.
                        !              Since 'evp_qtl_top = 0' in each layer ( since diabatic forcing is computed at the base interface ),
                        !              my below new formula of 'cmf_ad_dia(k,ks,m,ids) = 0.5_r8 * cmf_db' is exactly correct.   
                        ! Below line is previous wrong. 
                        ! cmf_ad_dia(k,ks,m,ids)   = cmf_dbt
                        ! Below line is new correct.
                        ! Apr.21.2011. Similar to updraft, I multiply 'dp/dp0(k)' to 'cmf_ad_dia' in order to perfectly
                        !              consider partial vertical movement of downdraft in each layer. 
                        ! cmf_ad_dia(k,ks,m,ids)       = 0.5_r8 * cmf_db * ( dp / dp0(k) )
                        ! Nov.07.2011. Critical bug fix. We must use below formula in order not to generate unreasonable
                        !              diabatic source in each layer for cmf_ad_dia(k,ks,m,ids).
                        !              From the consideration of idealized case, I clearly checked that below new formula is
                        !              absolutely correct and also is fully consistent with CAM5 shallow convection scheme.
                        cmf_ad_dia(k,ks,m,ids)       = 0.5_r8 * ( cmf_db + cmf_dt ) * ( dp / dp0(k) )
                        evp_thll_ad(k,ks,m,ids)      =     evp_thll            
                        evp_qtl_ad(k,ks,m,ids)       =      evp_qtl
                        evp_thli_ad(k,ks,m,ids)      =     evp_thli            
                        evp_qti_ad(k,ks,m,ids)       =      evp_qti
                        prep_thll_ad(k,ks,m,ids)     =    prep_thll
                        prep_qtl_ad(k,ks,m,ids)      =     prep_qtl
                        prep_thli_ad(k,ks,m,ids)     =    prep_thli
                        prep_qti_ad(k,ks,m,ids)      =     prep_qti
                        eff_ql_ad(k,ks,m,ids)        =       eff_ql
                        eff_qi_ad(k,ks,m,ids)        =       eff_qi
                        PGF_u_ad(k,ks,m,ids)         =        PGF_u
                        PGF_v_ad(k,ks,m,ids)         =        PGF_v
                        do mt = 1, ncnst
                           evp_tr_ad(k,ks,m,ids,mt)  =   evp_tr(mt)
                           prep_tr_ad(k,ks,m,ids,mt) =  prep_tr(mt)
                           ! wdep_tr_ad(k,ks,m,ids,mt) =  wdep_tr(mt)
                           eff_tr_ad(k,ks,m,ids,mt)  =   eff_tr(mt)
                        enddo

                        ! ----------------------------------------------------------------------- !
                        ! Compute 'net evaporation of precipitation' within each layer [kg/s/m^2] !
                        ! and update precipitation fluxes at all interfaces below.                ! 
                        ! ----------------------------------------------------------------------- !

                        ! CORRECTION 
                        ! Below two lines are previous wrong. 
                        ! evplflux = ( evp_qtl + prep_qtl ) * cmf_dbt
                        ! evpiflux = ( evp_qti + prep_qti ) * cmf_dbt
                        ! Below two lines are new correct.
                        ! Apr.26.2011. Change '0.5_r8 * cmf_db' to 'cmf_ad_dia(k,ks,m,ids)' in the below two quations.
                        ! evplflux = ( evp_qtl + prep_qtl ) * 0.5_r8 * cmf_db
                        ! evpiflux = ( evp_qti + prep_qti ) * 0.5_r8 * cmf_db
                        evplflux = ( evp_qtl + prep_qtl ) * cmf_ad_dia(k,ks,m,ids)
                        evpiflux = ( evp_qti + prep_qti ) * cmf_ad_dia(k,ks,m,ids)
                        ! Nov.29.2012. Add corresponding tracer parts.
                        ! When precipitation was evaporated, we set 'evp_tr(ixnumliq) = evp_tr(ixnumice) = 0' since this does not include 
                        ! droplet number concentration within downdraft. However, in order to impose a consistency between precipitation mass and 
                        ! precipitation droplet number, this evaporation process should decrease precipitating droplet number.
                        ! However, since we don't worry much about number concentration flux within precipitation, let's keep below approximate formula.
                        ! In future precise treatment, below should be refined later.
                        ! Dec.01.2012. For precipitation droplet concentration, I should do separate treatment as below.
                        ! Dec.13.2012. For more clearness, add separate treatment for 'mt = ixcldliq, ixcldice', which however, does not
                        !              change any simulation since tracers corresponding to 'mt = ixcldliq, ixcldice' are already treated
                        !              as a separate variables.
                        ! Feb.05.2013. Wet deposition flux is also included in the below computation of evptrflux(mt) for future use.
                        !              Note that wet deposition does not influence cloud condensate but only influence tracers.
                        ! Feb.06.2013. Since wet deposition of aerosols within convective downdraft (both cloud-borne and interstitial)
                        !              will be included into prep_tr(mt), I don't need wdep_tr(mt) in the below computation of evptrflux(mt).    

                        do mt = 1, ncnst
                           if( mt .eq. ixcldliq ) then
                              evptrflux(mt) = evplflux
                           elseif( mt .eq. ixcldice ) then
                              evptrflux(mt) = evpiflux
                           elseif( mt .eq. ixnumliq ) then
                              evptrflux(mt) = evplflux * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_rain**3 * density_rain )         
                           elseif( mt .eq. ixnumice ) then
                              evptrflux(mt) = evpiflux * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_snow**3 * density_snow )         
                           else 
                              evptrflux(mt) = ( evp_tr(mt) + prep_tr(mt) ) * cmf_ad_dia(k,ks,m,ids)
                              ! evptrflux(mt) = ( evp_tr(mt) + prep_tr(mt) + wdep_tr(mt) ) * cmf_ad_dia(k,ks,m,ids)
                           endif
                        enddo

                        !?        ! ----------------------------------------------------------------------------------------------------------- !
                        !?        ! Compute final precipitation flux at the bottom interface after evaporation within individual downdraft.     !
                        !?        ! Note that due to the way how evaporation is computed above, below 'flxrain_bot,flxsnow_bot,flxtrrs_bot(mt)' !
                        !?        ! are always guaranteed to be positive after evaporation.                                                     !
                        !?        ! Thus, I don't need corrective flux part in the further below block anymore, which is great.                 !    
                        !?        ! Feb.05.2013. Note that 'evptrflux' also contains wet deposition of aerosols within downdraft.               ! 
                        !?        ! ----------------------------------------------------------------------------------------------------------- !
                        flxrain_bot = flxrain_bot - evplflux
                        flxsnow_bot = flxsnow_bot - evpiflux 
                        do mt = 1, ncnst
                           flxtrrs_bot(mt) = flxtrrs_bot(mt) - evptrflux(mt)
                        enddo
                        !?
                        !? I think below corrective part is not necessary any more.
                        !?
 
                        !?          tmp1 = 0._r8
                        !?          tmp2 = 0._r8
                        !?        ! Nov.29.2012. Add corresponding tracer parts. 
                        !?          do mt = 1, ncnst
                        !?             tmp_tr(mt) = 0._r8
                        !?          enddo  
                        !?          do kc = km, 0, -1 ! This is an interface index.
                        !?             kcp = kc + 1
                        !?             flxrain_ava_msfc(kc,msfc) = flxrain_ava_msfc(kc,msfc) - evplflux + tmp1
                        !?             flxsnow_ava_msfc(kc,msfc) = flxsnow_ava_msfc(kc,msfc) - evpiflux + tmp2
                        !?           ! Nov.29.2012. Add corresponding tracer parts. 
                        !?             do mt = 1, ncnst
                        !?                flxtrrs_ava_msfc(kc,msfc,mt) = flxtrrs_ava_msfc(kc,msfc,mt) - evptrflux(mt) + tmp_tr(mt)
                        !?             enddo  
                        !?           ! Apr.26.2011. Add corrective production tendency of rain by using 'qv0' for future refinement.
                        !?           ! This assumes that 'qv0' is large enough to support the corrective precipitation production tendency.
                        !?           ! This should be generally true since downdraft mass flux is generally small. 
                        !?           ! Even when this corrective tendency induces negative qv0 after dt, it will be treated within 
                        !?           ! the 'positive_moisture' subroutine collectively. 
                        !?           ! Note also that this 'cvp_rainprd_msfc(k,msfc)' will be averaged to 'cvp_rainprd(k)', which 
                        !?           ! will be continuously used for similar correction for evaporation of convective precipitation within
                        !?           ! environment later. 
                        !?           ! Potentially, I should also consider corresponding decrease of tracers associated with positive-definite
                        !?           ! production tendencies of 'cvp_rainprd,cvp_snowprd'. This can be implemented later but for the time
                        !?           ! being, I will neglect this.
                        !?           ! Apr.27.2011. Later, 'cmf_ad_dia(k,ks,m,ids)' can be reduced by area-velocity constraint on downdraft.
                        !?           !              However, below 'cvp_rainprd_msfc,cvp_snowprd_msfc' are computed using the original 'cmf_ad_dia'.
                        !?           !              I am not doing any additional correction on 'cvp_rainprd_msfc,cvp_snowprd_msfc' and 
                        !?           !              'flxrain_ava_msfc,flxsnow_ava_msfc' associated with area-downdraft
                        !?           !              constraint but it is absolutely OK. Note that this 'cvp_rainprd_msfc,cvp_snowprd_msfc' are corrective
                        !?           !              production of precipitation from environment ( qv0 --> rain, snow ). Thus, by keeping this original even after 
                        !?           !              area-velocity constraints will still maintain positive precipitation flux at all interfaces. In fact,
                        !?           !              if I do correction 'cvp_rainprd_msfc,cvp_snowprd_msfc' following area-velocity constraints, I am not sure
                        !?           !              whether it can maintain positive precipitation flux.
                        !?           ! Nov.29.2012. Add corresponding tracer parts. Similar to individual rain and snow, this correction tendency is
                        !?           !              applied for individual tracer, which is perfectly correct and ideal. In case of rain/snow, 
                        !?           !              this corrective rain/snow production is generated by using 'qv0(k)' in the same layer which involves
                        !?           !              phase change. In case of corrective tracer tendency, it will be similarly generated from 'tr0(mt)'
                        !?           !              without phase change. As a result, treatment of tracers are easier and column-integrated tracers
                        !?           !              will be exactly conserved.  
                        !?             if( flxrain_ava_msfc(kc,msfc) .lt. 0._r8 ) then
                        !?                 cvp_rainprd_msfc(kcp,msfc) = cvp_rainprd_msfc(kcp,msfc) - flxrain_ava_msfc(kc,msfc) * ( g / dp0(kcp) ) ! [ kg / kg / s ]
                        !?                 tmp1                       = tmp1                       - flxrain_ava_msfc(kc,msfc)
                        !?                 flxrain_ava_msfc(kc,msfc)  = 0._r8                   
                        !?             endif
                        !?             if( flxsnow_ava_msfc(kc,msfc) .lt. 0._r8 ) then
                        !?                 cvp_snowprd_msfc(kcp,msfc) = cvp_snowprd_msfc(kcp,msfc) - flxsnow_ava_msfc(kc,msfc) * ( g / dp0(kcp) ) ! [ kg / kg / s ]
                        !?                 tmp2                       = tmp2                       - flxsnow_ava_msfc(kc,msfc)
                        !?                 flxsnow_ava_msfc(kc,msfc)  = 0._r8                   
                        !?             endif
                        !?           ! Nov.29.2012. Add corresponding tracer parts. 
                        !?           !              Note that I should use 'dptr0(kcp,mt)' instead of 'dp0(kcp)' in this tracer block. 
                        !?             do mt = 1, ncnst
                        !?                if( flxtrrs_ava_msfc(kc,msfc,mt) .lt. 0._r8 ) then
                        !?                    cvp_trrsprd_msfc(kcp,msfc,mt) = cvp_trrsprd_msfc(kcp,msfc,mt) - flxtrrs_ava_msfc(kc,msfc,mt) * ( g / dptr0(kcp,mt) ) ! [ kg (#) / kg / s ]
                        !?                    tmp_tr(mt)                    = tmp_tr(mt)                    - flxtrrs_ava_msfc(kc,msfc,mt)
                        !?                    flxtrrs_ava_msfc(kc,msfc,mt)  = 0._r8                   
                        !?                endif
                        !?             enddo
                        !?           ! Apr.26.2011. With above treatment of corrective precipitation production tendencies, I don't need below
                        !?           !              4 lines. Thus, I commented below 4 lines. This saves additional computation time. 
                        !?           ! if( flxrain_ava_msfc(kc,msfc) .lt. -1.e-18_r8 .or. flxsnow_ava_msfc(kc,msfc) .lt. -1.e-18_r8 ) then
                        !?           !     write(6,*) 'UNICON : Warning - Negative flxrain_ava and flxsnow_ava after evaporation within downdraft - Reset to zero'
                        !?           !     write(6,*)  kc, msfc, flxrain_ava_msfc(kc,msfc), flxsnow_ava_msfc(kc,msfc)
                        !?           ! endif 
                        !?           ! flxrain_ava_msfc(kc,msfc) = max( 0._r8, flxrain_ava_msfc(kc,msfc) )
                        !?           ! flxsnow_ava_msfc(kc,msfc) = max( 0._r8, flxsnow_ava_msfc(kc,msfc) )
                        !?          enddo

                        ! CHECK
                        ! write(6,*)
                        ! write(6,*) 'UNICON: Vertical Evolution of Individual Convective Downdraft'
                        ! write(6,*) 'Indices of ks, m, ids, k : ', ks, m, ids, k
                        ! write(6,*) 'cmf_dt,     cmf_db  = ', cmf_dt,     cmf_db
                        ! write(6,*) 'thl_dt,     thl_db  = ', thl_dt,     thl_db
                        ! write(6,*) 'qt_dt,       qt_db  = ', qt_dt,       qt_db
                        ! write(6,*) 'u_dt,         u_db  = ', u_dt,         u_db
                        ! write(6,*) 'v_dt,         v_db  = ', v_dt,         v_db 
                        ! write(6,*) 'evp_qtl,   evp_qti  = ', evp_qtl,   evp_qti 
                        ! write(6,*) 'evp_thll, evp_thli  = ', evp_thll, evp_thli
                        ! write(6,*) 'PGF_u,       PGF_v  = ', PGF_u,       PGF_v
                        ! write(6,*)
                        ! CHECK

                        ! ------------------------------------------------------------- !
                        ! Check whether this air will move down into the below layer.   !
                        ! Also, compute the properties of detrained airs for treating   !
                        ! organization.                                                 ! 
                        ! Detrainment of downdraft always occurs at the base interface. !
                        ! ------------------------------------------------------------- !  

                        ! Apr.21.2011. Remove below block since it has already been computed above.
                        !              This will save computation time.

                        ! thvl_db = thl_db * ( 1._r8 + zvir * qt_db )
                        ! call conden( p_b, thl_db, qt_db, th, qv, ql, qi, qse, id_check )
                        ! if( id_check .eq. 1 ) then
                        !     id_exit = .true.
                        !     go to 333
                        ! endif          
                        ! thv_db = th * ( 1._r8 + zvir * qv - ql - qi )

                        ! CHECK
                        ! if( get_nstep() .eq. 3 .and. ks .eq. 5 .and. ids .eq. 1 .and. k .eq. 5) then
                        !     write(6,*)
                        !     write(6,*) 'UNICON: Downdraft sorting at the base of ambiguous layer after diabatic forcing'
                        !     write(6,*) 'Time step & Layer & Segment Index: ', get_nstep(), k
                        !     write(6,*) 'cmf_db, thl_db, qt_db, thvl_db = ', cmf_db, thl_db, qt_db, thvl_db
                        !     write(6,*) 'thvl0(k), thvl_minE =', thvl0(k), thvl_minE
                        !     write(6,*)
                        ! endif
                        ! CHECK

                        ! ---------------------------------------------------------------------------------- !
                        ! Compute laterally-detrained airs from downdraft while it moves from 'p_t' to 'p_b' !
                        ! assuming that thermodynamic properties of detrained airs is the properties at the  !
                        ! p_t similar to the treatment of detrainment from convective updraft.               !
                        ! ---------------------------------------------------------------------------------- !  
                        ! Apr.21.2011. Two modifications are made : (1) 'fmixd' is multiplied,
                        !              (2) thl_dt --> 0.5 * ( thl_dt + thl_db ) and also the others.
                        !              I double checked that below final computation of 'cmf_ar,thl_ar' are actually 
                        !              the same as corresponding
                        !              updraft treatment, except that in case of updraft, 'mixed' properties
                        !              are assumed to be detrained, while in case of current downdraft, 
                        !              downdraft properties are assumed to be detrained. 
                        ! Aug.15.2011. Note that if eps_dn=del_dn, fmixd = 1 always. In future, I can impose a constraint
                        !              similar to eps0(m) for convective updraft. Note that below code is completely correct. 
                        ! Jan.30.2013. With a new constraint 'on eps_dn, del_dn' on this day,         
                        !              we don't need to use 'fmix_max' constraint in the      
                        !              below case of 'exp_cmf .eq. 1'. So, I commented out   
                        !              corresponding line.                                              
                        ! Feb.06.2013. Always choose physically reasonable 'exp_cmf .eq. 1'.

                        if( exp_cmf .eq. 1 ) then
                           if( dp * abs( eps_dn - del_dn ) .ge. 1.e-3_r8 ) then
                              fmixd = ( exp( dp * ( eps_dn - del_dn ) ) - 1._r8 ) / ( dp * ( eps_dn - del_dn ) )
                           else
                              fmixd = 1._r8
                           endif
                           !             ! fmixd = min( fmixd, fmix_max )
                        elseif( exp_cmf .eq. 2 ) then
                           fmixd = 1._r8
                           !           elseif( exp_cmf .eq. 3 ) then
                           !               if( eps_dn .ge. del_dn ) then
                           !                   fmixd = 1._r8
                           !               else
                           !                   if( dp * abs( eps_dn - del_dn ) .ge. 1.e-3_r8 ) then
                           !                       fmixd = ( exp( dp * ( eps_dn - del_dn ) ) - 1._r8 ) / ( dp * ( eps_dn - del_dn ) )
                           !                   else
                           !                       fmixd = 1._r8
                           !                   endif
                           !                   fmixd = min( fmixd, fmix_max )
                           !               endif
                        endif

                        ! Aug.02.2012. Temporary test
                        ! fmixd = 1._r8
                        ! Aug.02.2012. Temporary test

                        cmf_ar(k,ks,m,ids) = fmixd * del_dn * dp * cmf_dt
                        thl_ar(k,ks,m,ids) = 0.5_r8 * ( thl_dt + thl_db )
                        qt_ar(k,ks,m,ids)  = 0.5_r8 * (  qt_dt +  qt_db )
                        u_ar(k,ks,m,ids)   = 0.5_r8 * (   u_dt +   u_db )
                        v_ar(k,ks,m,ids)   = 0.5_r8 * (   v_dt +   v_db )
                        do mt = 1, ncnst
                           tr_ar(k,ks,m,ids,mt) = 0.5_r8 * ( tr_dt(mt) + tr_db(mt) )
                        enddo
                        ! Nov.28.2012.
                        ql_ar(k,ks,m,ids)  = 0.5_r8 * (  ql_dt +  ql_db )
                        qi_ar(k,ks,m,ids)  = 0.5_r8 * (  qi_dt +  qi_db )

                        ! --------------------------------------------------------------- !
                        ! Downdraft buoyancy sorting                                      !
                        ! Check whether downdraft will be detrained at the base interface !
                        ! --------------------------------------------------------------- !

                        fddet = 0._r8
                        if( dbsort_con ) then
                            fddet = ( thv_db - thv_min ) / max( thv_max - thv_min , nonzero )
                            fddet = max( 0._r8, min( 1._r8, fddet ) )
                        else
                            if( ithv_minE .eq. -1 ) then
                                tmp1 = thvl_db 
                                tmp2 = thvl_minE 
                            else
                                tmp1 = thv_db 
                                tmp2 = thv_minE 
                            endif 
                            if( tmp1 .gt. tmp2 ) fddet = 1._r8
                        endif 
                        if( k .eq. 1 .or. cmf_db * ( 1._r8 - fddet ) .lt. cmfmin ) fddet = 1._r8                

                      ! OPTION : It is good to impose consistency with convective updraft.
                     !? Below 'if' means that downdraft is detrained in the current layer without
                     !? penetrating into the next layer below. 
                     !? It is perfectly OK and reasonable to use 'cmfmin' instead of 'nonzero' in the below if condition.         

                      ! if( fddet .gt. 0._r8 ) then
                            tmp3 = cmf_ar(k,ks,m,ids)
                            cmf_ar(k,ks,m,ids) = tmp3 + cmf_db * fddet
                            thl_ar(k,ks,m,ids) = ( thl_ar(k,ks,m,ids) * tmp3 + &
                            thl_db * cmf_db * fddet ) / max( nonzero, cmf_ar(k,ks,m,ids) )
                            qt_ar(k,ks,m,ids)  = (  qt_ar(k,ks,m,ids) * tmp3 +  &
                            qt_db * cmf_db * fddet ) / max( nonzero, cmf_ar(k,ks,m,ids) )
                            u_ar(k,ks,m,ids)   = (   u_ar(k,ks,m,ids) * tmp3 +   &
                            u_db * cmf_db * fddet ) / max( nonzero, cmf_ar(k,ks,m,ids) )
                            v_ar(k,ks,m,ids)   = (   v_ar(k,ks,m,ids) * tmp3 +   &
                            v_db * cmf_db * fddet ) / max( nonzero, cmf_ar(k,ks,m,ids) )
                            do mt = 1, ncnst
                               tr_ar(k,ks,m,ids,mt) = (  tr_ar(k,ks,m,ids,mt) * tmp3 +  &
                            tr_db(mt) * cmf_db * fddet ) / max( nonzero, cmf_ar(k,ks,m,ids) )
                            enddo
                          ! Nov.28.2012. Below two lines are added. 
                            ql_ar(k,ks,m,ids)  = (  ql_ar(k,ks,m,ids) * tmp3 +  &
                            ql_db * cmf_db * fddet ) / max( nonzero, cmf_ar(k,ks,m,ids) )
                            qi_ar(k,ks,m,ids)  = (  qi_ar(k,ks,m,ids) * tmp3 +  &
                            qi_db * cmf_db * fddet ) / max( nonzero, cmf_ar(k,ks,m,ids) )
                      ! endif

                           ! ------------------------------------------------------------------------------ !
                           ! For diagnostic purpose and organization parameterization using cmf_d(0),       ! 
                           ! I am explicitly saving 'cmf_ad(0,ks,m,ids), thl_ad(0,ks,m,ids), and etc' here. !
                           ! This does not influence tendency computation in the lowest model layer         !
                           ! by downdraft since downdraft fluxes at surface will be set to zero before      !
                           ! computing tendency as will be explained later.                                 !
                           ! Jun.29.2011. Note that this explicit computation at surface is also used for   !
                           !              computing downdraft TKE within PBL ( DKE ) and anomalies of       !
                           !              downdraft conservative scalars within PBL later for convective    !
                           !              organization. Thus, this explicit adding here is important.       ! 
                           ! Jul.13.2011. This explicit non-zero setting at surface is extremely useful in  !
                           !              computing 'tkePBLorg = wa_d(0,it=1)' for computing additional     !
                           !              background mean w associated with convective organization.        !
                           ! Mar.19.2014. Below explicit computation of downdraft properties at the surface !
                           !              is now extremely important (not just diagnostic purpose), since   !
                           !              it is critically importantly used in partitioning convective      !
                           !              tendency in the lowest model layer intp the entire cumulus layers !
                           !              or the PBL depth in association with the ipartition = 1.          !        
                           ! ------------------------------------------------------------------------------ !
                           if( k .eq. 1 ) then
                              cmf_ad(km,ks,m,ids) = cmf_db            
                              thl_ad(km,ks,m,ids) = thl_db
                              qt_ad(km,ks,m,ids)  =  qt_db
                              u_ad(km,ks,m,ids)   =   u_db
                              v_ad(km,ks,m,ids)   =   v_db
                              w_ad(km,ks,m,ids)   =   w_db
                              a_ad(km,ks,m,ids)   = cmf_db / rho_b / w_db
                              do mt = 1, ncnst 
                                 tr_ad(km,ks,m,ids,mt) = tr_db(mt)
                              enddo
                              ! Nov.28.2012. Below two lines are added.
                              ql_ad(km,ks,m,ids)  =  ql_db
                              qi_ad(km,ks,m,ids)  =  qi_db
                           endif
                           ! Jul.13.2011. Note that if downdraft cannot pass through down the base interface, downdraft
                           !              vertical velocity is re-set to zero instead of 'wdmin', which is perfectly
                           !              reasonable and totally helpful in computing reasonable 'wa_d(0), w_d(0)' which
                           !              is used for convective-organization induced additional mean updraft vertical
                           !              velocity at surface. 
                           ! Mar.15.2014. For continuous buoyancy sorting in order to impose a stability in the code 
                           !              and in order to minimize perturbation growth.

                        if( fddet .eq. 1._r8 ) then                ! Complete detrainment 
                           cmf_db             =  0._r8
                           thl_db             =  0._r8
                           qt_db              =  0._r8
                           u_db               =  0._r8
                           v_db               =  0._r8
                           w_db               =  0._r8
                           do mt = 1, ncnst
                              tr_db(mt)       =  0._r8
                           enddo
                           ! Nov.28.2012. Below two lines are added.
                           ql_db              =  0._r8
                           qi_db              =  0._r8
                           kdtd(ks,m,ids)     =  k
                           !?            ! When downdraft is detrained at the base interface without moving further down, 
                           !?            ! I should do the following setting for 'cmf_d_src(ks,ids), ix_d_src(ks,ids)'
                           !?            ! variabled as below.
                           ix_d_src(ks,ids)   =  0
                           cmf_d_src(ks,ids)  =  0._r8
                           goto 20
                        endif
                        ! -------------------------------------------------------------- !
                        ! Allocate downdraft values at the base interface into the array !
                        ! -------------------------------------------------------------- !  
                        cmf_ad(km,ks,m,ids) = cmf_db * ( 1._r8 - fddet )           
                        thl_ad(km,ks,m,ids) = thl_db
                        qt_ad(km,ks,m,ids)  =  qt_db
                        u_ad(km,ks,m,ids)   =   u_db
                        v_ad(km,ks,m,ids)   =   v_db
                        w_ad(km,ks,m,ids)   =   w_db
                        a_ad(km,ks,m,ids)   = cmf_db / rho_b / w_db
                        do mt = 1, ncnst 
                           tr_ad(km,ks,m,ids,mt) = tr_db(mt)
                        enddo
                        ! Nov.28.2012. Below two lines are added.
                        ql_ad(km,ks,m,ids)  =  ql_db
                        qi_ad(km,ks,m,ids)  =  qi_db
                        ! --------------------------------------- !
                        ! Initialization for the next computation !
                        ! --------------------------------------- !  
                        !?          cmf_dt  = cmf_db
                        !?          thl_dt  = thl_db
                        !?          qt_dt   =  qt_db
                        !?          u_dt    =   u_db
                        !?          v_dt    =   v_db
                        !?          w_dt    =   w_db
                        !?          do mt = 1, ncnst
                        !?             tr_dt(mt) = tr_db(mt)
                        !?          enddo
                        !?        ! Nov.28.2012. Below two lines are added. Since below 'ql_dt,qi_dt' will be
                        !?        !              computed at the beginning of the next layer computation also, 
                        !?        !              I commented-out below two lines.
                        !?        ! ql_dt   =  ql_db
                        !?        ! qi_dt   =  qi_db
                        !?          subsat_dt = min( 1._r8, max( 0._r8, 1._r8 - qv_db / max( qs_db, nonzero ) ) )
                        !?        ! In the new code, I should initialized into the '_src' array variables as below.
                        !?        ! In the below block, 'ix_d_src(ks,ids) = 1' means that downdraft source generated from 'ks' layer 
                        !?        ! with a type of 'ids' is not detrained in the current layer but penetrate further down into the
                        !?        ! next layer below.
                        ix_d_src(ks,ids)  = 1
                        cmf_d_src(ks,ids) = cmf_db * ( 1._r8 - fddet )
                        thl_d_src(ks,ids) = thl_db
                        qt_d_src(ks,ids)  =  qt_db
                        u_d_src(ks,ids)   =   u_db
                        v_d_src(ks,ids)   =   v_db
                        w_d_src(ks,ids)   =   w_db
                        do mt = 1, ncnst
                           tr_d_src(ks,ids,mt) = tr_db(mt)
                        enddo
                        ql_d_src(ks,ids)  =  ql_db
                        qi_d_src(ks,ids)  =  qi_db
                        ! ------------------------------------------------------------------------ !
                        ! Mar.11.2013. Add initialization of evaporation rate at the top interface ! 
                        !              for the next layer below.                                   !
                        ! ------------------------------------------------------------------------ !
                        fevp1_t_rate_src(ks,ids) = fevp1_b_rate
                        fevp2_t_rate_src(ks,ids) = fevp2_b_rate
                        ! ------------------------------------------------ !
                        ! End of downdraft sorting of one downdraft source !
                        ! ------------------------------------------------ !  
                        
                        !?       enddo                     ! k = ks, 1, -1.             This 'k'    is a layer index from the source layer to the detrainment layer
                        !? 20 continue 
                        !?    enddo                        ! ks   = ks_top, ks_bot, -1. This 'ks'   is a layer index of downdraft source.
                        !?    enddo                        ! ids  = 1, 3.               This 'ids'  is a type of downdraft source.
                        !?    enddo                        ! msfc = 1, nseg             This 'msfc' is a number of updraft segment at surface.

                        !?
                        !? WARNING : I should check whether I should locate below '20 continue' line
                        !?           inside of above 'enddo ! ids  = 1, 3' line or here.
                        !?           This is a really critically important issue and I should also check the other
                        !?           cases of using 'continue' command. I think that I should locate inside
                        !?           the 'enddo ! ids  = 1, 3' line definitely. If not, I cannot perform the
                        !?           other cases of 'ids = 2 and 3' when goto 20 is performed at 'ids = 1'. 

20                      continue 
                     enddo                     ! ids  = 1, 3.                     This 'ids'  is a type of downdraft source.
                  enddo                        ! ks   = ktop_msfc(msfc), k, -1.   This 'ks'   is a layer index of downdraft source.

                  ! -------------------------------------------------------------------------------------- !
                  ! Assign final precipitation flux at the bottom interface into the array                 !
                  ! Also, compute 'evprain_d(k,msfc), evpsnow_d(k,msfc), evptrrs_d(k,msfc,mt)' >= 0        !
                  ! by differencing two flux variables.                                                    !
                  ! For safety and imposing full consistency, impose the constraint that droplet           !
                  ! size of precipitation rain/snow are externally specified.                              !
                  ! Note that 'flxtrrs_bot(mt)' also contains the effect of wet deposition of aerosols     !
                  ! as well as evaporation ( & production ) of convective precipitation within             !
                  ! convective downdraft. Note also that wet deposition does not influences condensate but !
                  ! only affect tracers.                                                                   !
                  ! -------------------------------------------------------------------------------------- !

                  flxrain_msfc(km,msfc)  = flxrain_bot
                  flxsnow_msfc(km,msfc)  = flxsnow_bot
                  evprain_d_msfc(k,msfc) = ( flxrain_bot_upeesm - flxrain_bot ) * ( g / dp0(k) ) ! >= 0.
                  evpsnow_d_msfc(k,msfc) = ( flxsnow_bot_upeesm - flxsnow_bot ) * ( g / dp0(k) ) ! >= 0.
                  do mt = 1, ncnst
                     if( mt .eq. ixcldliq ) then
                        flxtrrs_msfc(km,msfc,mt) = flxrain_msfc(km,msfc)
                     elseif( mt .eq. ixcldice ) then
                        flxtrrs_msfc(km,msfc,mt) = flxsnow_msfc(km,msfc)
                     elseif( mt .eq. ixnumliq ) then
                        flxtrrs_msfc(km,msfc,mt) = flxrain_msfc(km,msfc) * 3._r8 / ( 4._r8 * 3.141592_r8 * &
                                                   droprad_rain**3 * density_rain )         
                     elseif( mt .eq. ixnumice ) then
                        flxtrrs_msfc(km,msfc,mt) = flxsnow_msfc(km,msfc) * 3._r8 / ( 4._r8 * 3.141592_r8 * &
                                                   droprad_snow**3 * density_snow )         
                     else 
                        flxtrrs_msfc(km,msfc,mt) = flxtrrs_bot(mt)
                     endif
                     evptrrs_d_msfc(k,msfc,mt) = ( flxtrrs_msfc(km,msfc,mt) - flxtrrs_bot_upeesm(mt) ) * ( g / dptr0(k,mt) )
                  enddo

                  ! Sanity Check : In the new code, this case must not happen. 
                  if( flxrain_msfc(km,msfc) .lt. -1.e-18_r8 .or. flxsnow_msfc(km,msfc) .lt. -1.e-18_r8 ) then 
                     write(6,*) 'UNICON : Stop - Negative precipitation flux after computing evaporation within environment'
                     write(6,*)  k, flxrain_msfc(k,msfc), flxsnow_msfc(k,msfc), flxrain_msfc(km,msfc), flxsnow_msfc(km,msfc)
                     call endrun('STOP : UNICON - Negative Precipitation Flux')
                     write(6,*) 
                  endif

                  ! --------------------------------------------------------------------------------------------------- !
                  ! Final Net Rain and Snow Production Tendency in Each Layer for Each Updraft Segment.                 !
                  !                                                                                                     !
                  ! A. For evaporation and snow melting, the sign of tracer tendencies have been already reversed,      !
                  !    so that simplying adding all the tracer tendencies produces correct results.                     ! 
                  !                                                                                                     ! 
                  ! B. Note that if we turn-off area and vertical velocity constraint of convective downdraft, then     !
                  !                                                                                                     ! 
                  !    1. qrten_d_msfc(k,msfc)   = - evprain_d_msfc(k,msfc),                                            !
                  !    2. qrten_d_msfc(k,msfc)   = - evprain_d_msfc(k,msfc),                                            ! 
                  !    3. trrsten_d_msfc(k,msfc) =   evptrrs_d_msfc(k,msfc)                                             !
                  !                                                                                                     !
                  !    where 3 variables on the LSH will be computed later after performing vertical velocity and       !
                  !    are constraints on the convective downdraft. In fact, this is the versy reason why these are     !
                  !    computed later instead of downdraft computation loop above.                                      !
                  !                                                                                                     !
                  ! C. With the current treatment of new unified treatment of evaporation process with                  !
                  !    the 'do msfc = 1, nseg' loop outside of 'do k = ktop, 1, -1', there is no way to perfectly treat !
                  !    the area and vertical velocity constraint of convective downdraft. Thus, I should turn-off       !
                  !    the area and vertical velocity constraint of convective downdraft, which is OK given the huge    !
                  !    benefit of physically reasonable computation of evaporation process in a consistent way.         !
                  ! D. Note also that 'trrsten_u_msfc(k,msfc,mt),evptrrs_d_msfc(k,msfc,mt)' already contains the effect !
                  ! of wet deposition of aerosols within convective updraft and downdrafts.                             !
                  !                                                                                                     !
                  ! MODIFICATION IS REQUIRED :                                                                          ! 
                  !              Below 'x_p_msfc(km,msfc), y_p_msfc(km,msfc)' should be re-computed.                    ! 
                  !                                                                                                     !
                  ! Mar.05.2013. Recompute 'x_p_msfc(km,msfc), y_p_msfc(km,msfc)' using grid-mean precipitation fluxes  !
                  !              both from the one coming from at the top interface with evaporation within environment ! 
                  !              ( flxrain_bot_ee + flxsnow_bot_ee ) and the flux generated in the current layer from   !
                  !              convective updraft ( ( qrten_u_msfc(k,msfc) + qsten_u_msfc(k,msfc) ) * ( dp0(k) / g )  !
                  !              as weighting factors. Note that since snow melting and evaporation within downdraft    !
                  !              occur both in the above two sources in the same way, we don't need to consider the     !
                  !              effect of snow melting and evaporation within downdraft in computing x_p_msfc(km,msfc) !
                  !              and y_p_msfc(km,msfc). Note also that the weighting factor is the product of 'in-prep  !
                  !              precipitation flux' and the 'area', i.e., 'area' is also used as a weighting factor,   !
                  !              which is also a perfectly reasonable choice.                                           !
                  !              In addition, this new computation saves computation time.                              !
                  !              The fundamental simplifying assumption of this approach is that both precipitation and !
                  !              precipitating updraft areas can be described as a single disk with a single (x,y,R) at !
                  !              each model interface.                                                                  !  
                  ! --------------------------------------------------------------------------------------------------- !

                  !?      tmp1 = ( dp0(k) / g ) * ( qrten_u_msfc(k,msfc) + cvp_rainprd_msfc(k,msfc) - evprain_e_msfc(k,msfc) - evprain_d_msfc(k,msfc) + &
                  !?                                qsten_u_msfc(k,msfc) + cvp_snowprd_msfc(k,msfc) - evpsnow_e_msfc(k,msfc) - evpsnow_d_msfc(k,msfc) )
                  !o      tmp1 = ( dp0(k) / g ) * ( qrten_u_msfc(k,msfc) + qsten_u_msfc(k,msfc) )

                  !o    ! Note that 'x_um_msfc, y_um_msfc' are defined at the layer mid-point except in the 'ktop' layer
                  !o    ! where it is defined at the mid-height of cumulus updraft.
                  !o    ! The location of precipitation area at the base interface in each layer is assumed to be identical 
                  !o    ! to the location of cumulus updraft at the layer mid-point since precipitation flux at the base 
                  !o    ! interface is the sum of precipitation production in the layer.
                  !o      if( k .eq. ktop_msfc(msfc) ) then
                  !o          tmp3 = ztop_msfc(msfc) - zs0(km)
                  !o      else
                  !o          tmp3 = dz0(k)
                  !o      endif
                  !o      tmpx = tmpx * exp( -dz0(k) / zscale_evap ) + ( tmp1 ) * exp( -tmp3 / zscale_evap ) * x_um_msfc(k,msfc)
                  !o      tmpy = tmpy * exp( -dz0(k) / zscale_evap ) + ( tmp1 ) * exp( -tmp3 / zscale_evap ) * y_um_msfc(k,msfc)
                  !o      tmpw = tmpw * exp( -dz0(k) / zscale_evap ) + ( tmp1 ) * exp( -tmp3 / zscale_evap )

                  !o      x_p_msfc(km,msfc) = tmpx / max( nonzero, tmpw )
                  !o      y_p_msfc(km,msfc) = tmpy / max( nonzero, tmpw )

                  !o      March.05.2013. Below is a new correct computation on this day replacing the above block.
 
                  tmpw = ( flxrain_bot_ee + flxsnow_bot_ee ) + ( qrten_u_msfc(k,msfc) + qsten_u_msfc(k,msfc) ) * ( dp0(k) / g )
                  tmpw = max( tmpw, nonzero )
                  x_p_msfc(km,msfc) = (  x_p_msfc(k,msfc) * ( flxrain_bot_ee + flxsnow_bot_ee ) + &
                     x_um_msfc(k,msfc) * ( qrten_u_msfc(k,msfc) + qsten_u_msfc(k,msfc) ) * ( dp0(k) / g ) ) / tmpw
                  y_p_msfc(km,msfc) = (  y_p_msfc(k,msfc) * ( flxrain_bot_ee + flxsnow_bot_ee ) + &
                     y_um_msfc(k,msfc) * ( qrten_u_msfc(k,msfc) + qsten_u_msfc(k,msfc) ) * ( dp0(k) / g ) ) / tmpw

               enddo                        ! k    = ktop_msfc(msfc), 1, -1.        This 'k'    is a layer index where vertical evolution of downdraft is computed.
            enddo                        ! msfc = 1, nseg                        This 'msfc' is a number of updraft segment at surface.

            ! ------------------------------------------------------------------------------------------------------- !
            !                                                                                                         !                
            ! Iteration for treating accretion should end here.                                                       ! 
            !                                                                                                         !
            ! The variables used for the next accretion iteration computations within 'subroutine prod_prep_up' are   !
            !                                                                                                         !
            !  1. flxrain_msfc(k,msfc), flxsnow_msfc(k,msfc)                                                          !
            !  2. a_p_msfc(k,msfc)                                                                                    ! 
            !  3. am_us_msfc(k,msfc)                                                                                  !
            !  4. am_pu_msfc(k,msfc)                                                                                  ! 
            !                                                                                                         !
            ! all of which are already computed above. Thus, this is the perfect location of the end of accretion     !
            ! iteration loop.                                                                                         !
            ! ------------------------------------------------------------------------------------------------------- !

         enddo                        ! Enf of iacc = 1, nacc                 This 'iacc' is a number of accretion iteration.

         ! ---------------------------------------------------------- !
         ! Compute segment-summed grid-mean quantities                !
         ! flxrain_ava : Rain flux after evaporation within downdraft !
         ! flxsnow_ava : Snow flux after evaporation within downdraft !
         ! Nov.29.2012. Add corresponding tracer part.                !
         ! ---------------------------------------------------------- !

         !? Below block is not necessary any more since all precipitation flux variables
         !? are unified into flxrain_msfc(k,msfc) and flxtain(k).

         !?    do msfc = 1, nseg
         !?       do k = ktop_msfc(msfc), 0, -1                           ! This is an interface index 
         !?          flxrain_ava(k) = flxrain_ava(k) + flxrain_ava_msfc(k,msfc) 
         !?          flxsnow_ava(k) = flxsnow_ava(k) + flxsnow_ava_msfc(k,msfc) 
         !?        ! Nov.29.2012. Add corresponding tracer parts.
         !?          do mt = 1, ncnst
         !?             flxtrrs_ava(k,mt) = flxtrrs_ava(k,mt) + flxtrrs_ava_msfc(k,msfc,mt) 
         !?          enddo
         !?       enddo
         !?       ! Apr.26.2011. Below is added.
         !?       do k = ktop_msfc(msfc), 1, -1                           ! This is a layer index 
         !?          cvp_rainprd_d(k) = cvp_rainprd_d(k) + cvp_rainprd_msfc(k,msfc)
         !?          cvp_snowprd_d(k) = cvp_snowprd_d(k) + cvp_snowprd_msfc(k,msfc)
         !?        ! Nov.29.2012. Add corresponding tracer parts.
         !?          do mt = 1, ncnst
         !?             cvp_trrsprd_d(k,mt) = cvp_trrsprd_d(k,mt) + cvp_trrsprd_msfc(k,msfc,mt)
         !?          enddo
         !?       enddo
         !?    enddo

         ! --------------------------------------------------- !
         !                                                     !
         ! Vertical velocity and area constraints on downdraft ! 
         !                                                     !
         ! --------------------------------------------------- !                            

         !? With the new unified treatment of evaporation process in the above block,
         !? I should not perform below constraint of area and vertical velocity of convective downdraft
         !? as in the current code.
         !? So, I simply commented out below block to save computation time.
 
         !?    if( i_dnconon .eq. 1 ) then 

         !?    ! --------------------------------------------------- !
         !?    ! Vertical velocity constraint on downdraft mass flux !
         !?    ! --------------------------------------------------- !

         !?  ! CHECK
         !?  ! if( get_nstep() .eq. 3 ) then
         !?  !     write(6,*)
         !?  !     write(6,*) 'UNICON: Downdraft mass flux before vertical velocity constraint on downdraft'
         !?  !     write(6,*) 'Time step & Layer Index: ', get_nstep(), k
         !?  !     write(6,*) 'cmf_ad(4,5,1,1) =', cmf_ad(4,5,1,1)
         !?  !     write(6,*)
         !?  ! endif
         !?  ! CHECK

         !?  ! Jun.29.2011. I should check whether I can use 'do k = ktop, 1, -1' instead of 'do k = ktop, 2, -1'
         !?  !              for later use of convective organization treatment.

         !?    do k = ktop, 2, -1         ! This 'k'  is a layer index
         !?       km = k - 1              ! This 'km' is a base interface index of 'k'
         !?       do ks  = k, ktop
         !?          ksm = ks - 1
         !?       do m   = 1, N_up(ksm)
         !?       do ids = 1, 3 
         !?          if( w_ad(km,ks,m,ids) .gt. wdmax ) then
         !?              f_wd = ( 1._r8 - wdmax / w_ad(km,ks,m,ids) )
         !?              if( kdtd(ks,m,ids) .lt. k .and. kdtd(ks,m,ids) .ge. 1 ) then
         !?                  do kk = k, kdtd(ks,m,ids), -1
         !?                     kkm = kk - 1
         !?                     if( kk .eq. k ) then
         !?                         ! ---------------------------------------------------- !
         !?                         ! I used below general summing form in order to define !
         !?                         ! thermodynamic properties of newly detrained airs.    !
         !?                         ! ---------------------------------------------------- !
         !?                         tmp1                      =    cmf_ar(kk,ks,m,ids)
         !?                         cmf_ar(kk,ks,m,ids)       =                   tmp1 + cmf_ad(kkm,ks,m,ids) * f_wd  
         !?                         thl_ar(kk,ks,m,ids)       =  ( thl_ar(kk,ks,m,ids) * tmp1 + &
         !?                                                       thl_ad(kkm,ks,m,ids) * cmf_ad(kkm,ks,m,ids) * f_wd ) / max( nonzero, cmf_ar(kk,ks,m,ids) )
         !?                         qt_ar(kk,ks,m,ids)        =  (  qt_ar(kk,ks,m,ids) * tmp1 + &
         !?                                                        qt_ad(kkm,ks,m,ids) * cmf_ad(kkm,ks,m,ids) * f_wd ) / max( nonzero, cmf_ar(kk,ks,m,ids) )
         !?                         u_ar(kk,ks,m,ids)         =  (   u_ar(kk,ks,m,ids) * tmp1 + &
         !?                                                         u_ad(kkm,ks,m,ids) * cmf_ad(kkm,ks,m,ids) * f_wd ) / max( nonzero, cmf_ar(kk,ks,m,ids) )
         !?                         v_ar(kk,ks,m,ids)         =  (   v_ar(kk,ks,m,ids) * tmp1 + &
         !?                                                         v_ad(kkm,ks,m,ids) * cmf_ad(kkm,ks,m,ids) * f_wd ) / max( nonzero, cmf_ar(kk,ks,m,ids) ) 
         !?                         do mt = 1, ncnst
         !?                            tr_ar(kk,ks,m,ids,mt)  =  (   tr_ar(kk,ks,m,ids,mt) * tmp1 + &
         !?                                                         tr_ad(kkm,ks,m,ids,mt) * cmf_ad(kkm,ks,m,ids) * f_wd ) / max( nonzero, cmf_ar(kk,ks,m,ids) )
         !?                         enddo
         !?                       ! Nov.28.2012. Below two lines are added.
         !?                         ql_ar(kk,ks,m,ids)        =  (  ql_ar(kk,ks,m,ids) * tmp1 + &
         !?                                                        ql_ad(kkm,ks,m,ids) * cmf_ad(kkm,ks,m,ids) * f_wd ) / max( nonzero, cmf_ar(kk,ks,m,ids) )
         !?                         qi_ar(kk,ks,m,ids)        =  (  qi_ar(kk,ks,m,ids) * tmp1 + &
         !?                                                        qi_ad(kkm,ks,m,ids) * cmf_ad(kkm,ks,m,ids) * f_wd ) / max( nonzero, cmf_ar(kk,ks,m,ids) )
         !?                     elseif( kk .eq. kdtd(ks,m,ids) ) then
         !?                         cmf_ar(kk,ks,m,ids)       =    cmf_ar(kk,ks,m,ids) * ( 1._r8 - f_wd )
         !?                     endif
         !?                     cmf_ad(kkm,ks,m,ids)          =   cmf_ad(kkm,ks,m,ids) * ( 1._r8 - f_wd )
         !?                     w_ad(kkm,ks,m,ids)            =     w_ad(kkm,ks,m,ids) * ( 1._r8 - f_wd )
         !?                     ! ------------------------------------------------------------------------ !
         !?                     ! Same as convective updraft, downdraft area detrainment occurs after full !
         !?                     ! diabatic forcings from the top to the base interface within each layer.  !
         !?                     ! ------------------------------------------------------------------------ !
         !?                     ! Apr.27.2011. I checked below line many many times. Even though it looks unreasonable, 
         !?                     !              it is correct and fully consistent with the corresponding treatment of 
         !?                     !              convective updraft.
         !?                     if( kk .lt. k ) cmf_ad_dia(kk,ks,m,ids) = cmf_ad_dia(kk,ks,m,ids) * ( 1._r8 - f_wd )
         !?                  enddo
         !?              endif
         !?          endif
         !?       enddo
         !?       enddo
         !?       enddo
         !?    enddo

         !?  ! CHECK
         !?  ! if( get_nstep() .eq. 3 ) then
         !?  !     write(6,*)
         !?  !     write(6,*) 'UNICON: Downdraft mass flux after vertical velocity constraint on downdraft'
         !?  !     write(6,*) 'Time step & Layer Index: ', get_nstep(), k
         !?  !     write(6,*) 'cmf_ad(4,5,1,1) =', cmf_ad(4,5,1,1)
         !?  !     write(6,*)
         !?  ! endif
         !?  ! CHECK

         !?  ! Jun.29.2011. I should check whether I can use 'do k = ktop, 1, -1' instead of 'do k = ktop, 2, -1'
         !?  !              for later use of convective organization treatment.

         !?    ! ----------------------------------------------- !
         !?    ! Area fraction constraint on downdraft mass flux !
         !?    ! ----------------------------------------------- !

         !?    do k = ktop, 2, -1         ! This 'k'  is a layer index
         !?       km = k - 1              ! This 'km' is a base interface index of 'k'
         !?       cmf_tent = 0._r8
         !?       ad_tent  = 0._r8 
         !?       do ks  = k, ktop        ! This 'ks' is a layer index from the source layer to the release layer
         !?          ksm = ks - 1
         !?       do m   = 1, N_up(ksm)
         !?       do ids = 1, 3 
         !?          if( cmf_ad(km,ks,m,ids) .gt. nonzero ) then
         !?              cmf_tent = cmf_tent + cmf_ad(km,ks,m,ids)            
         !?              ad_tent  =  ad_tent +   a_ad(km,ks,m,ids)            
         !?          endif
         !?       enddo
         !?       enddo
         !?       enddo
         !?       if( ad_tent .gt. ad_max ) then
         !?         ! f_nd = max( 0._r8, cmf_tent * ( 1._r8 - ad_max / ad_tent ) ) / cmf_tent
         !?           f_nd = max( 0._r8, 1._r8 - ad_max / ad_tent )
         !?           do ks  = k, ktop
         !?              ksm = ks - 1
         !?           do m   = 1, N_up(ksm)
         !?           do ids = 1, 3 
         !?              if( kdtd(ks,m,ids) .lt. k .and. kdtd(ks,m,ids) .ge. 1 ) then
         !?                  do kk = k, kdtd(ks,m,ids), -1
         !?                     kkm = kk - 1
         !?                     if( kk .eq. k ) then
         !?                         ! ------------------------------------------------------------------------------- !
         !?                         ! I used below general summing form (1) due to the proceeding velocity constraint,!
         !?                         ! and (2) to define thermodynamic properties of newly detrained airs.             !
         !?                         ! ------------------------------------------------------------------------------- ! 
         !?                         tmp1                     =    cmf_ar(kk,ks,m,ids)
         !?                         cmf_ar(kk,ks,m,ids)      =                   tmp1 + cmf_ad(kkm,ks,m,ids) * f_nd  
         !?                         thl_ar(kk,ks,m,ids)      =  ( thl_ar(kk,ks,m,ids) * tmp1 + &
         !?                                                      thl_ad(kkm,ks,m,ids) * cmf_ad(kkm,ks,m,ids) * f_nd ) / max( nonzero, cmf_ar(kk,ks,m,ids) )
         !?                         qt_ar(kk,ks,m,ids)       =  (  qt_ar(kk,ks,m,ids) * tmp1 + &
         !?                                                       qt_ad(kkm,ks,m,ids) * cmf_ad(kkm,ks,m,ids) * f_nd ) / max( nonzero, cmf_ar(kk,ks,m,ids) )
         !?                         u_ar(kk,ks,m,ids)        =  (   u_ar(kk,ks,m,ids) * tmp1 + &
         !?                                                        u_ad(kkm,ks,m,ids) * cmf_ad(kkm,ks,m,ids) * f_nd ) / max( nonzero, cmf_ar(kk,ks,m,ids) )
         !?                         v_ar(kk,ks,m,ids)        =  (   v_ar(kk,ks,m,ids) * tmp1 + &
         !?                                                        v_ad(kkm,ks,m,ids) * cmf_ad(kkm,ks,m,ids) * f_nd ) / max( nonzero, cmf_ar(kk,ks,m,ids) ) 
         !?                         do mt = 1, ncnst
         !?                            tr_ar(kk,ks,m,ids,mt) = (  tr_ar(kk,ks,m,ids,mt) * tmp1 + &
         !?                                                      tr_ad(kkm,ks,m,ids,mt) * cmf_ad(kkm,ks,m,ids) * f_nd ) / max( nonzero, cmf_ar(kk,ks,m,ids) )
         !?                         enddo
         !?                       ! Nov.28.2012. Below two lines are added.
         !?                         ql_ar(kk,ks,m,ids)       =  (  ql_ar(kk,ks,m,ids) * tmp1 + &
         !?                                                       qi_ad(kkm,ks,m,ids) * cmf_ad(kkm,ks,m,ids) * f_nd ) / max( nonzero, cmf_ar(kk,ks,m,ids) )
         !?                         qi_ar(kk,ks,m,ids)       =  (  qi_ar(kk,ks,m,ids) * tmp1 + &
         !?                                                       qi_ad(kkm,ks,m,ids) * cmf_ad(kkm,ks,m,ids) * f_nd ) / max( nonzero, cmf_ar(kk,ks,m,ids) )
         !?	               elseif( kk .eq. kdtd(ks,m,ids) ) then
         !?                         cmf_ar(kk,ks,m,ids)      =    cmf_ar(kk,ks,m,ids) * ( 1._r8 - f_nd )
         !?                     endif
         !?                     cmf_ad(kkm,ks,m,ids)         =   cmf_ad(kkm,ks,m,ids) * ( 1._r8 - f_nd )
         !?                     a_ad(kkm,ks,m,ids)           =     a_ad(kkm,ks,m,ids) * ( 1._r8 - f_nd )
         !?                     ! ------------------------------------------------------------------------ !
         !?                     ! Same as convective updraft, downdraft area detrainment occurs after full !
         !?                     ! diabatic forcings from the top to the base interface within each layer.  !
         !?                     ! ------------------------------------------------------------------------ !
         !?                     ! Apr.27.2011. I checked below line many many times. Even though it looks unreasonable, 
         !?                     !              it is correct and fully consistent with the corresponding treatment of 
         !?                     !              convective updraft.
         !?                     if( kk .lt. k ) cmf_ad_dia(kk,ks,m,ids) = cmf_ad_dia(kk,ks,m,ids) * ( 1._r8 - f_nd )
         !?                  enddo
         !?              endif
         !?           enddo
         !?           enddo
         !?           enddo
         !?       endif
         !?    enddo

         !?  ! CHECK
         !?  ! if( get_nstep() .eq. 3 ) then
         !?  !     write(6,*)
         !?  !     write(6,*) 'UNICON: Downdraft mass flux after area fraction constraint on downdraft'
         !?  !     write(6,*) 'Time step & Layer Index: ', get_nstep(), k
         !?  !     write(6,*) 'cmf_ad(4,5,1,1) =', cmf_ad(4,5,1,1)
         !?  !     write(6,*)
         !?  ! endif
         !?  ! CHECK

         !?    endif

         ! ---------------------------------------------------------- !
         !                                                            !
         ! End of vertical velocity and area constraints on downdraft ! 
         !                                                            !
         ! ---------------------------------------------------------- !                            
 
         ! ---------------------------------------------------------------------- !
         ! Compute mass-flux weighted mean                                        !
         !  (1) downdraft properties at the interfaces                            !
         !  (2) detrained properties at the layer mid-point                       !
         ! Also compute mass-flux weighted diabatic contribution.                 !
         ! ---------------------------------------------------------------------- !

         ! orgforce(:mkx)           = 0._r8
         !d    orgforce1                = 0._r8
         !d    orgforce2                = 0._r8
         !d    orgforce3                = 0._r8
         !d    tkePBLorg                = 0._r8
         !d    cmfPBLorg                = 0._r8
         !d    thlPBLorg                = 0._r8
         !d    qtPBLorg                 = 0._r8
         !d    uPBLorg                  = 0._r8
         !d    vPBLorg                  = 0._r8
         ! Sep.10.2011. Restored below 9 variables.
         cmf_d_org_pblh           = 0._r8
         thl_d_org_pblh           = 0._r8
         qt_d_org_pblh            = 0._r8
         u_d_org_pblh             = 0._r8
         v_d_org_pblh             = 0._r8
         tr_d_org_pblh(1:ncnst)   = 0._r8
         qt_dia_d_org             = 0._r8
         thl_dia_d_org            = 0._r8
         tr_dia_d_org(1:ncnst)    = 0._r8
       ! May.1.2014. For the budget consistent cold-pool treatment.
         cmf_d_orgU_pblh          = 0._r8
         thl_d_orgU_pblh          = 0._r8
         qt_d_orgU_pblh           = 0._r8
         u_d_orgU_pblh            = 0._r8
         v_d_orgU_pblh            = 0._r8
         tr_d_orgU_pblh(1:ncnst)  = 0._r8
         qt_dia_d_orgU            = 0._r8
         thl_dia_d_orgU           = 0._r8
         tr_dia_d_orgU(1:ncnst)   = 0._r8
         ! tmp3                     = 0._r8
         do msfc = 1, nseg                         ! This 'msfc' is updraft segment index at surface.
            do ids  = 1, 3                            ! This 'ids' is the type of downdraft source ( 1 : mixing downdraft, 2 : top downdraft, 3 : area downdraft )
               if( ids .eq. 1 ) then
                  ks_top = ktop_msfc(msfc)
                  ks_bot = kiss + 1
               elseif( ids .eq. 2 ) then
                  ks_top = ktop_msfc(msfc)
                  ks_bot = ks_top
               elseif( ids .eq. 3 ) then
                  ks_top = ktop_msfc(msfc) - 1
                  ks_bot = kiss + 1
               endif
               do ks   = ks_top, ks_bot, -1   ! This 'ks'   is a layer index where downdraft sources are generated.
                  ksm  = ks - 1
                  ! ------------------------------------------------------------------------------------------- !
                  ! Convert updraft segment index at surface into shortened-updraft segment index in each layer !
                  ! ------------------------------------------------------------------------------------------- !
                  m = m_from_msfc(ks,msfc)
                  do k = ks, 1, -1            ! This 'k'   is a layer index from the source layer to the 1st (not 2nd) layer. 
                     km = k - 1               ! This 'km'  is a base interface index
                     ! ------------------------------------------------- !
                     ! Sum of downdraft properties at the base interface !
                     ! ------------------------------------------------- ! 
                     ! Aug.30.2011. Note that below 'cmf_ad(km,ks,m,ids) .gt. nonzero' condition already means that that specific
                     !              convective downdraft already passed downdraft buoyancy sorting. 
                     !              Thus, below block is very well constructed.
                     if( cmf_ad(km,ks,m,ids) .gt. nonzero ) then
                        cmf_d(km) = cmf_d(km) + cmf_ad(km,ks,m,ids)            
                        a_d(km)   =   a_d(km) +   a_ad(km,ks,m,ids)            
                        thl_d(km) = thl_d(km) + thl_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids)
                        qt_d(km)  =  qt_d(km) +  qt_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids)
                        u_d(km)   =   u_d(km) +   u_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids)
                        v_d(km)   =   v_d(km) +   v_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids)
                        w_d(km)   =   w_d(km) +   w_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids)
                        wa_d(km)  =  wa_d(km) +   w_ad(km,ks,m,ids) *   a_ad(km,ks,m,ids)
                        ! Nov.28.2012. Below 'conden' block computing 'ql_ad,qi_ad' are commented out since
                        !              they are already computed above on this same day. 
                        !              Note that below 'ql_d(km),qi_d(km)' are obtained by doing a simple adiabatic sum,
                        !              without mixing yet all the the downdraft component. Thus, these 'ql_d(km),qi_d(km)' are
                        !              internally consistent with 'tr_d(km,ixnumliq),tr_d(km,ixnumice)' since each
                        !              component of 'ql_ad(km,ks,m,ids),tr_ad(km,ks,m,ids,mt)' has been designed to be fully 
                        !              consistent. If I allow mixing by computing 'ql_d_mix(km),qi_d_mix(km)' from 'thl_d(km),qt_d(km)'
                        !              using subroutine 'conden', the resulting 'ql_d_mix(km)' will be generally differ from 'ql_d(km)'.
                        !              Using this difference information, I can also compute consistent 'tr_d_mix(km),tr_d_mix(km)'   
                        !              asuming homegeneous evaporation-condensation. This is the very reason why I accurately
                        !              computed all of 'ql,qi' for each the most basic component.
                        ! call conden( ps0(km), thl_ad(km,ks,m,ids), qt_ad(km,ks,m,ids), th, qv, ql, qi, qse, id_check)
                        ! if( id_check .eq. 1 ) then
                        !     id_exit = .true.
                        !     go to 333
                        ! endif
                        ! ql_ad(km,ks,m,ids) = ql
                        ! qi_ad(km,ks,m,ids) = qi
                        ql_d(km)  =  ql_d(km) +  ql_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids)  
                        qi_d(km)  =  qi_d(km) +  qi_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids)  
                        qla_d(km) = qla_d(km) +  ql_ad(km,ks,m,ids) *   a_ad(km,ks,m,ids)  
                        qia_d(km) = qia_d(km) +  qi_ad(km,ks,m,ids) *   a_ad(km,ks,m,ids)  
                        do mt = 1, ncnst
                           tr_d(km,mt)  =  tr_d(km,mt) +  tr_ad(km,ks,m,ids,mt) * cmf_ad(km,ks,m,ids)
                        enddo
                        ! ---------------------------------------------------------------------------------------- !
                        ! Refinement of Organization                                                               !
                        ! In order to compute convective organization at surface, only sum the downdraft mass flux !
                        ! that (1) was originated above PBLH, and (2) reaches down to surface by the rigorous      !
                        ! downdraft buoyancy sorting in the lowest model layer ( k = 1 ).                          !
                        ! This is an attempt to sort out only the downdraft mass flux forced by evaporation of     !
                        ! convective precipitation.                                                                !
                        ! Mar.11.2013. Comment-out below block since it is not used any more.                      !
                        !              In addition, 'th,qv,ql,qi' are not computed correctly since above 'conden'  !
                        !              was commented out.                                                          !  
                        ! ---------------------------------------------------------------------------------------- !
                        ! thvl = thl_ad(km,ks,m,ids) * ( 1._r8 + zvir * qt_ad(km,ks,m,ids) )
                        ! thv  = th * ( 1._r8 + zvir * qv - ql - qi )
                        ! if( ithv_minE .eq. -1 ) then
                        !     tmp1 = thvl
                        !     tmp2 = thvl0bot(k)
                        ! else
                        !     tmp1 = thv
                        !     tmp2 = thv0bot(k)
                        ! endif
                        ! Apr.03.2011. Refinement for organization. Use height instead of pressure to treat
                        !              high-mountain region ( i.e., Hymalaya ). Potentially, we can also use
                        !              w_ad(km,ks,m,ids) information. For example, we can use 'w_ad' as a weighting
                        !              factor since downdraft mass flux with stronger vertical velocity is likely to
                        !              be more efficient in triggering organized turbulence within the PBL. In order
                        !              for this weighting approach to be more effective, we should reduce 'wdmin' 
                        !              further down to for example, 0.1 [m/s]. We can also include the RH information
                        !              of downdraft ( i.e., already computed above as 'qv/qse' ) to pick up the 
                        !              necessary downdraft mass flux. The best way is to print-out every options 
                        !              and to pick-up the most reasonable case.  
                        ! Compute various optional choices.
                        ! Option.1. Original. Downdraft originated above the PBL top and reaching to the surface  
                        ! if( z0(ks) .gt. pblhz .and. k .eq. 1 .and. tmp1 .lt. tmp2 ) then 
                        !     orgforce(1) = orgforce(1) + cmf_ad(km,ks,m,ids)
                        ! endif 
                        ! Option.2 & 3. Downdraft originated above 5 km and reaching down into the mid PBL height.
                        !               Also multiply vertical velocity factor as 3rd option.
                        !               In order to suppress precipitation in Hymalaya, it may be good to use
                        !               pressure information instead of height. 
                        !               This 3rd option seems to be the best. Maybe, the height coordinate is better.
                        ! Jun.28.2011.  Change to the unit of TKE [m2/s2] by dividing by ( 2._r8 * rho0(k) ).
                        !               From this, 'org / ( cc2_org * tau_org )' [m2/s2] becomes mean TKE induced by
                        !               convective downdraft. 
                        ! if( zs0(km) .le. 0.5_r8 * pblhz .and. zs0(k) .ge. 0.5_r8 * pblhz .and. ps0(ksm) .lt. 7.e4_r8 ) then  
                        !     orgforce(2) = orgforce(2) + cmf_ad(km,ks,m,ids)
                        !     orgforce(3) = orgforce(3) + cmf_ad(km,ks,m,ids) * w_ad(km,ks,m,ids)
                        ! endif
                        ! Jul.28.2011. The '016' simulation mis-used negative sign in progup_wu2 for convective resulting in w_ad = wdmin = 0.1
                        !              almost always. In order to reproduce '016', I thus use only 'cmf_ad' and 'cc2_org' is reduced by 1 order
                        !              compared to '016'.
                        !! if( zs0(km) .le. 0.5_r8 * pblhz .and. zs0(k) .ge. 0.5_r8 * pblhz .and. zs0(ksm) .gt. max(1.e3_r8,pblhz) ) then
                        ! if( zs0(km) .le. 0.5_r8 * pblhz .and. zs0(k) .ge. 0.5_r8 * pblhz .and. zs0(ksm) .gt. (pblhz+10._r8) ) then    
                        ! orgforce(2) = orgforce(2) + cmf_ad(km,ks,m,ids)
                        ! orgforce1   = orgforce1   + cmf_ad(km,ks,m,ids) * w_ad(km,ks,m,ids) / ( 2._r8 * rho0(k) )
                        ! orgforce1   = orgforce1   + cmf_ad(km,ks,m,ids) * w_ad(km,ks,m,ids)
                        ! orgforce1   = orgforce1   + cmf_ad(km,ks,m,ids)
                        ! orgforce1   = orgforce1   + cmf_ad(km,ks,m,ids) / ( pblhz * rho0(k) )
                        ! endif
                        ! Jul.29.2011. Configuration to remove unreasonable climatological
                        !              (1) Remove stable PBL with kpblh = 1
                        !              (2) Remove area downdraft since it is non-physical quantities
                        !              (3) Only consider downdraft originated in the layers from above kpblh
                        !              Note that 'zs0(kpblhm)' is numerical PBL height that should be also used in computing
                        !              damping time scale ( tau_org ) of convective organization at the beginning.
                        !              The unit of below orgforce(3) before diving by zs0(kpblhm) is [ J/m2 ].
                        ! Very Important : I should use 'orgforce(3) = orgforce(3) / zs0(kpblhm)' later after finishing all the downdraft
                        !                  iteration loop, not here.  
                        !                  Note also that I am using height coordinate, not pressure coordinate to be consistent with
                        !                  the PBL depth, 'pblhz' expressed in height coordinate. 
                        !                  Note that the final orgforce(3) after dividing by PBL depth is a PBL-mean downdraft KE not the
                        !                  vertically integrated downdraft KE.
                        ! Sep.09.2011. Remove 'kpblh .ge. 2' because it is now automatically satisfied.
                        ! if( ids .ne. 3 .and. ks .gt. kpblh ) then 
                        !     if( km .eq. 0 ) then
                        !         dzi = z0(1) - zs0(0)
                        !     elseif( km .eq. kpblhm ) then
                        !         dzi = zs0(kpblhm) - z0(kpblhm)                    
                        !     else
                        !         dzi = z0(k) - z0(km)
                        !     endif
                        !   ! orgforce1 = orgforce1 + ( w_u(km) * cmf_u(km) / ( rho0bot(k) + rho0top(max(km,1)) ) ) * dzi
                        !  !! orgforce1 = orgforce1 / pblhz
                        ! endif
                        ! Aug.15.2011. Compute 'qtflx_org, slflx_org' generated by pure convective downdraft
                        !              driven by convective process.
                        ! Sep.09.2011. Remove 'kpblh .ge. 2' because it is now automatically satisfied.
                        !d              if( ids .ne. 3 .and. ks .gt. kpblh ) then 
                        !d                  cmf_d_org(km) = cmf_d_org(km) + cmf_ad(km,ks,m,ids)            
                        !d                  thl_d_org(km) = thl_d_org(km) + thl_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids)
                        !d                  qt_d_org(km)  =  qt_d_org(km) +  qt_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids)
                        !d              endif
                        ! -------------------------------------------------------------------------------------------- !
                        ! Aug.30.2011. Hopely, final correct and consistent organization formula.                      !
                        !              Compute mass-flux weighted mean downdraft properties at the PBL top interface   !
                        !              to compute conservative downdraft turbulent fluxes of conservative scalars and  !
                        !              corresponding buoyancy fluxs at the PBL top interface.                          !
                        !              Only consider downdraft that has been originated above PBL and reaches to the   !
                        !              1st model interface ( the top interface of the lowest model layer ). This is    !
                        !              very conservative constraint and so can effectively remove any organization in  !
                        !              the shallow convection case, such as BOMEX.                                     !             
                        !              Note that since (1) downdraft buoyancy sorting uses buoyancy instead of         !
                        !              vertical velocity and (2) cmf_ad(0,ks,m,ids) is inserted by explicit non-zero   !
                        !              value from above and (3) epsz_dn = delz_dn, below use of cmf_ad(1,ks,m,ids)     !
                        !              will produce the same results as the use of cmf_ad(0,ks,m,ids). That is, we can !
                        !              use the requirement that downdraft should reach to the surface.                 ! 
                        ! Sep.06.2011. In the below block, I should only select the downdraft mass flux that enteres   !
                        !              only into the wake area, not into the grid-mean. Since UNICON has 3 downdrafts  !
                        !              sources ( mixing, top, area downdraft ), this choice is important: for example, !
                        !              at the dry convective PBL top, all 3 downdrafts are likely to be distributed    !
                        !              all over the grid, not into the specific wake area. I should carefully devise   !
                        !              below if block in order to remove those clearly non-appropriate downdrafts at   !
                        !              the top of the dry convective PBL. For this purpose, the best constraint is to  !
                        !              use the precipitation flux information as well.                                 !   
                        !              Thus, I can use 'flxrain_ava_msfc(k,msfc) + flxsnow_ava_msfc(k,msfc)' where 'k' !
                        !              is a flux interface and there are 'rain + snow' fluxes after evaporation within !
                        !              downdraft for each updraft segments 'msfc'. Ideally, it might be better to use  !
                        !              precipitation flux after evaporation within environment too. But this will need !
                        !              to move below block after evaporation within environment. Thus, let's keep the  !
                        !              location of the below original block which is also reasonably good.             !
                        !                                                                                              !
                        ! Adding of diabatic forcing within convective downdraft : within below if block, I should     !
                        !              also compute diabatic forcing imposed into the convective downdraft since that  !
                        !              diabatic forcing will be also deposited into the wake area when downddraft is   !
                        !              eventually detrained in the wake area. Note differential grid-mean diabatic     !
                        !              forcing within environment between non-wake ( Qn ) and wake area ( Qw )         !
                        !              averaged over the PBL depth will be added later separately.                     !                                                                       
                        !                                                                                              !
                        ! Given the inclusion of precipitation flux constraint, I may not need to use the constraint   !
                        ! of 'cmf_ad(1,ks,m,ids) .gt. nonzero' in the below if block. I should carefully think about   !
                        ! this.                                                                                        !  
                        ! Sep.09.2011. Below block are commented-out since it will be collectively computed later.     ! 
                        ! Sep.10.2011. The '031h' simulation produced unreasonably large 'cuorg' in the stratocumulus  !
                        !              deck. In order to fix this problem, I restored below block to choose select     !
                        !              downdraft to remove, for example, penetrative downdraft at the top of dry and   !
                        !              stratocumulus-topped PBL, which are likely to be distributed all over the grid  !
                        !              instead of being concentrated over the wake area.                               !             
                        ! -------------------------------------------------------------------------------------------- !
                        ! Below is the old condition. 
                        ! Sep.09.2011. Remove 'kpblh .ge. 2' because it is now automatically satisfied.
                        !! if( ks .gt. kpblh .and. km .eq. kpblhm .and. cmf_ad(1,ks,m,ids) .gt. nonzero ) then 
                        ! Below is the new condition.
                        ! The first if block is imposing a constraint on 'ks','m or m(or msfc)' and 'ids'.
                        ! Sep.11.2011. Potentially, I can remove the last 3rd condition if it imposes too strong constraints.
                        ! ---------------------------------------------- !
                        ! Below is the original code before Aug.03.2012. !
                        ! ---------------------------------------------- !
                        ! if( ks                                                              .gt. kpblh   .and. & 
                        !     flxrain_ava_msfc(kpblhm,msfc) + flxsnow_ava_msfc(kpblhm,msfc)   .gt. nonzero .and. &
                        !     cmf_ad(1,ks,m,ids)                                              .gt. nonzero ) then 
                        ! ---------------------------------------- !
                        ! Below is the new code after Aug.03.2012. !
                        ! ---------------------------------------- ! 
                        ! Note that 'flxrain_ava_msfc(kpblhm,msfc),flxsnow_ava_msfc(kpblhm,msfc)' are precipitation fluxes
                        ! after evaporation in 'all' the convective downdrafts but before evaporation within environment.
                        ! In contrast to the above old treatment before Aug.03.2012, only consider the contribution of
                        ! mixing downdraft which has experienced evaporation of precipitation - note that I have not 
                        ! performed any evaporation within top downdraft and area downdraft in the above for consistency
                        ! with the current treatment.    
                        ! Note that the unit of precipitation flux in the below is changed from [kg/s/m2] to [mm/day]
                        ! by assuming that density of snow is 250 [kg/m^3].
                        ! The parameter sentence should specify 'prepminPBLH_org [ mm/day ]' in the parameter sentence, which
                        ! corresponds to 'individual' updraft segment, not the whole mean of various updrafts.
                        ! This should be carefully defined not to be sensitive to the choice of 'nseg'.                                                        
                        ! Feb.06.2013. As of today, we can use 'flxrain_msfc(kpblhm)' instead of 'flxrain_msfc(kpblhm,msfc)'
                        !              in the below if sentence. Thus, this can be reasonably used to reduce organization in
                        !              the trade cumulus regime by using positive small value of prepminPBLH_org, so that
                        !              we can potentially obtain reasonable SWCF there. This should be tested.
                        ! Mar.18.2013. Only include mixing downdraft similar to the treatment of evaporation within downdraft.

                        if( ids .eq. 1               .and. &  
                           ks   .gt. kpblh           .and. &
                           !?                  8.64e7_r8*(flxrain_ava_msfc(kpblhm,msfc)/1000._r8+flxsnow_ava_msfc(kpblhm,msfc)/250._r8)  .gt. prepminPBLH_org .and. &
                           !!                  8.64e7_r8*(flxrain_msfc(kpblhm)/1000._r8+flxsnow_msfc(kpblhm)/250._r8)                    .gt. prepminPBLH_org .and. &
                           8.64e7_r8*(flxrain_msfc(kpblhm,msfc)/1000._r8+flxsnow_msfc(kpblhm,msfc)/250._r8) .gt. prepminPBLH_org &
                           .and. cmf_ad(1,ks,m,ids) .gt. nonzero ) then 
                           ! ---------------------------------------------------------- !
                           ! Compute adiabatic downdraft fluxes of conservative scalars !
                           ! ---------------------------------------------------------- !
                           if( km .eq. kpblhm ) then
                              cmf_d_org_pblh        =     cmf_d_org_pblh +                          cmf_ad(km,ks,m,ids)
                              thl_d_org_pblh        =     thl_d_org_pblh +    thl_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids)
                              qt_d_org_pblh         =      qt_d_org_pblh +     qt_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids)
                              u_d_org_pblh          =       u_d_org_pblh +      u_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids)
                              v_d_org_pblh          =       v_d_org_pblh +      v_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids)
                              do mt = 1, ncnst
                                 tr_d_org_pblh(mt)  =  tr_d_org_pblh(mt) +  tr_ad(km,ks,m,ids,mt) * cmf_ad(km,ks,m,ids)
                              enddo
                           endif
                           ! ----------------------------------------------------------------------------------------------------------- !
                           ! Compute diabatic forcings integrated all over the layers within PBL.                                        !
                           ! Note that there is no diabatic forcing for 'u,v' since 'PGF' forcing is a simple conversion                 !
                           ! between environment and convective downdraft.                                                               !
                           ! For tracers, tendencies in each layer is computed by using 'pdelx = dpdry0(k)' not 'dp0(k)'.                !
                           ! I multiplied 'dp0(k)' for vertical integration. However, I should check this in future.                     !
                           ! Note that below computation of diabatic forcing within downdraft does not contain either 'snow melting'     !
                           ! or 'corrective flux', both of which will be treated later as a part of environmental diabatic forcing.      !
                           ! Thus, there will be no missing process or double counting.                                                  !
                           ! Sep.10.2011. Note tha below computation of diabatic forcing within downdraft within PBL should nbe done in  !
                           !              a fully cocnsitently way as the above computation of adiabatic forcing, i.e., using the        !
                           !              exactly same set of convective downdraft as in the current code.                               !
                           ! Aug.02.2012. From above, I only allowed evaporation of precipitation within mixing downdraft not within     !
                           !              top downdraft and area downdraft anymore.                                                      !
                           ! ----------------------------------------------------------------------------------------------------------- !
                           if( k .le. kpblhm ) then
                              qt_dia_d_org        =       qt_dia_d_org     + & 
                                 g * ( prep_qtl_ad(k,ks,m,ids)  + prep_qti_ad(k,ks,m,ids)  + evp_qtl_ad(k,ks,m,ids)  &
                                 + evp_qti_ad(k,ks,m,ids)  ) * cmf_ad_dia(k,ks,m,ids)
                              thl_dia_d_org       =       thl_dia_d_org    + & 
                                 g * ( prep_thll_ad(k,ks,m,ids) + prep_thli_ad(k,ks,m,ids) + evp_thll_ad(k,ks,m,ids) &
                                 + evp_thli_ad(k,ks,m,ids) ) * cmf_ad_dia(k,ks,m,ids)
                              do mt = 1, ncnst
                                 ! if( cnst_get_type_byind(mt) .eq. 'wet' ) then
                                 !     pdelx = dp0(k)
                                 ! else
                                 !     pdelx = dpdry0(k)
                                 ! endif
                                 tmp1 = dp0(k) / dptr0(k,mt)
                                 tr_dia_d_org(mt)   =     tr_dia_d_org(mt) + tmp1 * &
                                    g * ( evp_tr_ad(k,ks,m,ids,mt) + prep_tr_ad(k,ks,m,ids,mt) + wdep_tr_ad(k,ks,m,ids,mt) &
                                    + eff_tr_ad(k,ks,m,ids,mt) ) * cmf_ad_dia(k,ks,m,ids)
                              enddo
                           endif
                        endif

                      ! -------------------------------------------------------------------------------------------------------------------- !
                      ! May.1.2014. For budget consistent cold pool treatment.                                                               ! 
                      ! In contrast to the above part computing 'cmf_d_org_pblh' that exculsively sinks down into 'awk_PBL',                 !
                      ! this part computes 'cmf_d_orgU_pblh' that exclusively sinks down into '1-awk_PBL'.                                   !
                      ! Note that if 'i_budget_coldpool .eq. 1', there is no downdraft exclusively sinking into '1-awk_PBL', so that         !
                      ! it becomes 'cmf_d_orgU_pblh=0, thl_d_org_pblh=0, qt_dia_d_org=0' which is already done at the initialization at the  !
                      ! beginning of downdraft computation routine. Thus, I need to compute only for 'i_budget_cold_pool .eq. 2' when        !
                      ! all the downdrafts other than 'cmf_d_org_pblh' computed above exclusively fall into 'awk_PBL'.                       !
                      ! Below 'if' constraints is exact opposite to the above 'if' constraint, currently, but it can be further              !
                      ! generalized by similarly defining 'clf_d_orgG_pblh' in future.                                                       !
                      ! -------------------------------------------------------------------------------------------------------------------- !

                        if( i_budget_coldpool .eq. 2 .or. i_budget_coldpool .eq. 4 .or. &
                            i_budget_coldpool .eq. 5 ) then
               
                        if( .not. ( ids .eq. 1 .and. ks .gt. kpblh .and. &
!?                                  8.64e7_r8*(flxrain_ava_msfc(kpblhm,msfc)/1000._r8+flxsnow_ava_msfc(kpblhm,msfc)/250._r8)  .gt. prepminPBLH_org .and. &
!!                                  8.64e7_r8*(flxrain_msfc(kpblhm)/1000._r8+flxsnow_msfc(kpblhm)/250._r8)                    .gt. prepminPBLH_org .and. &
                                    8.64e7_r8*(flxrain_msfc(kpblhm,msfc)/1000._r8+&
                                    flxsnow_msfc(kpblhm,msfc)/250._r8) &
                                    .gt. prepminPBLH_org .and. &
                                    cmf_ad(1,ks,m,ids) &
                                    .gt. nonzero ) ) then 
                            ! ---------------------------------------------------------- !
                            ! Compute adiabatic downdraft fluxes of conservative scalars !
                            ! ---------------------------------------------------------- !
                            if( km .eq. kpblhm ) then
                                cmf_d_orgU_pblh        =     cmf_d_orgU_pblh + &
                                                             cmf_ad(km,ks,m,ids)
                                thl_d_orgU_pblh        =     thl_d_orgU_pblh + &
                                       thl_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids)
                                qt_d_orgU_pblh         =      qt_d_orgU_pblh + &
                                        qt_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids)
                                u_d_orgU_pblh          =       u_d_orgU_pblh + &
                                         u_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids)
                                v_d_orgU_pblh          =       v_d_orgU_pblh + &
                                         v_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids)
                                do mt = 1, ncnst
                                   tr_d_orgU_pblh(mt)  =  tr_d_orgU_pblh(mt) + &
                                     tr_ad(km,ks,m,ids,mt) * cmf_ad(km,ks,m,ids)
                                enddo 
                            endif
                            if( k .le. kpblhm ) then
                                qt_dia_d_orgU          =    qt_dia_d_orgU    + & 
                                                            g * ( prep_qtl_ad(k,ks,m,ids)  + &
   prep_qti_ad(k,ks,m,ids)  + evp_qtl_ad(k,ks,m,ids)  + evp_qti_ad(k,ks,m,ids)  ) * & 
                                                            cmf_ad_dia(k,ks,m,ids)
                                thl_dia_d_orgU         =    thl_dia_d_orgU   + & 
                                                            g * ( prep_thll_ad(k,ks,m,ids) + &
   prep_thli_ad(k,ks,m,ids) + evp_thll_ad(k,ks,m,ids) + evp_thli_ad(k,ks,m,ids) ) * & 
                                                            cmf_ad_dia(k,ks,m,ids)
                                do mt = 1, ncnst
                                   tmp1 = dp0(k) / dptr0(k,mt)
                                   tr_dia_d_orgU(mt)   =    tr_dia_d_orgU(mt) + tmp1 * &
                                                            g * ( evp_tr_ad(k,ks,m,ids,mt) + &
   prep_tr_ad(k,ks,m,ids,mt) + wdep_tr_ad(k,ks,m,ids,mt) + eff_tr_ad(k,ks,m,ids,mt) ) * & 
                                                            cmf_ad_dia(k,ks,m,ids)
                                enddo 
                            endif
                        endif

                        endif

                        ! Jul.25.2011. Below computes mean TKE within PBL of convective downdraft instead of the
                        !              value at the mid-height of PBL. This is designed to reduce the sensitivity
                        !              to abrupt convective downdraft. 
                        !  if( ksm .gt. kpblhm ) then
                        !      if( km .eq. 0 ) then
                        !          dpi = ps0(0) - p0(1)
                        !      elseif( kpblh .ne. 1 .and. km .eq. kpblhm ) then
                        !          dpi = p0(kpblhm) - ps0(kpblhm)                    
                        !      elseif( kpblh .eq. 1 .and. km .eq. 1 ) then
                        !          dpi = p0(1) - ps0(1)                    
                        !      else
                        !          dpi = p0(km) - p0(k)
                        !      endif
                        !      orgforce1 = orgforce1 + cmf_ad(km,ks,m,ids) * w_ad(km,ks,m,ids) / ( rho0bot(k) + rho0top(max(1,km)) ) * ( dpi / pblhp )
                        !  endif
                        ! Jul.08.2011. Compute 'grid-mean & averaged over PBL depth' TKE and perturbations of conservative
                        !              scalars by convective downdrafts that have been originated from 'kpbl+1' and above layers.
                        !              For environmental mean value at the interface, I used approximate simple
                        !              average by multiplying 0.5 instead of layer-thickness for saving computation time. 
                        !              This is similar to the way used for computing tkePBL by moist turbulences above.
                        !              Note that this 'tkePBLdn' can be directly used for the source of convective organization
                        !              either in a diagnostic or prognostic way.
                        ! if( km .le. kpblhm .and. ksm .ge. kpblh ) then    
                        !     if( km .eq. 0 ) then
                        !         dpi = ps0(0) - p0(1)
                        !     elseif( kpblh .ne. 1 .and. km .eq. kpblhm ) then
                        !         dpi = p0(kpblhm) - ps0(kpblhm)                    
                        !     elseif( kpblh .eq. 1 .and. km .eq. 1 ) then
                        !         dpi = p0(1) - ps0(1)                    
                        !     else
                        !         dpi = p0(km) - p0(k)
                        !     endif
                        !   ! tmp2      = ( cmf_ad(km,ks,m,ids) * w_ad(km,ks,m,ids) ) / ( rho0bot(k) + rho0top(max(1,km)) ) * ( dpi / pblhp )
                        !     tmp2      = 0.5_r8 * ( ( u_ad(km,ks,m,ids) - 0.5_r8 * ( u0(max(1,km)) + u0(k) ) )**2._r8 + &
                        !                            ( v_ad(km,ks,m,ids) - 0.5_r8 * ( v0(max(1,km)) + v0(k) ) )**2._r8 + &  
                        !                            ( w_ad(km,ks,m,ids)                                      )**2._r8 ) * a_ad(km,ks,m,ids) * ( dpi / pblhp )  
                        !     tkePBLorg = tkePBLorg + tmp2
                        !     thlPBLorg = thlPBLorg + ( thl_ad(km,ks,m,ids) - 0.5_r8 * ( thl0(max(1,km)) + thl0(k) ) ) * a_ad(km,ks,m,ids) * ( dpi / pblhp )
                        !     qtPBLorg  = qtPBLorg  + (  qt_ad(km,ks,m,ids) - 0.5_r8 * (  qt0(max(1,km)) +  qt0(k) ) ) * a_ad(km,ks,m,ids) * ( dpi / pblhp )
                        !     orgforce1 = orgforce1 + tmp2
                        ! endif 

                        ! if( km .eq. 0 .and. ksm .ge. 1 ) then    
                        ! if( km .eq. 0 .and. ksm .ge. kpblh ) then    
                        ! Below line is the very previous one.
                        ! if( km .eq. 0 .and. ksm .ge. kpblhm ) then
                        !d              if( km .eq. 0 .and. ksm .gt. kpblhm ) then
                        ! Jul.18.2011. I checked that below lines produced almost similar results as the above line.
                        !              Thus, I choose the above line which is mre conceptually attractable. 
                        ! if( zs0(km) .le. 0.5_r8 * pblhz .and. zs0(k) .ge. 0.5_r8 * pblhz .and. zs0(ksm) .gt. ( pblhz + 10._r8 ) ) then    
                        ! Jul.15.2011. Only includes mixing downdraft. Also remove downdraft generated at the PBL top interface. 
                        ! if( km .eq. 0 .and. ksm .gt. kpblhm .and. ids .eq. 1 ) then    
                        ! Jul.15.2011. For consistency with the computation of thlPBLorg_old etc., let's use the mass-flux instead of area.
                        !              for weighting factor, tmp1.
                        ! tmp1      = a_ad(km,ks,m,ids)
                        ! tmp1      = cmf_ad(km,ks,m,ids)
                        ! tmp2      = 0.5_r8 * ( ( u_ad(km,ks,m,ids) - u0bot(1) )**2._r8 + &
                        !                        ( v_ad(km,ks,m,ids) - v0bot(1) )**2._r8 + &  
                        !                        ( w_ad(km,ks,m,ids)            )**2._r8 ) * tmp1  
                        ! tmp2      = 0.5_r8 * w_ad(km,ks,m,ids)**2._r8 * tmp1
                        ! Jul.13.2011. As a semi-final configuration, tkePBLorg will be replaced by 'wa_d(0)' when it is
                        !              saved into 'inout' variables. Below 'tkePBLorg, thlPBLorg, qtPBLorg' are not used
                        !              in the actual computation in this semi-final configuration and I keep this here
                        !              just for possible future use.  
                        !              Note that the term with '1 < ASRG = pblhz / vertical scale of gust front within PBL < 10' denotes the
                        !              modification of meso-scale flux at surface during movement of the horizontal scale of 
                        !              meso-scale organization. Modification of w_ad(km,ks,m,ids) and aerosols are simply neglected 
                        !              at this stage. 
                        !              Note also that w_ad(km,ks,m,ids) is always larger than wdmin at surface. Thus, below computation does not cause
                        !              model blow-out.
                        ! Jul.15.2011. I should save downdraft mass flux in the tkePBLorg for reasonable computation of time-averaged conservative
                        !              scalars for organized source air. 
                        ! Jul.15.2011. Note that since strong 'w_ad(km,ks,m,ids)' may increase upward surface flux as well as reducing the contact 
                        !              time-scale of convective downdraft as near surface, we may not need the division by 'w_ad' due to double cancellation. 
                        !              Thus, I used 'sigma_thl', 'sigma_qt', etc. instead. 
                        ! Jul.16.2011. I use more physically-reasonable formulation including 'pblhz / turn_org' as below.
                        !              This new formulation will impose a necessary negative feedback for convective organization.
                        !              Note that cmf_ad(km,ks,m,ids) is multiplied for mass-flux weighted average.  
                        !              An appropriate upper limit should be pre-imposed on 'turn_org' to prevent too much perturbation on
                        !              thlPBLorg etc in the below line.  

                        ! tkePBLorg   = tkePBLorg + 0.5_r8 * w_ad(km,ks,m,ids)**2._r8 * a_ad(km,ks,m,ids)
                        !d                  tkePBLorg   = tkePBLorg + cmf_ad(km,ks,m,ids) * w_ad(km,ks,m,ids) / ( 2._r8 * rho0(k) )
                        !d                  cmfPBLorg   = cmfPBLorg + cmf_ad(km,ks,m,ids)

                        ! thlPBLorg   = thlPBLorg + ( thl_ad(km,ks,m,ids) - thl0bot(1) + ASRG * sigma_thl ) * cmf_ad(km,ks,m,ids)
                        ! qtPBLorg    =  qtPBLorg + (  qt_ad(km,ks,m,ids) -  qt0bot(1) + ASRG *  sigma_qt ) * cmf_ad(km,ks,m,ids)
                        ! uPBLorg     =   uPBLorg + (   u_ad(km,ks,m,ids) -   u0bot(1) + ASRG *   sigma_u ) * cmf_ad(km,ks,m,ids)
                        ! vPBLorg     =   vPBLorg + (   v_ad(km,ks,m,ids) -   v0bot(1) + ASRG *   sigma_v ) * cmf_ad(km,ks,m,ids)

                        !d                  thlPBLorg   = thlPBLorg + ( thl_ad(km,ks,m,ids) - thl0bot(k) + ASRG * shflx / ( rho0bot(k) * cp * exns0(km) * w_org ) ) * cmf_ad(km,ks,m,ids)
                        !d                  qtPBLorg    =  qtPBLorg + (  qt_ad(km,ks,m,ids) -  qt0bot(k) + ASRG * qflx  / ( rho0bot(k) *                  w_org ) ) * cmf_ad(km,ks,m,ids)
                        !d                  uPBLorg     =   uPBLorg + (   u_ad(km,ks,m,ids) -   u0bot(k) + ASRG * taux  / ( rho0bot(k) *                  w_org ) ) * cmf_ad(km,ks,m,ids)
                        !d                  vPBLorg     =   vPBLorg + (   v_ad(km,ks,m,ids) -   v0bot(k) + ASRG * tauy  / ( rho0bot(k) *                  w_org ) ) * cmf_ad(km,ks,m,ids)

                        ! orgforce1 = orgforce1 + tmp2
                        ! Jul.10.2011. Below 'orgforce(3)' formula does not contain horizontal momentum flux by convective downdraft.
                        !              It is not clear at this stage whether I should include horizontal flux component here.
                        !              Note also that 'cmf_ad(km,ks,m,ids) * w_ad(km,ks,m,ids)' is downdraft momentum flux by convective
                        !              downdraft, which is the source of TKE. Similarly, we can include horizontal momentum flux
                        !              by convective downdraft. Then, the physical meaning of convective organization becomes
                        !              more clear and similar to the TKE with a time history as I am requesting.
                        ! orgforce1 = orgforce1 + cmf_ad(km,ks,m,ids) * w_ad(km,ks,m,ids) / ( 2._r8 * rho0(k) )
                        ! orgforce1 = orgforce1 + cmf_ad(km,ks,m,ids)
                        ! tmp3        = tmp3 + cmf_ad(km,ks,m,ids)
                        !d              endif 

                        ! Option.4. Near-saturated downdraft reaching down into the mid PBL height. This does not consider
                        !           source height - seems to be most clean and should work well if the scheme is well 
                        !           formulated mimicking the nature. Multiply vertical velocity factor.
                        ! if( zs0(km) .le. 0.5_r8 * pblhz .and. zs0(k) .ge. 0.5_r8 * pblhz .and. ( qv / qse ) .gt. 0.9_r8 ) then  
                        !     orgforce(4) = orgforce(4) + cmf_ad(km,ks,m,ids) * w_ad(km,ks,m,ids)
                        ! endif              
                        ! Option.5. Same as option.4 but add origination height.
                        ! if( zs0(km) .le. 0.5_r8 * pblhz .and. zs0(k) .ge. 0.5_r8 * pblhz .and. zs0(ksm) .gt. max(1.e3_r8,pblhz) .and. ( qv / qse ) .gt. 0.9_r8 ) then  
                        !     orgforce(5) = orgforce(5) + cmf_ad(km,ks,m,ids) * w_ad(km,ks,m,ids)
                        ! endif
                        ! Option.6-8. Same as option 3-5 but only includes 'mixing downdraft'
                        ! if( zs0(km) .le. 0.5_r8 * pblhz .and. zs0(k) .ge. 0.5_r8 * pblhz .and. zs0(ksm) .gt. max(1.e3_r8,pblhz) .and. ids .eq. 1 ) then  
                        !     orgforce(6) = orgforce(6) + cmf_ad(km,ks,m,ids) * w_ad(km,ks,m,ids)
                        ! endif
                        ! if( zs0(km) .le. 0.5_r8 * pblhz .and. zs0(k) .ge. 0.5_r8 * pblhz .and. ( qv / qse ) .gt. 0.9_r8 .and. ids .eq. 1 ) then  
                        !     orgforce(7) = orgforce(7) + cmf_ad(km,ks,m,ids) * w_ad(km,ks,m,ids)
                        ! endif              
                        ! if( zs0(km) .le. 0.5_r8 * pblhz .and. zs0(k) .ge. 0.5_r8 * pblhz .and. zs0(ksm) .gt. max(1.e3_r8,pblhz) .and. ( qv / qse ) .gt. 0.9_r8 .and. ids .eq. 1 ) then  
                        !     orgforce(8) = orgforce(8) + cmf_ad(km,ks,m,ids) * w_ad(km,ks,m,ids)
                        ! endif
                     endif
                     ! --------------------------------------------- !
                     ! Sum of diabatic forcing at the base interface !
                     ! --------------------------------------------- !
                     if( cmf_ad_dia(k,ks,m,ids) .gt. nonzero ) then
                        cmf_d_dia(k)       =   cmf_d_dia(k)   +                             cmf_ad_dia(k,ks,m,ids)            
                        evp_thll_d(k)      =  evp_thll_d(k)   +   evp_thll_ad(k,ks,m,ids) * cmf_ad_dia(k,ks,m,ids)
                        evp_qtl_d(k)       =   evp_qtl_d(k)   +    evp_qtl_ad(k,ks,m,ids) * cmf_ad_dia(k,ks,m,ids)
                        evp_thli_d(k)      =  evp_thli_d(k)   +   evp_thli_ad(k,ks,m,ids) * cmf_ad_dia(k,ks,m,ids)
                        evp_qti_d(k)       =   evp_qti_d(k)   +    evp_qti_ad(k,ks,m,ids) * cmf_ad_dia(k,ks,m,ids)
                        prep_thll_d(k)     = prep_thll_d(k)   +  prep_thll_ad(k,ks,m,ids) * cmf_ad_dia(k,ks,m,ids)
                        prep_qtl_d(k)      =  prep_qtl_d(k)   +   prep_qtl_ad(k,ks,m,ids) * cmf_ad_dia(k,ks,m,ids)
                        prep_thli_d(k)     = prep_thli_d(k)   +  prep_thli_ad(k,ks,m,ids) * cmf_ad_dia(k,ks,m,ids)
                        prep_qti_d(k)      =  prep_qti_d(k)   +   prep_qti_ad(k,ks,m,ids) * cmf_ad_dia(k,ks,m,ids)
                        eff_ql_d(k)        =    eff_ql_d(k)   +     eff_ql_ad(k,ks,m,ids) * cmf_ad_dia(k,ks,m,ids)
                        eff_qi_d(k)        =    eff_qi_d(k)   +     eff_qi_ad(k,ks,m,ids) * cmf_ad_dia(k,ks,m,ids)
                        PGF_u_d(k)         =     PGF_u_d(k)   +      PGF_u_ad(k,ks,m,ids) * cmf_ad_dia(k,ks,m,ids)
                        PGF_v_d(k)         =     PGF_v_d(k)   +      PGF_v_ad(k,ks,m,ids) * cmf_ad_dia(k,ks,m,ids)
                        do mt = 1, ncnst
                           evp_tr_d(k,mt)  =  evp_tr_d(k,mt)  +  evp_tr_ad(k,ks,m,ids,mt) * cmf_ad_dia(k,ks,m,ids)
                           prep_tr_d(k,mt) = prep_tr_d(k,mt)  + prep_tr_ad(k,ks,m,ids,mt) * cmf_ad_dia(k,ks,m,ids)
                           ! wdep_tr_d(k,mt) = wdep_tr_d(k,mt)  + wdep_tr_ad(k,ks,m,ids,mt) * cmf_ad_dia(k,ks,m,ids)
                           eff_tr_d(k,mt)  =  eff_tr_d(k,mt)  +  eff_tr_ad(k,ks,m,ids,mt) * cmf_ad_dia(k,ks,m,ids)
                        enddo
                     endif
                     ! ----------------------------------------------------------------- !
                     ! Sum of detrained properties from downdraft at the layer mid-point !
                     ! ----------------------------------------------------------------- !
                     if( cmf_ar(k,ks,m,ids) .gt. nonzero ) then
                        cmf_rd(k)      =   cmf_rd(k) +                        cmf_ar(k,ks,m,ids)            
                        thl_rd(k)      =   thl_rd(k) +   thl_ar(k,ks,m,ids) * cmf_ar(k,ks,m,ids)
                        qt_rd(k)       =    qt_rd(k) +    qt_ar(k,ks,m,ids) * cmf_ar(k,ks,m,ids)
                        u_rd(k)        =     u_rd(k) +     u_ar(k,ks,m,ids) * cmf_ar(k,ks,m,ids)
                        v_rd(k)        =     v_rd(k) +     v_ar(k,ks,m,ids) * cmf_ar(k,ks,m,ids)
                        ! Apr.21.2011. While all detrainment of downdraft occurs at the base interface, it is good to relocate
                        !              the detrained condensate to the layer mid-point since for organization at the next time
                        !              step, we are assuming that all detrained airs are layer-mean values. Note also that
                        !              my curent approach considering individual 'ql,qi' from individual detrained airs
                        !              explicitly consider inhomogeneity of detrained airs, which is good.
                        !              So, I changed 'ps0(km)' to 'p0(k)' in the below 'conden' subroutine. 
                        !              This modification is exactly consistent with corresponding modification of updraft.  
                        ! Nov.28.2012. Comment out below block computing 'ql_ar(k,ks,m,ids),qi_ar(k,ks,m,ids)' since they
                        !              have already been computed above. Note that all of detrained airs are detrained
                        !              at the base interface except the laterally detrained air from downdraft. 
                        !              Below 'ql_rd,qi_rd' are simple adiabatic sum assuming they are conserved scalar.
                        !              Thus, these 'ql_rd(k),qi_rd(k)' are fully consistent with tr_rd(k,mt) until this 
                        !              stage. Mixing and phase conversion at the layer mid-point both for 'ql_rd(k),qi_rd(k)' 
                        !              and 'tr_rd(k,ixnumliq),tr_rd(k,ixnumice)' will be done later after combining with the
                        !              detrained airs from convective updraft.
                        !! call conden( ps0(km), thl_ar(k,ks,m,ids), qt_ar(k,ks,m,ids), th, qv, ql, qi, qse, id_check )
                        !  call conden( p0(k),   thl_ar(k,ks,m,ids), qt_ar(k,ks,m,ids), th, qv, ql, qi, qse, id_check )
                        !  if( id_check .eq. 1 ) then
                        !      id_exit = .true.
                        !      go to 333
                        !  endif
                        ql_rd(k)       =    ql_rd(k) +    ql_ar(k,ks,m,ids) * cmf_ar(k,ks,m,ids)
                        qi_rd(k)       =    qi_rd(k) +    qi_ar(k,ks,m,ids) * cmf_ar(k,ks,m,ids)
                        do mt = 1, ncnst
                           tr_rd(k,mt) = tr_rd(k,mt) + tr_ar(k,ks,m,ids,mt) * cmf_ar(k,ks,m,ids)
                        enddo
                     endif
                     ! ------------------------------------------------------------------------------------- !
                     ! Compute mean downdraft properties at the layer mid-point or at the interface for each ! 
                     ! original updraft segment 'msfc'. These are diagnostic quantities.                     !
                     ! ------------------------------------------------------------------------------------- ! 
                     ! Apr.21.2011. In computing 'am_d_msfc,qlm_d_msfc,qim_d_msfc', I multiplied 'dpad(k,ks,m,ids)/dp0(k)'
                     !              in order to exactly take into account of partial vertical fillness of downdraft in vertical
                     !              in source layer. 
                     !              Note that 'cmf_ad_dia' already includes this 'dpad(k,ks,m,ids)/dp0(k)' in it.
                     tmp1 = 0.5_r8 * ( a_ad(km,ks,m,ids) +  a_ad(k,ks,m,ids) ) * ( dpad(k,ks,m,ids) / dp0(k) )
                     am_d_msfc(k,msfc)    =  am_d_msfc(k,msfc) + tmp1
                     qlm_d_msfc(k,msfc)   = qlm_d_msfc(k,msfc) + tmp1 * 0.5_r8 * ( ql_ad(km,ks,m,ids) + ql_ad(k,ks,m,ids) ) * &
                                            ( dpad(k,ks,m,ids) / dp0(k) )
                     qim_d_msfc(k,msfc)   = qim_d_msfc(k,msfc) + tmp1 * 0.5_r8 * ( qi_ad(km,ks,m,ids) + qi_ad(k,ks,m,ids) ) * &
                                            ( dpad(k,ks,m,ids) / dp0(k) )
                     qrten_d_msfc(k,msfc) = qrten_d_msfc(k,msfc) - ( g / dp0(k) ) * ( prep_qtl_ad(k,ks,m,ids) + &
                                            evp_qtl_ad(k,ks,m,ids) ) * cmf_ad_dia(k,ks,m,ids)   ! <= 0
                     qsten_d_msfc(k,msfc) = qsten_d_msfc(k,msfc) - ( g / dp0(k) ) * ( prep_qti_ad(k,ks,m,ids) + &
                                            evp_qti_ad(k,ks,m,ids) ) * cmf_ad_dia(k,ks,m,ids)   ! <= 0
                     ! Nov.29.2012. Add corresponding tracer parts.
                     !              Note that I should use 'dptr0(k,mt)' instead of 'dp0(k)' for tracers.
                     ! Dec.01.2012. I should do separate treatment for precipitating droplet number.
                     do mt = 1, ncnst
                        if( mt .eq. ixcldliq ) then
                           trrsten_d_msfc(k,msfc,mt) = qrten_d_msfc(k,msfc)
                        elseif( mt .eq. ixcldice ) then
                           trrsten_d_msfc(k,msfc,mt) = qsten_d_msfc(k,msfc)
                        elseif( mt .eq. ixnumliq ) then
                           trrsten_d_msfc(k,msfc,mt) = qrten_d_msfc(k,msfc) * 3._r8 / ( 4._r8 * 3.141592_r8 * &
                                                       droprad_rain**3 * density_rain )        
                        elseif( mt .eq. ixnumice ) then
                           trrsten_d_msfc(k,msfc,mt) = qsten_d_msfc(k,msfc) * 3._r8 / ( 4._r8 * 3.141592_r8 * &
                                                       droprad_snow**3 * density_snow )         
                        else
                           trrsten_d_msfc(k,msfc,mt) = trrsten_d_msfc(k,msfc,mt) - ( g / dptr0(k,mt) ) * &
                                                       ( prep_tr_ad(k,ks,m,ids,mt) + evp_tr_ad(k,ks,m,ids,mt) + &
                                                       wdep_tr_ad(k,ks,m,ids,mt) ) * cmf_ad_dia(k,ks,m,ids)   ! <= 0
                        endif
                     enddo
                     if( cmf_ad(km,ks,m,ids) .gt. nonzero ) then
                        cmf_d_msfc(km,msfc) = cmf_d_msfc(km,msfc) + cmf_ad(km,ks,m,ids)            
                        a_d_msfc(km,msfc)   =   a_d_msfc(km,msfc) +   a_ad(km,ks,m,ids)            
                        thl_d_msfc(km,msfc) = thl_d_msfc(km,msfc) + thl_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids) 
                        qt_d_msfc(km,msfc)  =  qt_d_msfc(km,msfc) +  qt_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids) 
                        u_d_msfc(km,msfc)   =   u_d_msfc(km,msfc) +   u_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids) 
                        v_d_msfc(km,msfc)   =   v_d_msfc(km,msfc) +   v_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids) 
                        w_d_msfc(km,msfc)   =   w_d_msfc(km,msfc) +   w_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids) 
                        ql_d_msfc(km,msfc)  =  ql_d_msfc(km,msfc) +  ql_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids) 
                        qi_d_msfc(km,msfc)  =  qi_d_msfc(km,msfc) +  qi_ad(km,ks,m,ids) * cmf_ad(km,ks,m,ids) 
                        wa_d_msfc(km,msfc)  =  wa_d_msfc(km,msfc) +   w_ad(km,ks,m,ids) *   a_ad(km,ks,m,ids) 
                        qla_d_msfc(km,msfc) = qla_d_msfc(km,msfc) +  ql_ad(km,ks,m,ids) *   a_ad(km,ks,m,ids) 
                        qia_d_msfc(km,msfc) = qia_d_msfc(km,msfc) +  qi_ad(km,ks,m,ids) *   a_ad(km,ks,m,ids) 
                        do mt = 1, ncnst
                           tr_d_msfc(km,msfc,mt)  =  tr_d_msfc(km,msfc,mt) +  tr_ad(km,ks,m,ids,mt) * cmf_ad(km,ks,m,ids)
                        enddo
                     endif
                     ! ---------------------------------------------------------------------------- !
                     !                                                                              !  
                     ! ---------------------------------------------------------------------------- !
                  enddo                     ! k    = ks, 1, -1.          This 'k'    is a layer index.
               enddo                        ! ks   = ks_top, ks_bot, -1. This 'ks'   is a layer index of downdraft source.
            enddo                        ! ids  = 1, 3.               This 'ids'  is a type of downdraft source.
         enddo                        ! msfc = 1, nseg             This 'msfc' is a number of updraft segment at surface.

         ! ------------------------------------------------------------------------------------- !
         ! Jul.10.2011. In order to do in-downdraft perturbation, I should divide by 'tmp3'      !
         !              However, TKE is accumulated quantities.                                  !
         !              Note that final 'thlPBLorg,qtPBLorg' are mass-flux weighted quantities.  ! 
         ! Aug.03.2011. Below may be modified in future such that 'if cmfPBLorg .le. nonzero',   !
         !              I should set cmfPBLorg = 0.                                              !
         ! ------------------------------------------------------------------------------------- ! 
      
         !d    thlPBLorg   = thlPBLorg / max( cmfPBLorg, nonzero )
         !d    qtPBLorg    =  qtPBLorg / max( cmfPBLorg, nonzero )
         !d    uPBLorg     =   uPBLorg / max( cmfPBLorg, nonzero )
         !d    vPBLorg     =   vPBLorg / max( cmfPBLorg, nonzero )

         ! CHECK    
         ! write(6,*) 
         ! write(6,*) 'UNICON: Downdraft fractional area at surface for convective oeganization'
         ! write(6,*) 'a_d = ', tmp3
         ! write(6,*) 
         ! CHECK

         ! Jul.28.2011. Below line is critical for correct normalization of orgforce1 computed within the
         !              iteration loop for convective downdraft. 
         ! Note that 'zs0(kpblhm)' is numerical PBL height that should be also used in computing
         ! damping time scale ( tau_org ) of convective organization at the beginning.
         ! The unit of below orgforce1 before diving by zs0(kpblhm) is [ J/m2 ].

         ! if( kpblh .ge. 2 ) orgforce1 = orgforce1 / pblhz

         ! ----------------------------------------------------------------------------------------------------------------- !
         ! Aug.30.2011. Mean downdraft properties at the PBL top interface ( kpblhm ) for organized convective downdraft.    !
         ! Sep.06.2011. Also compute grid-mean vertically-averaged diabatic forcing within convective downdraft within PBL.  !
         ! Sep.09.2011. Below block is commented-out since all the wake-related adiabatic and diabatic forcings are treated  !
         !              later in a collective way.                                                                           !
         ! Sep.11.2011. I restored below block for selective chooce of convective downdrafts.
         ! ----------------------------------------------------------------------------------------------------------------- ! 

         if( cmf_d_org_pblh .gt. nonzero ) then
            thl_d_org_pblh          =     thl_d_org_pblh / cmf_d_org_pblh
            qt_d_org_pblh           =      qt_d_org_pblh / cmf_d_org_pblh 
            u_d_org_pblh            =       u_d_org_pblh / cmf_d_org_pblh 
            v_d_org_pblh            =       v_d_org_pblh / cmf_d_org_pblh 
            do mt = 1, ncnst
               tr_d_org_pblh(mt)    =  tr_d_org_pblh(mt) / cmf_d_org_pblh
            enddo
         else
            cmf_d_org_pblh          = 0._r8
            thl_d_org_pblh          = 0._r8
            qt_d_org_pblh           = 0._r8
            u_d_org_pblh            = 0._r8
            v_d_org_pblh            = 0._r8
            tr_d_org_pblh(1:ncnst)  = 0._r8 
         endif

         qt_dia_d_org        =     qt_dia_d_org / pblhp
         thl_dia_d_org       =    thl_dia_d_org / pblhp
         do mt = 1, ncnst 
            tr_dia_d_org(mt) = tr_dia_d_org(mt) / pblhp
         enddo

         ! --------------------------------------------------------------------------------------------------------- !
         ! May.1.2014.                                                                                               !
         ! Add exactly same part as the above but for 'cmf_d_orgU_pblh' that exclusively sinks down into '1-awk_PBL' !
         ! instead of 'awk_PBL' for 'i_budget_coldpool = 1,2' treatment (i.e., budget consistent cold pool).         !
         ! --------------------------------------------------------------------------------------------------------- !

         if( cmf_d_orgU_pblh .gt. nonzero ) then
             thl_d_orgU_pblh          =     thl_d_orgU_pblh / cmf_d_orgU_pblh
             qt_d_orgU_pblh           =      qt_d_orgU_pblh / cmf_d_orgU_pblh 
             u_d_orgU_pblh            =       u_d_orgU_pblh / cmf_d_orgU_pblh 
             v_d_orgU_pblh            =       v_d_orgU_pblh / cmf_d_orgU_pblh 
             do mt = 1, ncnst
                tr_d_orgU_pblh(mt)    =  tr_d_orgU_pblh(mt) / cmf_d_orgU_pblh
             enddo 
         else
             cmf_d_orgU_pblh          = 0._r8
             thl_d_orgU_pblh          = 0._r8
             qt_d_orgU_pblh           = 0._r8
             u_d_orgU_pblh            = 0._r8
             v_d_orgU_pblh            = 0._r8
             tr_d_orgU_pblh(1:ncnst)  = 0._r8 
         endif

         qt_dia_d_orgU        =     qt_dia_d_orgU / pblhp
         thl_dia_d_orgU       =    thl_dia_d_orgU / pblhp
         do mt = 1, ncnst 
            tr_dia_d_orgU(mt) = tr_dia_d_orgU(mt) / pblhp
         enddo

         ! --------------------------------------------------------------------------------------------------------- ! 
         ! Apr.21.2011. Below block is to compute diagnostic 'am_d,qlm_d,qim_d' extending element computation above. !
         !              This computation is same as corresnding computation of updraft ( am_u,qlm_u,qim_u ).         !
         ! --------------------------------------------------------------------------------------------------------- !  

         do msfc = 1, nseg
            do k = 1, ktop_msfc(msfc)
               qlm_d_msfc(k,msfc)  = qlm_d_msfc(k,msfc) / max( am_d_msfc(k,msfc), nonzero )
               qim_d_msfc(k,msfc)  = qim_d_msfc(k,msfc) / max( am_d_msfc(k,msfc), nonzero )
               am_d(k)  =  am_d(k) +  am_d_msfc(k,msfc)
               qlm_d(k) = qlm_d(k) +  am_d_msfc(k,msfc) * qlm_d_msfc(k,msfc)
               qim_d(k) = qim_d(k) +  am_d_msfc(k,msfc) * qim_d_msfc(k,msfc)
            enddo
         enddo
         qlm_d(k) = qlm_d(k) / max( am_d(k), nonzero )
         qim_d(k) = qim_d(k) / max( am_d(k), nonzero )

         ! ------------------------------------------ !
         ! Compute grid mean properties in each layer !
         ! ------------------------------------------ !

         do k = 1, ktop             ! This 'k'   is a layer index

            km = k - 1              ! This 'km'  is a base interface index of 'k'

            ! --------------------------------------------------------------------- !
            ! Mean downdraft properties at the base interface for each 'msfc' index !
            ! These are diagnostic quantities.                                      !
            ! --------------------------------------------------------------------- ! 

            do msfc = 1, nseg
               if( cmf_d_msfc(km,msfc) .gt. nonzero ) then
                  thl_d_msfc(km,msfc) = thl_d_msfc(km,msfc) / cmf_d_msfc(km,msfc) 
                  qt_d_msfc(km,msfc)  =  qt_d_msfc(km,msfc) / cmf_d_msfc(km,msfc)
                  u_d_msfc(km,msfc)   =   u_d_msfc(km,msfc) / cmf_d_msfc(km,msfc)
                  v_d_msfc(km,msfc)   =   v_d_msfc(km,msfc) / cmf_d_msfc(km,msfc)
                  w_d_msfc(km,msfc)   =   w_d_msfc(km,msfc) / cmf_d_msfc(km,msfc)
                  ql_d_msfc(km,msfc)  =  ql_d_msfc(km,msfc) / cmf_d_msfc(km,msfc)
                  qi_d_msfc(km,msfc)  =  qi_d_msfc(km,msfc) / cmf_d_msfc(km,msfc)
                  wa_d_msfc(km,msfc)  =  wa_d_msfc(km,msfc) /   a_d_msfc(km,msfc)
                  qla_d_msfc(km,msfc) = qla_d_msfc(km,msfc) /   a_d_msfc(km,msfc)
                  qia_d_msfc(km,msfc) = qia_d_msfc(km,msfc) /   a_d_msfc(km,msfc)
                  do mt = 1, ncnst
                     tr_d_msfc(km,msfc,mt) = tr_d_msfc(km,msfc,mt) / cmf_d_msfc(km,msfc)
                  enddo
               else
                  thl_d_msfc(km,msfc) = 0._r8
                  qt_d_msfc(km,msfc)  = 0._r8
                  u_d_msfc(km,msfc)   = 0._r8
                  v_d_msfc(km,msfc)   = 0._r8
                  w_d_msfc(km,msfc)   = 0._r8
                  ql_d_msfc(km,msfc)  = 0._r8
                  qi_d_msfc(km,msfc)  = 0._r8
                  wa_d_msfc(km,msfc)  = 0._r8
                  qla_d_msfc(km,msfc) = 0._r8
                  qia_d_msfc(km,msfc) = 0._r8
                  do mt = 1, ncnst
                     tr_d_msfc(km,msfc,mt) = 0._r8
                  enddo
               endif
            enddo

            ! ----------------------------------------------- !
            ! Mean downdraft properties at the base interface !
            ! ----------------------------------------------- ! 

            if( cmf_d(km) .gt. nonzero ) then
               thl_d(km) = thl_d(km) / cmf_d(km)
               qt_d(km)  =  qt_d(km) / cmf_d(km) 
               u_d(km)   =   u_d(km) / cmf_d(km)
               v_d(km)   =   v_d(km) / cmf_d(km)
               w_d(km)   =   w_d(km) / cmf_d(km)
               wa_d(km)  =  wa_d(km) /   a_d(km)
               ql_d(km)  =  ql_d(km) / cmf_d(km)
               qi_d(km)  =  qi_d(km) / cmf_d(km)
               qla_d(km) = qla_d(km) /   a_d(km)
               qia_d(km) = qia_d(km) /   a_d(km)
               do mt = 1, ncnst
                  tr_d(km,mt) = tr_d(km,mt) / cmf_d(km)
               enddo
            else
               cmf_d(km) = 0._r8
               thl_d(km) = 0._r8
               qt_d(km)  = 0._r8
               u_d(km)   = 0._r8
               v_d(km)   = 0._r8
               w_d(km)   = 0._r8
               wa_d(km)  = 0._r8
               ql_d(km)  = 0._r8
               qi_d(km)  = 0._r8
               qla_d(km) = 0._r8
               qia_d(km) = 0._r8
               do mt = 1, ncnst
                  tr_d(km,mt) = 0._r8
               enddo
            endif

            ! ---------------------------------------------------------------------------------------------------- !
            ! Aug.15.2011. Mean downdraft properties at the base interface only for organized convective downdraft !
            ! ---------------------------------------------------------------------------------------------------- ! 

            !d       if( cmf_d_org(km) .gt. nonzero ) then
            !d           thl_d_org(km) = thl_d_org(km) / cmf_d_org(km)
            !d           qt_d_org(km)  =  qt_d_org(km) / cmf_d_org(km) 
            !d       else
            !d           cmf_d_org(km) = 0._r8
            !d           thl_d_org(km) = 0._r8
            !d           qt_d_org(km)  = 0._r8
            !d       endif

            ! CHECK
            ! write(6,*)
            ! write(6,*) 'UNICON: Mean downdraft properties at the base interface'
            ! write(6,*) 'Cumulus Top and Layer index = ', ktop, k
            ! write(6,*) 'cmf_d  = ', cmf_d(km)
            ! write(6,*) 'thl_d  = ', thl_d(km)
            ! write(6,*) 'qt_d   = ', qt_d(km)
            ! write(6,*) 'u_d    = ', u_d(km)
            ! write(6,*) 'v_d    = ', v_d(km)
            ! write(6,*) 'w_d    = ', w_d(km)
            ! write(6,*) 'wa_d   = ', wa_d(km)
            ! write(6,*) 'ql_d   = ', ql_d(km)
            ! write(6,*) 'qi_d   = ', qi_d(km)
            ! write(6,*) 'qla_d  = ', qla_d(km)
            ! write(6,*) 'qia_d  = ', qia_d(km)
            ! write(6,*)
            ! CHECK

            ! ------------------------------------------------- !
            ! Mean diabatic forcings on downdraft in each layer !
            ! ------------------------------------------------- !

            if( cmf_d_dia(k) .gt. nonzero ) then
               evp_thll_d(k)  =  evp_thll_d(k) / cmf_d_dia(k)
               evp_qtl_d(k)   =   evp_qtl_d(k) / cmf_d_dia(k) 
               evp_thli_d(k)  =  evp_thli_d(k) / cmf_d_dia(k)
               evp_qti_d(k)   =   evp_qti_d(k) / cmf_d_dia(k) 
               prep_thll_d(k) = prep_thll_d(k) / cmf_d_dia(k)
               prep_qtl_d(k)  =  prep_qtl_d(k) / cmf_d_dia(k) 
               prep_thli_d(k) = prep_thli_d(k) / cmf_d_dia(k)
               prep_qti_d(k)  =  prep_qti_d(k) / cmf_d_dia(k) 
               eff_ql_d(k)    =    eff_ql_d(k) / cmf_d_dia(k) 
               eff_qi_d(k)    =    eff_qi_d(k) / cmf_d_dia(k) 
               PGF_u_d(k)     =     PGF_u_d(k) / cmf_d_dia(k)
               PGF_v_d(k)     =     PGF_v_d(k) / cmf_d_dia(k)
               do mt = 1, ncnst
                  evp_tr_d(k,mt)  =  evp_tr_d(k,mt) / cmf_d_dia(k) 
                  prep_tr_d(k,mt) = prep_tr_d(k,mt) / cmf_d_dia(k)
                  ! wdep_tr_d(k,mt) = wdep_tr_d(k,mt) / cmf_d_dia(k) 
                  eff_tr_d(k,mt)  =  eff_tr_d(k,mt) / cmf_d_dia(k) 
               enddo
            else
               cmf_d_dia(k)   = 0._r8
               evp_thll_d(k)  = 0._r8
               evp_qtl_d(k)   = 0._r8
               evp_thli_d(k)  = 0._r8
               evp_qti_d(k)   = 0._r8
               prep_thll_d(k) = 0._r8
               prep_qtl_d(k)  = 0._r8
               prep_thli_d(k) = 0._r8
               prep_qti_d(k)  = 0._r8
               eff_ql_d(k)    = 0._r8
               eff_qi_d(k)    = 0._r8
               PGF_u_d(k)     = 0._r8
               PGF_v_d(k)     = 0._r8
               do mt = 1, ncnst
                  evp_tr_d(k,mt)  = 0._r8
                  prep_tr_d(k,mt) = 0._r8
                  ! wdep_tr_d(k,mt) = 0._r8
                  eff_tr_d(k,mt)  = 0._r8
               enddo
            endif

            ! CHECK
            ! write(6,*)
            ! write(6,*) 'UNICON: Mean diabatic forcing within downdraft in each layer'
            ! write(6,*) 'Cumulus Top and Layer index = ', ktop, k
            ! write(6,*) 'cmf_d_dia    = ', cmf_d_dia(k)
            ! write(6,*) 'evp_thll_d   = ', evp_thll_d(k)
            ! write(6,*) 'evp_qtl_d    = ', evp_qtl_d(k)
            ! write(6,*) 'evp_thli_d   = ', evp_thli_d(k) 
            ! write(6,*) 'evp_qti_d    = ', evp_qti_d(k)
            ! write(6,*) 'prep_thll_d  = ', prep_thll_d(k)
            ! write(6,*) 'prep_qtl_d   = ', prep_qtl_d(k)
            ! write(6,*) 'prep_thli_d  = ', prep_thli_d(k)
            ! write(6,*) 'prep_qti_d   = ', prep_qti_d(k)
            ! write(6,*) 'PGF_u_d      = ', PGF_u_d(k)
            ! write(6,*) 'PGF_v_d      = ', PGF_v_d(k)
            ! write(6,*)
            ! CHECK

            ! ------------------------------------------------------- !
            ! Mean detrained properties from downdraft in each layer. !
            ! While all detrainment occurs at the base interface,     !
            ! we define detrained properties in each layer.           !
            ! ------------------------------------------------------- !

            if( cmf_rd(k) .gt. nonzero ) then
               thl_rd(k)  =  thl_rd(k) / cmf_rd(k)
               qt_rd(k)   =   qt_rd(k) / cmf_rd(k) 
               u_rd(k)    =    u_rd(k) / cmf_rd(k)
               v_rd(k)    =    v_rd(k) / cmf_rd(k)
               ql_rd(k)   =   ql_rd(k) / cmf_rd(k)
               qi_rd(k)   =   qi_rd(k) / cmf_rd(k)
               do mt = 1, ncnst
                  tr_rd(k,mt) = tr_rd(k,mt) / cmf_rd(k) 
               enddo
            else
               cmf_rd(k)  = 0._r8
               thl_rd(k)  = 0._r8
               qt_rd(k)   = 0._r8
               u_rd(k)    = 0._r8
               v_rd(k)    = 0._r8
               ql_rd(k)   = 0._r8 
               qi_rd(k)   = 0._r8
               do mt = 1, ncnst
                  tr_rd(k,mt) = 0._r8
               enddo
            endif

            ! CHECK
            ! if( get_nstep() .ge. 13 .and. get_nstep() .le. 15 .and. k .eq. 4  ) then
            !     write(6,*)
            !     write(6,*) 'UNICON: Mean properties of detrained airs from downdraft in each layer'
            !     write(6,*) 'Time and Layer index = ', get_nstep(), k
            !     write(6,*) 'cmf_rd   = ', cmf_rd(k)
            !     write(6,*) 'nl_rd = ', 0.000001_r8*tr_rd(k,ixnumliq)
            !     write(6,*) 'tr_srcds = ', tr_srcds(k,1,3,ixnumliq), tr_srcds(k,2,3,ixnumliq), &
            !                               tr_srcds(k,3,3,ixnumliq), tr_srcds(k,4,3,ixnumliq), &
            !                               tr_srcds(k,5,3,ixnumliq)
            !     write(6,*) 'tr_ar    = ', tr_ar(k,k,1,3,ixnumliq),  tr_ar(k,k,2,3,ixnumliq), &
            !                               tr_ar(k,k,3,3,ixnumliq),  tr_ar(k,k,4,3,ixnumliq), &
            !                               tr_ar(k,k,5,3,ixnumliq)
            !     write(6,*)
            ! endif
            ! CHECK 

            ! CHECK
            ! if( get_nstep() .ge. 13 .and. get_nstep() .le. 15 .and. k .eq. 4  ) then
            ! write(6,*)
            ! write(6,*) 'UNICON: Mean properties of detrained airs from downdraft in each layer'
            ! write(6,*) 'Cumulus Top and Layer index = ', ktop, k
            ! write(6,*) 'cmf_rd   = ', cmf_rd(k)
            ! write(6,*) 'thl_rd   = ', thl_rd(k)
            ! write(6,*) 'qt_rd    = ', qt_rd(k)
            ! write(6,*) 'u_rd     = ', u_rd(k) 
            ! write(6,*) 'v_rd     = ', v_rd(k)
            ! write(6,*) 'ql_rd    = ', ql_rd(k)
            ! write(6,*) 'qi_rd    = ', qi_rd(k)
            ! write(6,*)
            ! CHECK

            ! ---------------------------------------------------------------------- !
            ! Computation of mean properties of all detrained source airs by summing !
            ! 1 detrained air from updrafts and 3 detrained airs from downdrafts.    !                  
            ! ---------------------------------------------------------------------- !

            ! Nov.28.2012. Note that below 'ql_r(k),qi_r(k)' are fully adiabatic component by simply summing
            !              individual 'ql,qi' from various detrainment processes (each 'ql,qi' are obtained
            !              at different level depending on the process) by assuming individual 'ql,qi' are
            !              conserved scalar. By construction, 'ql_r(k),qi_r(k)' are fully consistent with
            !              the 'tr_ru(k,ixnumliq),tr_ru(k,ixnumice)'. 
            !              However, in order to treat all the detrained airs as a single parcel, we may
            !              want to compute 'ql_r_mix(k), qi_r_mix(k)' from 'thl_r(k),qt_r(k)' using subroutine 'conden'.
            !              Then, the difference between 'ql_r(k)' and 'ql_r_mix(k)' can be used to compute
            !              accurate 'tr_rd_mix(k,ixnumliq)' from 'tr_rd(k,ixnumliq)'.
            !              This is the reason why I computed adiabatic 'ql_r,qi_r' until now.

            cmf_r(k) =                cmf_ru(k) +             cmf_rd(k)             
            thl_r(k) =    thl_ru(k) * cmf_ru(k) + thl_rd(k) * cmf_rd(k) 
            qt_r(k)  =     qt_ru(k) * cmf_ru(k) +  qt_rd(k) * cmf_rd(k) 
            u_r(k)   =      u_ru(k) * cmf_ru(k) +   u_rd(k) * cmf_rd(k)
            v_r(k)   =      v_ru(k) * cmf_ru(k) +   v_rd(k) * cmf_rd(k)
            ql_r(k)  =     ql_ru(k) * cmf_ru(k) +  ql_rd(k) * cmf_rd(k)
            qi_r(k)  =     qi_ru(k) * cmf_ru(k) +  qi_rd(k) * cmf_rd(k)
            do mt = 1, ncnst 
               tr_r(k,mt) = tr_ru(k,mt) * cmf_ru(k) + tr_rd(k,mt) * cmf_rd(k) 
            enddo
            if( cmf_r(k) .gt. nonzero ) then
               thl_r(k) = thl_r(k) / cmf_r(k)
               qt_r(k)  =  qt_r(k) / cmf_r(k) 
               u_r(k)   =   u_r(k) / cmf_r(k)
               v_r(k)   =   v_r(k) / cmf_r(k)
               ql_r(k)  =  ql_r(k) / cmf_r(k)
               qi_r(k)  =  qi_r(k) / cmf_r(k)
               do mt = 1, ncnst
                  tr_r(k,mt) = tr_r(k,mt) / cmf_r(k) 
               enddo
            else
               cmf_r(k) = 0._r8
               thl_r(k) = 0._r8
               qt_r(k)  = 0._r8
               u_r(k)   = 0._r8
               v_r(k)   = 0._r8
               ql_r(k)  = 0._r8
               qi_r(k)  = 0._r8
               do mt = 1, ncnst
                  tr_r(k,mt) = 0._r8
               enddo
            endif

            ! ------------------------------------------------------------- !
            ! Treatment of detrained air purely from the convective updraft !
            ! ------------------------------------------------------------- !

            cmf_r2(k) =                 cmf_ru2(k) +             cmf_rd(k)             
            thl_r2(k) =    thl_ru2(k) * cmf_ru2(k) + thl_rd(k) * cmf_rd(k) 
            qt_r2(k)  =     qt_ru2(k) * cmf_ru2(k) +  qt_rd(k) * cmf_rd(k) 
            u_r2(k)   =      u_ru2(k) * cmf_ru2(k) +   u_rd(k) * cmf_rd(k)
            v_r2(k)   =      v_ru2(k) * cmf_ru2(k) +   v_rd(k) * cmf_rd(k)
            ql_r2(k)  =     ql_ru2(k) * cmf_ru2(k) +  ql_rd(k) * cmf_rd(k)
            qi_r2(k)  =     qi_ru2(k) * cmf_ru2(k) +  qi_rd(k) * cmf_rd(k)
            do mt = 1, ncnst 
               tr_r2(k,mt) = tr_ru2(k,mt) * cmf_ru2(k) + tr_rd(k,mt) * cmf_rd(k) 
            enddo
            if( cmf_r2(k) .gt. nonzero ) then
               thl_r2(k) = thl_r2(k) / cmf_r2(k)
               qt_r2(k)  =  qt_r2(k) / cmf_r2(k) 
               u_r2(k)   =   u_r2(k) / cmf_r2(k)
               v_r2(k)   =   v_r2(k) / cmf_r2(k)
               ql_r2(k)  =  ql_r2(k) / cmf_r2(k)
               qi_r2(k)  =  qi_r2(k) / cmf_r2(k)
               do mt = 1, ncnst
                  tr_r2(k,mt) = tr_r2(k,mt) / cmf_r2(k) 
               enddo
            else
               cmf_r2(k) = 0._r8
               thl_r2(k) = 0._r8
               qt_r2(k)  = 0._r8
               u_r2(k)   = 0._r8
               v_r2(k)   = 0._r8
               ql_r2(k)  = 0._r8
               qi_r2(k)  = 0._r8
               do mt = 1, ncnst
                  tr_r2(k,mt) = 0._r8
               enddo
            endif

            ! 'Flux-convergence' and 'Subsidence-detrainment' consistent diagnostic output for use in the macrophysics.

            cmf_det(k) = cmf_r2(k)
            ql_det(k)  =  ql_r2(k)
            qi_det(k)  =  qi_r2(k)

            ! CHECK
            ! if( get_nstep() .ge. 13 .and. get_nstep() .le. 15 .and. k .eq. 4  ) then
            !     write(6,*)
            !     write(6,*) 'UNICON: Mean properties of detrained airs from updraft and downdraft in each layer'
            !     write(6,*) 'Time and Layer index = ', get_nstep(), k
            !     write(6,*) 'cmf_r   = ', cmf_r(k)
            !     write(6,*) 'nl_r = ', 0.000001_r8*tr_r(k,ixnumliq)
            !     write(6,*)
            ! endif
            ! CHECK 

            ! -------------------------------------------------------------------- !
            ! Assign 'cmf_u_mix' and 'cmf_r' to the new variables for implementing !
            ! mesoscale organization at the next iteration.                        !
            ! -------------------------------------------------------------------- !
 
            ! Apr.21.2011. I added one switch to choose 'cmf_r','cmf_ru','cmf_rd'
            !              as 'cu_cmfr_out'. Since deep convection needs to entrain moist airs in order to
            !              grow deeply, this choice may have large impact.             
            ! Jul.13.2011. Note that 'cu_thlr_out, etc...' are anomalous value from the mean value in the
            !              lowest model layer. This is chosen since not only the grid-mean but also detrained
            !              convective airs can be changed by subsequent non-convective processes from the
            !              current to the next time step.
            !              Note that except the adding of 'f_srcrs(k,m,1)' by updraft buoyancy sorting at surface
            !              interface in the lowest model layer, 'cmf_r' is the same as the sum of downdrfat mass 
            !              flux at surface since all detrainment occurs at surface.
            ! Aug.01.2011. Brian Juwon Park's 9th Birthday.                                      
            !              The explicit ensemble mixing process 'iter' routine are included here.
            !              I have a hunch that this is the remaining final process I should      
            !              implement into the UNICON.                                            
            !              All the '_out' variables in the below block is renamed into '_mxen' with 
            !              iter argument for 'cuorg' weighted average later. 

            if( iorg_detrain .eq. 1 ) then

               ! ----------------------------------------------------------------------------------------------------- !
               ! OPTION.1 : Total Detrained Airs                                                                       !
               ! Jul.21.2011. Instead of using detrained airs ( which can be drier and colder than the environment )   !
               !              directly use convective updraft properties from the previous time step. By doing this,   !
               !              I think I don't need to modify source air w, thl, qt at all. Note that previous works    !
               !              of Cathy and Rio on the modification of source air properties are at the PBL top, which  !
               !              will be internally simulated by UNICON by entraining convective updraft properties       !
               !              from previous time step.                                                                 !
               !              Note that since buoyancy sorting occurs at the interface, this becomes moe easy.         !
               ! Below block is previous old.                                                                          !
               ! Detrained airs at the previous time step.                                                             !
               ! This maintains a full physical consistency. However, detrained airs are not moist enough, so that     !
               ! they cannot sustain the following convection. In this sence, the most reasonable approach seems to    !
               ! use below block ( to maintain a full physical consistency ) and turn-on 'iorg_src'.                   !
               ! ----------------------------------------------------------------------------------------------------- !

               ! ---------------------------------------------------------------------------------------------------------------------- !
               ! For more clear treatment fully consistent with the governing tendency equations, I can use 'cmf_r2(k), thl_r2(k),....' !
               ! in the below 'if' block instead of 'cmf_r(k), thl_r(k),....'. This should be tested in a near future.                  !
               ! I should do this today, after verifying that the modified code exactly reproduces the previous results.                !
               ! Nov.14.2014. I added 'i_detrain' option: '0' is previous formula-inconsistent default,                                 !
               !                                          '1' is a new formula consistent one.                                          !
               ! ---------------------------------------------------------------------------------------------------------------------- ! 

             ! if( i_detrain .eq. 0 ) then

                   if( cmf_r(k) .gt. nonzero ) then
                       cu_cmfr_mxen(k,iter)      =      cmf_r(k)
                       cu_thlr_mxen(k,iter)      =      thl_r(k) -   thl0(k)
                       cu_qtr_mxen(k,iter)       =       qt_r(k) -    qt0(k)
                       cu_ur_mxen(k,iter)        =        u_r(k) -     u0(k) 
                       cu_vr_mxen(k,iter)        =        v_r(k) -     v0(k)
                       cu_qlr_mxen(k,iter)       =       ql_r(k) -    ql0(k)
                       cu_qir_mxen(k,iter)       =       qi_r(k) -    qi0(k)
                       do mt = 1, ncnst
                          cu_trr_mxen(k,mt,iter) =    tr_r(k,mt) - tr0(k,mt)
                       enddo
                   endif
               
             ! else

             !     if( cmf_r2(k) .gt. nonzero ) then
             !         cu_cmfr_mxen(k,iter)      =      cmf_r2(k)
             !         cu_thlr_mxen(k,iter)      =      thl_r2(k) -   thl0(k)
             !         cu_qtr_mxen(k,iter)       =       qt_r2(k) -    qt0(k)
             !         cu_ur_mxen(k,iter)        =        u_r2(k) -     u0(k) 
             !         cu_vr_mxen(k,iter)        =        v_r2(k) -     v0(k)
             !         cu_qlr_mxen(k,iter)       =       ql_r2(k) -    ql0(k)
             !         cu_qir_mxen(k,iter)       =       qi_r2(k) -    qi0(k)
             !         do mt = 1, ncnst
             !            cu_trr_mxen(k,mt,iter) =    tr_r2(k,mt) - tr0(k,mt)
             !         enddo
             !     endif

             ! endif

            elseif( iorg_detrain .eq. 2 ) then

               ! -------------------------------------------------- !
               ! OPTION.2. : Detrained Airs from Convective Updraft !
               ! -------------------------------------------------- !
               
               if( cmf_ru(k) .gt. nonzero ) then
                  cu_cmfr_mxen(k,iter)      =     cmf_ru(k)
                  cu_thlr_mxen(k,iter)      =     thl_ru(k) -   thl0(k)  
                  cu_qtr_mxen(k,iter)       =      qt_ru(k) -    qt0(k)
                  cu_ur_mxen(k,iter)        =       u_ru(k) -     u0(k)
                  cu_vr_mxen(k,iter)        =       v_ru(k) -     v0(k)
                  cu_qlr_mxen(k,iter)       =      ql_ru(k) -    ql0(k)
                  cu_qir_mxen(k,iter)       =      qi_ru(k) -    qi0(k)
                  do mt = 1, ncnst
                     cu_trr_mxen(k,mt,iter) =   tr_ru(k,mt) - tr0(k,mt) 
                  enddo
               endif
               
            elseif( iorg_detrain .eq. 3 ) then

               ! ---------------------------------------------------- !
               ! OPTION.3. : Detrained Airs from Convective Downdraft !
               ! ---------------------------------------------------- !

               if( cmf_rd(k) .gt. nonzero ) then
                  cu_cmfr_mxen(k,iter)      =     cmf_rd(k)  
                  cu_thlr_mxen(k,iter)      =     thl_rd(k) -   thl0(k)
                  cu_qtr_mxen(k,iter)       =      qt_rd(k) -    qt0(k)
                  cu_ur_mxen(k,iter)        =       u_rd(k) -     u0(k)
                  cu_vr_mxen(k,iter)        =       v_rd(k) -     v0(k)
                  cu_qlr_mxen(k,iter)       =      ql_rd(k) -    ql0(k)
                  cu_qir_mxen(k,iter)       =      qi_rd(k) -    qi0(k)
                  do mt = 1, ncnst
                     cu_trr_mxen(k,mt,iter) =   tr_rd(k,mt) - tr0(k,mt)
                  enddo
               endif

            elseif( iorg_detrain .eq. 4 ) then

               ! -------------------------------------------------------------------------------------------------------------------- !
               ! OPTION.4. : Convective Updraft Airs                                                                                  !
               ! Below block is new on Jul.18.2011. Be careful of the index.                                                          !
               ! Convective updraft at the previous time step.                                                                        ! 
               ! Clearly, this breaks internal consistency since convective updraft properties are not part of grid-mean energy.      !
               ! Sep.14.2011. In addition, use of 'cmf_u(km)' as the mass of detrained 'passive' convective updraft                   !
               !              is not correct ( in addition to the violation of column-integrated grid-mean energy ).                  !
               !              If I want to use this option in order to improve diurnal cycle, I need to do more                       !
               !              thorough conceptual thinking including the concept of convective organization.                          !
               ! Sep.15.2011. Re-define (1) cu_cmfr_mxen(k,iter) as ( am_u(k) * dp0(k) ) / ( g * dt ) ( the concept of mass within    !
               !              the specified area am_u(k) at the layer mid-point, (2) instead of thl_u(km), use the thlm_u(k) which    !
               !              is the area-weighted mean quantities at the layer mid-point, and (3) use thl0(k) instead of thl0bot(k)  !
               !              for defining anomalies. While still these new cm_cmfr_mxen(k,iter) are not part of environmental mean   !
               !              due to the neglect of updraft storage, below new computation completely removes any inconsistency       !
               !              other than that. It seems to be clear that I should use below for mimicking the real nature even        !
               !              though there is very slight conceptual inconsistency. Note that below clearly improved diurnal cycle,   !
               !              strength of precipitation climatology, and is mostly well-mimicking the nature.                         !
               !              Since below uses area-weighting and since all scalars are defined based on 'am_u(k)', I am using am_u   !
               !              as the heading condition in the 'if' block. No initialization is necessary for am_u(k) < nonzero since  !
               !              this initialization has already been done at the beginning of the program.                              !
               !              MODIFICATION : For easy and general later use, I am using 'cu_cmfr_mxen' instead of 'am_u' as the       !
               !                             constraint within the if block. Since 'cu_thlr_mxen' is the anomaly field not the raw    !
               !                             value, below modification is completely OK, even though 'cu_thlr_mxen' is defined using  !
               !                             the 'am_u'.                                                                              !
               !                             Note that the information of 'partial thickness of cumulus updraft' ( e.g., at the       !
               !                             cumulus top layer, k = ktop ) is already incorporated into am_u(k). Thus, I should use   !
               !                             dp0(k) in the below computation of 'tmp1' even in the k = ktop layer which is very good. !
               !                                                                                                                      !
               ! Nov.28.2012. Note that below 'qlm_u(k),qim_u(k),trm_u(k,ixnumliq),trm_u(k,ixnumice)' are fully adiabatic field       !
               !              obtained by summing individual 'ql,qi,tr' components. Thus, 'qlm_u,trm_u(ixnumliq)' are internally      !
               !              consistent.                                                                                             ! 
               ! -------------------------------------------------------------------------------------------------------------------- !

               tmp1 = ( am_u(k) * dp0(k) ) / ( g * dt ) 
               ! if( am_u(k) .gt. nonzero ) then
               if( tmp1 .gt. nonzero ) then
                  cu_cmfr_mxen(k,iter)      =      tmp1
                  cu_thlr_mxen(k,iter)      =      thlm_u(k) -   thl0(k)
                  cu_qtr_mxen(k,iter)       =       qtm_u(k) -    qt0(k)
                  cu_ur_mxen(k,iter)        =        um_u(k) -     u0(k) 
                  cu_vr_mxen(k,iter)        =        vm_u(k) -     v0(k)
                  cu_qlr_mxen(k,iter)       =       qlm_u(k) -    ql0(k)
                  cu_qir_mxen(k,iter)       =       qim_u(k) -    qi0(k)
                  do mt = 1, ncnst
                     cu_trr_mxen(k,mt,iter) =    trm_u(k,mt) - tr0(k,mt)
                  enddo
               endif
               
            elseif( iorg_detrain .eq. 5 ) then

               ! ------------------------------------------------------------------------------------------------------------------- !
               ! OPTION.5. : Combination of Total Detrained Airs + Convective Updraft Airs                                           !
               ! Below block is new on Jul.25.2011. Be careful of the index. Sum of convective updraft and                           !
               ! detrained airs at the previous time step.                                                                           !
               ! Clearly, this breaks internal consistency since convective updraft properties are not a part of grid-mean tendency. !
               ! Sep.15.2011. Perform similar modification as the above.                                                             !
               !              I should carefully consider whether the 'nonzero' constraint in the 'if' block using                   !
               !              the mass flux not the area completely removes any unreasonable cases.                                  !
               !              this may not be a big problem since 'cu_thlr' is anomaly not the raw value itself.                     ! 
               !              As explained above, below seems to be perfectly OK.                                                    !  
               ! ------------------------------------------------------------------------------------------------------------------- !

               tmp1 = ( am_u(k) * dp0(k) ) / ( g * dt )
               cu_cmfr_mxen(k,iter)      =               cmf_r(k) +               tmp1
               cu_thlr_mxen(k,iter)      =    thl_r(k) * cmf_r(k) +   thlm_u(k) * tmp1
               cu_qtr_mxen(k,iter)       =     qt_r(k) * cmf_r(k) +    qtm_u(k) * tmp1
               cu_ur_mxen(k,iter)        =      u_r(k) * cmf_r(k) +     um_u(k) * tmp1
               cu_vr_mxen(k,iter)        =      v_r(k) * cmf_r(k) +     vm_u(k) * tmp1
               cu_qlr_mxen(k,iter)       =     ql_r(k) * cmf_r(k) +    qlm_u(k) * tmp1
               cu_qir_mxen(k,iter)       =     qi_r(k) * cmf_r(k) +    qim_u(k) * tmp1
               do mt = 1, ncnst 
                  cu_trr_mxen(k,mt,iter) =  tr_r(k,mt) * cmf_r(k) + trm_u(k,mt) * tmp1
               enddo
               if( cu_cmfr_mxen(k,iter) .gt. nonzero ) then
                  cu_thlr_mxen(k,iter)  = cu_thlr_mxen(k,iter) / cu_cmfr_mxen(k,iter) - thl0(k)
                  cu_qtr_mxen(k,iter)   =  cu_qtr_mxen(k,iter) / cu_cmfr_mxen(k,iter) -  qt0(k)
                  cu_ur_mxen(k,iter)    =   cu_ur_mxen(k,iter) / cu_cmfr_mxen(k,iter) -   u0(k)
                  cu_vr_mxen(k,iter)    =   cu_vr_mxen(k,iter) / cu_cmfr_mxen(k,iter) -   v0(k)
                  cu_qlr_mxen(k,iter)   =  cu_qlr_mxen(k,iter) / cu_cmfr_mxen(k,iter) -  ql0(k)
                  cu_qir_mxen(k,iter)   =  cu_qir_mxen(k,iter) / cu_cmfr_mxen(k,iter) -  qi0(k)
                  do mt = 1, ncnst
                     cu_trr_mxen(k,mt,iter) = cu_trr_mxen(k,mt,iter) / cu_cmfr_mxen(k,iter) - tr0(k,mt)
                  enddo
               else
                  cu_cmfr_mxen(k,iter)  = 0._r8
                  cu_thlr_mxen(k,iter)  = 0._r8
                  cu_qtr_mxen(k,iter)   = 0._r8
                  cu_ur_mxen(k,iter)    = 0._r8
                  cu_vr_mxen(k,iter)    = 0._r8
                  cu_qlr_mxen(k,iter)   = 0._r8
                  cu_qir_mxen(k,iter)   = 0._r8
                  do mt = 1, ncnst
                     cu_trr_mxen(k,mt,iter) = 0._r8
                  enddo
               endif

            elseif( iorg_detrain .eq. 6 ) then

               ! ------------------------------------------------------------------------------------------------------------------- !
               ! OPTION.6. : Combination of Detrained Airs from Convective Updraft + Convective Updraft Airs                         !
               ! ------------------------------------------------------------------------------------------------------------------- !

               tmp1 = ( am_u(k) * dp0(k) ) / ( g * dt )
               cu_cmfr_mxen(k,iter)      =                cmf_ru(k) +               tmp1
               cu_thlr_mxen(k,iter)      =    thl_ru(k) * cmf_ru(k) +   thlm_u(k) * tmp1
               cu_qtr_mxen(k,iter)       =     qt_ru(k) * cmf_ru(k) +    qtm_u(k) * tmp1
               cu_ur_mxen(k,iter)        =      u_ru(k) * cmf_ru(k) +     um_u(k) * tmp1
               cu_vr_mxen(k,iter)        =      v_ru(k) * cmf_ru(k) +     vm_u(k) * tmp1
               cu_qlr_mxen(k,iter)       =     ql_ru(k) * cmf_ru(k) +    qlm_u(k) * tmp1
               cu_qir_mxen(k,iter)       =     qi_ru(k) * cmf_ru(k) +    qim_u(k) * tmp1
               do mt = 1, ncnst 
                  cu_trr_mxen(k,mt,iter) =  tr_ru(k,mt) * cmf_ru(k) + trm_u(k,mt) * tmp1
               enddo
               if( cu_cmfr_mxen(k,iter) .gt. nonzero ) then
                  cu_thlr_mxen(k,iter)  = cu_thlr_mxen(k,iter) / cu_cmfr_mxen(k,iter) - thl0(k)
                  cu_qtr_mxen(k,iter)   =  cu_qtr_mxen(k,iter) / cu_cmfr_mxen(k,iter) -  qt0(k)
                  cu_ur_mxen(k,iter)    =   cu_ur_mxen(k,iter) / cu_cmfr_mxen(k,iter) -   u0(k)
                  cu_vr_mxen(k,iter)    =   cu_vr_mxen(k,iter) / cu_cmfr_mxen(k,iter) -   v0(k)
                  cu_qlr_mxen(k,iter)   =  cu_qlr_mxen(k,iter) / cu_cmfr_mxen(k,iter) -  ql0(k)
                  cu_qir_mxen(k,iter)   =  cu_qir_mxen(k,iter) / cu_cmfr_mxen(k,iter) -  qi0(k)
                  do mt = 1, ncnst
                     cu_trr_mxen(k,mt,iter) = cu_trr_mxen(k,mt,iter) / cu_cmfr_mxen(k,iter) - tr0(k,mt)
                  enddo
               else
                  cu_cmfr_mxen(k,iter)  = 0._r8
                  cu_thlr_mxen(k,iter)  = 0._r8
                  cu_qtr_mxen(k,iter)   = 0._r8
                  cu_ur_mxen(k,iter)    = 0._r8
                  cu_vr_mxen(k,iter)    = 0._r8
                  cu_qlr_mxen(k,iter)   = 0._r8
                  cu_qir_mxen(k,iter)   = 0._r8
                  do mt = 1, ncnst
                     cu_trr_mxen(k,mt,iter) = 0._r8
                  enddo
               endif

            elseif( iorg_detrain .eq. 7 ) then

               ! ------------------------------------------------------------------------------------------------------------------- !
               ! OPTION.7. : Combination of Detrained Airs from Convective Downdraft + Convective Updraft Airs                       !
               ! ------------------------------------------------------------------------------------------------------------------- !

               tmp1 = ( am_u(k) * dp0(k) ) / ( g * dt )
               cu_cmfr_mxen(k,iter)      =                cmf_rd(k) +               tmp1
               cu_thlr_mxen(k,iter)      =    thl_rd(k) * cmf_rd(k) +   thlm_u(k) * tmp1
               cu_qtr_mxen(k,iter)       =     qt_rd(k) * cmf_rd(k) +    qtm_u(k) * tmp1
               cu_ur_mxen(k,iter)        =      u_rd(k) * cmf_rd(k) +     um_u(k) * tmp1
               cu_vr_mxen(k,iter)        =      v_rd(k) * cmf_rd(k) +     vm_u(k) * tmp1
               cu_qlr_mxen(k,iter)       =     ql_rd(k) * cmf_rd(k) +    qlm_u(k) * tmp1
               cu_qir_mxen(k,iter)       =     qi_rd(k) * cmf_rd(k) +    qim_u(k) * tmp1
               do mt = 1, ncnst 
                  cu_trr_mxen(k,mt,iter) =  tr_rd(k,mt) * cmf_rd(k) + trm_u(k,mt) * tmp1
               enddo
               if( cu_cmfr_mxen(k,iter) .gt. nonzero ) then
                  cu_thlr_mxen(k,iter)  = cu_thlr_mxen(k,iter) / cu_cmfr_mxen(k,iter) - thl0(k)
                  cu_qtr_mxen(k,iter)   =  cu_qtr_mxen(k,iter) / cu_cmfr_mxen(k,iter) -  qt0(k)
                  cu_ur_mxen(k,iter)    =   cu_ur_mxen(k,iter) / cu_cmfr_mxen(k,iter) -   u0(k)
                  cu_vr_mxen(k,iter)    =   cu_vr_mxen(k,iter) / cu_cmfr_mxen(k,iter) -   v0(k)
                  cu_qlr_mxen(k,iter)   =  cu_qlr_mxen(k,iter) / cu_cmfr_mxen(k,iter) -  ql0(k)
                  cu_qir_mxen(k,iter)   =  cu_qir_mxen(k,iter) / cu_cmfr_mxen(k,iter) -  qi0(k)
                  do mt = 1, ncnst
                     cu_trr_mxen(k,mt,iter) = cu_trr_mxen(k,mt,iter) / cu_cmfr_mxen(k,iter) - tr0(k,mt)
                  enddo
               else
                  cu_cmfr_mxen(k,iter)  = 0._r8
                  cu_thlr_mxen(k,iter)  = 0._r8
                  cu_qtr_mxen(k,iter)   = 0._r8
                  cu_ur_mxen(k,iter)    = 0._r8
                  cu_vr_mxen(k,iter)    = 0._r8
                  cu_qlr_mxen(k,iter)   = 0._r8
                  cu_qir_mxen(k,iter)   = 0._r8
                  do mt = 1, ncnst
                     cu_trr_mxen(k,mt,iter) = 0._r8
                  enddo
               endif

            endif

            cu_cmfum_mxen(k,iter)         =  cmf_u_mix(k)

            ! Jun.28.2011. Below block is added for treating the effect of convective organization on the
            !              source air properties of convective updraft.

            if( cmf_rd(k) .gt. nonzero ) then
               cu_cmfrd_mxen(k,iter)         =     cmf_rd(k)
               cu_thlrd_mxen(k,iter)         =     thl_rd(k) -   thl0(k) 
               cu_qtrd_mxen(k,iter)          =      qt_rd(k) -    qt0(k)
               cu_urd_mxen(k,iter)           =       u_rd(k) -     u0(k)
               cu_vrd_mxen(k,iter)           =       v_rd(k) -     v0(k)
               cu_qlrd_mxen(k,iter)          =      ql_rd(k) -    ql0(k) 
               cu_qird_mxen(k,iter)          =      qi_rd(k) -    qi0(k)
               do mt = 1, ncnst
                  cu_trrd_mxen(k,mt,iter)    =   tr_rd(k,mt) - tr0(k,mt)
               enddo
            endif

            ! CHECK
            ! write(6,*)
            ! write(6,*) 'UNICON: Mean properties of whole detrained airs from updraft and downdraft in each layer'
            ! write(6,*) 'Cumulus Top and Layer index = ', ktop, k
            ! write(6,*) 'cmf_r     = ', cmf_r(k)
            ! write(6,*) 'thl_r     = ', thl_r(k)
            ! write(6,*) 'qt_r      = ', qt_r(k)
            ! write(6,*) 'u_r       = ', u_r(k) 
            ! write(6,*) 'v_r       = ', v_r(k)
            ! write(6,*) 'ql_r      = ', ql_r(k)
            ! write(6,*) 'qi_r      = ', qi_r(k)
            ! write(6,*) 'cmf_u_mix = ', cmf_u_mix(k)
            ! write(6,*)
            ! CHECK

         enddo

         ! CHECK
         ! if( cu_qtr_out(1) * 1.e3_r8 .lt. -4._r8 .or. get_nstep() .eq. 614 .or. get_nstep() .eq. 616 .or. get_nstep() .eq. 618 ) then
         !     write(6,*)
         !     write(6,*) 'UNICON: Extremely dry detrained airs in the lowest model layers'
         !     write(6,*) 'Time index and Cumulus Top Layer = ', get_nstep(), ktop
         !     write(6,*) 'cmf_r     = ', cmf_r(1)
         !     write(6,*) 'thl_r     = ', thl_r(1), thl0(1)
         !     write(6,*) 'qt_r      = ', qt_r(1), qt0(1)
         !     write(6,*) 'u_r       = ', u_r(1), u0(1) 
         !     write(6,*) 'v_r       = ', v_r(1), v0(1)
         !     write(6,*) 'ql_r      = ', ql_r(1), ql0(1)
         !     write(6,*) 'qi_r      = ', qi_r(1), qi0(1)
         !     write(6,*) 'cmf_ru, cmf_rd    = ', cmf_ru(1), cmf_rd(1)
         !     write(6,*) 'qt_ru, qt_rd    = ', qt_ru(1), qt_rd(1)
         !     write(6,*) 'f_srcrs(1,m,ids) , qt_srcrs(1,m,ids) = ', f_srcrs(1,1,1) , qt_srcrs(1,1,1)
         !     write(6,*) 'f_srcrs(1,m,ids) , qt_srcrs(1,m,ids) = ', f_srcrs(1,2,1) , qt_srcrs(1,2,1)
         !     write(6,*) 'f_srcrs(1,m,ids) , qt_srcrs(1,m,ids) = ', f_srcrs(1,1,2) , qt_srcrs(1,1,2)
         !     write(6,*) 'f_srcrs(1,m,ids) , qt_srcrs(1,m,ids) = ', f_srcrs(1,2,2) , qt_srcrs(1,2,2)
         !     write(6,*) 'f_srcrs(1,m,ids) , qt_srcrs(1,m,ids) = ', f_srcrs(1,1,3) , qt_srcrs(1,1,3)
         !     write(6,*) 'f_srcrs(1,m,ids) , qt_srcrs(1,m,ids) = ', f_srcrs(1,2,3) , qt_srcrs(1,2,3)
         ! endif
         ! CHECK

         ! Test Diagnostic Output. Imsi.

         !      thl_org_out(i)   = org_src * ( thl_r(1) - thl0(1)  )
         !      qt_org_out(i)    = org_src * ( qt_r(1)  - qt0(1)   ) * 1.e3_r8
         !      u_org_out(i)     = org_src * ( u_r(1)   - u0(1)    )
         !      v_org_out(i)     = org_src * ( v_r(1)   - v0(1)    )

         ! --------------------------------------------------------------------------- !
         ! Computation of updated 'cuorg_out'                                          !
         ! In the current code, the diagnostic 'cmf_u(0) > 0' while 'cmf_d(0) = 0'.    !
         ! However, physically, it is 'cmf_d(0) = cmf_d(1)' and 'cmf_u(1) > cmf_u(0)'. !
         ! --------------------------------------------------------------------------- !

         ! if( kiss .eq. 0 ) then 
         !     cuorg_out = max( 0._r8, cmf_d(1) / max( nonzero, cmf_u(0) ) )
         !     if( ktop .le. 2 ) cuorg_out = 0._r8
         ! elseif( kiss .eq. 1 ) then
         !     cuorg_out = max( 0._r8, cmf_d(1) / max( nonzero, cmf_u(1) ) )
         !     if( ktop .le. 3 ) cuorg_out = 0._r8    
         ! endif

         ! ------------------------------------------------------------ !
         ! Computation of grid-mean tendency of 'u,v' by horizontal PGF !
         ! The unit of 'uten_PGF' and 'vten_PGF' is [ m/s/s ].          !
         ! I checked that the sign is correct.                          ! 
         ! ------------------------------------------------------------ !

         do k = 1, ktop                       
            uten_PGF(k) = - ( g / dp0(k) ) * ( cmf_u_dia(k) * PGF_u_u(k) + cmf_d_dia(k) * PGF_u_d(k) )
            vten_PGF(k) = - ( g / dp0(k) ) * ( cmf_u_dia(k) * PGF_v_u(k) + cmf_d_dia(k) * PGF_v_d(k) )
         enddo

         ! --------------------------------------------------------------------------------------- !
         ! Compute rain and snow production tendencies & effective tendencies of cloud condensate. !
         ! Important Sanity Check for Positive Precipitation Flux.                                 !
         ! --------------------------------------------------------------------------------------- !

         rainflx = 0._r8
         snowflx = 0._r8
         ! Nov.29.2012. Add corresponding tracer part.
         do mt = 1, ncnst
            trrsflx(mt) = 0._r8
         enddo
         do k = ktop, 1, -1  ! This is a layer index 
            km = k - 1
            qlten_eff_u(k) = ( g / dp0(k) ) * eff_ql_u(k) * cmf_u_dia(k) 
            qiten_eff_u(k) = ( g / dp0(k) ) * eff_qi_u(k) * cmf_u_dia(k) 
            qlten_eff_d(k) = ( g / dp0(k) ) * eff_ql_d(k) * cmf_d_dia(k) 
            qiten_eff_d(k) = ( g / dp0(k) ) * eff_qi_d(k) * cmf_d_dia(k) 
            do mt = 1, ncnst
               ! if( cnst_get_type_byind(mt) .eq. 'wet' ) then
               !     pdelx = dp0(k)
               ! else
               !     pdelx = dpdry0(k)
               ! endif
               trten_eff_u(k,mt) = ( g / dptr0(k,mt) ) * eff_tr_u(k,mt) * cmf_u_dia(k) 
               trten_eff_d(k,mt) = ( g / dptr0(k,mt) ) * eff_tr_d(k,mt) * cmf_d_dia(k) 
            enddo
            ! ------------------------------------------------------------------------------------- !
            ! Below considers 'production  of precipitation within   updraft ( prep_qtl_u < 0 ) and !
            !                 'evaporation of precipitation within downdraft (  evp_qtl_d > 0 ).    !
            !  1. By multiplying mass flux, the updraft/downdraft area information are included.    !
            !  2. In a certain layer, qrten, qsten can be negative due to the evaporation. However, !
            !     its downward integrated 'rainflx, snowflx' is always positive at all interfaces   !
            !     due to the how 'evp_qtl_d' is computed.                                           !
            !  3. Snow melting effect is included into 'qrten(k), qsten(k)'. Note that it should    !
            !     not be included into 'qrten_u(k), qsten_u(k)' - very important.                   ! 
            ! Nov.29.2012. Add tracer 'trrsten' associated with rain/snow components.               !
            ! Feb.06.2013. Note that wet deposition of aerosols (both interstitial and cloud-borne) !
            !              within convective updraft and downdraft will be treated as a part of     !
            !              prep_tr_u(k,mt) and prep_tr_d(k,mt). Thus, I don't need separate use of  !
            !              wdep_tr_u(k,mt) and wdep_tr_d(k,mt) in the below computation of          !
            !              trten_dia_u(k,mt) and trten_dia_d(k,mt).                                 !   
            ! ------------------------------------------------------------------------------------- !
            thlten_dia_u(k) = ( g / dp0(k) ) * ( prep_thll_u(k) + prep_thli_u(k) +  evp_thll_u(k) +  evp_thli_u(k) ) * cmf_u_dia(k)
            qtten_dia_u(k)  = ( g / dp0(k) ) * ( prep_qtl_u(k)  + prep_qti_u(k)  +  evp_qtl_u(k)  +  evp_qti_u(k)  ) * cmf_u_dia(k)
            qlten_dia_u(k)  = ( g / dp0(k) ) * ( prep_qtl_u(k)                                                     ) * cmf_u_dia(k)
            qiten_dia_u(k)  = ( g / dp0(k) ) * ( prep_qti_u(k)                                                     ) * cmf_u_dia(k)
            thlten_dia_d(k) = ( g / dp0(k) ) * ( prep_thll_d(k) + prep_thli_d(k) +  evp_thll_d(k) +  evp_thli_d(k) ) * cmf_d_dia(k)
            qtten_dia_d(k)  = ( g / dp0(k) ) * ( prep_qtl_d(k)  + prep_qti_d(k)  +  evp_qtl_d(k)  +  evp_qti_d(k)  ) * cmf_d_dia(k)
            qlten_dia_d(k)  = ( g / dp0(k) ) * ( prep_qtl_d(k)                                                     ) * cmf_d_dia(k)
            qiten_dia_d(k)  = ( g / dp0(k) ) * ( prep_qti_d(k)                                                     ) * cmf_d_dia(k)
            do mt = 1, ncnst
               ! if( cnst_get_type_byind(mt) .eq. 'wet' ) then
               !     pdelx = dp0(k)
               ! else
               !     pdelx = dpdry0(k)
               ! endif
               trten_dia_u(k,mt) = ( g / dptr0(k,mt) ) * ( prep_tr_u(k,mt) + evp_tr_u(k,mt) ) * cmf_u_dia(k) 
               trten_dia_d(k,mt) = ( g / dptr0(k,mt) ) * ( prep_tr_d(k,mt) + evp_tr_d(k,mt) ) * cmf_d_dia(k) 
               ! trten_dia_u(k,mt) = ( g / dptr0(k,mt) ) * ( prep_tr_u(k,mt) + evp_tr_u(k,mt) + wdep_tr_u(k,mt) ) * cmf_u_dia(k) 
               ! trten_dia_d(k,mt) = ( g / dptr0(k,mt) ) * ( prep_tr_d(k,mt) + evp_tr_d(k,mt) + wdep_tr_d(k,mt) ) * cmf_d_dia(k) 
            enddo
            qrten_u(k) = - ( g / dp0(k) ) * ( prep_qtl_u(k) + evp_qtl_u(k) ) * cmf_u_dia(k)   ! >= 0
            qrten_d(k) = - ( g / dp0(k) ) * ( prep_qtl_d(k) + evp_qtl_d(k) ) * cmf_d_dia(k)   ! <= 0
            qsten_u(k) = - ( g / dp0(k) ) * ( prep_qti_u(k) + evp_qti_u(k) ) * cmf_u_dia(k)   ! >= 0
            qsten_d(k) = - ( g / dp0(k) ) * ( prep_qti_d(k) + evp_qti_d(k) ) * cmf_d_dia(k)   ! <= 0
            ! Nov.29.2012. Add corresponding tracer part. Be careful that (-) should be at the front.
            ! Nov.01.2012. Below block is commented out since it is treated below.
            ! do mt = 1, ncnst
            !    trrsten_u(k,mt) = - trten_dia_u(k,mt)
            !    trrsten_d(k,mt) = - trten_dia_d(k,mt)         
            ! enddo
            qrten(k)   =   qrten_u(k) + qrten_d(k)
            qsten(k)   =   qsten_u(k) + qsten_d(k)
            !? Below 'qrten(k),qsten(k)' are not used in actual computation any more.
            !? Since 'snowmlt_e(k)' are computed later, I commented out below two lines and used above
            !? two lines instead.
            !?       qrten(k)   =   qrten_u(k) + snowmlt_e(k) + qrten_d(k)
            !?       qsten(k)   =   qsten_u(k) - snowmlt_e(k) + qsten_d(k)
            ! Nov.29.2012. Add corresponding tracer part.
            ! Dec.01.2012. Separate treatment for precipitating droplet number.
            do mt = 1, ncnst
               if( mt .eq. ixcldliq ) then
                  trrsten(k,mt) = qrten(k)
               elseif( mt .eq. ixcldice ) then
                  trrsten(k,mt) = qsten(k)
               elseif( mt .eq. ixnumliq ) then
                  trrsten(k,mt) = qrten(k) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_rain**3 * density_rain )        
               elseif( mt .eq. ixnumice ) then
                  trrsten(k,mt) = qsten(k) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_snow**3 * density_snow )        
               else 
                  trrsten_u(k,mt) = - trten_dia_u(k,mt)
                  trrsten_d(k,mt) = - trten_dia_d(k,mt)         
                  trrsten(k,mt)   = trrsten_u(k,mt) + trrsten_d(k,mt)
               endif
            enddo
            !?     ! Apr.26.2011. In the below two lines, I added 'cvp_rainprd_d(k),cvp_snowprd_d(k)'.
            !?       rainflx    =   rainflx + ( qrten(k) + cvp_rainprd_d(k) ) * ( dp0(k) / g )
            !?       snowflx    =   snowflx + ( qsten(k) + cvp_snowprd_d(k) ) * ( dp0(k) / g )
            !?       flxrain_aftdn(km) = rainflx
            !?       flxsnow_aftdn(km) = snowflx
            !?     ! Nov.29.2012. Add corresponding tracer part. Note that I should use pdelx.
            !?     !              Although this block is only for diagnostic checking, let's add below for future use.
            !?       do mt = 1, ncnst
            !?        ! if( cnst_get_type_byind(mt) .eq. 'wet' ) then
            !?        !     pdelx = dp0(k)
            !?        ! else
            !?        !     pdelx = dpdry0(k)
            !?        ! endif
            !?          trrsflx(mt)          = trrsflx(mt) + ( trrsten(k,mt) + cvp_trrsprd_d(k,mt) ) * ( dptr0(k,mt) / g )
            !?          flxtrrs_aftdn(km,mt) = trrsflx(mt)
            !?       enddo
            !?     ! Note than 'flxrain_aftdn(km), flxsnow_aftdn(km)' are just diagnostic variables to
            !?     ! check whether precipitation flux is positive after evaporation within downdraft.
            !?       if( rainflx .lt. -1.e-18_r8 .or. snowflx .lt. -1.e-18_r8 ) then
            !?           write(6,*) 'UNICON : Negative precipitation flux after evaporation within downdraft'
            !?           write(6,*) 'k, rainflx, snowflx = ', k, rainflx, snowflx
            !?         ! stop
            !?       endif
            !?     ! CHECK
            !?     ! write(6,*)
            !?     ! write(6,*) 'UNICON: Precipitation flux at the base interface after evaporation within downdraft'
            !?     ! write(6,*) 'Cumulus Top Layer and Layer Index = ', ktop, k
            !?     ! write(6,*) 'flxrain_aftdn(',km,')  = ', flxrain_aftdn(km)
            !?     ! write(6,*) 'flxsnow_aftdn(',km,')  = ', flxsnow_aftdn(km) 
            !?     ! write(6,*)
            !?     ! CHECK
         end do

         ! ---------------------------------------------------------------------- !
         ! Compute 'qrten_msfc(k,msfc)' and 'qrten_msfc(k,msfc)' for later use in !
         ! computing evaporation of precipitation within downdraft.               !
         ! Nov.29.2012. Add corresponding tracer part.                            ! 
         ! ---------------------------------------------------------------------- ! 

         do msfc = 1, nseg
            do k = ktop_msfc(msfc), 1, -1  ! This is a layer index 
               !?       qrten_msfc(k,msfc)   =   qrten_u_msfc(k,msfc) + snowmlt_e_msfc(k,msfc) + qrten_d_msfc(k,msfc)
               !?       qsten_msfc(k,msfc)   =   qsten_u_msfc(k,msfc) - snowmlt_e_msfc(k,msfc) + qsten_d_msfc(k,msfc)
               qrten_msfc(k,msfc)   =   qrten_u_msfc(k,msfc) + qrten_d_msfc(k,msfc)
               qsten_msfc(k,msfc)   =   qsten_u_msfc(k,msfc) + qsten_d_msfc(k,msfc)
               ! Nov.29.2012. 
               ! Dec.01.2012. Separate treatment is necessary for number concentration.
               do mt = 1, ncnst
                  if( mt .eq. ixcldliq ) then
                     trrsten_msfc(k,msfc,mt) = qrten_msfc(k,msfc)
                  elseif( mt .eq. ixcldice ) then
                     trrsten_msfc(k,msfc,mt) = qsten_msfc(k,msfc)
                  elseif( mt .eq. ixnumliq ) then
                     trrsten_msfc(k,msfc,mt) = qrten_msfc(k,msfc) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_rain**3 * density_rain )        
                  elseif( mt .eq. ixnumice ) then
                     trrsten_msfc(k,msfc,mt) = qsten_msfc(k,msfc) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_snow**3 * density_snow )        
                  else
                     trrsten_msfc(k,msfc,mt) = trrsten_u_msfc(k,msfc,mt) + trrsten_d_msfc(k,msfc,mt)
                  endif
               enddo
            end do
         end do

         ! ------------------------------------------------------------------------ !
         ! Grid-mean tendencies of non-conservative scalars: 'ql,qi'                !
         ! This is a sum of compensating subsidence and condensate detrainment.     !
         ! Note that 'ql(i)flx_u(i)' at surface is set to zero even though cmf_d(0) !
         ! was explicitly computed above. As a result, the tendency computation is  !
         ! absolutely correct, which is good.                                       ! 
         ! Mar.19.2014. Note that tendency computation will be done further below   !
         !              after computing flux first. As discussed further below,     !
         !              should compute non-zero convective flux (both updraft and   !
         !              downdraft) for use with 'ipartition = 1' option.            ! 
         ! ------------------------------------------------------------------------ ! 
         
         ! Below block is computed in a consistent discrete way at the beginning of the code.
         ! So, I commented out.

         ! if( kiss .eq. 0 ) then 
         !     do mt = 1, ncnst
         !        trflx_u(0,mt) = aflx(mt) * I_cri
         !     enddo 
         ! endif

         do k = 1, ktop - 1    ! This is a top interface index or layer index
            km = k - 1
            kp = k + 1
            um = abs( g * cmf_u(k) * dt )
            dm = abs( g * cmf_d(k) * dt )
            call envcon_flux( k, mkx, um, dm, ql0(1:mkx), ssql0(1:mkx), ps0(0:mkx), ql_env_u, ql_env_d )
            call envcon_flux( k, mkx, um, dm, qi0(1:mkx), ssqi0(1:mkx), ps0(0:mkx), qi_env_u, qi_env_d )
            ql_env_ua(k)  = ql_env_u 
            qi_env_ua(k)  = qi_env_u
            ql_env_da(kp) = ql_env_d 
            qi_env_da(kp) = qi_env_d
            if( iflux_env .eq. 0 ) then
               ql_env_ua(k)  = ql0bot(kp)
               qi_env_ua(k)  = qi0bot(kp)
               ql_env_da(kp) = ql0top(k) 
               qi_env_da(kp) = qi0top(k)
            endif
            qlflx_u(k) =   cmf_u(k) * ( ql_u(k)  -   ql_env_ua(k) )
            qiflx_u(k) =   cmf_u(k) * ( qi_u(k)  -   qi_env_ua(k) )
            qlflx_d(k) = - cmf_d(k) * ( ql_d(k)  -  ql_env_da(kp) )
            qiflx_d(k) = - cmf_d(k) * ( qi_d(k)  -  qi_env_da(kp) )
            do mt = 1, ncnst
               ! Nov.30.2012. Strictly speaking, we should not use 'ps0' but use the interface pressure corresponding
               !              to individual tracers derived from 'dptr0(k,mt)'. This should be done in future. 
               call envcon_flux( k, mkx, um, dm, tr0(1:mkx,mt), sstr0(1:mkx,mt), ps0(0:mkx), tr_env_u, tr_env_d )
               if( iflux_env .eq. 0 ) then
                  tr_env_u = tr0bot(kp,mt)
                  tr_env_d = tr0top(k,mt)
               endif
               trflx_u(k,mt) =   cmf_u(k) * ( tr_u(k,mt)  -  tr_env_u )
               trflx_d(k,mt) = - cmf_d(k) * ( tr_d(k,mt)  -  tr_env_d )
               ! ------------------------------------------------------------------------------------------ !
               ! Temporary hack to be consistent with the treatment in CAM5.                                !
               ! Assign a fixed droplet radius to convective updraft and downdraft condensates, if any.     ! 
               ! This block should be removed if my scheme correctly compute 'tr_u(k,mt),tr_d(k,mt)' later. !
               ! In CAM5, for deep    scheme,  8 (liquid) and 25 (ice) micron, while                        !
               !          for shallow scheme, 10 (liquid) and 50 (ice) micron are used.                     !
               ! Here, I will combine them with a ramper between 700 hPa and 400 hPa.                       !
               ! Note that the density of cloud liquid and ice differs.                                     ! 
               !                                                                                            ! 
               ! Nov.28.2012. Given all of the above consistent treatments made on this day, below block is !
               !              redundant and is not necessary anymore. So, on this day, I am commenting-out  !
               !              entire 'if block' below.                                                      !    
               ! ------------------------------------------------------------------------------------------ !
               ! if( mt .eq. ixnumliq ) then
               !   ! Nov.08.2011. Specify fixed droprad_liq from the parameter sentence.
               !   ! if( ps0(k) .gt. 70000._r8 ) then
               !   !     tmp1 = droprad_liq_LZ
               !   ! elseif( ps0(k) .lt. 40000._r8 ) then
               !   !     tmp1 = droprad_liq_HZ
               !   ! else
               !   !     tmp1 = droprad_liq_LZ - ( 70000._r8 - ps0(k) ) * ( droprad_liq_LZ -droprad_liq_HZ ) / ( 70000._r8 - 40000._r8 )
               !   ! endif
               !   ! 1.May.2011. Since correct 'ql,qi' are not yet in the tracer array, I should use 'ql,qi'
               !   !             instead of 'tr_u,tr_d' in the below two lines.
               !     tmp2 = ql_u(k) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_liq**3 * density_liq )
               !     tmp3 = ql_d(k) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_liq**3 * density_liq )
               !   ! tmp2 = tr_u(k,2) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_liq**3 * density_liq )
               !   ! tmp3 = tr_d(k,2) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_liq**3 * density_liq )
               !     trflx_u(k,mt) =   cmf_u(k) * ( tmp2  -  tr_env_u )
               !     trflx_d(k,mt) = - cmf_d(k) * ( tmp3  -  tr_env_d )
               ! elseif( mt .eq. ixnumice ) then
               !   ! Nov.08.2011. Specify fixed droprad_ice from the parameter sentence.
               !   ! if( ps0(k) .gt. 70000._r8 ) then
               !   !     tmp1 = droprad_ice_LZ
               !   ! elseif( ps0(k) .lt. 40000._r8 ) then
               !   !     tmp1 = droprad_ice_HZ
               !   ! else
               !   !     tmp1 = droprad_ice_LZ - ( 70000._r8 - ps0(k) ) * ( droprad_ice_LZ - droprad_ice_HZ ) / ( 70000._r8 - 40000._r8 )
               !   ! endif
               !   ! 1.May.2011. Since correct 'ql,qi' are not yet in the tracer array, I should use 'ql,qi'
               !   !             instead of 'tr_u,tr_d' in the below two lines.
               !     tmp2 = qi_u(k) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_ice**3 * density_ice )
               !     tmp3 = qi_d(k) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_ice**3 * density_ice )
               !   ! tmp2 = tr_u(k,3) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_ice**3 * density_ice )
               !   ! tmp3 = tr_d(k,3) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_ice**3 * density_ice )
               !     trflx_u(k,mt) =   cmf_u(k) * ( tmp2  -  tr_env_u )
               !     trflx_d(k,mt) = - cmf_d(k) * ( tmp3  -  tr_env_d )
               ! endif
            enddo
         enddo
         ! ------------------------------------------------------------------------------------------- !
         ! Mar.19.2014. Compute downdraft flux at the base interface.                                  !
         !              Similar to the treatment of the updraft flux with 'ipartition = 1' option,     !
         !              I should compute the downdraft flux at the surface interface, and partition    !
         !              the downdraft surface flux uniformly over the entire cumulus layer or the      !
         !              PBL depth. I should do this for the 'ql,qi' and 'tracers' too.                 ! 
         !              This treatment of the 'ql,qi,tracer' fluxes are done here before computing     !
         !              corresponding tendencies, using the exactly same method used here below for    !
         !              conservative scalars.                                                          !
         !              Note that at this stage, we have already computed non-zero cmf_d(0), thl_d(0), ! 
         !              qt_d(0), u_d(0), v_d(0), so that below treatment is perfectly correct.         !
         !              Similar computation of convective fluxes at the surface for 'slflx_d(0),       !
         !              qtflx_d(0), uflx_d(0), vflx_d(0)' will be done later. The same computation for !
         !              convective updraft fluxes at the surface for all the scalars wre already done  !
         !              at the beginning portion of this module. Thus below computation for 'ql,qi'    !
         !              and 'tracers' of convective downdraft fluxes at the surface is enough.         !
         ! ------------------------------------------------------------------------------------------- !
         qlflx_d(0)       = -cmf_d(0) * ( ql_d(0)  -  ql0bot(1) )
         qiflx_d(0)       = -cmf_d(0) * ( qi_d(0)  -  qi0bot(1) )
         do mt = 1, ncnst
            trflx_d(0,mt) = -cmf_d(0) * ( tr_d(0,mt) - tr0bot(1,mt) )
         enddo

         ! ----------------------------------------------------------------------------------- !
         ! Mar.19.2014. Computation of tendencies of 'ql,qi,tracers' using the fluxes.         !
         !              Note that we are using non-zero surface fluxes here for consistent use ! 
         !              with the other conservativee scalars with ipartition=1.                !
         ! ----------------------------------------------------------------------------------- !

         do k = 1, ktop
            km = k - 1
            qlten_u(k) = ( g / dp0(k) ) * ( qlflx_u(km) - qlflx_u(k) ) + qlten_dia_u(k) + qlten_eff_u(k)
            qiten_u(k) = ( g / dp0(k) ) * ( qiflx_u(km) - qiflx_u(k) ) + qiten_dia_u(k) + qiten_eff_u(k)
            qlten_d(k) = ( g / dp0(k) ) * ( qlflx_d(km) - qlflx_d(k) ) + qlten_dia_d(k) + qlten_eff_d(k)
            qiten_d(k) = ( g / dp0(k) ) * ( qiflx_d(km) - qiflx_d(k) ) + qiten_dia_d(k) + qiten_eff_d(k)
            do mt = 1, ncnst
               ! if( cnst_get_type_byind(mt) .eq. 'wet' ) then
               !     pdelx = dp0(k)
               ! else
               !     pdelx = dpdry0(k)
               ! endif
               trten_u(k,mt) = ( g / dptr0(k,mt) ) * ( trflx_u(km,mt) - trflx_u(k,mt) ) + trten_dia_u(k,mt) + trten_eff_u(k,mt)
               trten_d(k,mt) = ( g / dptr0(k,mt) ) * ( trflx_d(km,mt) - trflx_d(k,mt) ) + trten_dia_d(k,mt) + trten_eff_d(k,mt)
            enddo

            ! CHECK
            ! if( get_nstep() .eq. 3 .and. k .eq. 5 ) then
            !     write(6,*)
            !     write(6,*) 'UNICON: Computation of qlten in the ambiguous layer'
            !     write(6,*) 'Time step & Layer Index: ', get_nstep(), k
            !     write(6,*) 'qlten_u(k), ( g / dp0(k) ) * ( qlflx_u(km) - qlflx_u(k) ), qrten_u(k), qlten_eff_u(k) = ', &
            !                 qlten_u(k), ( g / dp0(k) ) * ( qlflx_u(km) - qlflx_u(k) ), qrten_u(k), qlten_eff_u(k)
            !     write(6,*) 'qlten_d(k), ( g / dp0(k) ) * ( qlflx_d(km) - qlflx_d(k) ), qrten_d(k), qlten_eff_d(k) = ', &
            !                 qlten_d(k), ( g / dp0(k) ) * ( qlflx_d(km) - qlflx_d(k) ), qrten_d(k), qlten_eff_d(k)
            !     write(6,*) 
            ! endif
            ! CHECK

         end do

         ! ----------------------------------------------------- !
         ! Tendency due to Compensating Subsidence : [ kg/kg/s ] !
         ! ----------------------------------------------------- ! 

         do k = 1, ktop
            km = k - 1
            kp = k + 1
            ! --------- !
            ! OPTION. 0 !
            ! --------- !
            ! if( k .eq. 1 ) then
            !     qlten_sub(k) = g * ( cmf_u(k)  * ( ql_env_ua(k) - ql0(k) ) ) / dp0(k)
            !     qiten_sub(k) = g * ( cmf_u(k)  * ( qi_env_ua(k) - qi0(k) ) ) / dp0(k)
            ! elseif( k .eq. ktop ) then     
            !     qlten_sub(k) = g * ( cmf_d(km) * ( ql_env_da(k) - ql0(k) ) ) / dp0(k)
            !     qiten_sub(k) = g * ( cmf_d(km) * ( qi_env_da(k) - qi0(k) ) ) / dp0(k)
            ! else                           
            !     qlten_sub(k) = g * ( cmf_u(k)  * ( ql_env_ua(k) - ql0(k) ) + cmf_d(km) * ( ql_env_da(k) - ql0(k) ) ) / dp0(k)
            !     qiten_sub(k) = g * ( cmf_u(k)  * ( qi_env_ua(k) - qi0(k) ) + cmf_d(km) * ( qi_env_da(k) - qi0(k) ) ) / dp0(k)
            ! endif       
            ! -------- !
            ! Option.1.! 
            ! -------- !
            if( k .eq. 1 ) then
               qlten_sub(k) = g * 0.5_r8 * ( cmf_u(k) + cmf_u(km) - cmf_d(k) - cmf_d(km) ) * &
                  ( ql0(k+1) -  ql0(1) ) / ( p0(1) - p0(k+1) ) 
               qiten_sub(k) = g * 0.5_r8 * ( cmf_u(k) + cmf_u(km) - cmf_d(k) - cmf_d(km) ) * &
                  ( qi0(k+1) -  qi0(1) ) / ( p0(1) - p0(k+1) ) 
            elseif( k .eq. ktop ) then     
               qlten_sub(k) = g * 0.5_r8 * ( cmf_u(k) + cmf_u(km) - cmf_d(k) - cmf_d(km) ) * &
                  ( ql0(ktop) - ql0(k-1) ) / ( p0(k-1) - p0(ktop) ) 
               qiten_sub(k) = g * 0.5_r8 * ( cmf_u(k) + cmf_u(km) - cmf_d(k) - cmf_d(km) ) * &
                  ( qi0(ktop) - qi0(k-1) ) / ( p0(k-1) - p0(ktop) ) 
            else                           
               qlten_sub(k) = g * 0.5_r8 * ( cmf_u(k) + cmf_u(km) - cmf_d(k) - cmf_d(km) ) * &
                  ( ql0(k+1) -  ql0(k-1) ) / ( p0(k-1) - p0(k+1) ) 
               qiten_sub(k) = g * 0.5_r8 * ( cmf_u(k) + cmf_u(km) - cmf_d(k) - cmf_d(km) ) * &
                  ( qi0(k+1)  - qi0(k-1) ) / ( p0(k-1) - p0(k+1) ) 
            endif
         enddo

         ! ---------------------------------------------------- !
         ! Tendency due to Condensate Detrainment : [ kg/kg/s ] !
         ! ---------------------------------------------------- ! 

         rliq = 0._r8
         rice = 0._r8
         do k = 1, ktop   ! This is a layer index
            km = k - 1    ! This is a base interface index
            ! ------------------------------------------------------------------------------------------------------ !
            ! Nov.04.2014. For the fully consistent treatment directly relating 'flux-convergence' formula to        !
            ! the 'subsidence-detrainment' formula, I should use 'cmf_r2(k), ql_r2(k), qi_r2(k)' in the below block. ! 
            ! Thus, I changed to the correct formula today.                                                          !
            ! ------------------------------------------------------------------------------------------------------ !
          ! qlten_det(k) = cmf_r(k) * ( ql_r(k) - ql0(k) ) * ( g / dp0(k) )
          ! qiten_det(k) = cmf_r(k) * ( qi_r(k) - qi0(k) ) * ( g / dp0(k) )
            qlten_det(k) = cmf_r2(k) * ( ql_r2(k) - ql0(k) ) * ( g / dp0(k) )
            qiten_det(k) = cmf_r2(k) * ( qi_r2(k) - qi0(k) ) * ( g / dp0(k) )
            ! TEST
            ! qlten_det(k) = 0._r8
            ! qiten_det(k) = 0._r8 
            ! TEST
            ! Original. Currently use this. 
            ! rqc_l(k) = 0._r8
            ! rqc_i(k) = 0._r8
            ! rnc_l(k) = 0._r8
            ! rnc_i(k) = 0._r8
            ! Modified. Use this when droplet number is also treated in future.
            ! 1.May.2011. No. Even in future, I should use the above original since UNICON
            !             completely treats this process internally.
            ! 2.Jan.04.2012. Use below block for testing 'cu_det_st = .true.' option.
            ! rqc_l(k) = cmf_r(k) * ql_r(k) * ( g / dp0(k) )          ! [ kg/kg/s ] >= 0. 
            ! rqc_i(k) = cmf_r(k) * qi_r(k) * ( g / dp0(k) )          ! [ kg/kg/s ] >= 0.
            ! rnc_l(k) = cmf_r(k) * tr_r(k,ixnumliq) * ( g / dp0(k) ) ! [ #/kg/s ] >= 0. 
            ! rnc_i(k) = cmf_r(k) * tr_r(k,ixnumice) * ( g / dp0(k) ) ! [ #/kg/s ] >= 0.
            ! 3.Mar.02.2015. '_r' is changed to '_r2' for fully energy consistent treatment.
            rqc_l(k) = cmf_r2(k) * ql_r2(k) * ( g / dp0(k) )          ! [ kg/kg/s ] >= 0. 
            rqc_i(k) = cmf_r2(k) * qi_r2(k) * ( g / dp0(k) )          ! [ kg/kg/s ] >= 0.
            rnc_l(k) = cmf_r2(k) * tr_r2(k,ixnumliq) * ( g / dp0(k) ) ! [ #/kg/s ] >= 0. 
            rnc_i(k) = cmf_r2(k) * tr_r2(k,ixnumice) * ( g / dp0(k) ) ! [ #/kg/s ] >= 0.
            rqc(k)   = rqc_l(k) + rqc_i(k)
            rliq     = rliq  +   rqc(k) * dp0(k) / g / 1000._r8       ! [ liquid m/s ]
            rice     = rice  + rqc_i(k) * dp0(k) / g / 1000._r8       ! [ liquid m/s ]
         enddo ! k = 1, ktop. Here, 'k' is a layer index.

         ! --------------------------------------- !
         !                                         !
         ! Fractional Areas at the Layer Mid-Point ! 
         !                                         !
         ! --------------------------------------- !

         !? Below block has already been computed above.
         !? So, I comment-out below block.

         !?   do k = 1, ktop                ! Thus is a layer index
         !?      km = k - 1                 ! This is a base interface
         !?    ! ------------------------------------------------------------------------------------------ !
         !?    ! Note that 'a_u(ktop)=0' and 'a_d(0)=0' by construction.                                    !
         !?    ! But am_u(ktop) and am_d(1) can be defined in a slightly different way (e.g., area-weighted !
         !?    ! cloud top average by using volume concept) for consistency with the treatment of cmf_u_dia !
         !?    ! and cmf_d_dia.                                                                             !
         !?    ! ------------------------------------------------------------------------------------------ !
         !?    ! Apr.21.2011. I have already computed 'am_u,am_d' by summing individual element's 
         !?    !              fractional area by explicitly considering partial fillness of updraft and
         !?    !              downdraft in vertical in the cumulus top and downdraft source layers.
         !?    !              Thus, I comment out below two lines of am_u(k) and am_d(k).
         !?    !              In addition, 'if( ifinad_evpenv .eq. 0 )' is applied individually below
         !?    !              at several locations instead of applying in the below block. 
         !?    !              While it needed several coding, the modified
         !?    !              individual application is better since it does not change the pre-computed 
         !?    !              diagnostic output of 'am_d,am_d_msfc'.
         !?    ! am_u(k) = 0.5_r8 * ( a_u(km) + a_u(k) )
         !?    ! am_d(k) = 0.5_r8 * ( a_d(km) + a_d(k) )
         !?    ! if( ifinad_evpenv .eq. 0 ) am_d(k) = 0._r8
         !?    ! ---------------------------------------------------------- !
         !?    ! Note that 'am_e(k)' is not used in the actual computation, ! 
         !?    ! so we don't need to worry about this.                      !
         !?    ! ---------------------------------------------------------- ! 
         !?      if( ifinad_evpenv .eq. 0 ) then
         !?          am_e(k) = 1._r8 - am_u(k)          
         !?      else
         !?          am_e(k) = 1._r8 - am_u(k) - am_d(k) 
         !?      endif 
         !?    ! am_e(k) = 1._r8 - max( am_u(k), am_d(k) ) ! Modified. Jan. 22. 2010.
         !?    ! am_e(k) = 1._r8 - am_u(k)                 ! Modified. May. 24. 2010
         !?    ! ----------------------------------------------------------------------------------- !
         !?    ! Re-define input stratiform cloud area such that the sum of 'am_u' and               !
         !?    ! 'am_s' ( stratiform fractional area at the layer mid-point ) is always less that 1. !
         !?    ! Consistent with the assumption of a_d = 0 throughout the whole model, we are        !
         !?    ! assuming a_d = 0.                                                                   ! 
         !?    ! Here, ast0(i,k) is input stratus fraction at the layer mid-point while am_s(k)      !
         !?    ! is adjusted stratus fraction at the layer mid-point.                                !
         !?    ! ----------------------------------------------------------------------------------- !
         !?      am_s(k) = ast0(k)
         !?    ! ----------------------------------------------------------------------------------- !
         !?    ! Below two lines are more advanced correct treatment                                 !
         !?    ! explicitly considering finite downdraft fractional area.                            !
         !?    ! Below line should be used in combination of (1) ad_max = 0.1 (or so, not 1.e8) and  !
         !?    ! (2) computation of 'a_pr' and 'a_ps' later below.                                   !                 
         !?    ! Since separate cloud macrophysics does not explicitly consider convective downdraft !
         !?    ! treatment of non-zero downdraft fractional area may cause inconsistency, not within !
         !?    ! convection scheme, but within the whole CAM.                                        ! 
         !?    ! Below 'Origin' OPTION is quivalent to assuming that downdraft fractional area is    !
         !?    ! zero ( but still non-overlapped with updraft and environmental area ). Thus, the    !
         !?    ! original assumption is also conceptually acceptable even though we compute finite   !
         !?    ! downdraft fractional area for diagnostic purpose. The 'Advanced' option used the    !
         !?    ! downdraft fractional area for dynamic computation of downdraft process explicitly,  !
         !?    ! which is also good. However, unless cloud macrophysics explicitly treat downdraft   !
         !?    ! fractional area in a consistent way, there is still confliction. Thus, let's use    !
         !?    ! the original option for the time being.                                             !   
         !?    ! ----------------------------------------------------------------------------------- !
         !?      if( ifinad_evpenv .eq. 0 ) then
         !?          if( ( am_u(k) + ast0(k) ) .gt. 1._r8 ) am_s(k) = 1._r8 - am_u(k)  
         !?      else
         !?          if( ( am_u(k) + am_d(k) + ast0(k) ) .gt. 1._r8 ) am_s(k) = 1._r8 - am_u(k) - am_d(k)
         !?      endif
         !?      am_r(k) = 1._r8 - am_u(k) - am_s(k)
         !?    ! --------------------------------------------------------------------------------------- !
         !?    ! Computation of precipitating convective updraft fractional area at the layer mid-point. !
         !?    ! Note that I used 'qrten(k) + qsten(k)' instead of 'qrten_u(k) + qsten_u(k)'             !
         !?    ! to take into account of the evaporation within convective downdrafts.                   !
         !?    ! --------------------------------------------------------------------------------------- ! 
         !?    ! Mar.12.2011. I computed 'am_up' and 'am_us' already by considering individual
         !?    !              updraft segment properties, which is much more reasonable.
         !?    !  am_up(k) = am_u(k)
         !?    !! if( ( qrten(k)   +   qsten(k) ) .le. 0._r8 ) am_up(k) = 0._r8 
         !?    !  if( ( qrten_u(k) + qsten_u(k) ) .le. 0._r8 ) am_up(k) = 0._r8 
         !?   enddo

         ! -------------------------------------------- !
         !                                              !
         ! Grid-Mean Tendencies of Conservative Scalars !
         !                                              !
         ! -------------------------------------------- !

         ! ----------------------------------------------------------------- !
         ! When convective updraft plumes launch from the surface ( k = 0 ), ! 
         ! also specify non-zero updraft flux value at surface.              !
         ! By defult, the flux at surface is set to be zero.                 ! 
         ! As expected, this 'kiss=0' causes conservation error.             !
         ! However, by setting I_cri = 0 when kiss = 0, we can avoid         !
         ! conservation error in a most reasonable way.                      ! 
         ! ----------------------------------------------------------------- !     

         ! Below block is computed in a consistent discrete way at the beginning of the code.
         ! So, I commented out.

         ! if( kiss .eq. 0 ) then 
         !     slflx_u(0) =  shflx * I_cri
         !     qtflx_u(0) =   qflx * I_cri
         !     uflx_u(0)  =   taux * I_cri
         !     vflx_u(0)  =   tauy * I_cri
         ! endif

         ! ---------------------------------- ! 
         ! Tendency due to Convective Updraft !
         ! ---------------------------------- !

         do k = 1, ktop - 1    ! This is a layer index        
            um = abs( g * cmf_u(k) * dt )
            dm = 0._r8
            call envcon_flux( k, mkx, um, dm, thl0(1:mkx), ssthl0(1:mkx), ps0(0:mkx), thl_env_u, thl_env_d )
            call envcon_flux( k, mkx, um, dm, qt0(1:mkx), ssqt0(1:mkx), ps0(0:mkx), qt_env_u, qt_env_d )
            call envcon_flux( k, mkx, um, dm, u0(1:mkx), ssu0(1:mkx), ps0(0:mkx), u_env_u, u_env_d )
            call envcon_flux( k, mkx, um, dm, v0(1:mkx), ssv0(1:mkx), ps0(0:mkx), v_env_u, v_env_d )
            ! CHECK
            ! write(6,*)
            ! write(6,*) 'UNICON: Environmental profile value for updraft flux computation'
            ! write(6,*) 'Layer index : ', k
            ! write(6,*) 'Ratio of (g*cmf_u*dt)/dp0(k) = ', um/dp0(k)
            ! write(6,*) 'cmf_u(k) at the top interface : ', cmf_u(k)
            ! write(6,*) 'thl_u(k), thl_env_u, thl0bot(k+1), thl0top(k+1), thl0bot(k+2), thl0top(k+2) = ', &
            !             thl_u(k), thl_env_u, thl0bot(k+1), thl0top(k+1), thl0bot(k+2), thl0top(k+2)
            ! write(6,*) ' qt_u(k), qt_env_u,  qt0bot(k+1),  qt0top(k+1),  qt0bot(k+2),  qt0top(k+2) = ', &
            !              qt_u(k), qt_env_u,  qt0bot(k+1),  qt0top(k+1),  qt0bot(k+2),  qt0top(k+2)
            ! write(6,*) '  u_u(k), u_env_u,   u0bot(k+1),   u0top(k+1),   u0bot(k+2),   u0top(k+2) = ', &
            !               u_u(k), u_env_u,   u0bot(k+1),   u0top(k+1),   u0bot(k+2),   u0top(k+2)
            ! write(6,*) '  v_u(k), v_env_u,   v0bot(k+1),   v0top(k+1),   v0bot(k+2),   v0top(k+2) = ', &
            !               v_u(k), v_env_u,   v0bot(k+1),   v0top(k+1),   v0bot(k+2),   v0top(k+2)
            ! write(6,*)
            ! CHECK
            ! ---------------------------- !
            ! Use UW approach as an option !
            ! ---------------------------- !
            if( iflux_env .eq. 0 ) then
               thl_env_u = thl0bot(k+1)
               qt_env_u  = qt0bot(k+1)
               u_env_u   = u0bot(k+1)
               v_env_u   = v0bot(k+1)
            endif

            ! CHECK
            ! if( get_nstep() .eq. 3 .and. k .eq. 4 ) then
            !     write(6,*)
            !     write(6,*) 'UNICON: Computation of updraft properties at the base of ambiguous layer'
            !     write(6,*) 'Time step & Layer & Segment Index: ', get_nstep(), k, m
            !     write(6,*) 'cmf_u(4), thl_u(4), thl_env_u =', cmf_u(4), thl_u(4), thl_env_u
            !     write(6,*) 'thl0(3), thl0(4), thl0(5), thl0(6) =', thl0(3), thl0(4), thl0(5), thl0(6)
            !     write(6,*) 
            ! endif
            ! CHECK

            slflx_u(k) = cp * exns0(k) * cmf_u(k) * ( thl_u(k) - thl_env_u )
            qtflx_u(k) =                 cmf_u(k) * ( qt_u(k)  -  qt_env_u )
            uflx_u(k)  =                 cmf_u(k) * ( u_u(k)   -   u_env_u )
            vflx_u(k)  =                 cmf_u(k) * ( v_u(k)   -   v_env_u )

            ! Mar.27.2012. Trun-off momentum flux for debugging of energy conservation error
            ! uflx_u(k) = 0._r8
            ! vflx_u(k) = 0._r8

            ! ----------------------------------------------------------- !
            ! Save into array variable for use in breaking CFL later.     !
            ! Below variables are defined in each layer not at interface. !
            ! ----------------------------------------------------------- !
            !a      thl_env_ua(k) = thl_env_u 
            !a      qt_env_ua(k)  = qt_env_u
            !a      u_env_ua(k)   = u_env_u
            !a      v_env_ua(k)   = v_env_u
         end do

         do k = 1, ktop
            km = k - 1
            slten_u(k) = ( g / dp0(k) ) * ( slflx_u(km) - slflx_u(k) ) + cp * exn0(k) * thlten_dia_u(k)
            qtten_u(k) = ( g / dp0(k) ) * ( qtflx_u(km) - qtflx_u(k) ) + qtten_dia_u(k)
            uten_u(k)  = ( g / dp0(k) ) * ( uflx_u(km)  -  uflx_u(k) )
            vten_u(k)  = ( g / dp0(k) ) * ( vflx_u(km)  -  vflx_u(k) )
            sten_u(k)  = slten_u(k) + xlv * qlten_u(k) + xls * qiten_u(k)
            qvten_u(k) = qtten_u(k) - qlten_u(k) - qiten_u(k)
         end do

         ! ------------------------------------------------------------------------ ! 
         ! Tendency due to Convective Downdraft                                     !
         ! Note that the fluxes at surface are set to zero even though cmf_d(0)     !
         ! was explicitly computed above. As a result, the tendency computation is  !
         ! absolutely correct, which is good.                                       ! 
         ! ------------------------------------------------------------------------ ! 

         do k = 1, ktop - 1    ! This is a top interface index or layer index
            um = abs( g * cmf_u(k) * dt )
            dm = abs( g * cmf_d(k) * dt )
            call envcon_flux( k, mkx, um, dm, thl0(1:mkx), ssthl0(1:mkx), ps0(0:mkx), thl_env_u, thl_env_d )
            call envcon_flux( k, mkx, um, dm, qt0(1:mkx), ssqt0(1:mkx), ps0(0:mkx), qt_env_u, qt_env_d )
            call envcon_flux( k, mkx, um, dm, u0(1:mkx), ssu0(1:mkx), ps0(0:mkx), u_env_u, u_env_d )
            call envcon_flux( k, mkx, um, dm, v0(1:mkx), ssv0(1:mkx), ps0(0:mkx), v_env_u, v_env_d )

            ! CHECK
            ! write(6,*)
            ! write(6,*) 'UNICON: Environmental profile value for downdraft flux computation'
            ! write(6,*) 'Layer index : ', k
            ! write(6,*) 'cmf_d(k) at the top interface : ', cmf_d(k)
            ! write(6,*) 'thl_d(k), thl_env_d, thl0top(k), thl0bot(k+1), thl0top(k+1) = ', &
            !             thl_d(k), thl_env_d, thl0top(k), thl0bot(k+1), thl0top(k+1)
            ! write(6,*) ' qt_d(k),  qt_env_d,  qt0top(k),  qt0bot(k+1),  qt0top(k+1) = ', &
            !              qt_d(k),  qt_env_d,  qt0top(k),  qt0bot(k+1),  qt0top(k+1)
            ! write(6,*) '  u_d(k),   u_env_d,   u0top(k),   u0bot(k+1),   u0top(k+1) = ', &
            !               u_d(k),   u_env_d,   u0top(k),   u0bot(k+1),   u0top(k+1)
            ! write(6,*) '  v_d(k),   v_env_d,   v0top(k),   v0bot(k+1),   v0top(k+1) = ', &
            !               v_d(k),   v_env_d,   v0top(k),   v0bot(k+1),   v0top(k+1)
            ! write(6,*)
            ! CHECK

            ! ---------------------------- !
            ! Use UW approach as an option !
            ! ---------------------------- !
            if( iflux_env .eq. 0 ) then
               thl_env_d = thl0top(k)
               qt_env_d  = qt0top(k)
               u_env_d   = u0top(k)
               v_env_d   = v0top(k)
            endif

            ! CHECK
            ! if( get_nstep() .eq. 3 .and. k .eq. 4 ) then
            !     write(6,*)
            !     write(6,*) 'UNICON: Computation of downdraft properties at the base of ambiguous layer'
            !     write(6,*) 'Time step & Layer & Segment Index: ', get_nstep(), k, m
            !     write(6,*) 'cmf_d(4), thl_d(4), thl_env_d =', cmf_d(4), thl_d(4), thl_env_d
            !     write(6,*) 'thl0(3), thl0(4), thl0(5), thl0(6) =', thl0(3), thl0(4), thl0(5), thl0(6)
            !     write(6,*) 
            ! endif
            ! CHECK

            slflx_d(k) = - cp * exns0(k) * cmf_d(k) * ( thl_d(k) - thl_env_d )
            qtflx_d(k) = -                 cmf_d(k) * ( qt_d(k)  -  qt_env_d )
            uflx_d(k)  = -                 cmf_d(k) * ( u_d(k)   -   u_env_d )
            vflx_d(k)  = -                 cmf_d(k) * ( v_d(k)   -   v_env_d )

            ! Mar.27.2012. Trun-off momentum flux for debugging of energy conservation error
            ! uflx_d(k) = 0._r8
            ! vflx_d(k) = 0._r8

            ! ----------------------------------------------------------- !
            ! Save into array variable for use in breaking CFL later.     !
            ! Below variables are defined in each layer not at interface. !
            ! Be careful that we should use 'k+1' not 'k' below.          !
            ! ----------------------------------------------------------- !
            !a      thl_env_da(k+1) = thl_env_d 
            !a      qt_env_da(k+1)  = qt_env_d
            !a      u_env_da(k+1)   = u_env_d
            !a      v_env_da(k+1)   = v_env_d

            ! --------------------------------------------------------------------------- !
            ! Aug.15.2011. Compute downdraft flux associated with convective organization !
            ! --------------------------------------------------------------------------- !
            ! Aug.31.2011. Strictly speaking, 'thl_env_d,qt_env_d' should be recomputed using
            !              cmf_d_org(k) instead of cmf_d(k).  

            !d      slflx_d_org(k) = - cp * exns0(k) * cmf_d_org(k) * ( thl_d_org(k) - thl_env_d )
            !d      qtflx_d_org(k) = -                 cmf_d_org(k) * ( qt_d_org(k)  -  qt_env_d )

         end do
         ! ------------------------------------------------------------------------------------------- !
         ! Mar.19.2014. Compute downdraft flux at the base interface.                                  !
         !              Similar to the treatment of the updraft flux with 'ipartition = 1' option,     !
         !              I should compute the downdraft flux at the surface interface, and partition    !
         !              the downdraft surface flux uniformly over the entire cumulus layer or the      !
         !              PBL depth. I should do this for the 'ql,qi' and 'tracers' too.                 ! 
         !              This treatment of the 'ql,qi,tracer' fluxes are done above before computing    !
         !              corresponding tendencies, using the exactly same method used here below for    !
         !              conservative scalars.                                                          !
         !              Note that at this stage, we have already computed non-zero cmf_d(0), thl_d(0), ! 
         !              qt_d(0), u_d(0), v_d(0), so that below treatment is perfectly correct.         !
         ! ------------------------------------------------------------------------------------------- !
         slflx_d(0) = - cp * exns0(0) * cmf_d(0) * ( thl_d(0) - thl0bot(1) )
         qtflx_d(0) = -                 cmf_d(0) * ( qt_d(0)  -  qt0bot(1) )
         uflx_d(0)  = -                 cmf_d(0) * ( u_d(0)   -   u0bot(1) )
         vflx_d(0)  = -                 cmf_d(0) * ( v_d(0)   -   v0bot(1) )

         ! ----------------------------------------------------------------------------------------------------- !
         ! Aug.30.2011. Compute downdraft flux associated with convective organization at the PBL top interface. !
         !              Also compute buoyancy flux to compute 'convective organization' and 'vertical velocity   !
         !              perturbation at surface associated with convective organization.                         !
         ! Sep.07.2011. I should carefully choose whether I want to impose specific choice of only positive      !
         !              buoyancy flux.                                                                           ! 
         ! Sep.09.2011. New computation is made for imposing a full consistency and a full generality.           !
         !              Now, the case of negative buoyancy flux at the PBL top as well as positive buoyancy flux !
         !              is completely and generally treated.                                                     !
         ! ----------------------------------------------------------------------------------------------------- !
    
         ! Below is new and complete block on Sep.09.2011.  
         ! Sep.09.2011. Below block is re-located into the 'iter' averaging part to collectively 
         !              treat all the wake-related forcings at the same spot. 

         ! cmf_d_org_pblh          =      cmf_d(kpblhm)
         ! thlflx_d_org_pblh       =    slflx_d(kpblhm) / cp / exns0(kpblhm)
         ! qtflx_d_org_pblh        =    qtflx_d(kpblhm)
         ! uflx_d_org_pblh         =     uflx_d(kpblhm)
         ! vflx_d_org_pblh         =     vflx_d(kpblhm)
         ! do mt = 1, ncnst
         !    trflx_d_org_pblh(mt) = trflx_d(kpblhm,mt)
         ! enddo

         ! Below is old block before Sep.09.2011.  
         ! Sep.10.2011. I restored below block for selective choose of convective downdraft.
         ! Sep.08.2011. The condition of 'kpblh .ge. 2' is removed since it is now automatically satisfied.
         ! Dec.17.2012. Critical Modification. Analysis of scam5 ARM97/GATEIII clearly showed that below 
         !              uee of 'thl_env_d' for computing 'thlflx_d_org_pblh' is not good and produces somewhat
         !              noisy results. It is definitely much better to use 'thl0PBL', which is also fully 
         !              consistent with the philosophy of 'bulk' treatment of convective organization within PBL. 
 
         if( cmf_d_org_pblh .gt. nonzero ) then 
            ! Dec.17.2012. Below block is the new treatment on this day.
            thlflx_d_org_pblh = - cmf_d_org_pblh * ( thl_d_org_pblh - thl0PBL )
            qtflx_d_org_pblh  = - cmf_d_org_pblh * ( qt_d_org_pblh  -  qt0PBL )
            uflx_d_org_pblh   = - cmf_d_org_pblh * ( u_d_org_pblh   -   u0PBL )
            vflx_d_org_pblh   = - cmf_d_org_pblh * ( v_d_org_pblh   -   v0PBL )
            ! Aug.30.2011. Modification is required in the below block for cloud liquid and ice droplet number 
            !              following the previous treatment above since we are assuming a certain fixed droplet
            !              radius for convective updraft and downdraft. However, since convective downdraft is
            !              likely not to have any condensate, below is likely to be OK for the time being.
            do mt = 1, ncnst
               trflx_d_org_pblh(mt) = - cmf_d_org_pblh * ( tr_d_org_pblh(mt)  -  tr0PBL(mt) )
            enddo
            ! Dec.17.2012. Below block is the old treatment before this day.  
            ! um = abs( g * cmf_u(kpblhm) * dt )
            ! dm = abs( g * cmf_d_org_pblh * dt )
            ! call envcon_flux( kpblhm, mkx, um, dm, thl0(1:mkx), ssthl0(1:mkx), ps0(0:mkx), thl_env_u, thl_env_d )
            ! call envcon_flux( kpblhm, mkx, um, dm, qt0(1:mkx), ssqt0(1:mkx), ps0(0:mkx), qt_env_u, qt_env_d )
            ! call envcon_flux( kpblhm, mkx, um, dm, u0(1:mkx), ssu0(1:mkx), ps0(0:mkx), u_env_u, u_env_d )
            ! call envcon_flux( kpblhm, mkx, um, dm, v0(1:mkx), ssv0(1:mkx), ps0(0:mkx), v_env_u, v_env_d )
            ! if( iflux_env .eq. 0 ) then
            !     thl_env_d = thl0top(kpblhm)
            !     qt_env_d  = qt0top(kpblhm)
            !     u_env_d   = u0top(kpblhm)
            !     v_env_d   = v0top(kpblhm)
            ! endif
            ! thlflx_d_org_pblh = - cmf_d_org_pblh * ( thl_d_org_pblh - thl_env_d )
            ! qtflx_d_org_pblh  = - cmf_d_org_pblh * ( qt_d_org_pblh  -  qt_env_d )
            ! uflx_d_org_pblh   = - cmf_d_org_pblh * ( u_d_org_pblh   -   u_env_d )
            ! vflx_d_org_pblh   = - cmf_d_org_pblh * ( v_d_org_pblh   -   v_env_d )
            ! Aug.30.2011. Modification is required in the below block for cloud liquid and ice droplet number 
            !              following the previous treatment above since we are assuming a certain fixed droplet
            !              radius for convective updraft and downdraft. However, since convective downdraft is
            !              likely not to have any condensate, below is likely to be OK for the time being.
            ! do mt = 1, ncnst
            !    call envcon_flux( kpblhm, mkx, um, dm, tr0(1:mkx,mt), sstr0(1:mkx,mt), ps0(0:mkx), tr_env_u, tr_env_d )
            !    if( iflux_env .eq. 0 ) then
            !        tr_env_d = tr0top(kpblhm,mt)
            !    endif
            !    trflx_d_org_pblh(mt) = - cmf_d_org_pblh * ( tr_d_org_pblh(mt)  -  tr_env_d )
            ! enddo
            ! Compute buoyancy flux at the PBL top interface by convective downdraft in unit of [ rho * w * thv ] = [ ( kg/m3 ) * ( m/s ) * K ].
            ! Note that similar to the other convective fluxes, density 'rho' is multiplied in the below thvflx_d_org_pblh.
            ! Sep.08.2011. Strictly speaking, I am computing 'thvlflx_d_org_pblh' in the below block. However, this approximation is
            !              OK since both the mean environment and downdraft area most likely to be unsaturated within PBL. 
            ! Sep.10.2011. I don't need below block since I don't prognose 'thv' anymore.
            ! tmp1 =         zvir * 0.5_r8 * ( thl0(kpblhm) + thl0(kpblh) )
            ! tmp2 = 1._r8 + zvir * 0.5_r8 * ( qt0(kpblhm)  +  qt0(kpblh) ) 
            ! thvflx_d_org_pblh = tmp1 * qtflx_d_org_pblh + tmp2 * thlflx_d_org_pblh
            ! In order to guarantee positive organization or positive buoyancy temperature difference between off-wake region and mean environment,
            ! only consider when thvflx_d_org_pblh >= 0. If it is negative, neglect all org-related flux component.
            ! However, below condition might be unnecessary - simply clipping negative omega to zero is enough and conceptually reasonable.
            ! I remove below block - if buoyancy flux at the PBL top is negative, it is likely that that downdraft cannot reach to the
            ! surface, so that its contribution will be zero. However, if I think block is necessary, I can restore below block again.
            ! Aug.31.2011. I restored below block in order to ensure that all 'thl(qt,u,v,tr)flx_d_org_pblh' and corresponding excess in
            !              the wake area is zero when cuorg is zero. Imposing this consistency is conceptually much better and does not
            !              interrupt the BOMEX simulation, for example.
            ! Sep.06.2011. In making a decision whether I will choose the specific forcing or not, it is definitely good to consider with
            !              a sum of total forcings ( adiabatic forcing at the PBL top, diabatic forcing within convective downdraft, and
            !              diabatic forcing within environment ) since that total forcing is used for prognostic equation. This decision
            !              will be made later. Thus, I am removing below constraint if block.
            ! Sep.08.2011. While additional constraint will be imposed on the total forcing, it seems to be good to impose this constraint
            !              here too. By doing this, we can have a freedon to control only 'adiabatic forcing', separate from the control of
            !              total forcing ( adiabatic + diabatic within downdraft + diabatic within environment ) later.
            !              Note that I also re-set cmf_d_org_pblh = 0, which is imporant to correctly compute 'taui' and 'orgforce' for 
            !              awk_PBL later. 
            ! Sep.10.2011. I don't need below 'if' constraints since UNICON can also handle negative buoyancy flux case using the 
            !              inhomogeneous adjustment procedure at the beginning of next time step.
            ! if( thvflx_d_org_pblh .lt. 0._r8 ) then
            !     cmf_d_org_pblh            = 0._r8
            !     thlflx_d_org_pblh         = 0._r8
            !     qtflx_d_org_pblh          = 0._r8
            !     uflx_d_org_pblh           = 0._r8
            !     vflx_d_org_pblh           = 0._r8
            !     thvflx_d_org_pblh         = 0._r8
            !     trflx_d_org_pblh(1:ncnst) = 0._r8
            ! endif
         else
            cmf_d_org_pblh            = 0._r8
            thlflx_d_org_pblh         = 0._r8
            qtflx_d_org_pblh          = 0._r8
            uflx_d_org_pblh           = 0._r8
            vflx_d_org_pblh           = 0._r8
            ! thvflx_d_org_pblh         = 0._r8
            trflx_d_org_pblh(1:ncnst) = 0._r8
         endif

         ! -------------------------------------------------------------------------------------------------------------------------- !
         ! May.1.2014.                                                                                                                !
         ! For the treatment of budget consistent coldpool (i_budget_coldpool = 1,2), add the computation of 'qtflx_d_orgU_pblh' from !
         ! the downdrafts that exclusively sinks down into '1-awk_PBL' instead of 'awk_PBL' as the above, and also 'qtflx_u_org_pblh' !
         ! that is the flux by convective updraft defalted from the PBL. Note that 'qtflx_u_org_pblh' is slightly different from the  !
         ! already computed 'qtflx_u(kpblhm)' in that sense that 'qtflx_u_org_pblh' is using 'qt0PBL'. Since we are considering the   !
         ! budget of 'bulk' budget for coldpool treatment, we should use 'qtflx_u_org_pblh' instead of 'qtflx_u(kpblhm)' for the      !
         ! fully internally-self consistent treatment of cold pool.                                                                   !
         ! -------------------------------------------------------------------------------------------------------------------------- !

         if( cmf_d_orgU_pblh .gt. nonzero ) then 
             thlflx_d_orgU_pblh = - cmf_d_orgU_pblh * ( thl_d_orgU_pblh - thl0PBL )
             qtflx_d_orgU_pblh  = - cmf_d_orgU_pblh * ( qt_d_orgU_pblh  -  qt0PBL )
             uflx_d_orgU_pblh   = - cmf_d_orgU_pblh * ( u_d_orgU_pblh   -   u0PBL )
             vflx_d_orgU_pblh   = - cmf_d_orgU_pblh * ( v_d_orgU_pblh   -   v0PBL )
           ! Aug.30.2011. Modification is required in the below block for cloud liquid and ice droplet number 
           !              following the previous treatment above since we are assuming a certain fixed droplet
           !              radius for convective updraft and downdraft. However, since convective downdraft is
           !              likely not to have any condensate, below is likely to be OK for the time being.
             do mt = 1, ncnst
                trflx_d_orgU_pblh(mt) = - cmf_d_orgU_pblh * ( tr_d_orgU_pblh(mt)  -  tr0PBL(mt) )
             enddo
         else
             cmf_d_orgU_pblh            = 0._r8
             thlflx_d_orgU_pblh         = 0._r8
             qtflx_d_orgU_pblh          = 0._r8
             uflx_d_orgU_pblh           = 0._r8
             vflx_d_orgU_pblh           = 0._r8
           ! thvflx_d_orgU_pblh         = 0._r8
             trflx_d_orgU_pblh(1:ncnst) = 0._r8
         endif

         cmf_u_org_pblh = cmf_u(kpblhm)
    !lim if( cmf_u_org_pblh .gt. nonzero ) then 
             thlflx_u_org_pblh          = cmf_u_org_pblh * ( thl_u(kpblhm) - thl0PBL )
             qtflx_u_org_pblh           = cmf_u_org_pblh * ( qt_u(kpblhm)  -  qt0PBL )
             uflx_u_org_pblh            = cmf_u_org_pblh * ( u_u(kpblhm)   -   u0PBL )
             vflx_u_org_pblh            = cmf_u_org_pblh * ( v_u(kpblhm)   -   v0PBL )
             do mt = 1, ncnst
                trflx_u_org_pblh(mt)    = cmf_u_org_pblh * ( tr_u(kpblhm,mt)  -  tr0PBL(mt) )
             enddo
    !lim else
    !lim     cmf_u_org_pblh             = 0._r8
    !lim     thlflx_u_org_pblh          = 0._r8
    !lim     qtflx_u_org_pblh           = 0._r8
    !lim     uflx_u_org_pblh            = 0._r8
    !lim     vflx_u_org_pblh            = 0._r8
    !lim     trflx_u_org_pblh(1:ncnst)  = 0._r8
    !lim endif

         ! -------------------------------------------------- !
         ! Compute grid-mean tendency by convective downdraft !
         ! -------------------------------------------------- !

         do k = 1, ktop
            km = k - 1
            slten_d(k) = ( g / dp0(k) ) * ( slflx_d(km) - slflx_d(k) ) + cp * exn0(k) * thlten_dia_d(k)
            qtten_d(k) = ( g / dp0(k) ) * ( qtflx_d(km) - qtflx_d(k) ) + qtten_dia_d(k)
            uten_d(k)  = ( g / dp0(k) ) * (  uflx_d(km) -  uflx_d(k) )
            vten_d(k)  = ( g / dp0(k) ) * (  vflx_d(km) -  vflx_d(k) )
            sten_d(k)  = slten_d(k) + xlv * qlten_d(k) + xls * qiten_d(k)
            qvten_d(k) = qtten_d(k) - qlten_d(k) - qiten_d(k)
         end do

         ! CHECK
         !  if( get_nstep() .eq. 616 ) then
         !      write(6,*)
         !      write(6,*) 'SUNGSU: Mean profile, updraft, downdraft, and detrained air check at 616'
         !      do k = 1, ktop
         !         km = k - 1
         !         write(6,*) 'k, qt0(k), qt_u(km), qt_u(k), qt_d(km), qt_d(k)  = ', k, qt0(k), qt_u(km), qt_u(k), qt_d(km), qt_d(k) 
         !         write(6,*) 'k, qt_r(k), cmf_r(k), qt_ru(k), cmf_ru(k), qt_rd(k), cmf_rd(k) = ', k, qt_r(k), cmf_r(k), qt_ru(k), cmf_ru(k), qt_rd(k), cmf_rd(k)
         !         write(6,*)
         !      enddo
         !  endif 
         ! CHECK

         ! -------------------------------------------------------------------------- !
         ! Tendencies due to Snow Melting and Evaporation of Convective Precipitation ! 
         ! within the Environment.                                                    ! 
         ! We should treat this process for each 'msfc' segment independently since   !
         ! we are assuming individual 'msfc' updraft segments are geographically      !
         ! separated.                                                                 !
         ! -------------------------------------------------------------------------- !

         !? Below entire block is not necessary any more since it is computed above in the new code.

         !?   do msfc = 1, nseg

         !?      evpint_rain = 0._r8 
         !?      evpint_snow = 0._r8
         !?    ! Nov.29.2012. Add tracer block. 
         !?      do mt = 1, ncnst
         !?         evpint_trrs(mt) = 0._r8
         !?      enddo

         !?   do k = ktop_msfc(msfc), 1, -1  ! 'k' is a layer index : 'mkx'('1') is the top ('bottom') layer
          
         !?      km = k - 1

         !?      ! -------------------------------------------------------------------------- !
         !?      ! We should only consider evaporation of precipitation within environment    !
         !?      ! since evaporation of precipitation within each convective updraft and      !
         !?      ! downdraft has already been treated.                                        !
         !?      ! Also, we should only consider 'convective precipitation', not 'stratiform  !
         !?      ! precipitation'.                                                            !
         !?      ! -------------------------------------------------------------------------- !
         
         !?      ! -------------------------------------------------------------------------- !
         !?      ! Compute minimum precipitation flux from the top interface of current layer ! 
         !?      ! to surface.                                                                ! 
         !?      ! -------------------------------------------------------------------------- !

         !?      ! Apr.26.2011. With an improved treatment of evaporation of precipitation within environment with
         !?      !              corrective production tendencies, I don't need 'flxrain_min' and 'flxsnow_min' anymore.
         !?      !              Thus, I commented out below block which will save computation time.

         !?    ! flxrain_min = 1.e8_r8
         !?    ! flxsnow_min = 1.e8_r8
         !?    ! do kk = 0, k
         !?    !    flxrain_min = min( flxrain_min, unity * flxrain_ava_msfc(kk,msfc) )
         !?    !    flxsnow_min = min( flxsnow_min, unity * flxsnow_ava_msfc(kk,msfc) )
         !?    ! end do
         !?    ! if( flxrain_min .lt. 0._r8 .or. flxsnow_min .lt. 0._r8 ) then
         !?    !     write(6,*)  flxrain_min, flxsnow_min, k, msfc
         !?    !     call endrun('UNICON : Negative flxrain_min and flxsnow_min in treating evaporation of precip within environment')
         !?    ! endif 

         !?      ! -------------------------------------------------------------------------- !
         !?      ! We only treat minimum tilting ( beta1 = 0 ) following observation.         !
         !?      ! For the purpose of treating evaporation of convective precipitation within !   
         !?      ! environment, we simply assume downdraft fractional area is zero.           !
         !?      ! Mar.28.2011. I restored the functionality of 'beta1'. Perfectly correct if !
         !?      ! beta1 = 0, but if beta1 > 0, caution is ecessary since we are treating     !
         !?      ! individual plume separately.                                               !
         !?      ! In case of maximum tilting ( beta1 = 1 ), overlapping area                 !
         !?      ! between 'a_p' and 'am_u' becomes minimum.                                  !
         !?      ! The opposite is true for minimum tilting ( beta1 = 0 ).                    !
         !?      ! Apr.05.2012. Below original formula of 'a_pu' does not allow evaporation   !
         !?      !     within unsaturated updraft. If beta1 = 0 (non-tilting or maximum       !
         !?      !     overlap) on perfectly straight cumulus , this will not do any          !
         !?      !     evaporation within environment, so causing problem including no        !
         !?      !     effect at all in generating organization. In order to correct this     !
         !?	!     problem, I use 'am_us_msfc(k,msfc)' in computing 'a_pu', which is      !
         !?      !     equivalent to shrinking 'am_u' to zero if updraft is unsaturated       !
         !?      !     ONLY for the purpose of computing evaporation of precipitation within  !
         !?      !     environment. This single modification is perfectly consistent with     !
         !?	!     all the other parts of the code (i.e., computations of qv_clr,         !
         !?      !     precipitation area) in a fully conceptually clear way. I checked this  !
         !?      !     clearness and correctness many times. By doing this, we can let        !
         !?      !     the evaporation of convective precipitation heppen within PBL below    !
         !?      !     cumulus base, which contributes to the generation of negative buoyancy !
         !?	!     within wake area (a_D), so that more effective organized TKE can be    !
         !?      !     generated within especially over land areas where qv_clr is small      !
         !?      !     so that evaporation is more active within PBL than over the land.      !
         !?      !     This is really good feature.                                           !
         !?      !     With all of these, the best choice both conceptually and physically    !
         !?      !     (even though any choice can be made in a fully consistent way without  !
         !?      !     any contradiation and inconsistency in the code) is to use             !
         !?      !     (1) beta1 = 0 (minimum tilting of cumulus updraft plume) and           !
         !?      !     (2) beta2 = 1 (all evaporation occurs in the wake area whenever enough !
         !?      !                    wake area exists within PBL).                           !
         !?      !     These two above choices are the best ones recommended.                 !
         !?      ! -------------------------------------------------------------------------- !
         !?      if( i_ovp .eq. 0 ) then 
         !?        ! Apr.05.2012. Below is old code before Apr.05.2012 that uses 'am_u_msfc(k,msfc)' which does not
         !?        !              allows evaporation of precipitation within unsaturated updraft.
         !?        ! a_pu  = ( 1._r8  - beta1 ) * min( a_p_msfc(k,msfc),  am_u_msfc(k,msfc) ) + &
         !?        !                    beta1   * max( a_p_msfc(k,msfc) + am_u_msfc(k,msfc) - 1._r8, 0._r8 )
         !?        ! Apr.05.2012. Below is new code after Apr.05.2012 that uses 'am_us_msfc(k,msfc)' which allows
         !?        !              evaporation if updraft is unsaturated.
         !?          a_pu  = ( 1._r8  - beta1 ) * min( a_p_msfc(k,msfc),  am_us_msfc(k,msfc) ) + &
         !?                             beta1   * max( a_p_msfc(k,msfc) + am_us_msfc(k,msfc) - 1._r8, 0._r8 )
         !?      elseif( i_ovp .eq. 1 ) then 
         !?        ! Apr.25.2012.
         !?        ! Compute overlapping area between precipitation area at the top interace and 
         !?        ! saturated updraft fractional area at the layer mid-point.
         !?        ! Note that I am simply using previous computed 'x_p_msfc(k,msfc), y_p_msfc(k,msfc)' which
         !?        ! was computed assuming exponential decay of precipitation flux with model depth. 
         !?        ! This is inevitable but best and very nice approximation.
         !?        ! Note that 'num_u_msfc(km,msfc)' is height-independent constant from the surface to the cumulus top.
         !?          a_pu = area_overlap( x_p_msfc(k,msfc),  y_p_msfc(k,msfc),  a_p_msfc(k,msfc),   & 
         !?                               x_um_msfc(k,msfc), y_um_msfc(k,msfc), am_us_msfc(k,msfc), &
         !?                               num_u_msfc(0,msfc) )
         !?      endif
         !?    ! Apr.05.2012. Ideally, we can also use 'am_ds_msfc(k,msfc)' in the below as the above.
         !?    !              However, since downdraft fractional area is assumed to be zero for the purpose
         !?    !              of evaporation, this does not matter at all.
         !?      a_pd  = ( 1._r8  - beta1 ) * min( a_p_msfc(k,msfc) - a_pu,  am_d_msfc(k,msfc) ) + &
         !?                         beta1   * max( a_p_msfc(k,msfc) - a_pu + am_d_msfc(k,msfc) - 1._r8, 0._r8 )
         !?    ! a_pu  = min( a_p_msfc(k,msfc)        , am_u_msfc(k,msfc) )
         !?    ! a_pd  = min( a_p_msfc(k,msfc) - a_pu , am_d_msfc(k,msfc) )
         !?      if( ifinad_evpenv .eq. 0 ) a_pd  = 0._r8 
         ! ---------------------------------------------------------------------------------- !
         ! Below two lines are more advanced correct treatment                                !
         ! explicitly considering finite downdraft fractional area.                           !
         ! Below line should be used in combination of (1) ad_max = 0.1 (or so, not 1.e8) and !
         ! (2) computation of 'am_s' above, & (3) computation of 'eta1_a' and 'eta2_a' below. !
         ! Below 'Origin' OPTION is quivalent to assuming that downdraft fractional area is   !
         ! zero ( but still non-overlapped with updraft and environmental area ). Thus, the   !
         ! original assumption is also conceptually acceptable even though we compute finite  !
         ! downdraft fractional area for diagnostic purpose. The 'Advanced' option used the   !
         ! downdraft fractional area for dynamic computation of downdraft process explicitly, !
         ! which is also good. However, unless cloud macrophysics explicitly treat downdraft  !
         ! fractional area in a consistent way, there is still confliction. Thus, let's use   !
         ! the original option for the time being.                                            !   
         ! ---------------------------------------------------------------------------------- !
         !?    ! OPTION
         !?    ! a_pr  = ( a_p_msfc(k,msfc) - a_pu ) * am_r(k) / ( am_r(k) + am_s(k) )           ! Origin.
         !?    ! a_ps  = ( a_p_msfc(k,msfc) - a_pu ) * am_s(k) / ( am_r(k) + am_s(k) )           ! Origin.
         !?      a_pr  = ( a_p_msfc(k,msfc) - a_pu - a_pd ) * am_r(k) / ( am_r(k) + am_s(k) )    ! Advanced.
         !?      a_ps  = ( a_p_msfc(k,msfc) - a_pu - a_pd ) * am_s(k) / ( am_r(k) + am_s(k) )    ! Advanced.

         ! ------------------------------------------------------------------- !
         ! Compute area ( a_evp ) in which evaporation of precipitation occurs !
         ! other than the downdraft area.                                      ! 
         ! Note that evaporation within downdraft has already been treated.    !
         ! Below treatment allows evaporation of precipitation within updraft  !
         ! when updraft is unsaturated. However, since this is post-process of !
         ! after updraft dynamics, this evaporation of precipitation within    !
         ! updraft does not change updraft dynamics. I think this is perfectly !
         ! acceptable and reasonable.                                          !
         ! ------------------------------------------------------------------- !
         !?      a_evp = a_pr
         !?    ! By commenting out below line, evaporation of precipitation within convective
         !?    ! updraft is always neglected regardless whether updraft is saturated or not.
         !?    ! if( ( qlm_u_msfc(k,msfc) + qim_u_msfc(k,msfc) ) .le. 0._r8 ) a_evp = a_evp + a_pu 

         ! ------------------------------------------------------------------------------ !
         ! Compute 'eta1_a(k)' and 'eta2_a(k)' for use at the next iteration of iter = 2. ! 
         ! ------------------------------------------------------------------------------ !
         ! I should comment below below block since it is unnecessary in the umltiple-plume treatment.
         ! eta1_a(k) = max( 0._r8, min( 1._r8, a_pd / max( am_d(k), nonzero ) ) )
         ! eta2_a(k) = max( 0._r8, min( 1._r8, a_pd / max(  a_p(k), nonzero ) ) )
         ! if( ifinad_evpenv .eq. 0 ) eta1_a(k) = 1._r8

         ! CHECK
         ! write(6,*)
         ! write(6,*) 'UNICON: Check eta1 and eta2' 
         ! write(6,*) 'Cumulus Top Layer and Layer Index = ', ktop, k
         ! write(6,*) 'eta1_a(k), eta2_a(k), am_d(k), a_p(k), a_pd = ', eta1_a(k), eta2_a(k), am_d(k), a_p(k), a_pd
         ! write(6,*)
         ! CHECK

         ! CHECK
         ! write(6,*)
         ! write(6,*) 'UNICON: Precipitation area at the top interface and Various overlapping areas'
         ! write(6,*) 'Cumulus Top Layer and Layer Index = ', ktop, k
         ! write(6,*) 'a_p, a_pu, a_pr, a_ps, a_evp  = ', a_p(k), a_pu, a_pr, a_ps, a_evp
         ! write(6,*) 'am_up, am_u, am_r, am_s  = ', am_up(k), am_u(k), am_r(k), am_s(k)
         ! write(6,*)
         ! CHECK

         ! Oct.12.2010. Below is original block. Since 'snowmlt_e(k)' was already treated before
         !              evaporation within downdraft, I commented out below block and set
         !              snowmlt_msfc(k,msfc) = 0 here.
         ! Apr.26.2011. Add option to treat snow melting (1) before evaporation within downdraft ( default )
         !              or (2) after evaporation within downdraft. Note also that the previous code
         !              used 'flxsnow_msfc(k,msfc)' while the new code is using 'flxsnow_min' for full
         !              consistency.
         !              Note that the shortage of 'i_snowmlt .eq. 0' does not allow evaporation of snow within downdraft,
         !              while 'i_snowmlt .eq. 1' can generate non-zero snow flux at surface even though temperature is
         !              large. Thus, the first default option seems to be more attractable, but I am keeping both 
         !              functionality available as an option. 
         
         !?      if( t0(k) .ge. 273.15_r8 ) then
         !?          if( i_snowmlt .eq. 0 ) then
         !?              snowmlt_msfc(k,msfc) = 0._r8
         !?          else
         !?              snowmlt_msfc(k,msfc) = max( 0._r8, flxsnow_min * g / dp0(k) ) 
         !?          endif
         !?      else
         !?          snowmlt_msfc(k,msfc) = 0._r8
         !?      endif

         ! Below is previous code.
         ! if( t0(k) .gt. 273.16_r8 ) then
         !     snowmlt_msfc(k,msfc) = max( 0._r8, flxsnow_msfc(k,msfc) * g / dp0(k) ) 
         ! else
         !     snowmlt_msfc(k,msfc) = 0._r8
         ! endif
         ! snowmlt_msfc(k,msfc) = max( 0._r8, min( snowmlt_msfc(k,msfc), snowmlt_msfc(k,msfc) + qsten_msfc(k,msfc) ) )

         !?      flxrain_all    = flxrain_msfc(k,msfc) + snowmlt_msfc(k,msfc) * ( dp0(k) / g )
         !?      flxsnow_all    = flxsnow_msfc(k,msfc) - snowmlt_msfc(k,msfc) * ( dp0(k) / g )
         !?      flx_all        = flxrain_all + flxsnow_all

         !?      flxrain_all_in = flxrain_all / max( nonzero, a_p_msfc(k,msfc) )
         !?      flxsnow_all_in = flxsnow_all / max( nonzero, a_p_msfc(k,msfc) )
         !?      flx_all_in     = flxrain_all_in + flxsnow_all_in

         ! Nov.29.2012. Add corresponding tracer part.
         ! Dec.01.2012. Due to snow melting above, I should do separate treatment for precipitating
         !              droplet numbers.
         !?      do mt = 1, ncnst
         !?         if( mt .eq. ixcldliq ) then
         !?             flxtrrs_all(mt) = flxrain_all
         !?         elseif( mt .eq. ixcldice ) then
         !?             flxtrrs_all(mt) = flxsnow_all
         !?         elseif( mt .eq. ixnumliq ) then
         !?             flxtrrs_all(mt) = flxrain_all * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_rain**3 * density_rain )               
         !?         elseif( mt .eq. ixnumice ) then
         !?             flxtrrs_all(mt) = flxsnow_all * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_snow**3 * density_snow )  
         !?         else
         !?             flxtrrs_all(mt) = flxtrrs_msfc(k,msfc,mt)
         !?         endif
         !?         flxtrrs_all_in(mt) = flxtrrs_all(mt) / max( nonzero, a_p_msfc(k,msfc) )
         !?      enddo  

         ! --------------------------------------------------------------------------------- !
         ! Assume (1) input qv0(k) does not contain cumulus portion,                         ! 
         ! and (2) RH within stratus is 1.                                                   !
         ! Because of the uncertainty in am_s(k) which includes both liquid and ice stratus, ! 
         ! below computation of 'qv_clr' is not precise but just approximation.              !
         ! So, I am imposing an upper limit of qv0(k) on qv_clr to prevent model crash.      !
         ! This 'qv_clr' was one of the main reasons of model crash before.                  ! 
         ! Apr.5.2012. In principle, 'am_s(k)' used below in computing 'qv_clr' should not   !
         !             physical stratus fraction but non-physical stratus fraction since     !
         !             qv0(k) is defined using non-cumulus portion. Thus, if 'acu0' is input !
         !             cumulus fraction, instead of using 'am_s(k)', we should use           !
         !            'ast0(k)/(1-acu0(k))' ONLY for computing qv_clr in the below line.     !
         !             Note that I should use 'ast0(k)/(1-acu0(k))' not 'am_s(k)/(1-acu0(k))'!
         !             since am_s(k) is modified from ast0(k) considering cumulus fraction   !
         !             computed at the current time step. This should be modified later.     !
         ! --------------------------------------------------------------------------------- !
         !?      call qsat( t0(k), p0(k), es, qs )
         !?      qv_clr       = max( nonzero, qv0(k) - am_s(k) * qs ) / max( nonzero, 1._r8 - am_s(k) )
         !?      qv_clr       = min( min( qv_clr, qv0(k) ), qs )   
         !?      subsat_clr   = min( 1._r8, max( 0._r8, 1._r8 - qv_clr / max( qs, nonzero ) ) )
         ! ----------------------------------------------------------------------- !
         ! Evaporation rate within the overlapping area between precipitation area ! 
         ! at the top interface and clear area at the layer mid-point.             !
         ! ----------------------------------------------------------------------- !
         ! Apr.27.2011. Separate speficiation of 'kevp_rain,kevp_snow' are made similar to
         !              the evaporation within downdraft.
         !?      evprain_clr  = kevp_rain * subsat_clr * sqrt( max( 0._r8, flxrain_all_in ) )
         !?      evpsnow_clr  = kevp_snow * subsat_clr * sqrt( max( 0._r8, flxsnow_all_in ) )
         ! ---------------------------------------------------- !
         ! Limit 1 : Evaporation cannot induce super-saturation ! 
         ! ---------------------------------------------------- !
         
         ! CHECK
         ! if( get_nstep() .eq. 1 .and. lchnk .eq. 105 .and. i .eq. 8 .and. k .eq. 8 ) then
         !     write(6,*)
         !     write(6,*) 'UNICON: Input to findsp_single 2'
         !     write(6,*) 'Time step & Column & Layer & Chunk Index: ', get_nstep(), i, k, lchnk
         !     write(6,*) 'qv_clr, t, p_b = ', qv_clr, t0(k), p0(k)
         !     write(6,*) 'qv0(k), am_s(k), qs = ', qv0(k), am_s(k), qs
         !     write(6,*)
         ! endif
         ! CHECK

         !?      call findsp_single( qv_clr, t0(k), p0(k), tw, qw_clr, i, k, lchnk )
         !?      evplimit_clr = max( 0._r8, ( qw_clr - qv_clr ) / dt )
         ! ------------------------------------------------------------------------------------------- !
         ! Limit 2 : ( a ) Evaporation cannot consumes more than available precipitation flux coming   !
         !                 down into the layer                                                         ! 
         !           ( b ) Evaporation should not generate negative precipitation flux at the          !
         !                 interfaces below the current layer.                                         !
         !                 It is possible that 'evplimit_clr_rain, evplimit_clr_rain < 0' after        !
         !                 constraints of the below two lines. This is totally reasonable.             !
         !                 In this case, 'evprain_clr, evpsnow_clr' actually generates adjustive       !
         !                 precipitating condensate instead of evaporating precipitating condensate in ! 
         !                 order to ensure positive flxrain(km) and flxsnow(km) at the base interface. !
         ! Oct.12.2010. Below original limiter caused model crash associated with the onset of         !  
         !             'Impossible correction of precipitation generation'. Thus, following the        !
         !              treatment of evaporation within downdraft, I use 'flxrain_min' & 'flxsnow_min' !
         !              for the limiter below. However, for computation of 'evprain_clr, evpsnow_clr'  !
         !              I correctly used 'flxrain_all_in, flxsnow_all_in'. This treatment is the       !
         !              most ideal and correct and fully identical to the treatment of the evaporation !
         !              within downdraft. With this, it is always guaranteed evprain(snow)_clr >=0     !
         !              and negative precipitation flux never happens at all interfaces below.         !
         !              Note that in order to allow evaporation within environment as well as within   !
         !              downdraft, it is good to use eta2 < 1, not 1. While 'eta2' can be computed     !
         !              from the detailed consideration of cloud-overlap, let's use eta2 = 0.5 or small!   
         !              value. I should carefully consider the effects of snow melting.                !
         ! ------------------------------------------------------------------------------------------- !
         !?      ! Apr.26.2011. Below block computing 'flxrain_min, flxsnow_min' has been moved upward 
         !?      !              in order to use in computing 'snowmlt_msfc(k,msfc)'. 
         !?    ! flxrain_min = 1.e8_r8
         !?    ! flxsnow_min = 1.e8_r8
         !?    ! do kk = 0, k
         !?    !    flxrain_min = min( flxrain_min, unity * flxrain_ava_msfc(kk,msfc) )
         !?    !    flxsnow_min = min( flxsnow_min, unity * flxsnow_ava_msfc(kk,msfc) )
         !?    ! end do
         !?    ! if( flxrain_min .lt. 0._r8 .or. flxsnow_min .lt. 0._r8 ) then
         !?    !     write(6,*)  flxrain_min, flxsnow_min, k, msfc
         !?    !     call endrun('UNICON : Negative flxrain_min and flxsnow_min in treating evaporation of precip within environment')
         !?    ! endif 
         !?    ! Apr.26.2011. In the below 2 lines, I replaced 'flxrain_min --> flxrain_all' and 'flxsnow_min --> flxsnow_all'
         !?    !              with an improved treatment of evaporation of precipitation within environment with
         !?    !              corrective production tendencies. Then, I don't need 'flxrain_min' and 'flxsnow_min' anymore.
         !?    ! Apr.27.2011. I changed 'flxrain_all / max( nonzero, a_p_msfc(k,msfc) )' to 'flxrain_all_in', which are identical.
         !?    !              Same as for snow.  This will save computation time.
         !?    ! Jul.10.2011. Similar to the treatment of evaporation within convective downdraft, constraint associated with 'evplimit_clr'
         !?    !              are made in the below 'Limit 1a' block separately. Thus, I modified below two lines
         !?    !              without the constraint of 'evplimit_clr', in consistent with the treatment of evaporation within
         !?    !              convective downdraft.
         !?    ! Below two lines are original before Jul.10.2011.
         !?    ! evplimit_clr_rain = min( evplimit_clr, flxrain_all_in * g / dp0(k) ) ! New. Perfect.
         !?    ! evplimit_clr_snow = min( evplimit_clr, flxsnow_all_in * g / dp0(k) ) ! New. Perfect.
         !?    ! Below two lines are new after Jul.10.2011. 
         !?      evplimit_clr_rain = flxrain_all_in * g / dp0(k) ! New. Perfect.
         !?      evplimit_clr_snow = flxsnow_all_in * g / dp0(k) ! New. Perfect.
         !?    ! evplimit_clr_rain = min( evplimit_clr, flxrain_min / max( nonzero, a_p_msfc(k,msfc) ) * g / dp0(k) ) ! New. Perfect.
         !?    ! evplimit_clr_snow = min( evplimit_clr, flxsnow_min / max( nonzero, a_p_msfc(k,msfc) ) * g / dp0(k) ) ! New. Perfect.
         !?    ! evplimit_clr_rain = min( evplimit_clr, flxrain_all_in * g / dp0(k) + min( 0._r8, qrten(k) / max( nonzero, a_evp ) ) ) ! Previous. Imperfect.
         !?    ! evplimit_clr_snow = min( evplimit_clr, flxsnow_all_in * g / dp0(k) + min( 0._r8, qsten(k) / max( nonzero, a_evp ) ) ) ! Previous. Imperfect.
         !?      evprain_clr       = min(  evprain_clr, evplimit_clr_rain )
         !?      evpsnow_clr       = min(  evpsnow_clr, evplimit_clr_snow )
         !?      if( ( evprain_clr + evpsnow_clr ) .lt. ( - qv0(k) / dt / max( nonzero, a_evp ) ) ) then
         !?            call endrun('UNICON : Impossible correction of precipitation generation')  
         !?      endif
         ! ------------------------------------------------------- !
         ! Limit 1a : Supplement of Limit 1 for each rain and snow !
         ! ------------------------------------------------------- !
         !?      if( ( evprain_clr + evpsnow_clr ) .gt. evplimit_clr ) then
         !?          if( evprain_clr .ge. 0._r8 .and. evpsnow_clr .ge. 0._r8 ) then
         !?              tmp1 = evprain_clr * evplimit_clr / ( evprain_clr + evpsnow_clr )
         !?              tmp2 = evpsnow_clr * evplimit_clr / ( evprain_clr + evpsnow_clr )
         !?              evprain_clr = tmp1
         !?              evpsnow_clr = tmp2
         !?          elseif( evprain_clr .lt. 0._r8 ) then
         !?              evpsnow_clr = evplimit_clr - evprain_clr
         !?          elseif( evpsnow_clr .lt. 0._r8 ) then
         !?              evprain_clr = evplimit_clr - evpsnow_clr
         !?          else
         !?              call endrun('UNICON : Impossible case in Limit 1a')  
         !?          endif
         !?      endif
         ! ------------------------------------------------------------------------------------- !
         ! Final Grid-Mean Evaporation Tendency                                                  !
         ! Nov.29.2012. Add corresponding tracer part. Here, we use proportional relationship    !
         !              using the fluxes of 'precipitation' and 'tracers' at the top interface.  !
         !              This seems to be correct and most reasonable approach.                   !
         !              If flx_all --> 0, then evprain_msfc(k,msfc) + evpsnow_msfc(k,msfc) --> 0,!
         !              so that unreasonable large-value is automatically prohibited, which is   !
         !              very good.                                                               !
         !              The same approach is used for the evaporation within downdraft.          !
         ! Dec.01.2012. Do separate treatment for precipitating droplet numbers.                 ! 
         ! ------------------------------------------------------------------------------------- !
         ! ------------------------------------------------------------------------------------------------------------------------------------- !
         ! Nov.03.2012. REFINEMENT IS NECESSARY FOR AEROSOL WET DEPOSITION WITHIN NON-CUMULUS PRECIPITATING AREA.                                !
         ! Wet deposition of aerosols within convectie updraft/downdraft ( (1) in-cumulus-droplet autoconversion, (2) in-cumulus-drop accretion, ! 
         ! (3) interestitial aerosols within convective updraft/downdraft ) and its impact on the convective updraft/downdraft and               ! 
         ! on the grid-mean tendency has already been completely treated. Here, we should only treat the wet scavenging of aerosols              !
         ! by convective precipitation within NON-UPDRFT area (note that downdraft area is assumed to be zero).                                  !
         ! Among the above 3 wet scavenging terms ((1),(2),(3)), we only need to worry about the interstitial aerosols ((3)), since              !
         ! accretion of stratiform droplet by convective precipitation is simply neglected.                                                      !
         ! We should use below 3 quantities :                                                                                                    !
         !        (1) flxrain_all_in   : rain flux at the top interface averaged within the precipitation area,                                  !
         !        (2) flxsnow_all_in   : snow flux at the top interface averaged within the precipitation area,                                  !
         !        (3) a_p_msfc(k,msfc) : precipitation are at the top interface,                                                                 !
         !        (4) a_pr             : overlapping area between 'a_p_msfc' and 'clear' portion at the layer mid-point.                         ! 
         !        (5) a_ps             : overlapping area between 'a_p_msfc' and 'stratus' portion at the layer mid-point.                       ! 
         !        (6) tr0(k,mt)      : grid-mean interstitial tracer concentration                                                               !
         ! and note that 'a_pr + a_ps + a_pu = a_p_msfc'.                                                                                        !
         ! After computing wet scavenging of aerosols within 'a_pr + a_ps' area by using 'flxrain_all_in and flxsnow_all_in', and                ! 
         ! by assuming that interstitial aerosol concentration is homogeneous within this area given by 'tr0', we can compute                    !
         ! the final grid-mean wet scavenging tendency of aerosols by multiplying 'a_pr + a_ps'.                                                 !
         ! Note that in the current code, 'a_pu' uses 'saturated updraft area' not 'updraft' area. However, for the wet                          !
         ! scavenging of aerosols within non-cumulus area, 'a_pu' should be redefined using 'updraft' area not 'saturated updraft area',         !
         ! which should be redefined as the variable name of 'a_puw'. Then, we recompute                                                         !
         !     a_prw  = ( a_p_msfc(k,msfc) - a_puw - a_pd ) * am_r(k) / ( am_r(k) + am_s(k) )    ! Advanced.                                     !
         !     a_psw  = ( a_p_msfc(k,msfc) - a_puw - a_pd ) * am_s(k) / ( am_r(k) + am_s(k) )    ! Advanced.                                     ! 
         ! and then compute all the processes mentioned above. For actual computation of wet scavenging of aerosols within                       !
         ! the area of 'a_prw + a_psw', I can refer to the method in CAM5.                                                                       !
         ! The resulting grid-mean tendency of tracers by wet scavenging will be defined as 'wdeptrrs_msfc(k,msfc,mt)' and                       !
         ! will be added to the final tracer tendency below. We should define 'trten_wdep(k,mt)' too similar to 'trten_evp(k,mt)'.               !
         ! Since it is good to compute a single 'cvp_trrsprd(k,mt)' that includes both the effect of evaporation and scavenging,                 !
         ! this 'wdeptrrs_msfc(k,msfc,mt)' should be appropriately included in computing 'cvp_trrsprd_msfc(k,msfc,mt)' and                       !
         ! corresponding related variables below.                                                                                                !
         ! As of this, we can completely treat wet scavenging of aerosols within non-cumulus area (treated here) and also                        !
         ! within cumulus area( which was treated before within accretion-related iteration loop.                                                !
         ! Nov.03.2012. REFINEMENT IS NECESSARY FOR AEROSOL WET DEPOSITION WITHIN NON-CUMULUS PRECIPITATING AREA.                                !
         ! Dec.13.2012. Add separate treatment of 'ixcldliq,ixcldice' in the below 'trrsten' variables.                                          !
         ! Dec.13.2012. Temporarily, set 'wdeptrrs_msfc(k,msfc,mt) = 0' since currently, wet deposition of aerosols are computed in the separate !
         !              wet deposition routine. In the near future, this wet deposition by convective precipitation should be computed within    !
         !              UNICON and separate wet deposition routine associated with convective precipitation should be disabled.                  !    
         !              Note that both 'evptrrs_msfc > 0' and 'wdeptrrs_msfc > 0'.                                                               ! 
         ! ------------------------------------------------------------------------------------------------------------------------------------- !      
         !?      evprain_msfc(k,msfc)  = evprain_clr * a_evp 
         !?      evpsnow_msfc(k,msfc)  = evpsnow_clr * a_evp 
         !?      do mt = 1, ncnst
         !?         if( mt .eq. ixcldliq ) then
         !?             evptrrs_msfc(k,msfc,mt) = evprain_msfc(k,msfc)
         !?         elseif( mt .eq. ixcldice ) then
         !?             evptrrs_msfc(k,msfc,mt) = evpsnow_msfc(k,msfc)
         !?         elseif( mt .eq. ixnumliq ) then
         !?             evptrrs_msfc(k,msfc,mt) = evprain_msfc(k,msfc) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_rain**3 * density_rain )  
         !?         elseif( mt .eq. ixnumice ) then
         !?             evptrrs_msfc(k,msfc,mt) = evpsnow_msfc(k,msfc) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_snow**3 * density_snow )  
         !?         else
         !?             evptrrs_msfc(k,msfc,mt) = flxtrrs_all(mt) * ( ( evprain_msfc(k,msfc) + evpsnow_msfc(k,msfc) ) / max( flx_all, nonzero ) )
         !?         endif
         !?         wdeptrrs_msfc(k,msfc,mt) = 0._r8
         !?      enddo  

         ! Apr.26.2011. With improved treatment of evaporation, below 3 blocks are relocated
         !              further down. Thus, I commented out below 3 blocks.

         ! evpint_rain           = evpint_rain + evprain_msfc(k,msfc) * dp0(k) / g
         ! evpint_snow           = evpint_snow + evpsnow_msfc(k,msfc) * dp0(k) / g
         ! ntraprd_msfc(k,msfc)  = qrten_msfc(k,msfc) + snowmlt_msfc(k,msfc) - evprain_msfc(k,msfc)
         ! ntsnprd_msfc(k,msfc)  = qsten_msfc(k,msfc) - snowmlt_msfc(k,msfc) - evpsnow_msfc(k,msfc)
         ! flxrain_msfc(km,msfc) = flxrain_msfc(k,msfc) + ntraprd_msfc(k,msfc) * dp0(k) / g
         ! flxsnow_msfc(km,msfc) = flxsnow_msfc(k,msfc) + ntsnprd_msfc(k,msfc) * dp0(k) / g

         ! if( flxrain_msfc(km,msfc) .lt. 0._r8 .or. flxsnow_msfc(km,msfc) .lt. 0._r8 ) then 
         !   ! Note that below case is possible if a_evp = 0.
         !   ! In this case, below recomputation of 'ntraprd,evprain' and 'ntsnprd,evpsnow' is good enough.
         !     write(6,*) 'UNICON : Stop - Negative precipitation flux after computing evaporation within environment'
         !     write(6,*)  k, flxrain_msfc(k,msfc), flxsnow_msfc(k,msfc), flxrain_msfc(km,msfc), flxsnow_msfc(km,msfc)
         !     write(6,*)  k, qrten_msfc(k,msfc), qsten_msfc(k,msfc), snowmlt_msfc(k,msfc), evprain_msfc(k,msfc), evpsnow_msfc(k,msfc)
         !     write(6,*)  k, evprain_clr, a_evp
         !   ! stop
         ! endif

         ! flxrain_msfc(km,msfc)   = max( flxrain_msfc(km,msfc), 0._r8 )
         ! if( flxrain_msfc(km,msfc) .eq. 0._r8 ) then
         !     ntraprd_msfc(k,msfc) = - flxrain_msfc(k,msfc) * g / dp0(k)
         !     evprain_msfc(k,msfc) = qrten_msfc(k,msfc) + snowmlt_msfc(k,msfc) - ntraprd_msfc(k,msfc)
         ! endif 
         ! flxsnow_msfc(km,msfc)   = max( flxsnow_msfc(km,msfc), 0._r8 )         
         ! if( flxsnow_msfc(km,msfc) .eq. 0._r8 ) then
         !     ntsnprd_msfc(k,msfc) = - flxsnow_msfc(k,msfc) * g / dp0(k)
         !     evpsnow_msfc(k,msfc) = qsten_msfc(k,msfc) - snowmlt_msfc(k,msfc) - ntsnprd_msfc(k,msfc)
         ! endif
         ! evapc_msfc(k,msfc) = evprain_msfc(k,msfc) + evpsnow_msfc(k,msfc)

         ! -------------------------------------------------------------------------- !
         ! Update precipitation flux at all interfaces to impose correct limit on the !
         ! on the 'evprain_clr' and 'evpsnow_clr' in the next layer below.            !
         ! This treatment is exactly identical to the treatment of the evaporation    !
         ! within downdraft.                                                          !        
         ! Due to snow melting, 'flxsnow_ava(kc)' can be negative. In this case,      !
         ! simply set 'flxsnow_ava(kc) = 0' which is perfectly OK conceptually and    !
         ! indeed correct.                                                            ! 
         ! Oct.12.2010. Note that 'snowmlt_msfc(k,msfc)' is set to be zero due to     !
         !              previous treatment of 'snowmlt_e(k)' before evaporation       !
         !              within downdraft.                                             !
         ! Nov.26.2012. Add corresponding tracer part.                                !
         ! -------------------------------------------------------------------------- !

         ! Apr.26.2011. Note that 'flxrain_ava_msfc,flxsnow_ava_msfc' already contains 'cvp_rainprd_msfc,cvp_snowprd_msfc'
         !              from evaporation within convective downdraft. Note that this 'cvp_rainprd_msfc,cvp_snowprd_msfc'
         !              are assumed to come from environment, not from downdraft for both evaporation within downdraft
         !              and environment.   
        
         !?      tmp1 = 0._r8
         !?      tmp2 = 0._r8 
         !?    ! Nov.29.2012. Add corresponding tracer parts. 
         !?      do mt = 1, ncnst
         !?         tmp_tr(mt) = 0._r8
         !?      enddo  
         !?      do kc = km, 0, -1
         !?         kcp = kc + 1
         !?         flxrain_ava_msfc(kc,msfc) = flxrain_ava_msfc(kc,msfc) - ( evprain_msfc(k,msfc) - snowmlt_msfc(k,msfc) ) * ( dp0(k) / g ) + tmp1 
         !?         flxsnow_ava_msfc(kc,msfc) = flxsnow_ava_msfc(kc,msfc) - ( evpsnow_msfc(k,msfc) + snowmlt_msfc(k,msfc) ) * ( dp0(k) / g ) + tmp2
         !?       ! Nov.29.2012. Add corresponding tracer parts. 
         !?       !              Note that I should use 'dptr0(k,mt)' instead of 'dp0(k)' in the below tracer block.
         !?       ! Dec.13.2012. Wet deposition term is added. Note that 'wdeptrrs_msfc > 0' and 'evptrrs_msfc > 0'.
         !?         do mt = 1, ncnst
         !?            flxtrrs_ava_msfc(kc,msfc,mt) = flxtrrs_ava_msfc(kc,msfc,mt) + ( wdeptrrs_msfc(k,msfc,mt) - evptrrs_msfc(k,msfc,mt) ) * ( dptr0(k,mt) / g ) + tmp_tr(mt)
         !?         enddo  
         !?       ! Apr.26.2011. Add corrective production tendency of rain by using 'qv0' for future refinement.
         !?         if( flxrain_ava_msfc(kc,msfc) .lt. 0._r8 ) then
         !?             cvp_rainprd_msfc(kcp,msfc) = cvp_rainprd_msfc(kcp,msfc) - flxrain_ava_msfc(kc,msfc) * ( g / dp0(kcp) ) ! [ kg / kg / s ]
         !?             tmp1                       = tmp1                       - flxrain_ava_msfc(kc,msfc)
         !?             flxrain_ava_msfc(kc,msfc)  = 0._r8                   
         !?         endif
         !?         if( flxsnow_ava_msfc(kc,msfc) .lt. 0._r8 ) then
         !?             cvp_snowprd_msfc(kcp,msfc) = cvp_snowprd_msfc(kcp,msfc) - flxsnow_ava_msfc(kc,msfc) * ( g / dp0(kcp) ) ! [ kg / kg / s ]
         !?             tmp2                       = tmp2                       - flxsnow_ava_msfc(kc,msfc)
         !?             flxsnow_ava_msfc(kc,msfc)  = 0._r8                   
         !?         endif
         !?       ! Nov.29.2012. Add corresponding tracer parts. 
         !?       !              Note that I should use 'dptr0(k,mt)' instead of 'dp0(k)' in the below tracer block.
         !?         do mt = 1, ncnst
         !?            if( flxtrrs_ava_msfc(kc,msfc,mt) .lt. 0._r8 ) then
         !?                cvp_trrsprd_msfc(kcp,msfc,mt) = cvp_trrsprd_msfc(kcp,msfc,mt) - flxtrrs_ava_msfc(kc,msfc,mt) * ( g / dptr0(kcp,mt) ) ! [ kg (#) / kg / s ]
         !?                tmp_tr(mt)                    = tmp_tr(mt)                    - flxtrrs_ava_msfc(kc,msfc,mt)
         !?                flxtrrs_ava_msfc(kc,msfc,mt)  = 0._r8                   
         !?            endif
         !?         enddo  
         !?       ! if( flxrain_ava_msfc(kc,msfc) .lt. 0._r8 ) then
         !?       !     evprain_msfc(kc+1,msfc) = evprain_msfc(kc+1,msfc) + flxrain_ava_msfc(kc,msfc) * ( g /dp0(kcp) )
         !?       !     flxrain_ava_msfc(kc,msfc) = 0._r8
         !?       ! endif
         !?       ! if( flxsnow_ava_msfc(kc,msfc) .lt. 0._r8 ) then
         !?       !     evpsnow_msfc(kc+1,msfc) = evpsnow_msfc(kc+1,msfc) + flxsnow_ava_msfc(kc,msfc) * ( g /dp0(kcp) )
         !?       !     flxsnow_ava_msfc(kc,msfc) = 0._r8
         !?       ! endif
         !?       ! Apr.26.2011. With the improved treatment of evaporation within environment, I don't need below
         !?       !              4 lines. So, I removed below 4 lines. This will save computation time.
         !?       ! if( flxrain_ava_msfc(kc,msfc) .lt. -1.e-18_r8 .or. flxsnow_ava_msfc(kc,msfc) .lt. -1.e-18_r8 ) then
         !?       !     write(6,*) 'UNICON : Warning - Negative flxrain_ava and flxsnow_ava after evaporation within env. - Reset to zero'
         !?       !     write(6,*)  kc, msfc, flxrain_ava_msfc(kc,msfc), flxsnow_ava_msfc(kc,msfc)
         !?       ! endif 
         !?       ! flxrain_ava_msfc(kc,msfc) = max( 0._r8, flxrain_ava_msfc(kc,msfc) )
         !?       ! flxsnow_ava_msfc(kc,msfc) = max( 0._r8, flxsnow_ava_msfc(kc,msfc) )
         !?      enddo

         ! ------------------------------------------------------------------------------------------------ !
         ! Final Grid-Mean Evaporation Tendency                                                             !
         ! Nov.29.2012. Add corresponding tracer parts.                                                     !
         !              Note that I should use 'dptr0(k,mt)' instead of 'dp0(k)' in the below tracer block. !
         ! ------------------------------------------------------------------------------------------------ !
         !?      evpint_rain           = evpint_rain + evprain_msfc(k,msfc) * ( dp0(k) / g )
         !?      evpint_snow           = evpint_snow + evpsnow_msfc(k,msfc) * ( dp0(k) / g )
         !?      ntraprd_msfc(k,msfc)  = qrten_msfc(k,msfc) + snowmlt_msfc(k,msfc) - evprain_msfc(k,msfc) + cvp_rainprd_msfc(k,msfc)
         !?      ntsnprd_msfc(k,msfc)  = qsten_msfc(k,msfc) - snowmlt_msfc(k,msfc) - evpsnow_msfc(k,msfc) + cvp_snowprd_msfc(k,msfc)
         !?      flxrain_msfc(km,msfc) = flxrain_msfc(k,msfc) + ntraprd_msfc(k,msfc) * ( dp0(k) / g )
         !?      flxsnow_msfc(km,msfc) = flxsnow_msfc(k,msfc) + ntsnprd_msfc(k,msfc) * ( dp0(k) / g )
         !?      if( flxrain_msfc(km,msfc) .lt. -1.e-18_r8 .or. flxsnow_msfc(km,msfc) .lt. -1.e-18_r8 ) then 
         !?        ! Note that below case is possible if a_evp = 0.
         !?        ! In this case, below recomputation of 'ntraprd,evprain' and 'ntsnprd,evpsnow' is good enough.
         !?          write(6,*) 'UNICON : Stop - Negative precipitation flux after computing evaporation within environment'
         !?          write(6,*)  k, flxrain_msfc(k,msfc), flxsnow_msfc(k,msfc), flxrain_msfc(km,msfc), flxsnow_msfc(km,msfc)
         !?          write(6,*)  k, qrten_msfc(k,msfc), qsten_msfc(k,msfc), snowmlt_msfc(k,msfc), evprain_msfc(k,msfc), evpsnow_msfc(k,msfc)
         !?          write(6,*)  k, cvp_rainprd_msfc(k,msfc), cvp_snowprd_msfc(k,msfc), a_evp
         !?        ! stop
         !?      endif
         !?      flxrain_msfc(km,msfc) = max( flxrain_msfc(km,msfc), 0._r8 )
         !?      flxsnow_msfc(km,msfc) = max( flxsnow_msfc(km,msfc), 0._r8 )         
         !?      evapc_msfc(k,msfc)    = evprain_msfc(k,msfc) + evpsnow_msfc(k,msfc)
         ! ---------------------------------------------------------------------------------- !
         ! Nov.29.2012. Below is a tracer block.                                              ! 
         ! Dec.01.2012. Should do separate treatment for precipitating droplet numbers due to !
         !              snow melting treated above.                                           !
         ! Dec.13.2012. Wet deposition term ( wdeptrrs_msfc ) is added.                       !
         !              Note that 'evptrrs_msfc > 0' and 'wdeptrrs_msfc > 0'.                 !
         !              Note also that 'trrsten_msfc = trrsten_u_msfc + trrsten_d_msfc', i.e.,!
         !              it does not include tendency within environment.                      !
         ! ---------------------------------------------------------------------------------- !
         !?      do mt = 1, ncnst
         !?         if( mt .eq. ixcldliq ) then
         !?             evpint_trrs(mt)           =          evpint_rain
         !?             nttrrsprd_msfc(k,msfc,mt) =  ntraprd_msfc(k,msfc)
         !?             flxtrrs_msfc(km,msfc,mt)  = flxrain_msfc(km,msfc)
         !?         elseif( mt .eq. ixcldice ) then
         !?             evpint_trrs(mt)           =          evpint_snow
         !?             nttrrsprd_msfc(k,msfc,mt) =  ntsnprd_msfc(k,msfc)
         !?             flxtrrs_msfc(km,msfc,mt)  = flxsnow_msfc(km,msfc)
         !?         elseif( mt .eq. ixnumliq ) then
         !?             evpint_trrs(mt)           =          evpint_rain  * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_rain**3 * density_rain )
         !?             nttrrsprd_msfc(k,msfc,mt) =  ntraprd_msfc(k,msfc) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_rain**3 * density_rain )
         !?             flxtrrs_msfc(km,msfc,mt)  = flxrain_msfc(km,msfc) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_rain**3 * density_rain )
         !?         elseif( mt .eq. ixnumice ) then
         !?             evpint_trrs(mt)           =          evpint_snow  * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_snow**3 * density_snow )
         !?             nttrrsprd_msfc(k,msfc,mt) =  ntsnprd_msfc(k,msfc) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_snow**3 * density_snow )
         !?             flxtrrs_msfc(km,msfc,mt)  = flxsnow_msfc(km,msfc) * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_snow**3 * density_snow )
         !?         else
         !?             evpint_trrs(mt)           = evpint_trrs(mt) + evptrrs_msfc(k,msfc,mt) * ( dptr0(k,mt) / g )
         !?             nttrrsprd_msfc(k,msfc,mt) = trrsten_msfc(k,msfc,mt) - evptrrs_msfc(k,msfc,mt) + wdeptrrs_msfc(k,msfc,mt) + cvp_trrsprd_msfc(k,msfc,mt)
         !?             flxtrrs_msfc(km,msfc,mt)  = flxtrrs_msfc(k,msfc,mt) + nttrrsprd_msfc(k,msfc,mt) * ( dptr0(k,mt) / g )
         !?         endif
         ! Dec.13.2012. Below if test often picks anomalous cases, but with very small
         !              value of flxtrrs_msfc(km,msfc,mt) = 1.e-15 for 'number' variables.
         !              This is likely due to the use of float instead of double precision.
         !              For the time being, without risk, I commented out below block to
         !              suppress error message. In future, however, I should completely debug below.  
         ! if( flxtrrs_msfc(km,msfc,mt) .lt. -1.e-18_r8 ) then 
         !   ! Note that below case is possible if a_evp = 0.
         !   ! In this case, below recomputation of 'nttrrsprd,evptrrs' is good enough.
         !     write(6,*) 'UNICON : Stop - Negative tracer flux after computing evaporation within environment'
         !     write(6,*)  k, mt, flxtrrs_msfc(k,msfc,mt), flxtrrs_msfc(km,msfc,mt)
         !     write(6,*)  k, mt, trrsten_msfc(k,msfc,mt), evptrrs_msfc(k,msfc,mt), wdeptrrs_msfc(k,msfc,mt)
         !     write(6,*)  k, mt, cvp_trrsprd_msfc(k,msfc,mt), a_evp
         !   ! stop
         ! endif
         !?         flxtrrs_msfc(km,msfc,mt) = max( flxtrrs_msfc(km,msfc,mt), 0._r8 )
         !?      enddo

         ! Apr.26.2011. With improved treatment of evaporation, below block is not necessary.
         !              Thus, I commented out below two blocks.
         ! if( flxrain_msfc(km,msfc) .eq. 0._r8 ) then
         !     ntraprd_msfc(k,msfc) = - flxrain_msfc(k,msfc) * g / dp0(k)
         !     evprain_msfc(k,msfc) = qrten_msfc(k,msfc) + snowmlt_msfc(k,msfc) - ntraprd_msfc(k,msfc)
         ! endif 
         ! if( flxsnow_msfc(km,msfc) .eq. 0._r8 ) then
         !     ntsnprd_msfc(k,msfc) = - flxsnow_msfc(k,msfc) * g / dp0(k)
         !     evpsnow_msfc(k,msfc) = qsten_msfc(k,msfc) - snowmlt_msfc(k,msfc) - ntsnprd_msfc(k,msfc)
         ! endif

         ! ------------------------------------------------------------------ !
         ! Computation of convective precipitation area at the base interface !
         ! for use in the next layer below.                                   !  
         ! Replaces 'a_p' at the top interface to 'a_p' at the base interface.!
         ! If a_evp = 0., below two produces the same results.                !
         ! So, it works perfectly.                                            !
         ! 12.Oct.2010 : Below first if block is modified in consistent with  !
         !               the above modification of limiter on the same day.   ! 
         !               Below new treatment assumes 'a_evp' is overlapped    !
         !               with neither 'precipitation-generating updraft' or   !
         !              'precipitation-evaporating' downdraft areas.          !
         !               Thus, below new treatment is perfectly reasonable    !
         !               and most correct.                                    !
         ! ------------------------------------------------------------------ !
         !?      if( i_ovp .eq. 0 ) then
         !?        ! Mar.12.2011. I re-checked that my below formula produced perfectly
         !?        !              correct results for all possible cases.
         !?        ! Below is new perfect.
         !?          if( ( flx_all_in - nonzero ) .le. ( evprain_clr + evpsnow_clr ) * dp0(k) / g ) then
         !?        ! Below is previous old.
         !?        ! if( ( flx_all_in - nonzero ) .le. ( evprain_clr + evpsnow_clr - & 
         !?        !       min( 0._r8, ( qrten(k) + qsten(k) ) / max( nonzero, a_evp ) ) ) * dp0(k) / g ) then
         !?                a_ovp   = ( 1._r8 - beta1 ) * min( a_p_msfc(k,msfc) - a_evp,  am_up_msfc(k,msfc) ) + &
         !?                                    beta1   * max( a_p_msfc(k,msfc) - a_evp + am_up_msfc(k,msfc) - 1._r8, 0._r8 )
         !?                a_p_msfc(km,msfc) = a_p_msfc(k,msfc) - a_evp + am_up_msfc(k,msfc) - a_ovp
         !?          else
         !?                a_ovp   = ( 1._r8 - beta1 ) * min( a_p_msfc(k,msfc),  am_up_msfc(k,msfc) ) + & 
         !?                                    beta1   * max( a_p_msfc(k,msfc) + am_up_msfc(k,msfc) - 1._r8, 0._r8 )
         !?                a_p_msfc(km,msfc) = a_p_msfc(k,msfc) + am_up_msfc(k,msfc) - a_ovp
         !?          endif
         !?      elseif( i_ovp .eq. 1 ) then
         ! ------------------------------------------------------------------------------------------------------- !
         ! Apr.25.2012.                                                                                            ! 
         ! Compute overlapping area between precipitation area at the top interace and                             !
         ! precipitating updraft fractional area at the layer mid-point.                                           !
         ! Note that I am simply using previous computed 'x_p_msfc(k,msfc), y_p_msfc(k,msfc)' which                !
         ! was computed assuming exponential decay of precipitation flux with model depth.                         !
         ! This is inevitable but best and very nice approximation.                                                !  
         ! Note also that evaporation area 'a_evp' is always located outside of precipitating updraft              !
         ! fractional area. So, as an input of below subroutine 'area_overlap', I should                           !
         ! use the 'a_p_msfc(k,msfc)' instead of 'a_p_msfc(k,msfc) - a_evp' in contrast to the                     ! 
         ! above computation of 'i_ovp .eq. 0' (in the above option, I must use 'a_p_msfc(k,msfc) - a_evp'         !
         ! as I checked from the actual simulation).                                                               !
         ! In case that updraft is unsaturated, it is 'am_up_msfc(k,msfc) = 0', so that 'a_pu  = 0'.               !
         ! In other word, in general case, I should use 'a_p_msfc(k,msfc)' instead of 'a_p_msfc(k,msfc) - a_evp'   !
         ! as the argument of below subroutine 'area_overlap. This is very important and good feature.             !
         ! However, in computing final 'a_p_msfc(km,msfc)' at the base interface, I should subtract 'a_evp'        !
         ! depending on the 'if' sentence as below.                                                                !
         ! Note that 'num_u_msfc(km,msfc)' is height-independent constant from the surface to the cumulus top.     !
         ! ------------------------------------------------------------------------------------------------------- ! 
         !?          a_ovp = area_overlap( x_p_msfc(k,msfc),  y_p_msfc(k,msfc),  a_p_msfc(k,msfc),   & 
         !?                                x_um_msfc(k,msfc), y_um_msfc(k,msfc), am_up_msfc(k,msfc), &
         !?                                num_u_msfc(0,msfc) )
         !?          if( ( flx_all_in - nonzero ) .le. ( evprain_clr + evpsnow_clr ) * dp0(k) / g ) then
         !?                a_p_msfc(km,msfc) = a_p_msfc(k,msfc) - a_evp + am_up_msfc(k,msfc) - a_ovp
         !?          else
         !?                a_p_msfc(km,msfc) = a_p_msfc(k,msfc) + am_up_msfc(k,msfc) - a_ovp
         !?          endif
         !?      endif
         !?      if( ( flxrain_msfc(km,msfc) + flxsnow_msfc(km,msfc) ) .le. 0._r8 ) a_p_msfc(km,msfc) = 0._r8
         !?      a_p_msfc(km,msfc) = max( 0._r8, min( 1._r8, a_p_msfc(km,msfc) ) )

         ! -------------------------------------------------------------------- !
         ! Jun.30.2011. Save 'a_evp' for future use for convective organization !
         !              Since 'a_evp' is defined at the layer mid-point, 'k' in !
         !              the below line is a layer-index.                        ! 
         ! -------------------------------------------------------------------- !

         !?      am_evp_msfc(k,msfc) = a_evp

         !?   end do
         !?   end do

         ! ------------------------------------------------------------ !
         ! Compute grid-mean tendencies by averaging or summing all the !
         ! updraft segment tendencies.                                  ! 
         ! ------------------------------------------------------------ !

         do k = ktop, 1, -1  ! 'k' is a layer index : 'mkx'('1') is the top ('bottom') layer          
            ! ------------------------------------------------------------ !
            ! Save the results into the array of grid-mean state variables.! 
            ! For tracers, I temporarily set it to be zero but it should   !
            ! be refined later.                                            !
            ! Oct.12.2010. Note that I added 'snowmlt_e(k)' in 'slten_evp' !
            ! ------------------------------------------------------------ !
            ! Apr.26.2011. In association with the improved treatment of evaporation within downdraft and environment,
            !              I added the computation of 'cvp_rainprd(k),cvp_snowprd(k)' below.
            !              In addition, it is added to the computation of 'qvten_evp(k),slten_evp(k)' below.
            !              Note that this corrective 'cvp_rainprd(k),cvp_snowprd(k)' are direct conversion between
            !              precipitation and environment ( not downdraft ). Thus, these two tendencies are added
            !              into the computation of 'qvten_evp(k),slten_evp(k)' below.  
            ! Sep.09.2011. I added 'snowmlt(k)' computation for removing any ambuguity in computation of
            !              slten_evp(k) below and wake forcing computation later. 
            ! Nov.29.2012. Add tracer block. Note that 'evapc_msfc(k,msfc) = evprain_msfc(k,msfc) + evpsnow_msfc(k,msfc)' 
            !              corresponds to 'evptrrs_msfc(k,msfc,mt)' which is already defined, so I don't separately 
            !              define the tracer variables corresponding to 'evapc_msfc'. 
            do msfc = 1, nseg
               !?         snowmlt(k)     = snowmlt(k)     +     snowmlt_msfc(k,msfc) 
               snowmlt_e(k)   = snowmlt_e(k)   +   snowmlt_e_msfc(k,msfc) 
               ntraprd(k)     = ntraprd(k)     +     ntraprd_msfc(k,msfc) 
               ntsnprd(k)     = ntsnprd(k)     +     ntsnprd_msfc(k,msfc)
               !?         evprain(k)     = evprain(k)     +     evprain_msfc(k,msfc)
               !?         evpsnow(k)     = evpsnow(k)     +     evpsnow_msfc(k,msfc)
               evprain_e(k)   = evprain_e(k)   +   evprain_e_msfc(k,msfc)
               evpsnow_e(k)   = evpsnow_e(k)   +   evpsnow_e_msfc(k,msfc)
               evprain_d(k)   = evprain_d(k)   +   evprain_d_msfc(k,msfc)
               evpsnow_d(k)   = evpsnow_d(k)   +   evpsnow_d_msfc(k,msfc)
               flxrain(k)     = flxrain(k)     +     flxrain_msfc(k,msfc)
               flxsnow(k)     = flxsnow(k)     +     flxsnow_msfc(k,msfc)
               cvp_rainprd(k) = cvp_rainprd(k) + cvp_rainprd_msfc(k,msfc)
               cvp_snowprd(k) = cvp_snowprd(k) + cvp_snowprd_msfc(k,msfc)
               !?         evapc(k)       = evapc(k)       +       evapc_msfc(k,msfc)
               a_p(k)         = a_p(k)         +         a_p_msfc(k,msfc)
               am_up(k)       = am_up(k)       +       am_up_msfc(k,msfc)
               am_us(k)       = am_us(k)       +       am_us_msfc(k,msfc)
               am_evp(k)      = am_evp(k)      +      am_evp_msfc(k,msfc)
               am_pu(k)       = am_pu(k)       +       am_pu_msfc(k,msfc)
               am_pd(k)       = am_pd(k)       +       am_pd_msfc(k,msfc)
               am_pr(k)       = am_pr(k)       +       am_pr_msfc(k,msfc)
               am_ps(k)       = am_ps(k)       +       am_ps_msfc(k,msfc)
               ! Nov.29.2012. Add tracer block.
               ! Dec.13.2012. Add the line of wet deposition within enironment. Note that wet deposition
               !              within convective updraft and downdraft have already been computed.
               do mt = 1, ncnst
                  nttrrsprd(k,mt)   = nttrrsprd(k,mt)   +   nttrrsprd_msfc(k,msfc,mt) 
                  !?            evptrrs(k,mt)     = evptrrs(k,mt)     +     evptrrs_msfc(k,msfc,mt)
                  evptrrs_e(k,mt)   = evptrrs_e(k,mt)   +   evptrrs_e_msfc(k,msfc,mt)
                  evptrrs_d(k,mt)   = evptrrs_d(k,mt)   +   evptrrs_d_msfc(k,msfc,mt)
                  !?            wdeptrrs(k,mt)    = wdeptrrs(k,mt)    +    wdeptrrs_msfc(k,msfc,mt)
                  wdeptrrs_e(k,mt)  = wdeptrrs_e(k,mt)  +  wdeptrrs_e_msfc(k,msfc,mt)
                  flxtrrs(k,mt)     = flxtrrs(k,mt)     +     flxtrrs_msfc(k,msfc,mt)
                  cvp_trrsprd(k,mt) = cvp_trrsprd(k,mt) + cvp_trrsprd_msfc(k,msfc,mt)
               end do
            end do
            ! Since evaporation within downdraft has already been treated as a part of downdraft tendency ( qtten_d(k) ), 
            ! below treatment of '_evp(k)' should only contain the processes occuring within the environment.
            qlten_evp(k)  = 0._r8
            qiten_evp(k)  = 0._r8
            qvten_evp(k)  = evprain_e(k) - cvp_rainprd(k) + evpsnow_e(k) - cvp_snowprd(k)
            qtten_evp(k)  = qlten_evp(k) + qiten_evp(k) + qvten_evp(k)
            !?      slten_evp(k)  = - xlv * ( evprain(k) - cvp_rainprd(k) ) - xls * ( evpsnow(k) - cvp_snowprd(k) ) - ( xls - xlv ) * ( snowmlt(k) + snowmlt_e(k) )         
            slten_evp(k)  = -xlv*(evprain_e(k) - cvp_rainprd(k)) - xls*(evpsnow_e(k) - cvp_snowprd(k)) - (xls - xlv)*snowmlt_e(k)
            sten_evp(k)   = slten_evp(k) + xlv * qlten_evp(k) + xls * qiten_evp(k)
            uten_evp(k)   = 0._r8
            vten_evp(k)   = 0._r8
            ! ----------------------------------------------------------------------------------------- !
            ! TRACERS REFINEMENT NECESSARY : EVAPORATION OF CONVECTIVE PRECIPITATION WITHIN ENVIRONMENT !
            ! Nov.29.2012. Below is updated and correctly computed.                                     !
            ! Dec.13.2012. I should carefully check whether below is double-counting with the separate  !
            !              routine of wet deposition of aerosols.                                       !
            ! Dec.13.2012. Add wet deposition part.                                                     !
            !              Note that 'evptrrs > 0' and 'wdeptrrs > 0'. Note also that wet deposition    !
            !              component is only applied to tracers not to the other thermodynamic scalars. !
            !              For convenience and following previous code, 'cvp_trrsprd' is added into     !
            !              the 'trten_evp'.                                                             !   
            !              Note that (-) sign should be multiplied in front of 'wdeptrrs'.              !
            ! Dec.13.2012. Note that 'cvp_trrsprd > 0' contains corrective tendencies associated with   !
            !              evaporation both within downdraft and environment, so that it is a function  !
            !              of 'evptrrs'. This re-geration of aerosols by evaporation of precipitation   !
            !              i.e., 'evptrrs' is to some degree already treated in the separate wet        !
            !              deposition routine. Thus, in order to precent double counting in the current !
            !              CAM5 structure, I should in principle remove 'evptrrs' in the below formula  !
            !              of 'trten_evp'. If then, however, 'trten_evp << 0', so that resulting        !
            !              concentration of aerosols after convection may become negative. Of course,   !
            !              by using 'positive_tracer' subroutine, negative tracer will be eventually    !
            !              converted into positive tracer. So, in order to reduce global AOD,           !
            !              let's remove 'evptrrs' in the below computation of trten_evp.                !   
            ! Feb.05.2013. Note that below 'trten_evp(k,mt),trten_wdep(k,mt)' are tendencies only by    !
            !              the processes within environment, since corresponding tendencies occuring    !
            !              within convective updraft and downdraft have already been treated and saved  !
            !              into 'trten_dia_u(k,mt)' and 'trten_dia_d(k,mt)'.                            !
            !              All final tendencies of tracers associated with diabatic forcings within     !
            !              environment ( trten_evp, trten_wdep ) are totally handled in the below block.!
            !              Thus, for correct computation of tracer tendency ( trten not trrsten ) by    !
            !              evaporation and wet deposition within environment, I only need to modify     !
            !              below block, which is sufficient and necessary.                              !    
            ! ----------------------------------------------------------------------------------------- !
            do mt = 1, ncnst 
               if( mt .eq. 1 .or. mt .eq. ixcldliq .or. mt .eq. ixcldice .or. mt .eq. ixnumliq .or. mt .eq. ixnumice ) then
                  trten_evp(k,mt)  = 0._r8
                  trten_wdep(k,mt) = 0._r8
               else
                  !?           ! In principle, I should use below two lines with appropriate computations of evptrrs_e(k,mt)
                  !?           ! and wdeptrrs_e(k,mt) in the main program. However, in order to avoid double counting with
                  !?           ! the similar treatment in the separate wet deposition routine in CAM5, I temporary set
                  !?           ! these two tendencies to zero. In future, if I turn-off wet deposition treatment by 
                  !?           ! convective precipitation in the separate routine in CAM5 ( i.e., by setting input cumulus
                  !?           ! area and convective precipitation to be zero ), I can use my robust below formula.    
                  ! trten_evp(k,mt)  =   - evptrrs_e(k,mt) - cvp_trrsprd(k,mt)
                  ! trten_wdep(k,mt) =  - wdeptrrs_e(k,mt)             
                  trten_evp(k,mt)  = - cvp_trrsprd(k,mt)
                  trten_wdep(k,mt) =   0._r8
               endif
            enddo
            ! ----------------------------------------------------------------------------------------- !
            ! TRACERS REFINEMENT NECESSARY : EVAPORATION OF CONVECTIVE PRECIPITATION WITHIN ENVIRONMENT !
            ! ----------------------------------------------------------------------------------------- !
         end do

         ! ----------------------------- !
         ! Precipitation flux at surface !
         ! Nov.29.2012. Add tracer block !
         ! ----------------------------- !
         do msfc = 1, nseg
            flxrain(0)    = flxrain(0) + flxrain_msfc(0,msfc)
            flxsnow(0)    = flxsnow(0) + flxsnow_msfc(0,msfc)
            ! Nov.29.2012. Add tracer block. 
            do mt = 1, ncnst 
               flxtrrs(0,mt) = flxtrrs(0,mt) + flxtrrs_msfc(0,msfc,mt)
            end do
            a_p(0)        = a_p(0)     +     a_p_msfc(0,msfc)
         end do
         precip  = ( flxrain(0) + flxsnow(0) ) / 1000._r8
         snow    =   flxsnow(0) / 1000._r8       

         ! -------------------------------------------------------------------------------------------------------- !
         ! Vertically-integrated grid-mean differential evaporation rate of convective precipitation ( aw*(Qn-Qw) ) !
         ! averaged over the PBL depth. Note that this should only consider didbatic forcing within environment not !
         ! within convective downdraft since diabatic forcing within convective downdraft has already been computed !
         ! above.                                                                                                   !
         ! I should also include 'corrective flux' ( 'cev' ) and 'snow melting'.                                    ! 
         ! For simplicity, I will assume that 'corrective flux' is homogeneous across the grid and so does not      !
         ! contribute to the computation of aw*(Qn-Qw).                                                             ! 
         ! Snow melting is assumed to occur even in the convective updraft in contrast to the                       !
         ! evaporation of convective precipitation. In order to treat snow melting more rigorously, I shoud use the !
         ! precipitation area before treating evaporation within downdraft ( a_p_prevp(k) defined at the interface )! 
         ! since snow melting was treated before evaporation within downdraft.                                      !
         ! As a more rigorous choice, I will assume that 'evaporation area, a_evp' is either within                 !
         ! completely within 'non-wake' area or within 'wake' area whenever possible. This different geometrical    !
         ! structure might be roughly described by using the similar tilting parameter, 'beta2'.                    !
         ! Conceptually, it seems to be most reasonable to assume that whenever possible, evaporation area exists   !
         ! within wake area ( i.e., beta2 = 1 ).                                                                    !       
         ! Future works : Treatment of tracers should be refined in future. Note that snow melting does not affect  !
         !                tracer concentrations. So, I can use tmp2 not tmp3.                                       !
         ! Sep.09.2011. Below block is commented-out since it will be computed later below in a collectively way    !
         !              for the whole wake forcing computation.                                                     !
         ! -------------------------------------------------------------------------------------------------------- !

         ! qt_dia_env_org           = 0._r8 
         ! thl_dia_env_org          = 0._r8
         ! tr_dia_env_org(1:ncnst)  = 0._r8  
         ! do k = 1, kpblhm
         !  ! Below 'tmp2' is from the the assumption of homogeneous distribution.
         !  ! tmp2 = - ( awk_PBL / ( 1._r8 - awk_PBL ) ) * ( am_u(k) / ( 1._r8 - am_u(k) )
         !  ! Here, 'a_evp_wk' is overlapping area between 'evaporation area' and 'wake area'. Similar to the
         !  ! overlapping treatment between precipitation area and updraft fractional area, I am using additional
         !  ! tilting parameter to control the overlap between evaporation area ( am_evp(k) ) and wake area ( awk_PBL ).
         !  ! Note that 'beta1' is likely to be related to 'beta2'.   
         !  ! Rigorously speaking, below treatment of snow melting is only valid if 'i_snowmlt = 0' and so all snow
         !  ! melting occurs before evaporation within downdraft ( so 'snowmlt(k) = 0' but 'snowmlt_e(k) > 0 ' ). 
         !  ! However, since I will choose 'i_snowmlt = 0' as a default forever, below treatment is completely correct.
         !  ! Sep.13.2011. Below is new one similar to the previous 'a_p_u' using beta. 
         !    am_evp_nw             =  ( 1._r8 - beta2 ) * min( am_evp(k),    1._r8 - awk_PBL ) + beta2 * max( am_evp(k)    - awk_PBL, 0._r8 )
         !    am_p_nw               =  ( 1._r8 - beta2 ) * min( a_p_prevp(k), 1._r8 - awk_PBL ) + beta2 * max( a_p_prevp(k) - awk_PBL, 0._r8 )
         !    am_evp_wk             =  max( 0._r8, am_evp(k)     - am_evp_nw )
         !    am_p_wk               =  max( 0._r8, a_p_prevp(k)  -   am_p_nw )
         !    tmp2                  =  ( 1._r8 / ( 1._r8 - awk_PBL ) ) * ( am_evp_nw / max( am_evp(k),    nonzero ) - ( 1._r8 - awk_PBL ) )
         !    tmp3                  =  ( 1._r8 / ( 1._r8 - awk_PBL ) ) * ( am_p_nw   / max( a_p_prevp(k), nonzero ) - ( 1._r8 - awk_PBL ) )     
         !  ! Below is previous old one. 
         !  ! am_evp_wk             =  ( 1._r8 - beta2 ) * ( am_evp(k)    - min( am_evp(k),    1._r8 - awk_PBL ) ) + beta2 * min( am_evp(k),    awk_PBL )
         !  ! am_p_wk               =  ( 1._r8 - beta2 ) * ( a_p_prevp(k) - min( a_p_prevp(k), 1._r8 - awk_PBL ) ) + beta2 * min( a_p_prevp(k), awk_PBL )
         !  ! tmp2                  =  ( 1._r8 / ( 1._r8 - awk_PBL ) ) * ( awk_PBL -  am_evp_wk / max( am_evp(k),    nonzero ) )
         !  ! tmp3                  =  ( 1._r8 / ( 1._r8 - awk_PBL ) ) * ( awk_PBL -  am_p_wk   / max( a_p_prevp(k), nonzero ) )     
         !    qt_dia_env_org        =    qt_dia_env_org +   tmp2 * ( evprain(k) + evpsnow(k) ) * dp0(k)
         !    thl_dia_env_org       =   thl_dia_env_org + ( tmp2 * ( - xlv * evprain(k) - xls * evpsnow(k) ) + tmp3 * ( - ( xls - xlv ) * ( snowmlt(k) + snowmlt_e(k) ) ) ) / ( cp * exn0(k) ) * dp0(k)
         !    do mt = 1, ncnst
         !       tr_dia_env_org(mt) = tr_dia_env_org(mt) + tmp2 * ( trten_evp(k,mt) + trten_wdep(k,mt) ) * dp0(k)
         !    enddo
         ! enddo
         ! qt_dia_env_org           =  qt_dia_env_org / pblhp 
         ! thl_dia_env_org          = thl_dia_env_org / pblhp  
         ! do mt = 1, ncnst
         !    tr_dia_env_org(mt)    = tr_dia_env_org(mt) / pblhp
         ! enddo

         ! ----------------------------------------------------------------------------------------------- !
         ! Column-integrated evaporation rate of convective precipitation both within convective downdraft !
         ! and environment for convective organization.                                                    !
         ! ----------------------------------------------------------------------------------------------- !

         ! OPTION.1.
         ! Below block is previous one based on the column-integrated evaporation rate
         ! The suggested cc2_org = 2 for this case.
         !d   orgforce1 = 0._r8
         !d   do k = 1, ktop
         !?      orgforce1 = orgforce1 + ( evprain(k) + evpsnow(k) - qrten_d(k) - qsten_d(k) ) * ( dp0(k) / g )
         !d      orgforce1 = orgforce1 + ( evprain_e(k) + evpsnow_e(k) - qrten_d(k) - qsten_d(k) ) * ( dp0(k) / g )
         !d   end do
         ! orgforce1 = orgforce1 / pblhz
         
         ! OPTION.2.
         ! Jul.29.2011. Below block is a new one based on column-integrated downdraft vertical TKE. 
         !              In order to remove the case of stable PBL, the lowest surface interface is not included. 
         !              Note that at the cloud top interface, cmf_u(ktop) > 0, but since w_u(ktop)=0, below
         !              computation is perfectly reasonable.
         !              The final unit of below orgforce1 = [ J / m^2 ].
         ! orgforce1 = 0._r8
         ! if( ktop .ge. 2 ) then 
         !     do k = 2, ktop
         !        km = k - 1
         !        orgforce1 = orgforce1 +  ( w_u(km) * cmf_u(km) / ( rho0bot(k) + rho0top(km) ) ) * ( p0(km) - p0(k) ) / g
         !     end do
         ! endif

         ! OPTION.3.
         ! Jul.30.2011. Above formula integrated over the whole cumulus depth generated unreasonable equatorial 
         !              precipitation maxima over the central-eastern equatorial area. However, my original formula
         !              using downdraft mass flux within the PBL did not produce this unreasonable maxima. 
         !              This implies that the key length scale for the forcing of convective organization is
         !              not 'cumulus top height' but 'PBL depth'. Below formula is designed to address this issue.
         !              Note also than we should divide by 'pblhz' to obtain correct budget of convective organization 
         !              within PBL. 
         ! orgforce1 = 0._r8
         ! if( kpblh .gt. 2 ) then 
         !     do km = 1, kpblhm - 1
         !        orgforce1 = orgforce1 +  ( w_u(km) * cmf_u(km) / ( rho0bot(k) + rho0top(km) ) ) * ( p0(km) - p0(k) ) / g
         !     end do
         ! endif
         ! orgforce1 = orgforce1 / pblhz

         ! ------------------------------------------------------------------------------------------- !
         ! Jun.29.2011. Computation of grid-mean downdraft kinetic energy ( tke_dn_PBL ) and           !
         !              grid-mean evaporation-induced kinetic energy ( tke_ev_PBL ) averaged over PBL. !
         !              Also compute grid-mean perturbation of conservative scalars averaged over PBL  !
         !              by convective downdraft and evaporation of precipitation within PBL.           !
         !              Only 'qt,thl' perturbations are considered here. Later, I can also include     !
         !              the preturbations of 'u,v,aerosols', if I think it is necessary.               !
         ! ------------------------------------------------------------------------------------------- ! 

         !    tkePBLorgDN = 0._r8
         !    thlPBLorgDN = 0._r8
         !    qtPBLorgDN  = 0._r8

         !    tkePBLorgEV = 0._r8
         !    thlPBLorgEV = 0._r8
         !    qtPBLorgEV  = 0._r8

         !    tkePBLorg   = 0._r8
         !    thlPBLorg   = 0._r8
         !    qtPBLorg    = 0._r8

         !     do k = ktop, 1, -1                       ! This 'k'   is a layer index
         !        km = k - 1                            ! This 'km'  is a base interface index of 'k'
         !        ! ----------------------------------------------------------- !
         !        ! Compute the contribution of convective downdraft within PBL !
         !        ! ----------------------------------------------------------- !
         !        if( cmf_d(km) .gt. nonzero .and. km .le. kpblhm ) then
         !            if( km .eq. kpblhm ) then
         !                tmp1 = 0.5_r8 * ( thl0(km) + thl0top(km) )
         !                tmp2 = 0.5_r8 * ( qt0(km)  +  qt0top(km) )
         !                tmp3 = rho0top(km)
         !                dpi  = p0(km) - ps0(km)                        
         !            elseif( km .eq. 0 ) then
         !                tmp1 = 0.5_r8 * ( thl0(k)  +  thl0bot(k) )
         !                tmp2 = 0.5_r8 * ( qt0(k)   +   qt0bot(k) ) 
         !                tmp3 = rho0bot(k)                  
         !                dpi  = ps0(0) - p0(1)
         !            else
         !                tmp1 = ( 0.5_r8 * ( thl0(k)  +  thl0bot(k) ) * ( ps0(km) -   p0(k) ) + 
         !                         0.5_r8 * ( thl0(km) + thl0top(km) ) * ( p0(km)  - ps0(km) ) ) / ( p0(km) - p0(k) )
         !                tmp2 = ( 0.5_r8 * ( qt0(k)   +   qt0bot(k) ) * ( ps0(km) -   p0(k) ) + 
         !                         0.5_r8 * ( qt0(km)  +  qt0top(km) ) * ( p0(km)  - ps0(km) ) ) / ( p0(km) - p0(k) )
         !                tmp3 =   0.5_r8 * ( rho0bot(k) + rho0top(km) )                  
         !                dpi  = p0(km) - p0(k)
         !            endif
         !            tkePBLorgDN = tkePBLorgDN + dpi * ( cmf_d(km) * w_d(km) / ( 2._r8 * tmp3 ) )
         !            thlPBLorgDN = thlPBLorgDN + dpi * ( thl_d(km) - tmp1 )
         !            qtPBLorgDN  = qtPBLorgDN  + dpi * ( qt_d(km)  - tmp2 )
         !        endif
         !        ! -------------------------------------------------------------------------- !
         !        ! Compute the contribution of evaporation of precipitation within the PBL    !
         !        ! Note that similar to the evaporation within downdraft, I did not use 'dt'  !
         !        ! but used 'dz0(k) / vfall_rain' and 'dz0(k) / vfall_snow'. This is very     !
         !        ! important to remove sensitivity to time resolution, and is also physically !
         !        ! reasonable.                                                                ! 
         !        ! -------------------------------------------------------------------------- !
         !        if( k .le. kpblhm ) then
         !            tmp1 =   ( evprain(k) / vfall_rain + evpsnow(k) / vfall_snow ) * dz0(k)
         !            tmp2 = - ( xlv * evprain(k) / vfall_rain + xls * evpsnow(k) / vfall_snow ) / ( cp * exn0(k) ) * dz0(k)
         !            qtPBLorgEV  = qtPBLorgEV  + dpi * tmp1  
         !            thlPBLorgEV = thlPBLorgEV + dpi * tmp2
         !            tmp3 = - ( ( t0(k) / exn0(k) ) * zvir * tmp1 + ( 1._r8 + zvir * qv0(k) - ql0(k) - qi0(k) ) * tmp2 ) * ( g / thv0(k) )
         !            tkePBLorgEV = tkePBLorgEV + 0.5_r8 * tmp3 * ( ps0(0) - ps0(k) )**2._r8
         !        endif 
         !     enddo

         !    tkePBLorgDN = tkePBLorgDN / pblhp
         !    thlPBLorgDN = thlPBLorgDN / pblhp
         !    qtPBLorgDN  = qtPBLorgDN  / pblhp
         !    tkePBLorgEV = tkePBLorgEV / pblhp
         !    thlPBLorgEV = thlPBLorgEV / pblhp
         !    qtPBLorgEV  = qtPBLorgEV  / pblhp
         !    tkePBLorg   = tkePBLorgDN + tkePBLorgEV
         !    thlPBLorg   = thlPBLorgDN + thlPBLorgEV
         !    qtPBLorg    = qtPBLorgDN  + qtPBLorgEV
     
         ! Jun.30.2011. Below only consider the lowest model layer.

         !    if( evprain(1) + evpsnow(1) .gt. nonzero ) then
         !        tmp1 = ( 1._r8 / am_evp(1) - 1._r8 )
         !    else
         !        tmp1 = 0._r8
         !    endif

         !    tmp1 = 1._r8

         !    qtPBLorgDN   = qtten_d(1) * dt 
         !    thlPBLorgDN  = slten_d(1) / ( cp * exn0(1) ) * dt
         !    qtPBLorgEV   =   ( evprain(1) + evpsnow(1) ) * dt 
         !    thlPBLorgEV  = - ( xlv * evprain(1) + xls * evpsnow(1) ) / ( cp * exn0(1) ) * dt
         !    tkePBLorgDN  =   ( cmf_d(1) * w_d(1) + cmf_d(0) * w_d(0) ) / ( 4._r8 * rho0(1) )
         !    tkePBLorgEV  =   0._r8 
         !    tkePBLorg    = tkePBLorgDN + tkePBLorgEV
         !    thlPBLorg    = tmp1 * ( thlPBLorgDN + thlPBLorgEV )
         !    qtPBLorg     = tmp1 * ( qtPBLorgDN  +  qtPBLorgEV )
         
         ! ------------------------------------------------------------------ !
         ! Computation of updated organization-related variables              !
         ! Jun.28.2011. Change to the precipitation flux at the PBL top.      !
         ! Jun.30.2011. Add organization-derived perturbations within PBL.    !
         ! ------------------------------------------------------------------ !

         ! cu_prep_mxen(iter)      = flxrain(0) + flxsnow(0)
         !d   cu_prep_mxen(iter)      = flxrain(kpblhm) + flxsnow(kpblhm)
         ! Jul.13.2011. As a semi-final configuration, I am inserting 'wa_d(0)' to 'cu_tkePBLorg_out'
         !              based on a simple-Bernulli principle.
         !              We can choose either 'wa_d(0)' ( area-weighted ) or 'w_d(0)' ( mass-flux weighted ) 
         !              in the below cu_thlPBLorg_out. For consistency with 'cu_thlr, cu_qtr' which are
         !              mass-flux weighted average, it may be good to use 'w_d(0)' but even in this case
         !              we cannot impose a full consistency between 'cu_thlr, cu_qtr' and 'w_d(0)' due to
         !              the contribution of non-zero f_srcrs(k,m,1) in computing 'cu_thlr, cu_qtr'. While
         !              this f_srcrs(k,m,1) is likely to be zero when surface buoyancy flux is positive, 
         !              it can be positive in the stable lowest layer. However, in the stable case, 
         !              oeganization is likely to be very small, so this would not be a big problem. 
         !              Additionally, considering Bernulli principle, it is much more reasonable to use
         !              area-weighted 'wa_d(0)', not the mass-flux weighted 'w_d(0)' for cu_tkePBLorg_out.    

         !d   cu_tkePBLorg_mxen(iter) = tkePBLorg
         !d   cu_cmfPBLorg_mxen(iter) = cmfPBLorg
         !d   cu_thlPBLorg_mxen(iter) = thlPBLorg
         !d   cu_qtPBLorg_mxen(iter)  =  qtPBLorg
         !d   cu_uPBLorg_mxen(iter)   =   uPBLorg
         !d   cu_vPBLorg_mxen(iter)   =   vPBLorg
         !d   if( kiss .eq. 0 ) then
         !d       cu_cmfu_mxen(iter)  = cmf_u(0)
         !d       cu_cmfd_mxen(iter)  = cmf_d(0)
         !d     ! ------------------------------------------------------------------- ! 
         !d     ! Refinement of cumulus organization                                  !
         !d     ! Apr.4.2011. I should choose appropriate option number for orgforce. !
         !d     !             The 'iorgforce' should be specified in the parameter.   !   
         !d     ! ------------------------------------------------------------------- !
         !d     ! cu_cmfd_mxen(iter)  = orgforce(iorgforce)
         !d     ! cu_cmfd_mxen(iter)  = cmf_d_sfcorg
         !d     ! cu_cmfd_mxen(iter)  = cmf_d(0)
         !d     ! if( ktop .le. 2 ) cu_cmfd_mxen(iter) = 0._r8
         !d   else
         !d       cu_cmfu_mxen(iter)  = cmf_u(1)
         !d       cu_cmfd_mxen(iter)  = cmf_d(1)
         !d       if( ktop .le. 3 ) cu_cmfd_mxen(iter) = 0._r8
         !d   endif

         ! --------------------------------------------------------------------------- !
         !                                                                             !    
         ! Compute Grid-Mean Tendencies without repartitioning and dissipation heating !
         !                                                                             !
         ! --------------------------------------------------------------------------- !

         ! ------------------------------------------------------------------- !
         ! Currently, no constraint is imposed on qvten(k), qlten(k), qiten(k).!
         ! But negative condensate will be treated in positive_moisture in     ! 
         ! the above subroutine.                                               !
         ! ------------------------------------------------------------------- ! 

         do k = 1, ktop

            slten_NUM(k) =   slten_u(k) +     slten_d(k) +   slten_evp(k)
            qtten_NUM(k) =   qtten_u(k) +     qtten_d(k) +   qtten_evp(k)                
            uten_NUM(k)  =    uten_u(k) +      uten_d(k) +    uten_evp(k)                              
            vten_NUM(k)  =    vten_u(k) +      vten_d(k) +    vten_evp(k)                              

            ! OPTION : Below two lines are new computation based on flux-convergence formula.
            ! Dec.13.2012. Wet deposition term is added. 
            qlten_NUM(k) =   qlten_u(k) +     qlten_d(k) +   qlten_evp(k)  
            qiten_NUM(k) =   qiten_u(k) +     qiten_d(k) +   qiten_evp(k)
            do mt = 1, ncnst
               trten_NUM(k,mt) = trten_u(k,mt) + trten_d(k,mt) + trten_evp(k,mt) + trten_wdep(k,mt)    
            enddo

            ! OPTION : Below two lines is the previous alternative choice based on detrainment-subsidence.
            ! qlten_NUM(k) = qlten_det(k) +   qlten_sub(k)
            ! qiten_NUM(k) = qiten_det(k) +   qiten_sub(k)

            ! qlten_NUM(k) = max( qlten_NUM(k), -ql0(k) / dt )
            ! qiten_NUM(k) = max( qiten_NUM(k), -qi0(k) / dt )

            qvten_NUM(k) = qtten_NUM(k) -       qlten_NUM(k) -       qiten_NUM(k)
            sten_NUM(k)  = slten_NUM(k) + xlv * qlten_NUM(k) + xls * qiten_NUM(k)

            ! CHECK
            ! if( get_nstep() .ge. 0 .and. get_nstep() .lt. 20000 ) then 
            !     write(6,*)
            !     write(6,*) 'UNICON: Computation of various tendencies'
            !     write(6,*) 'Time step & Layer Index: ', get_nstep(), k
            !     write(6,*) 'slten_u(k), qtten_u(k), qlten_u(k), qiten_u(k) = ', &
            !                 slten_u(k), qtten_u(k), qlten_u(k), qiten_u(k)
            !     write(6,*) 'slten_d(k), qtten_d(k), qlten_d(k), qiten_d(k) = ', &
            !                 slten_d(k), qtten_d(k), qlten_d(k), qiten_d(k)
            !     write(6,*) 'cmf_u(k-1), cmf_u(k), cmf_d(k-1), cmf_d(k) = ', &
            !                 cmf_u(k-1), cmf_u(k), cmf_d(k-1), cmf_d(k)
            !     write(6,*) 
            ! endif
            ! CHECK

         enddo

         ! ---------------------------------------------------------------------------------------- !
         ! Repartition the tendency in the lowest model layer                                       !
         ! into all the layers within the PBL or top of convection or whole atmospheric layer.      !
         ! It seems to be most reasonable to distribute to the whole convection layer.              !
         ! Note that the partition is done only for surface updraft flux not downdraft flux.        !
         ! Sep.12.2011. I double checked that my below 'ipartition' formula is perfect because      !
         !              (1) it conserves column-integrated energy, and (2) it completely remove     !
         !              the generation of unreasonable convective tendency in the lowest model      !
         !              layer by convection, so that it grauantees computation of reasonable        ! 
         !              surface heat, moisture, momentum, and tracer fluxes at surface in the       !  
         !              following surface flux computation routine in the CAM. Also, I don't        !
         !              need to modify any parts of CAM5 ( e.g., PBL scheme, surface flux           !
         !              routine ), since all the required modifications are contained in the        !
         !              UNICON in a fully reasonable way.                                           !
         !              By using 'ipartition = 1' option, I don't need to combine 'symmetric        !
         !              moist turbulence scheme' with the 'asymmetric moist turbulence scheme'      !
         !              within the implicit iteration loop, so that I can save tremendous amount    !    
         !              of computation time.                                                        !
         ! Oct.24.2011. For correct consistent output, I should also correct flux at each model     !
         !              interface, i.e., from each flux interface, I should subtract linear flux    !
         !              profile that is 'slflx_u(0)' at surface but 'zero' at k = ktop interface.   !
         ! Mar.19.2014. I should compute a similar non-zero partitioning tendency of 'ql,qi' below, !
         !              which is done on this day. In addition, I added the similar portion of      ! 
         !              convective downdraft fluxes in computing below partitioning tendencies.     !              
         !              Note that 'kpblhm >= 1' and 'iopt_partition = 2' might be more conceptually !
         !              consistent with the cold-pool formulation.                                  ! 
         ! ---------------------------------------------------------------------------------------- !


         if( iup_par .eq. 1 ) then             ! Lowest Layer - No Partitioning
             ktop_up_par = 1
         elseif( iup_par .eq. 2 ) then         ! Minimum of PBL Top and Cumulus Top
             ktop_up_par = min( kpblhm, ktop )
         elseif( iup_par .eq. 3 ) then         ! PBL Layers   
             ktop_up_par = kpblhm
         elseif( iup_par .eq. 4 ) then         ! Cumulus Layers
             ktop_up_par = ktop
         elseif( iup_par .eq. 5 ) then         ! Entire Layers
             ktop_up_par = mkx
         endif 

         if( idn_par .eq. 1 ) then             ! Lowest Layer - No Partitioning
             ktop_dn_par = 1
         elseif( idn_par .eq. 2 ) then         ! Minimum of PBL Top and Cumulus Top
             ktop_dn_par = min( kpblhm, ktop )
         elseif( idn_par .eq. 3 ) then         ! PBL Layers   
             ktop_dn_par = kpblhm
         elseif( idn_par .eq. 4 ) then         ! Cumulus Layers
             ktop_dn_par = ktop
         elseif( idn_par .eq. 5 ) then         ! Entire Layers
             ktop_dn_par = mkx
         endif 

         do k = ktop_up_par, 1, -1
            tmp2 = g / ( ps0(0) - ps0( ktop_up_par ) )
            slten_par(k) = - slflx_u(0) * tmp2
            qtten_par(k) = - qtflx_u(0) * tmp2
            uten_par(k)  = -  uflx_u(0) * tmp2
            vten_par(k)  = -  vflx_u(0) * tmp2
            qlten_par(k) = - qlflx_u(0) * tmp2
            qiten_par(k) = - qiflx_u(0) * tmp2
            do mt = 1, ncnst
               trten_par(k,mt) = - trflx_u(0,mt) * tmp2
            enddo
            ! -------------------------------------------------------------------------- !
            ! Oct.24.2011. Added below block for diagnostic 'ipartition' flux output.    !
            !              Note that below correction does not change simulation output. !
            ! Mar.20.2014. Note that fluxes at the surface are printed-out as non-zero   !
            !              purely for the diagnostic purpose. However, in the numerical  !
            !              computation they are treated to be zero with partitioning.    !  
            ! -------------------------------------------------------------------------- ! 
            tmp1         =   ( ps0(k) - ps0( ktop_up_par ) ) / ( ps0(0) - ps0( ktop_up_par ) )
            slflx_u(k)   =   slflx_u(k) - slflx_u(0) * tmp1
            qtflx_u(k)   =   qtflx_u(k) - qtflx_u(0) * tmp1
            uflx_u(k)    =    uflx_u(k) -  uflx_u(0) * tmp1
            vflx_u(k)    =    vflx_u(k) -  vflx_u(0) * tmp1
            qlflx_u(k)   =   qlflx_u(k) - qlflx_u(0) * tmp1
            qiflx_u(k)   =   qiflx_u(k) - qiflx_u(0) * tmp1
            do mt = 1, ncnst
               trflx_u(k,mt) = trflx_u(k,mt) - trflx_u(0,mt) * tmp1
            enddo
         enddo

         do k = ktop_dn_par, 1, -1
            tmp2 = g / ( ps0(0) - ps0( ktop_dn_par ) )
            slten_par(k) = slten_par(k) - slflx_d(0) * tmp2
            qtten_par(k) = qtten_par(k) - qtflx_d(0) * tmp2
            uten_par(k)  =  uten_par(k) -  uflx_d(0) * tmp2
            vten_par(k)  =  vten_par(k) -  vflx_d(0) * tmp2
            qlten_par(k) = qlten_par(k) - qlflx_d(0) * tmp2
            qiten_par(k) = qiten_par(k) - qiflx_d(0) * tmp2
            do mt = 1, ncnst
               trten_par(k,mt) = trten_par(k,mt) - trflx_d(0,mt) * tmp2
            enddo
            ! -------------------------------------------------------------------------- !
            ! Oct.24.2011. Added below block for diagnostic 'ipartition' flux output.    !
            !              Note that below correction does not change simulation output. !
            ! Mar.20.2014. Note that fluxes at the surface are printed-out as non-zero   !
            !              purely for the diagnostic purpose. However, in the numerical  !
            !              computation they are treated to be zero with partitioning.    !  
            ! -------------------------------------------------------------------------- ! 
            tmp1         =   ( ps0(k) - ps0( ktop_dn_par ) ) / ( ps0(0) - ps0( ktop_dn_par ) )
            slflx_d(k)   =   slflx_d(k) - slflx_d(0) * tmp1
            qtflx_d(k)   =   qtflx_d(k) - qtflx_d(0) * tmp1
            uflx_d(k)    =    uflx_d(k) -  uflx_d(0) * tmp1
            vflx_d(k)    =    vflx_d(k) -  vflx_d(0) * tmp1
            qlflx_d(k)   =   qlflx_d(k) - qlflx_d(0) * tmp1
            qiflx_d(k)   =   qiflx_d(k) - qiflx_d(0) * tmp1
            do mt = 1, ncnst
               trflx_d(k,mt) = trflx_d(k,mt) - trflx_d(0,mt) * tmp1
            enddo
         enddo

         do k = max( ktop_up_par, ktop_dn_par ), 1, -1
            slten_NUM(k) =  slten_NUM(k) +   slten_par(k)
            qtten_NUM(k) =  qtten_NUM(k) +   qtten_par(k)
            uten_NUM(k)  =   uten_NUM(k) +    uten_par(k)
            vten_NUM(k)  =   vten_NUM(k) +    vten_par(k)
            qlten_NUM(k) =  qlten_NUM(k) +   qlten_par(k)
            qiten_NUM(k) =  qiten_NUM(k) +   qiten_par(k)
            qvten_NUM(k) =  qtten_NUM(k) -       qlten_NUM(k) -       qiten_NUM(k)
            sten_NUM(k)  =  slten_NUM(k) + xlv * qlten_NUM(k) + xls * qiten_NUM(k)
            do mt = 1, ncnst
               trten_NUM(k,mt) = trten_NUM(k,mt) + trten_par(k,mt)
            enddo        
         enddo

         ! -------------------------------------------------------------------------- !
         ! Reset surface flux to be zero for column energy conservation.              !
         ! I commented-out below lines for looking at the detailed diagnostic output. !
         ! Note that this resetting does not influence numerical computation at all.  !
         ! Oct.24.2011. I restored below block for correct diagnostic output.         !
         ! Mar.19.2014. I added downdraft portition with the ipartition=1 condition   !
         !              and also 'ql,qi' portions.                                    !
         !              However, I commented-out below block on this day to see the   !
         !              actual non-zero convective fluxes at the surface.             !
         ! -------------------------------------------------------------------------- !
    !par if( ipartition .eq. 1 .and. kiss .eq. 0 ) then 
    !par     slflx_u(0) =  0._r8
    !par     qtflx_u(0) =  0._r8
    !par     uflx_u(0)  =  0._r8
    !par     vflx_u(0)  =  0._r8
    !par     qlflx_u(0) =  0._r8
    !par     qiflx_u(0) =  0._r8
    !par     do mt = 1, ncnst
    !par        trflx_u(0,mt) = 0._r8
    !par     enddo
    !par     slflx_d(0) =  0._r8
    !par     qtflx_d(0) =  0._r8
    !par     uflx_d(0)  =  0._r8
    !par     vflx_d(0)  =  0._r8
    !par     qlflx_d(0) =  0._r8
    !par     qiflx_d(0) =  0._r8
    !par     do mt = 1, ncnst
    !par        trflx_d(0,mt) = 0._r8
    !par     enddo
    !par endif

         ! ----------------------------------------------------------------------------------------- !
         ! Breaking through the CFL constraint with full conservation of column energy and moisture. !
         ! This is a critical process to reduce sensitivity to vertical resolution and to obtain     !
         ! stable solutions regardless of 'dp0(k)' and 'dt'                                          !
         ! ----------------------------------------------------------------------------------------- !

         ! ------------------------------------------------ !
         ! 1. Compute CFL-satisfying tendency in each layer !
         ! ------------------------------------------------ !

         !a   do k = 1, ktop
         !a      km = k - 1 
         !a      kp = k + 1
         !a      mass_adi = cmf_r(k) + cmf_u(k) + cmf_d(km) 
         !a      CFL = g * mass_adi * dt / dp0(k)
         !a    ! OPTION
         !a    ! CFL = min( 1.0_r8, CFL )
         !a    ! OPTION
         !a      CFL_out(i,k) = CFL 
         !a      do ivar = 1, 6
         !a         if( ivar .eq. 1 ) then
         !a             va_i   =   thl0(k)
         !a             cc     = ( slten_evp(k) + slten_par(k) ) / ( cp * exn0(k) )
         !a             va_adi = ( cmf_r(k) * thl_r(k) + cmf_u(k) * thl_env_ua(k) + cmf_d(km) * thl_env_da(k) ) / max( mass_adi, nonzero )   
         !a         elseif ( ivar .eq. 2 ) then
         !a             va_i   =   qt0(k)
         !a             cc     =   qtten_evp(k) + qtten_par(k)
         !a             va_adi = ( cmf_r(k) * qt_r(k) + cmf_u(k) * qt_env_ua(k) + cmf_d(km) * qt_env_da(k) ) / max( mass_adi, nonzero )   
         !a         elseif ( ivar .eq. 3 ) then
         !a             va_i   =   u0(k)
         !a             cc     =   uten_PGF(k)
         !a             va_adi = ( cmf_r(k) * u_r(k)  + cmf_u(k) *  u_env_ua(k) + cmf_d(km) *  u_env_da(k) ) / max( mass_adi, nonzero )   
         !a         elseif ( ivar .eq. 4 ) then
         !a             va_i   =   v0(k)
         !a             cc     =   vten_PGF(k)
         !a             va_adi = ( cmf_r(k) * v_r(k)  + cmf_u(k) *  v_env_ua(k) + cmf_d(km) *  v_env_da(k) ) / max( mass_adi, nonzero )   
         !a         elseif ( ivar .eq. 5 ) then
         !a             va_i   =   ql0(k)
         !a             cc     =   qlten_par(k)
         !a             va_adi = ( cmf_r(k) * ql_r(k) + cmf_u(k) * ql_env_ua(k) + cmf_d(km) * ql_env_da(k) ) / max( mass_adi, nonzero )   
         !a         elseif ( ivar .eq. 6 ) then
         !a             va_i   =   qi0(k)
         !a             cc     =   qiten_par(k)
         !a             va_adi = ( cmf_r(k) * qi_r(k) + cmf_u(k) * qi_env_ua(k) + cmf_d(km) * qi_env_da(k) ) / max( mass_adi, nonzero )   
         !a         endif
         !a         va_dia = dt * cc / max( CFL, nonzero )     
         !a         va_ext = va_adi + va_dia 
         !a         if( CFL .gt. 1.e-3_r8 ) then
         !a             va_f = exp(-CFL) * va_i + ( 1._r8 - exp(-CFL) ) * va_ext  
         !a         else
         !a             va_f = va_i + ( va_adi - va_i ) * CFL + cc * dt
         !a         endif
         !a         va_ten = ( va_f - va_i ) / dt
         !a         if( ivar .eq. 1 ) then
         !a             slten_CFL(k) = cp * exn0(k) * va_ten
         !a         elseif( ivar .eq. 2 ) then
         !a             qtten_CFL(k) = va_ten
         !a         elseif( ivar .eq. 3 ) then
         !a             uten_CFL(k)  = va_ten
         !a         elseif( ivar .eq. 4 ) then
         !a             vten_CFL(k)  = va_ten
         !a         elseif( ivar .eq. 5 ) then
         !a             qlten_CFL(k) = va_ten
         !a         elseif( ivar .eq. 6 ) then
         !a             qiten_CFL(k) = va_ten
         !a         endif
         !a      enddo
         !a   enddo

         ! ---------------------------------------------------------------------------- !
         ! 2. Compute 'Energy-Moisture-Conservating' corrective tendency in each layer  !
         !    This corrective tendency is height-independent ( uniform ) within the     !
         !    convective layers ( 1 <= k <= ktop ) and zero above ( k > ktop ).         !
         !    This is performed only for conservative scalars 'sl,qt,u,v' not the       !
         !    non-conservative scalars 'ql,qi' since we don't need to conserve column-  !
         !    integrated 'ql,qi'.                                                       ! 
         ! ---------------------------------------------------------------------------- !
 
         !a   tmp1 = 0._r8
         !a   do k = 1, ktop
         !a      tmp1 = tmp1 + ( slten_NUM(k) - slten_CFL(k) ) * dp0(k)
         !a   enddo
         !a   tmp1 = tmp1 / ( ps0(0) - ps0( ktop ) )
         !a   slten_EMC(1:ktop) = tmp1     

         !a   tmp1 = 0._r8
         !a   do k = 1, ktop
         !a      tmp1 = tmp1 + ( qtten_NUM(k) - qtten_CFL(k) ) * dp0(k)
         !a   enddo
         !a   tmp1 = tmp1 / ( ps0(0) - ps0( ktop ) )
         !a   qtten_EMC(1:ktop) = tmp1     
         
         !a   tmp1 = 0._r8
         !a   do k = 1, ktop
         !a      tmp1 = tmp1 + ( uten_NUM(k) - uten_CFL(k) ) * dp0(k)
         !a   enddo
         !a   tmp1 = tmp1 / ( ps0(0) - ps0( ktop ) )
         !a   uten_EMC(1:ktop) = tmp1     

         !a   tmp1 = 0._r8
         !a   do k = 1, ktop
         !a      tmp1 = tmp1 + ( vten_NUM(k) - vten_CFL(k) ) * dp0(k)
         !a   enddo
         !a   tmp1 = tmp1 / ( ps0(0) - ps0( ktop ) )
         !a   vten_EMC(1:ktop) = tmp1     

         ! ---------------------------------------------------------------------------- !
         ! 3. Compute final analytical tendency that overcome CFL constraints and       !
         !    at the same time conserve column-integrated energy and moisture.          !
         ! ---------------------------------------------------------------------------- !

         !a   do k = 1, ktop
         !a      slten_ANA(k) = slten_CFL(k) + slten_EMC(k)
         !a      qtten_ANA(k) = qtten_CFL(k) + qtten_EMC(k)
         !a      uten_ANA(k)  =  uten_CFL(k) +  uten_EMC(k)
         !a      vten_ANA(k)  =  vten_CFL(k) +  vten_EMC(k)
         !a      qlten_ANA(k) = qlten_CFL(k) + qlten_EMC(k)
         !a      qiten_ANA(k) = qiten_CFL(k) + qiten_EMC(k)
         !a      qvten_ANA(k) = qtten_ANA(k) -       qlten_ANA(k) -       qiten_ANA(k)
         !a      sten_ANA(k)  = slten_ANA(k) + xlv * qlten_ANA(k) + xls * qiten_ANA(k)
         !a   enddo

         ! ---------------------------------------------------------------------- !
         ! Choose either 'NUMerial' or 'ANAlytical' tendency as a final tendency. !
         ! ---------------------------------------------------------------------- !

         ! Feb.06.2013. Always choose numerical tendency ( itendency .eq. 0 ) and remove 
         !              the other option as of this day.

         !a   if( itendency .eq. 0 ) then
         slten(:mkx) = slten_NUM(:mkx)
         qtten(:mkx) = qtten_NUM(:mkx)
         uten(:mkx)  =  uten_NUM(:mkx)
         vten(:mkx)  =  vten_NUM(:mkx)
         qlten(:mkx) = qlten_NUM(:mkx)
         qiten(:mkx) = qiten_NUM(:mkx)
         qvten(:mkx) = qvten_NUM(:mkx)
         sten(:mkx)  =  sten_NUM(:mkx)
         do mt = 1, ncnst
            trten(:mkx,mt) = trten_NUM(:mkx,mt)
         enddo
         !a   else
         !a       slten(:mkx) = slten_ANA(:mkx)
         !a       qtten(:mkx) = qtten_ANA(:mkx)
         !a       uten(:mkx)  =  uten_ANA(:mkx)
         !a       vten(:mkx)  =  vten_ANA(:mkx)
         !a       qlten(:mkx) = qlten_ANA(:mkx)
         !a       qiten(:mkx) = qiten_ANA(:mkx)
         !a       qvten(:mkx) = qvten_ANA(:mkx)
         !a       sten(:mkx)  =  sten_ANA(:mkx)
         !a   endif

         ! Mar.27.2012. Below computation of dissipation heating should be done after 
         !              computing 'cuorg' ensemble mean computation since below 
         !              dissipation heating is a non-linear function of flux.
         !              This wss the source of energy conservation error when 
         !              we choose 'niter = 2'.
         !              Today, I fixed this.

         ! --------------------------------------------------------------------------- !
         ! Compute diabatic tendency associated with KE dissipative heating            !
         ! In contrast to local symmetric turbulence scheme, KE dissipative heating by !
         ! nonlocal asymmetric turbulence (i.e., convection scheme)                    !
         ! can be either positive or negative.                                         !
         ! In order to suppress energy conservation error, this should be done here at !
         ! the end after choosing 'NUM' or 'ANA'.                                      ! 
         ! --------------------------------------------------------------------------- !
         ! do k = 1, ktop
         !    uf(k) = u0(k) + uten(k) * dt
         !    vf(k) = v0(k) + vten(k) * dt
         ! enddo
         ! ------------------------------------------------------------------------- !
         ! Reconstruct momemtum flux from the reconstructed uten_u(k) and uten_d(k)  !
         ! and vten_u(k) and vten_d(k) associated with ipartition = 1.               !
         ! Sep.12.2011. I should re-check whether below formula corretly incorporate !
         !              the 'ipartition = 1' effect. However, probably below is      !
         !              correct since it seems that now I can trust myself with      !
         !              reasonable amount of confidence.                             !  
         ! ------------------------------------------------------------------------- !
         ! do k = 1, ktop
         !    km = k - 1
         !    uflx(k) = uflx(km) - uten(k) * ( dp0(k) / g )
         !    vflx(k) = vflx(km) - vten(k) * ( dp0(k) / g )
         ! end do
         ! ----------------------------------------------------- !
         ! Add dissipation heating to the final heating tendency !
         ! ----------------------------------------------------- !
         ! do k = 1, ktop
         !    kp = k + 1
         !    km = k - 1 
         !    if( k .eq. 1 ) then
         !        sten_dis(k) = - g / 4._r8 * ( &
         !                        uflx(k)   * ( uf(kp) - uf(k) + u0(kp) - u0(k) ) / dps0(k) + & 
         !                        vflx(k)   * ( vf(kp) - vf(k) + v0(kp) - v0(k) ) / dps0(k) )
         !    elseif( k .ge. 2 .and. k .le. ktop - 1 ) then
         !        sten_dis(k) = - g / 4._r8 * ( &
         !                        uflx(k)   * ( uf(kp) -  uf(k) + u0(kp) -  u0(k) ) /  dps0(k) + &
         !                        uflx(km)  * (  uf(k) - uf(km) +  u0(k) - u0(km) ) / dps0(km) + &
         !                        vflx(k)   * ( vf(kp) -  vf(k) + v0(kp) -  v0(k) ) /  dps0(k) + &
         !                        vflx(km)  * (  vf(k) - vf(km) +  v0(k) - v0(km) ) / dps0(km) )
         !    elseif( k .eq. ktop ) then
         !        sten_dis(k) = - g / 4._r8 * ( &
         !                        uflx(km)  * ( uf(k) - uf(km) + u0(k) - u0(km) ) / dps0(km) + &
         !                        vflx(km)  * ( vf(k) - vf(km) + v0(k) - v0(km) ) / dps0(km) )
         !    endif
         !    slten_dis(k) = sten_dis(k)
         !    qtten_dis(k) = 0._r8 
         !    uten_dis(k)  = 0._r8
         !    vten_dis(k)  = 0._r8
         !    qvten_dis(k) = 0._r8
         !    qlten_dis(k) = 0._r8
         !    qiten_dis(k) = 0._r8
         !    do mt = 1, ncnst
         !       trten_dis(k,mt) = 0._r8 
         !    enddo
         !    slten(k)     = slten(k) + slten_dis(k)
         !    sten(k)      = sten(k)  +  sten_dis(k)
         ! enddo

         ! ------------------------------------------------------------------------------------- !
         ! Prevent negative tracers by adjusting convective fluxes                               !
         ! Following uwshcu.F90, I can construct this routine. However, since                    !
         ! (1) 'positive_aerosol' will be performed later and (2) tracers have diabatic forcing, !
         ! I will not do this here. But I can include this later, if necessary.                  !
         ! ------------------------------------------------------------------------------------- !

         ! ----------------------------------------------------------------------------------- !
         ! Save '_mxen' variables associated with multiple mixing environmental airs.          !
         ! Aug.01.2011. Brian Juwon Park's 10th Birthday.                                      !
         !              The explicit ensemble mixing process 'iter' routine are included here. !
         !              I have a hunch that this is the remaining final process I should       !
         !              implement into the UNICON.                                             !
         ! ----------------------------------------------------------------------------------- !

         cmf_u_mxen(0:mkx,iter)                   =                   cmf_u(0:mkx)
         cmf_d_mxen(0:mkx,iter)                   =                   cmf_d(0:mkx)
         slflx_u_mxen(0:mkx,iter)                 =                 slflx_u(0:mkx)
         slflx_d_mxen(0:mkx,iter)                 =                 slflx_d(0:mkx)
         qtflx_u_mxen(0:mkx,iter)                 =                 qtflx_u(0:mkx)
         qtflx_d_mxen(0:mkx,iter)                 =                 qtflx_d(0:mkx)
         uflx_u_mxen(0:mkx,iter)                  =                  uflx_u(0:mkx)
         uflx_d_mxen(0:mkx,iter)                  =                  uflx_d(0:mkx)
         vflx_u_mxen(0:mkx,iter)                  =                  vflx_u(0:mkx)
         vflx_d_mxen(0:mkx,iter)                  =                  vflx_d(0:mkx)

         ! Aug.15.2011. Add downdraft flux associated with convective organization

         flxrain_u_mxen(0:mkx,iter)               =                 flxrain(0:mkx)
         flxsnow_u_mxen(0:mkx,iter)               =                 flxsnow(0:mkx)

         !d   slflx_d_org_mxen(0:mkx,iter)             =             slflx_d_org(0:mkx)
         !d   qtflx_d_org_mxen(0:mkx,iter)             =             qtflx_d_org(0:mkx)

         ! ------------------------------------------------------------------------------------------------------------------------------------------- !
         ! Aug.31.2011. Add downdraft flux at the PBL top interface associated with convective organization                                            !
         !              in order to parameterize density current and convective organization.                                                          !
         ! Sep.07.2011. Compute total organization densitiy current forcing of conservative scalars and thv                                            !
         !              for the difference between non-wake area and grid-mean.                                                                        ! 
         !              Include not only adiabatic forcing but also diabatic forcing both within convective                                            !
         !              downdraft and environment. Also change the variable name from 'thlflx_d_org_pblh_mxen'                                         !
         !              to 'thl_orgforce_mxen' to denote that it includes all adiabatic and diabatic forcings.                                         !
         !              CAREFUL CONSIDERATION : Also impose a constraint based on the sign of total buoyancy forcing, if necessary.                    !
         !              Below is overall forcing averaged over the PBL.                                                                                !    
         !              The sum of below 3 should be positive in order to generate negative 'thv' anomaly within wake area or                          !
         !              equivalently, positive 'thv' anomaly within the non-wake area.                                                                 !
         ! 1. Adiabatic forcing                             : thvflx_d_org_pblh * g / pblhp                                                 [ K / s ]  !
         ! 2. Diabatic  forcing within convective downdraft : thl_dia_d_org * ( 1._r8 + zvir * qt0PBL ) + zvir * thl0PBL * qt_dia_d_org     [ K / s ]  !
         ! 3. Diabatic  forcing within environment          : thl_dia_env_org * ( 1._r8 + zvir * qt0PBL ) + zvir * thl0PBL * qt_dia_env_org [ K / s ]  !
         !                                                                                                                                             !
         ! Sep.07.2011. I also included 'inverse tau' into the mxen array in the below block.                                                          !
         !              Here, 'cd_' is non-dimensional darg coefficient for each conservative scalar and 'ws' is wind speed in the lowest model layer. !
         !              Temporarily, these drag coefficients are set to zero but we can include this component later.                                  !  
         !              Note that 'awk_' should not have this drag component since vertical mass exchange does not occur between the surface and       !
         !              atmosphere.                                                                                                                    !
         !              ( Example ) Fs [J/s/m2] = rho * cp * cd_thl * ws1 * ( Ts - thl0(1) ). Thus, if we know Ts, we can back up 'cd_thl'.            !
         ! Sep.07.2011. Instead of setting to zero, let's use a certain characteristic value of cd = 1.5e-3 for all scalars.                           !
         !              The ;thv' is not prognosed anymore for full consistency.                                                                       !
         ! ------------------------------------------------------------------------------------------------------------------------------------------- !

         ! -------------------------------------------- !
         !                                              !
         ! Computation of all the wake-related forcings !
         !                                              ! 
         ! -------------------------------------------- ! 
   
         ! -------------------------------------------------------------------------------- ! 
         ! 1. Grid-mean adiabatic forcing at the PBL top interface by convective downdraft. !
         !    The resulting units area fluxes not the tendency. Thus, we should multiply    !
         !   'g / pblhp' to get the final tendency ( e.g., [ K / s ] ) averaged over PBL.   !
         !    Sep.10.2011. Below block is removed since these are computed above by         !
         !                 selective choose convective downdraft elements.                  !
         ! -------------------------------------------------------------------------------- !
         
         ! cmf_d_org_pblh          =      cmf_d(kpblhm)
         ! thlflx_d_org_pblh       =    slflx_d(kpblhm) / cp / exns0(kpblhm)
         ! qtflx_d_org_pblh        =    qtflx_d(kpblhm)
         ! uflx_d_org_pblh         =     uflx_d(kpblhm)
         ! vflx_d_org_pblh         =     vflx_d(kpblhm)
         ! do mt = 1, ncnst
         !    trflx_d_org_pblh(mt) = trflx_d(kpblhm,mt)
         ! enddo

         ! -------------------------------------------------------------------------------------------------------------------- !
         ! 2. Differential diabatic forcing between 'non-wake' and 'all over the grid'.                                         !                                      
         !    ONLY WITHIN convective updraft and downdraft ( ['a_nw*Q_nw'/a_nw - 'grid-mean Q']_only_within_updraft_downdraft ) !
         !    NOT  WITHIN environmental portions of 'non-wake' and 'all over the grid'.                                         !
         !    The 'und' denotes 'updraft and downdraft' in contrast to 'env' which denotes environment.                         ! 
         !    Note that we should not include 'momentum forcing' here since 'momentum C' is conversion not diabatic forcing.    !
         !    The resulting units are [ kg / kg / s ], [ K / s ], [ # / kg / s ] or [ kg / kg / s ].                            !
         !    Sep.10.2011. Below block is alternatively chosen for using selectively chosen convective downdraft instead of     !
         !                 all convective downdrafts.                                                                           !
         !    Sep.13.2011. Through rigorous methematical derivation, I double-checked that                                      !
         !                 Below is always valid regardless whether I choose all convective downdraft or selective downdraft.   !
         ! -------------------------------------------------------------------------------------------------------------------- !
     
         qt_dia_und_org           = 0._r8 
         thl_dia_und_org          = 0._r8
         tr_dia_und_org(1:ncnst)  = 0._r8  
         tmp2                     = awk_PBL / ( 1._r8 - awk_PBL )

         do k = 1, kpblhm
            qt_dia_und_org        =     qt_dia_und_org + dp0(k) * ( tmp2 *   qtten_dia_u(k) ) 
            thl_dia_und_org       =    thl_dia_und_org + dp0(k) * ( tmp2 *  thlten_dia_u(k) ) 
            do mt = 1, ncnst
               ! Nov.29.2012. I should use dptr0(k,mt) instead of dp0(k) in the below line.
               !              However, since 'pblhp' is used, I should keep 'dp0(k)'.
               !              In future, I should define 'pblhp_tr' and should use dptr0(k,mt).  
               tr_dia_und_org(mt) = tr_dia_und_org(mt) + dp0(k) * ( tmp2 * ( trten_dia_u(k,mt) + trten_eff_u(k,mt) ) )
            enddo
         enddo
         qt_dia_und_org           =     qt_dia_und_org / pblhp  -     qt_dia_d_org
         thl_dia_und_org          =    thl_dia_und_org / pblhp  -    thl_dia_d_org
         do mt = 1, ncnst
            tr_dia_und_org(mt)    = tr_dia_und_org(mt) / pblhp  - tr_dia_d_org(mt)  
         enddo

         ! Below block is old before Sep.10.2011 choosing all the convective downdrafts.
         ! tmp2                     = awk_PBL / ( 1._r8 - awk_PBL )
         ! do k = 1, kpblhm
         !    qt_dia_und_org        =     qt_dia_und_org + dp0(k) * ( tmp2 *   qtten_dia_u(k) -  qtten_dia_d(k) ) 
         !    thl_dia_und_org       =    thl_dia_und_org + dp0(k) * ( tmp2 *  thlten_dia_u(k) - thlten_dia_d(k) ) 
         !    do mt = 1, ncnst
         !       tr_dia_und_org(mt) = tr_dia_und_org(mt) + dp0(k) * ( tmp2 * ( trten_dia_u(k,mt) + trten_eff_u(k,mt) ) - ( trten_dia_d(k,mt) + trten_eff_d(k,mt) ) )
         !    enddo
         ! enddo
         ! qt_dia_und_org           =     qt_dia_und_org / pblhp
         ! thl_dia_und_org          =    thl_dia_und_org / pblhp
         ! do mt = 1, ncnst
         !    tr_dia_und_org(mt)    = tr_dia_und_org(mt) / pblhp
         ! enddo

         ! ------------------------------------------------------------------------------------------------------------- !
         ! 2. Differential diabatic forcing between 'non-wake' and 'all over the grid'                                   !               
         !    ONLY WITHIN environmental portions of 'non-wake' and 'all over the grid'.                                  !
         !    This is caused by two processes : (1) evaporation of precipitation within environment,                     !
         !                                      (2) snow melting                 within environment.                     !
         !    The corrective tendendies 'cev' is inevitable assumed to occur uniformly all over the grid                 ! 
         !    and so does not contribute here.                                                                           !
         !    Note als that I am assuming dissipative heating is uniformly distributed all over the grid                 !
         !    and so does not contribute here.                                                                           !
         !    The resulting units are [ kg / kg / s ], [ K / s ], [ # / kg / s ] or [ kg / kg / s ].                     !
         !    Below 'tmp2' is from the the assumption of homogeneous distribution.                                       !
         !    tmp2 = - ( awk_PBL / ( 1._r8 - awk_PBL ) ) * ( am_u(k) / ( 1._r8 - am_u(k) )                               !
         !    Here, 'a_evp_wk' is overlapping area between 'evaporation area' and 'wake area'. Similar to the            !
         !    overlapping treatment between precipitation area and updraft fractional area, I am using additional        !
         !    tilting parameter to control the overlap between evaporation area ( am_evp(k) ) and wake area ( awk_PBL ). !
         !    Note that 'beta1' is likely to be related to 'beta2'.                                                      !
         !    Rigorously speaking, since below formula is explicitly using a_p_prevp(k), below treatment of snow melting !
         !    is only valid if 'i_snowmlt = 0' and so all snow melting occurs before evaporation within downdraft (      !  
         !    thus 'snowmlt(k) = 0' but 'snowmlt_e(k) > 0 ' )                                                            !
         !    However, since I will choose 'i_snowmlt = 0' as a default forever, below treatment is completely correct.  !
         !    Sep.09.2011. I checked couple of times that below formula is completely correct.                           !
         !                 Note that snow melting does not influence the tracers.                                        ! 
         !    Sep.13.2011. I newly define 'am_evp_wk' and 'am_p_wk' similar to the definition of 'a_p_u' that is using   !
         !                 beta.   This new formulation produces very similar but very slightly different results from   !
         !                 the previous one. Definitely, I should use the new one for full consistency between beta1 and !
         !                 beta2.                                                                                        !
         !    Oct.03.2011. Since 'am_p_wk' and 'tmp3' are used for partitioning snow melting and since snow melting was  !
         !                 computed before evaporation of precipitation within downdraft and environment, I should use   !
         !                 the 'a_p_prevp' not the 'a_p' in computing 'am_p_wk' and 'tmp3' below. Thus, my below code    !
         !                 is completely correct.                                                                        !                            
         ! ------------------------------------------------------------------------------------------------------------- !

         ! Feb.08.2013. Time to do here.
         !              I should impose a full cosistency in treating various fractional areas and associated evaporation
         !              within updraft and environment, and with wake and non-wake area. 
         !              The single kep constraint I should keep is that 'updraft always rises in the non-wake area'.
         !              Until now, I have neglected evaporation within convective updraft regardless whether it is 
         !              saturated or not. However, in order to impose a full macrophysical consistency, I may need to
         !              relax this assumption. However, this evaporation of precipitation within convective updraft may 
         !              cause negative precipitation flux during the 2nd accretion iteration loop. I should carefully
         !              this situation such that negative precipitation flux does not happen. However, the probability of
         !              the onset of negative precipitation flux is likely to be very small. Relatded to this, this
         !              evaporation of precipitation within convective updraft can be handled in a consistent way within
         !              the subroutine 'prod_prep_up', and the resulting evaporation-related quantities can be inserted
         !              into 'evp_qtl_au', which requires re-structuring of computation routine of 'evp_qtl_au' right
         !              after computing '_eff' instead of before '_eff'. By doing this, we can impose a final full consistency.                

         qt_dia_env_org           = 0._r8 
         thl_dia_env_org          = 0._r8
         tr_dia_env_org(1:ncnst)  = 0._r8  
         do k = 1, kpblhm
            ! Sep.13.2011. Below is new one similar to the previous 'a_p_u' using beta. 
            ! Mar.27.2012. I changed from 'maximum-minimum overlap' to 'maximum-random overlap', hoping to further delay 
            !              the diurnal cycle of convective precipitation at surface.
            ! Apr.05.2012. It is good to keep previous 'maximum-minimum' overlap for effectively and
            !              conceptualy clear development of wake.
            ! Below two lines are previous 'maximum(beta2=1)-minimum(beta2=0)' overlap.
            ! am_evp_nw             =  ( 1._r8 - beta2 ) * min( am_evp(k),    1._r8 - awk_PBL ) + beta2 * max( am_evp(k)    - awk_PBL, 0._r8 )
            ! am_p_nw               =  ( 1._r8 - beta2 ) * min( a_p_prevp(k), 1._r8 - awk_PBL ) + beta2 * max( a_p_prevp(k) - awk_PBL, 0._r8 )
            ! Below two lines are 'maximum(beta2=1)-random(beta2=0)' overlap.
            ! Feb.09.2013. 
            ! The formulation computing 'am_p_nw' is slightly revised since we know that 'am_pu(k)' is always in the -non-wake' area
            ! due to the assumption that convective updraft always rises in the wake area. This revised 'am_p_nw' influences the
            ! computation of 'tmp3' and partitioning of snow melting tendency ( snowmlt_e(k) ) between the wake and non-wake area.
            ! Note also that while some of precipitation area definitely overlap with updraft area ( am_pu(k) ), we are assuming that
            ! snow melting is occuring entirely within environment, which is perfectly OK assumption conservating energy and moisture.
            ! All the previous formulation are set up based on this assumption of snow melting entirely within the environment.
            ! Note also that in contrast to 'a_p(k)', none of 'am_evp(k)' exists in the updraft fractional area. Thus, below original
            ! computation of 'am_evp_nw' and related variables are completely OK and correct.
            am_evp_nw  = ( 1._r8 - beta2 ) * am_evp(k)      * ( 1._r8 - awk_PBL ) + beta2 * max( am_evp(k)    - awk_PBL, 0._r8 )
            am_p_nw    = am_pu(k) + (1._r8 - beta2)*(a_p(k) - am_pu(k))*(1._r8 - awk_PBL) + &
                                           beta2*max( a_p(k) - am_pu(k) - awk_PBL, 0._r8 )
            !j      am_p_nw               =  ( 1._r8 - beta2 ) * a_p(k)         * ( 1._r8 - awk_PBL ) + beta2 * max( a_p(k)       - awk_PBL, 0._r8 )
            !?      am_p_nw               =  ( 1._r8 - beta2 ) * a_p_prevp(k)   * ( 1._r8 - awk_PBL ) + beta2 * max( a_p_prevp(k) - awk_PBL, 0._r8 )
            ! Below two lines are new 'random(beta2=1)-minimum(beta2=0)' overlap.
            ! am_evp_nw             =  ( 1._r8 - beta2 ) * min( am_evp(k),    1._r8 - awk_PBL ) + beta2 * am_evp(k)    * ( 1._r8 - awk_PBL ) 
            ! am_p_nw               =  ( 1._r8 - beta2 ) * min( a_p_prevp(k), 1._r8 - awk_PBL ) + beta2 * a_p_prevp(k) * ( 1._r8 - awk_PBL )
            am_evp_wk             =  max( 0._r8, am_evp(k)    - am_evp_nw )
            am_p_wk               =  max( 0._r8, a_p(k)       -   am_p_nw )
            !?      am_p_wk               =  max( 0._r8, a_p_prevp(k) -   am_p_nw )
            ! Nov.20.2013. Below 'tmp2,tmp3' and associated 'qt_dia_env_org,thl_dia_env_org' did not produce correct results in the 
            !              limiting case of 'am_evp(k) --> 0' and 'a_p(k) --> 0'. Thus I revised on this day.
            ! Below is the old code.
            ! tmp2                  =  ( 1._r8 / ( 1._r8 - awk_PBL ) ) * ( am_evp_nw / max( am_evp(k),    nonzero ) - ( 1._r8 - awk_PBL ) )
            ! tmp3                  =  ( 1._r8 / ( 1._r8 - awk_PBL ) ) * ( am_p_nw   / max( a_p(k),       nonzero ) - ( 1._r8 - awk_PBL ) )     
            ! Below is the new code on Nov.20.2013.
            tmp2                  =  ( 1._r8 / ( 1._r8 - awk_PBL ) ) * ( am_evp_nw - am_evp(k) * ( 1._r8 - awk_PBL ) )
            tmp3                  =  ( 1._r8 / ( 1._r8 - awk_PBL ) ) * ( am_p_nw   - a_p(k)    * ( 1._r8 - awk_PBL ) )     
            !?      tmp3                  =  ( 1._r8 / ( 1._r8 - awk_PBL ) ) * ( am_p_nw   / max( a_p_prevp(k), nonzero ) - ( 1._r8 - awk_PBL ) )     
            ! Below is previous old one. 
            ! am_evp_wk             =  ( 1._r8 - beta2 ) * ( am_evp(k)    - min( am_evp(k),    1._r8 - awk_PBL ) ) + beta2 * min( am_evp(k),    awk_PBL )
            ! am_p_wk               =  ( 1._r8 - beta2 ) * ( a_p_prevp(k) - min( a_p_prevp(k), 1._r8 - awk_PBL ) ) + beta2 * min( a_p_prevp(k), awk_PBL )
            ! tmp2                  =  ( 1._r8 / ( 1._r8 - awk_PBL ) ) * ( awk_PBL -  am_evp_wk / max( am_evp(k),    nonzero ) )
            ! tmp3                  =  ( 1._r8 / ( 1._r8 - awk_PBL ) ) * ( awk_PBL -  am_p_wk   / max( a_p_prevp(k), nonzero ) )     
            !?      qt_dia_env_org        =    qt_dia_env_org  +   tmp2 * ( evprain(k) + evpsnow(k) ) * dp0(k)
            !?      thl_dia_env_org       =   thl_dia_env_org  + ( tmp2 * ( - xlv * evprain(k) - xls * evpsnow(k) ) + tmp3 * ( - ( xls - xlv ) * ( snowmlt(k) + snowmlt_e(k) ) ) ) / ( cp * exn0(k) ) * dp0(k)
            ! Nov.20.2013. Below 'tmp2,tmp3' and associated 'qt_dia_env_org,thl_dia_env_org' did not produce correct results in the 
            !              limiting case of 'am_evp(k) --> 0' and 'a_p(k) --> 0'. Thus I revised on this day.
            ! Below is the old code.
            ! qt_dia_env_org        =    qt_dia_env_org  +   tmp2 * ( evprain_e(k) + evpsnow_e(k) ) * dp0(k)
            ! thl_dia_env_org       =   thl_dia_env_org  + ( tmp2 * ( - xlv * evprain_e(k) - xls * evpsnow_e(k) ) + tmp3 * ( - ( xls - xlv ) * snowmlt_e(k) ) ) / ( cp * exn0(k) ) * dp0(k)
            ! Below is the new code on Nov.20.2013.
            qt_dia_env_org  =    qt_dia_env_org +  tmp2*( evprain_e(k) + evpsnow_e(k) ) / max( am_evp(k), nonzero ) * dp0(k)
            thl_dia_env_org =   thl_dia_env_org + (tmp2*(-xlv*evprain_e(k) - xls*evpsnow_e(k))/max(am_evp(k),nonzero) + & 
                                                   tmp3*(-(xls-xlv)*snowmlt_e(k))/max(a_p(k),nonzero))/(cp*exn0(k))*dp0(k)

            ! Aug.08.2013. Add the contribution of the evaporation of stratiform precipitation within the PBL.
            !              The 'evprain_st(k)' and 'evpsnow_st(k)' are the grid-mean evaporation rates of stratiform rain and snow, respectively [kg/kg/s] >= 0.
            !              The melting of stratiform snow is not included yet (snowmlt_st(k) is set to zero) for simplicity, which can be included in future.
            !              Note that corresponding tendencies of tracers are simply neglected, in consistent with the current treatment of convective part, which
            !              can be included in future.
            am_evp_nw_st = (1._r8 - beta2_st)*am_evp_st(k)*(1._r8 - awk_PBL) + beta2_st*max( am_evp_st(k) - awk_PBL, 0._r8 )
            tmp2_st      =  ( 1._r8 / ( 1._r8 - awk_PBL ) ) * ( am_evp_nw_st - am_evp_st(k) * ( 1._r8 - awk_PBL ) )
            qt_dia_env_org  = qt_dia_env_org + tmp2_st*(evprain_st(k) + evpsnow_st(k)) / max( am_evp_st(k), nonzero ) * dp0(k)
            thl_dia_env_org = thl_dia_env_org + ( tmp2_st * ( - xlv * evprain_st(k) - xls * evpsnow_st(k) ) / &
                                                  max( am_evp_st(k), nonzero ) ) / ( cp * exn0(k) ) * dp0(k)
            ! End of Aug.08.2013

            do mt = 1, ncnst
               ! Nov.29.2012. I should use dptr0(k,mt) instead of dp0(k) in the below line.
               !              However, since 'pblhp' is used, I should keep 'dp0(k)'.
               !              In future, I should define 'pblhp_tr' and should use dptr0(k,mt).
               ! Dec.13.2012. Wet deposition term is added.
               tr_dia_env_org(mt) = tr_dia_env_org(mt) +   tmp2 * ( trten_evp(k,mt) + trten_wdep(k,mt) ) * dp0(k)
            enddo
         enddo
         qt_dia_env_org           =     qt_dia_env_org / pblhp 
         thl_dia_env_org          =    thl_dia_env_org / pblhp  
         do mt = 1, ncnst
            tr_dia_env_org(mt)    = tr_dia_env_org(mt) / pblhp
         enddo

         ! ---------------------------------------------------------------------------------- !
         ! Computation of total wake forcing and relaxation time scale                        !
         ! Sep.09.2011. Note that I don't need to impose any limitation based on the the sign !
         !              of buoyancy flux or forcing since now UNICON can generally handle all !
         !              of the cases of positive and negative buoyancy forcings.              ! 
         !              Note that I don't need to prognose 'thv' anymore since it will be     !
         !              computed diagnostically from the prognosed 'thl,qt' at the beginning  !
         !              of nex time step. This will impose a full consistency into the model. !   
         ! Sep.16.2011. Note that 'cdrag' should be further reduced in principle since the    !
         !              entrainment flux at the PBL top in the 'a_D' area will be reduced due !
         !              to enhanced stratification at the PBL top within 'a_D'.               !
         !              This reduced entrainment effect should be simulated by the 'cdrag'    !
         !              alone in the current UNICON. Thus, we should use smaller 'cdrag'      !
         !              than the common value of 1.5e-3. The use of small value will also     !
         !              improve the diurnal cycle.                                            !
         !              In addition, in order to reduce model sensitivity to the vertical     !
         !              resolution, we may dfine 'ws1' using the PBL-averaged wind instead of !
         !              the value in the lowest model layer. This should be considered in     !
         !              future.                                                               !        
         ! Dec.20.2012. Bug fix. In computing inverse relaxation time scale of conservative   !
         !              scalars (taui below) other than 'taui_awk_mxen', I should include     !
         !              the following below term which has a unit of [1/s] :                  !
         !               ( g / pblhp ) * max( 0._r8, cmf_d(kpblhm) - cmf_d_org_pblh ) : [1/s] !
         !              This correction will help to reduce simulated convective organization !
         !              due to the increase of damping effect. This is fully physically and   !
         !              conceptually consistent.                                              !
         ! Dec.20.2012. In addition, I also add entrainment rate at the PBL top interface,    !
         !              went_eff [m/s] as well as 'cmf_d(kpblhm) - cmf_d_org_pblh' in         !
         !              computing 'tmp3' below. Note that the unit of rho0(kpblhm) * went_eff !
         !              is [ kg / m2 / s ], same as the unit of the mass flux.                !
         ! ---------------------------------------------------------------------------------- !

         ! ------------------------ !
         ! 1. Relaxation Time Scale !
         ! ------------------------ !   

         tmp1           = ( g / pblhp )
         !m   tmp2           = rho0(1) / sqrt( rho0(1) * rho0(kpblhm) )
         !fix tmp3           = tmp1 * ( max( 0._r8, cmf_d(kpblhm) - cmf_d_org_pblh ) + rho0(kpblhm) * went_eff )
       ! May.1.2014. Correct budget of cold pool.
         if( i_budget_coldpool .eq. 0 ) then
             tmp3           = tmp1 * ( max( 0._r8, &
             cmf_d(kpblhm) - cmf_d_org_pblh ) - cmf_u(kpblhm) + rho0(kpblhm) * went_eff )
         elseif( i_budget_coldpool .eq. 3 ) then
             tmp3           = tmp1 * ( max( 0._r8, &
             cmf_d(kpblhm) - cmf_d_org_pblh ) + rho0(kpblhm) * went_eff - &
             ( ( 1._r8 - awk_PBL * cdelta_s ) / ( 1._r8 - awk_PBL ) ) * cmf_u(kpblhm) )
         elseif( i_budget_coldpool .eq. 6 ) then
             tmp3           = tmp1 * ( max( 0._r8, &
             cmf_d(kpblhm) - cmf_d_org_pblh ) + rho0(kpblhm) * went_eff - &
             ( ( 1._r8 - awk_PBL * cdelta_s ) / ( 1._r8 - awk_PBL ) ) * cmf_u_org_pblh )
         elseif( i_budget_coldpool .eq. 1 .or. i_budget_coldpool .eq. 2 ) then
             tmp3           = tmp1 * ( max( 0._r8, &
             cmf_d(kpblhm) - cmf_d_org_pblh - cmf_d_orgU_pblh ) + & 
             ( cmf_d_orgU_pblh - cmf_u_org_pblh ) / ( 1._r8 - awk_PBL ) + rho0(kpblhm) * went_eff )
         elseif( i_budget_coldpool .eq. 4 ) then 
             tmp3           = tmp1 * ( max( 0._r8, &
             cmf_d_orgU_pblh / ( 1._r8 - awk_PBL ) ) - cmf_u(kpblhm) + rho0(kpblhm) * went_eff )
         elseif( i_budget_coldpool .eq. 5 ) then 
             tmp3           = tmp1 * ( cmf_d_orgU_pblh / ( 1._r8 - awk_PBL ) + &
                                       rho0(kpblhm) * went_eff - &
                                     ( ( 1._r8 - awk_PBL * cdelta_s ) / &
                                       ( 1._r8 - awk_PBL ) ) * cmf_u(kpblhm) )
         endif
         tmp4           = awk_PBL / ( 1._r8 - awk_PBL )
         ws1            = sqrt( u0(1)**2._r8 + v0(1)**2._r8 )
         cd_thl         = cdrag
         cd_qt          = cdrag
         cd_u           = cdrag
         cd_v           = cdrag
         ! cd_thv         = cdrag
         cd_tr(:ncnst)  = cdrag

         ! Aug.03.2012. Compute 'del_wk_eff' internally, such that updraft mass flux at the inversion base does not
         !              change 'a_D'. This may help to retard the timing of diurnal cycle of convective precipitation
         !              over continental land. Note that modification here is enough to ensure a full consistency in
         !              the entire model. 
         !              CAUTION : Since analytical integration is performed, not only 'del_wk_eff' but also the
         !              format of 'taui,_orgforce' should be changed together. Thus, below option of 'int_del_wk .eq. 1'
         !              is incomplete at this stage. This should be refined later.
         ! Dec.20.2012. Additional term of 'tmp3 = tmp1 * max( 0._r8, cmf_d(kpblhm) - cmf_d_org_pblh )' is added into the
         !              computation of inverse relaxation time scale of conservative scalar other tha 'taui_awk_mxen'.
         !              This correction will help to reduce simulated convective organization due to the increase of
         !              damping effect as explained above.
      
         if( int_del_wk .eq. 1 ) then
            del_wk_eff =  c_del_wk * tmp1 * awk_PBL * cmf_u(kpblhm)
         endif

         !m   taui_thl_mxen(iter)                      = del_wk_eff / max( nonzero, awk_PBL * ( 1._r8 - awk_PBL ) ) +     cd_thl * tmp2 * ws1 / pblhz + tmp3
         !m   taui_qt_mxen(iter)                       = del_wk_eff / max( nonzero, awk_PBL * ( 1._r8 - awk_PBL ) ) +      cd_qt * tmp2 * ws1 / pblhz + tmp3
         !m   taui_u_mxen(iter)                        = del_wk_eff / max( nonzero, awk_PBL * ( 1._r8 - awk_PBL ) ) +       cd_u * tmp2 * ws1 / pblhz + tmp3
         !m   taui_v_mxen(iter)                        = del_wk_eff / max( nonzero, awk_PBL * ( 1._r8 - awk_PBL ) ) +       cd_v * tmp2 * ws1 / pblhz + tmp3
         !m ! taui_thv_mxen(iter)                      = del_wk_eff / max( nonzero, awk_PBL * ( 1._r8 - awk_PBL ) ) +     cd_thv * tmp2 * ws1 / pblhz + tmp3
         !m   do mt = 1, ncnst
         !m      taui_tr_mxen(mt,iter)                 = del_wk_eff / max( nonzero, awk_PBL * ( 1._r8 - awk_PBL ) ) +  cd_tr(mt) * tmp2 * ws1 / pblhz + tmp3
         !m   enddo

         taui_thl_mxen(iter) = del_wk_eff / max( nonzero, awk_PBL * ( 1._r8 - awk_PBL ) ) +  cd_thl * tmp1 * ws1 * rho0(1) + tmp3
         taui_qt_mxen(iter)  = del_wk_eff / max( nonzero, awk_PBL * ( 1._r8 - awk_PBL ) ) +   cd_qt * tmp1 * ws1 * rho0(1) + tmp3
         taui_u_mxen(iter)   = del_wk_eff / max( nonzero, awk_PBL * ( 1._r8 - awk_PBL ) ) +    cd_u * tmp1 * ws1 * rho0(1) + tmp3
         taui_v_mxen(iter)   = del_wk_eff / max( nonzero, awk_PBL * ( 1._r8 - awk_PBL ) ) +    cd_v * tmp1 * ws1 * rho0(1) + tmp3
         ! taui_thv_mxen(iter)                      = del_wk_eff / max( nonzero, awk_PBL * ( 1._r8 - awk_PBL ) ) +     cd_thv * tmp1 * ws1 * rho0(1) + tmp3
         do mt = 1, ncnst
            taui_tr_mxen(mt,iter) = del_wk_eff/max(nonzero, awk_PBL*(1._r8 - awk_PBL)) + cd_tr(mt) * tmp1 * ws1 * rho0(1) + tmp3
         enddo

       ! May.1.2014. Correct budget of cold pool.
         if( i_budget_coldpool .eq. 0 .or. i_budget_coldpool .eq. 3 ) then
             taui_awk_mxen(iter)                  = tmp1 * ( cmf_d_org_pblh - cmf_u(kpblhm) )
         elseif( i_budget_coldpool .eq. 6 ) then
             taui_awk_mxen(iter)                  = tmp1 * ( cmf_d_org_pblh - cmf_u_org_pblh )
         else
             taui_awk_mxen(iter)                  = tmp1 * ( cmf_d_org_pblh + cmf_d_orgU_pblh - cmf_u_org_pblh )
         endif 

         !og  Below block is a new energy-consistent parameterization of meso-scale organized flow, replacing the above block.
         !og  Note that in the above, it is defined as 'eps_wk_eff = eps_wk0 * awk_PBL' and 'del_wk_eff = del_wk0 * awk_PBL'. 
         !og  In order to prevent the numerical glitch, define below 'taui' using 'eps_wk0, del_wk0' instead of 'eps_wk_eff, del_wk_eff'. 
         !og  For 'taui_awk_mxen', the form should also be slightly changed.
         !og Below is used both for the fully and partially energy-consistent formula.
 
         if( i_energy_coldpool .eq. 1 .or. i_energy_coldpool .eq. 2 ) then  
 
            taui_thl_mxen(iter) = del_wk0 / max( nonzero, ( 1._r8 - awk_PBL ) ) +     cd_thl * tmp1 * ws1 * rho0(1) + tmp3
            taui_qt_mxen(iter)  = del_wk0 / max( nonzero, ( 1._r8 - awk_PBL ) ) +      cd_qt * tmp1 * ws1 * rho0(1) + tmp3
            taui_u_mxen(iter)   = del_wk0 / max( nonzero, ( 1._r8 - awk_PBL ) ) +       cd_u * tmp1 * ws1 * rho0(1) + tmp3
            taui_v_mxen(iter)   = del_wk0 / max( nonzero, ( 1._r8 - awk_PBL ) ) +       cd_v * tmp1 * ws1 * rho0(1) + tmp3
            ! taui_thv_mxen(iter) = del_wk0 / max( nonzero, ( 1._r8 - awk_PBL ) ) +     cd_thv * tmp1 * ws1 * rho0(1) + tmp3
            do mt = 1, ncnst
               taui_tr_mxen(mt,iter) = del_wk0 / max( nonzero, ( 1._r8 - awk_PBL ) ) +  cd_tr(mt) * tmp1 * ws1 * rho0(1) + tmp3
            enddo
 
          ! May.1.2014. Correct budget of cold pool.
            if( i_budget_coldpool .eq. 0 .or. i_budget_coldpool .eq. 3 ) then
                taui_awk_mxen(iter)                  = tmp1 * ( cmf_d_org_pblh - &
                cmf_u(kpblhm) ) + ( del_wk0 - eps_wk0 )
            elseif( i_budget_coldpool .eq. 6 ) then
                taui_awk_mxen(iter)                  = tmp1 * ( cmf_d_org_pblh - &
                cmf_u_org_pblh ) + ( del_wk0 - eps_wk0 )
            else
                taui_awk_mxen(iter)                  = tmp1 * ( cmf_d_org_pblh + &
                cmf_d_orgU_pblh - cmf_u_org_pblh ) + ( del_wk0 - eps_wk0 )
            endif 

         endif
 
         !og  Above block is a new energy-consistent parameterization of meso-scale organized flow, replacing the above block.
 
         !ogg Temporary diagnostic output.
         !ogg These two diagnostic output will be used to assess the approximate magnitude of 
         !ogg detrainment of cold pool, in combiation with the use of Lagrangian z=h.
 
         del_org_mxen(iter)  = awk_PBL * ( 1._r8 - awk_PBL ) * ( g / pblhp ) * cmf_u(kpblhm)
         del0_org_mxen(iter) =           ( 1._r8 - awk_PBL ) * ( g / pblhp ) * cmf_u(kpblhm)
 
         !ogg Temporary diagnostic output
 

         ! --------------------- !
         ! 2. Total Wake Forcing !
         ! --------------------- !   

       ! May.1.2014. Correct budget of cold pool. Note that 'awk_force_mxen' is identical to the previous case.
 
         if( i_budget_coldpool .eq. 0 .or. i_budget_coldpool .eq. 3 ) then

             thl_orgforce_mxen(iter)                  =       thlflx_d_org_pblh * tmp1 +    thl_dia_und_org +    thl_dia_env_org
             qt_orgforce_mxen(iter)                   =        qtflx_d_org_pblh * tmp1 +     qt_dia_und_org +     qt_dia_env_org
             u_orgforce_mxen(iter)                    =         uflx_d_org_pblh * tmp1
             v_orgforce_mxen(iter)                    =         vflx_d_org_pblh * tmp1
           ! thv_orgforce_mxen(iter)                  =       thvflx_d_org_pblh * tmp1 + (  thl_dia_und_org +    thl_dia_env_org ) * ( 1._r8 + zvir *  qt0PBL ) + &
           !                                                                             (   qt_dia_und_org +     qt_dia_env_org ) * (         zvir * thl0PBL )
             do mt = 1, ncnst
                tr_orgforce_mxen(mt,iter)             =    trflx_d_org_pblh(mt) * tmp1 + &
                tr_dia_und_org(mt) +  tr_dia_env_org(mt)    
             enddo

         elseif( i_budget_coldpool .eq. 1 .or. i_budget_coldpool .eq. 2 ) then

             thl_orgforce_mxen(iter)                  =  (    thlflx_d_org_pblh - &
             tmp4 * ( thlflx_u_org_pblh + thlflx_d_orgU_pblh ) ) * tmp1 + & 
                                                                thl_dia_und_org + &
             tmp4 * thl_dia_d_orgU + thl_dia_env_org
             qt_orgforce_mxen(iter)                   =  (     qtflx_d_org_pblh - &
             tmp4 * (  qtflx_u_org_pblh +  qtflx_d_orgU_pblh ) ) * tmp1 + &  
                                                                 qt_dia_und_org + &
             tmp4 *  qt_dia_d_orgU +  qt_dia_env_org
             u_orgforce_mxen(iter)                    =  (      uflx_d_org_pblh - &
             tmp4 * (   uflx_u_org_pblh +   uflx_d_orgU_pblh ) ) * tmp1
             v_orgforce_mxen(iter)                    =  (      vflx_d_org_pblh - &
             tmp4 * (   vflx_u_org_pblh +   vflx_d_orgU_pblh ) ) * tmp1
             do mt = 1, ncnst
                tr_orgforce_mxen(mt,iter)             =  ( trflx_d_org_pblh(mt) - &
             tmp4 * ( trflx_u_org_pblh(mt) + trflx_d_orgU_pblh(mt) ) ) * tmp1 + & 
                                                             tr_dia_und_org(mt) + &
             tmp4 * tr_dia_d_orgU(mt) + tr_dia_env_org(mt)    
             enddo

         elseif( i_budget_coldpool .eq. 4 .or. i_budget_coldpool .eq. 5 ) then

             thl_orgforce_mxen(iter)                  =  (    thlflx_d_org_pblh - &
             tmp4 * (        0._r8 + thlflx_d_orgU_pblh ) ) * tmp1 + & 
                                                                thl_dia_und_org + &
             tmp4 * thl_dia_d_orgU + thl_dia_env_org
             qt_orgforce_mxen(iter)                   =  (     qtflx_d_org_pblh - &
             tmp4 * (        0._r8 +  qtflx_d_orgU_pblh ) ) * tmp1 + &  
                                                                 qt_dia_und_org + &
             tmp4 *  qt_dia_d_orgU +  qt_dia_env_org
             u_orgforce_mxen(iter)                    =  (      uflx_d_org_pblh - &
             tmp4 * (        0._r8 +   uflx_d_orgU_pblh ) ) * tmp1
             v_orgforce_mxen(iter)                    =  (      vflx_d_org_pblh - &
             tmp4 * (        0._r8 +   vflx_d_orgU_pblh ) ) * tmp1
             do mt = 1, ncnst
                tr_orgforce_mxen(mt,iter)             =  ( trflx_d_org_pblh(mt) - &
             tmp4 * (        0._r8 + trflx_d_orgU_pblh(mt) ) ) * tmp1 + & 
                                                             tr_dia_und_org(mt) + &
             tmp4 * tr_dia_d_orgU(mt) + tr_dia_env_org(mt)    
             enddo

         elseif( i_budget_coldpool .eq. 6 ) then

             thl_orgforce_mxen(iter)                  =  (    thlflx_d_org_pblh - &
             tmp4 * ( thlflx_u_org_pblh - cmf_u_org_pblh * cdelta_s * delta_thl_PBL ) ) * tmp1 + &
                                                                thl_dia_und_org + &
             thl_dia_env_org
             qt_orgforce_mxen(iter)                   =  (     qtflx_d_org_pblh - &
             tmp4 * (  qtflx_u_org_pblh - cmf_u_org_pblh * cdelta_s * delta_qt_PBL ) ) * tmp1 + &
                                                                 qt_dia_und_org + &
              qt_dia_env_org
             u_orgforce_mxen(iter)                    =  (      uflx_d_org_pblh - &
             tmp4 * (   uflx_u_org_pblh - cmf_u_org_pblh * cdelta_s *  delta_u_PBL ) ) * tmp1
             v_orgforce_mxen(iter)                    =  (      vflx_d_org_pblh - &
             tmp4 * (   vflx_u_org_pblh - cmf_u_org_pblh * cdelta_s *  delta_v_PBL ) ) * tmp1 
             do mt = 1, ncnst
                tr_orgforce_mxen(mt,iter)             =  ( trflx_d_org_pblh(mt) - &
             tmp4 * ( trflx_u_org_pblh(mt) - cmf_u_org_pblh * cdelta_s * delta_tr_PBL(mt) ) ) * tmp1 + &  
                                                             tr_dia_und_org(mt) + &
             tr_dia_env_org(mt)    
             enddo

         endif

         awk_orgforce_mxen(iter)                  =          cmf_d_org_pblh * tmp1 +  eps_wk_eff - del_wk_eff 
         
         !og  Below block is a new energy-consistent parameterization of meso-scale organized flow, replacing the above block.
         !og  Note that in the above, it is defined as 'eps_wk_eff = eps_wk0 * awk_PBL' and 'del_wk_eff = del_wk0 * awk_PBL'. 
         !og  In contrast to 'taui', I only need to redefine 'awk_orgforce_mxen(iter)' for this forcing case.
         !og  Here, 'eps_wk_eff - del_wk_eff' should dissappear because it is now a part of the time scale.
         !og  Below is used both for the fully and partially energy-consistent formula.
 
         if( i_energy_coldpool .eq. 1 .or. i_energy_coldpool .eq. 2 ) then  
 
            awk_orgforce_mxen(iter)              =          cmf_d_org_pblh * tmp1
 
         endif
 
         !og  Above block is a new energy-consistent parameterization of meso-scale organized flow, replacing the above block.

         ! -------------------------------------------------- !
         ! 2-1. Individual Wake Forcing for Diagnostic Output !
         ! -------------------------------------------------- !   

         thl_orgforce_flx_mxen(iter)              =       thlflx_d_org_pblh * tmp1
         thl_orgforce_und_mxen(iter)              =                thl_dia_und_org
         thl_orgforce_env_mxen(iter)              =                thl_dia_env_org
         
         qt_orgforce_flx_mxen(iter)               =        qtflx_d_org_pblh * tmp1
         qt_orgforce_und_mxen(iter)               =                 qt_dia_und_org
         qt_orgforce_env_mxen(iter)               =                 qt_dia_env_org

         u_orgforce_flx_mxen(iter)                =         uflx_d_org_pblh * tmp1
         u_orgforce_und_mxen(iter)                =                          0._r8
         u_orgforce_env_mxen(iter)                =                          0._r8

         v_orgforce_flx_mxen(iter)                =         vflx_d_org_pblh * tmp1
         v_orgforce_und_mxen(iter)                =                          0._r8
         v_orgforce_env_mxen(iter)                =                          0._r8

         do mt = 1, ncnst
            tr_orgforce_flx_mxen(mt,iter)         =    trflx_d_org_pblh(mt) * tmp1
            tr_orgforce_und_mxen(mt,iter)         =             tr_dia_und_org(mt)
            tr_orgforce_env_mxen(mt,iter)         =             tr_dia_env_org(mt)
         enddo

         awk_orgforce_flx_mxen(iter)              =          cmf_d_org_pblh * tmp1
         awk_orgforce_mix_mxen(iter)              =        eps_wk_eff - del_wk_eff 
         
         cmf_d_org_pblh_mxen(iter)                =                 cmf_d_org_pblh

         ! ---------------------------------------------------------------------------------------------------- !
         ! Sep.07.2011. I should carefully consider whether I want to include below buoyancy constraint or not. !
         !              It seems to be more transparent and safe to include below buoyancy constraint block.    !
         !              Note that I still need to compute damping time scale for this case.                     !
         !              In case of 'taui_awk_mxen' and 'awk_orgforce_mxen', both of them are functions of       !
         !              cmf_d_org_pblh. Thus, when below if conditions happens, both the 'taui_awk_mxen' and    !
         !             'awk_orgforce_mxen' should be consistently modified. However, we already imposed the     !
         !              adiabatic forcing constraint on mass when buoyancy flux is negative, i.e,, I already    !
         !              imposed the constraint of cmf_d_org_pblh = 0 before. So, in principle, I don't need to  !
         !              do anything here. However, for safety, I also imposed the constraints on  awk as below. !                             
         ! Sep.09.2011. I don't need below if constraint any more sine UNICON is quite generally formulated to  !
         !              handle both positive/negative buoyancy forcing in wake.                                 ! 
         ! ---------------------------------------------------------------------------------------------------- !

         ! if( thv_orgforce_mxen(iter) .lt. 0._r8 ) then 
         !     thl_orgforce_mxen(iter)              =   0._r8
         !     qt_orgforce_mxen(iter)               =   0._r8
         !     u_orgforce_mxen(iter)                =   0._r8
         !     v_orgforce_mxen(iter)                =   0._r8
         !     do mt = 1, ncnst
         !        tr_orgforce_mxen(mt,iter)         =   0._r8
         !     enddo
         !     thv_orgforce_mxen(iter)              =   0._r8
         !     awk_orgforce_mxen(iter)              =   eps_wk_eff - del_wk_eff 
         !     taui_awk_mxen(iter)                  = - tmp1 * cmf_u(kpblhm)
         ! endif
    
         ! ------------------------- !
         ! End of Organization Block !
         ! ------------------------- !

         qvten_mxen(:mkx,iter)                    =                    qvten(:mkx)
         qlten_mxen(:mkx,iter)                    =                    qlten(:mkx)
         qiten_mxen(:mkx,iter)                    =                    qiten(:mkx)
         do mt = 1, ncnst
            trten_mxen(:mkx,mt,iter)              =                 trten(:mkx,mt)
         enddo
         sten_mxen(:mkx,iter)                     =                     sten(:mkx)
         uten_mxen(:mkx,iter)                     =                     uten(:mkx)
         vten_mxen(:mkx,iter)                     =                     vten(:mkx) 
         qrten_mxen(:mkx,iter)                    =                    qrten(:mkx) 
         qsten_mxen(:mkx,iter)                    =                    qsten(:mkx) 

         rqc_l_mxen(:mkx,iter)                    =                    rqc_l(:mkx)
         rqc_i_mxen(:mkx,iter)                    =                    rqc_i(:mkx)
         rqc_mxen(:mkx,iter)                      =                      rqc(:mkx)
         rnc_l_mxen(:mkx,iter)                    =                    rnc_l(:mkx)
         rnc_i_mxen(:mkx,iter)                    =                    rnc_i(:mkx)

         cmf_det_mxen(:mkx,iter)                  =                  cmf_det(:mkx)
         ql_det_mxen(:mkx,iter)                   =                   ql_det(:mkx)
         qi_det_mxen(:mkx,iter)                   =                   qi_det(:mkx)

         evapc_mxen(:mkx,iter)                    =                    evapc(:mkx)

         am_u_mxen(:mkx,iter)                     =                     am_u(:mkx)
         qlm_u_mxen(:mkx,iter)                    =                    qlm_u(:mkx)
         qim_u_mxen(:mkx,iter)                    =                    qim_u(:mkx)

         am_d_mxen(:mkx,iter)                     =                     am_d(:mkx)
         qlm_d_mxen(:mkx,iter)                    =                    qlm_d(:mkx)
         qim_d_mxen(:mkx,iter)                    =                    qim_d(:mkx)

         rliq_mxen(iter)                          =                           rliq
         rice_mxen(iter)                          =                           rice
         precip_mxen(iter)                        =                         precip
         snow_mxen(iter)                          =                           snow

         cnt_mxen(iter)                           =                            cnt
         cnb_mxen(iter)                           =                            cnb

         slten_u_mxen(:mkx,iter)                  =                  slten_u(:mkx)
         qtten_u_mxen(:mkx,iter)                  =                  qtten_u(:mkx)
         uten_u_mxen(:mkx,iter)                   =                   uten_u(:mkx)
         vten_u_mxen(:mkx,iter)                   =                   vten_u(:mkx)
         sten_u_mxen(:mkx,iter)                   =                   sten_u(:mkx)
         qvten_u_mxen(:mkx,iter)                  =                  qvten_u(:mkx)
         qlten_u_mxen(:mkx,iter)                  =                  qlten_u(:mkx)
         qiten_u_mxen(:mkx,iter)                  =                  qiten_u(:mkx)
         do mt = 1, ncnst
            trten_u_mxen(:mkx,mt,iter)            =               trten_u(:mkx,mt)
         enddo

         slten_d_mxen(:mkx,iter)                  =                  slten_d(:mkx)
         qtten_d_mxen(:mkx,iter)                  =                  qtten_d(:mkx)
         uten_d_mxen(:mkx,iter)                   =                   uten_d(:mkx)
         vten_d_mxen(:mkx,iter)                   =                   vten_d(:mkx)
         sten_d_mxen(:mkx,iter)                   =                   sten_d(:mkx)
         qvten_d_mxen(:mkx,iter)                  =                  qvten_d(:mkx)
         qlten_d_mxen(:mkx,iter)                  =                  qlten_d(:mkx)
         qiten_d_mxen(:mkx,iter)                  =                  qiten_d(:mkx)
         do mt = 1, ncnst
            trten_d_mxen(:mkx,mt,iter)            =               trten_d(:mkx,mt)
         enddo

         slten_evp_mxen(:mkx,iter)                =                slten_evp(:mkx)
         qtten_evp_mxen(:mkx,iter)                =                qtten_evp(:mkx)
         uten_evp_mxen(:mkx,iter)                 =                 uten_evp(:mkx)
         vten_evp_mxen(:mkx,iter)                 =                 vten_evp(:mkx)
         sten_evp_mxen(:mkx,iter)                 =                 sten_evp(:mkx)
         qvten_evp_mxen(:mkx,iter)                =                qvten_evp(:mkx)
         qlten_evp_mxen(:mkx,iter)                =                qlten_evp(:mkx)
         qiten_evp_mxen(:mkx,iter)                =                qiten_evp(:mkx)
         ! Dec.13.2012. Wet deposition term is added.
         do mt = 1, ncnst
            trten_evp_mxen(:mkx,mt,iter)          =             trten_evp(:mkx,mt)
            trten_wdep_mxen(:mkx,mt,iter)         =            trten_wdep(:mkx,mt)
         enddo

         ! Mar.27.2012. I commented out below 'dis_mxen' variables.

         ! slten_dis_mxen(:mkx,iter)                =                slten_dis(:mkx)
         ! qtten_dis_mxen(:mkx,iter)                =                qtten_dis(:mkx)
         ! uten_dis_mxen(:mkx,iter)                 =                 uten_dis(:mkx)
         ! vten_dis_mxen(:mkx,iter)                 =                 vten_dis(:mkx)
         ! sten_dis_mxen(:mkx,iter)                 =                 sten_dis(:mkx)
         ! qvten_dis_mxen(:mkx,iter)                =                qvten_dis(:mkx)
         ! qlten_dis_mxen(:mkx,iter)                =                qlten_dis(:mkx)
         ! qiten_dis_mxen(:mkx,iter)                =                qiten_dis(:mkx)
         ! do mt = 1, ncnst
         !    trten_dis_mxen(:mkx,mt,iter)          =             trten_dis(:mkx,mt)
         ! enddo

         qlten_sub_mxen(:mkx,iter)                =                qlten_sub(:mkx)
         qiten_sub_mxen(:mkx,iter)                =                qiten_sub(:mkx)

       ! Apr.15.2014. Temporary Hack

       ! qlten_sub_mxen(:mkx,iter)                =  qrten_u(:mkx) + qsten_u(:mkx)
       ! qiten_sub_mxen(:mkx,iter)                =  qrten_d(:mkx) + qsten_d(:mkx)

         qlten_det_mxen(:mkx,iter)                =                qlten_det(:mkx)
         qiten_det_mxen(:mkx,iter)                =                qiten_det(:mkx)

         thl_u_mxen(0:mkx,iter)                   =                   thl_u(0:mkx)
         qt_u_mxen(0:mkx,iter)                    =                    qt_u(0:mkx)
         u_u_mxen(0:mkx,iter)                     =                     u_u(0:mkx)
         v_u_mxen(0:mkx,iter)                     =                     v_u(0:mkx)
         w_u_mxen(0:mkx,iter)                     =                     w_u(0:mkx)
         ql_u_mxen(0:mkx,iter)                    =                    ql_u(0:mkx)
         qi_u_mxen(0:mkx,iter)                    =                    qi_u(0:mkx)
         do mt = 1, ncnst
            tr_u_mxen(0:mkx,mt,iter)              =                 tr_u(0:mkx,mt)
         enddo
         a_u_mxen(0:mkx,iter)                     =                     a_u(0:mkx)
         num_u_mxen(0:mkx,iter)                   =                   num_u(0:mkx)
         wa_u_mxen(0:mkx,iter)                    =                    wa_u(0:mkx)
         qla_u_mxen(0:mkx,iter)                   =                   qla_u(0:mkx)
         qia_u_mxen(0:mkx,iter)                   =                   qia_u(0:mkx)
         rad_u_mxen(0:mkx,iter)                   =                   rad_u(0:mkx)
         thva_u_mxen(0:mkx,iter)                  =                  thva_u(0:mkx)

         a_p_mxen(0:mkx,iter)                     =                     a_p(0:mkx)
         am_evp_mxen(:mkx,iter)                   =                   am_evp(:mkx)
         am_pu_mxen(:mkx,iter)                    =                    am_pu(:mkx)
         x_p_mxen(0:mkx,iter)                     =              x_p_msfc(0:mkx,1)
         y_p_mxen(0:mkx,iter)                     =              y_p_msfc(0:mkx,1)
         x_um_mxen(:mkx,iter)                     =              x_um_msfc(:mkx,1)
         y_um_mxen(:mkx,iter)                     =              y_um_msfc(:mkx,1)

         thl_d_mxen(0:mkx,iter)                   =                   thl_d(0:mkx)
         qt_d_mxen(0:mkx,iter)                    =                    qt_d(0:mkx)
         u_d_mxen(0:mkx,iter)                     =                     u_d(0:mkx)
         v_d_mxen(0:mkx,iter)                     =                     v_d(0:mkx)
         w_d_mxen(0:mkx,iter)                     =                     w_d(0:mkx)
         ql_d_mxen(0:mkx,iter)                    =                    ql_d(0:mkx)
         qi_d_mxen(0:mkx,iter)                    =                    qi_d(0:mkx)
         do mt = 1, ncnst
            tr_d_mxen(0:mkx,mt,iter)              =                 tr_d(0:mkx,mt)
         enddo
         a_d_mxen(0:mkx,iter)                     =                     a_d(0:mkx)
         wa_d_mxen(0:mkx,iter)                    =                    wa_d(0:mkx)
         qla_d_mxen(0:mkx,iter)                   =                   qla_d(0:mkx)
         qia_d_mxen(0:mkx,iter)                   =                   qia_d(0:mkx)

         thl_u_msfc_mxen(0:mkx,:nseg,iter)        =        thl_u_msfc(0:mkx,:nseg)
         qt_u_msfc_mxen(0:mkx,:nseg,iter)         =         qt_u_msfc(0:mkx,:nseg)
         u_u_msfc_mxen(0:mkx,:nseg,iter)          =          u_u_msfc(0:mkx,:nseg)
         v_u_msfc_mxen(0:mkx,:nseg,iter)          =          v_u_msfc(0:mkx,:nseg)
         w_u_msfc_mxen(0:mkx,:nseg,iter)          =          w_u_msfc(0:mkx,:nseg)
         ql_u_msfc_mxen(0:mkx,:nseg,iter)         =         ql_u_msfc(0:mkx,:nseg)
         qi_u_msfc_mxen(0:mkx,:nseg,iter)         =         qi_u_msfc(0:mkx,:nseg)
         do mt = 1, ncnst
            tr_u_msfc_mxen(0:mkx,:nseg,mt,iter)   =      tr_u_msfc(0:mkx,:nseg,mt) 
         enddo
         cmf_u_msfc_mxen(0:mkx,:nseg,iter)        =        cmf_u_msfc(0:mkx,:nseg)
         a_u_msfc_mxen(0:mkx,:nseg,iter)          =          a_u_msfc(0:mkx,:nseg)
         num_u_msfc_mxen(0:mkx,:nseg,iter)        =        num_u_msfc(0:mkx,:nseg)
         rad_u_msfc_mxen(0:mkx,:nseg,iter)        =        rad_u_msfc(0:mkx,:nseg)

         eps0_u_msfc_mxen(0:mkx,:nseg,iter)       =       eps0_u_msfc(0:mkx,:nseg)
         eps_u_msfc_mxen(0:mkx,:nseg,iter)        =        eps_u_msfc(0:mkx,:nseg)
         del_u_msfc_mxen(0:mkx,:nseg,iter)        =        del_u_msfc(0:mkx,:nseg)
         eeps_u_msfc_mxen(0:mkx,:nseg,iter)       =       eeps_u_msfc(0:mkx,:nseg)
         ddel_u_msfc_mxen(0:mkx,:nseg,iter)       =       ddel_u_msfc(0:mkx,:nseg)
         xc_u_msfc_mxen(0:mkx,:nseg,iter)         =         xc_u_msfc(0:mkx,:nseg)
         xs_u_msfc_mxen(0:mkx,:nseg,iter)         =         xs_u_msfc(0:mkx,:nseg)
         xemin_u_msfc_mxen(0:mkx,:nseg,iter)      =      xemin_u_msfc(0:mkx,:nseg)
         xemax_u_msfc_mxen(0:mkx,:nseg,iter)      =      xemax_u_msfc(0:mkx,:nseg)
         cridis_u_msfc_mxen(0:mkx,:nseg,iter)     =     cridis_u_msfc(0:mkx,:nseg)
         thvcuenv_u_msfc_mxen(0:mkx,:nseg,iter)   =   thvcuenv_u_msfc(0:mkx,:nseg)
         thvegenv_u_msfc_mxen(0:mkx,:nseg,iter)   =   thvegenv_u_msfc(0:mkx,:nseg)
         thvxsenv_u_msfc_mxen(0:mkx,:nseg,iter)   =   thvxsenv_u_msfc(0:mkx,:nseg)
         fmix_u_msfc_mxen(0:mkx,:nseg,iter)       =       fmix_u_msfc(0:mkx,:nseg)
         cmfumix_u_msfc_mxen(0:mkx,:nseg,iter)    =    cmfumix_u_msfc(0:mkx,:nseg)

         thl_d_msfc_mxen(0:mkx,:nseg,iter)        =        thl_d_msfc(0:mkx,:nseg)
         qt_d_msfc_mxen(0:mkx,:nseg,iter)         =         qt_d_msfc(0:mkx,:nseg)
         u_d_msfc_mxen(0:mkx,:nseg,iter)          =          u_d_msfc(0:mkx,:nseg)
         v_d_msfc_mxen(0:mkx,:nseg,iter)          =          v_d_msfc(0:mkx,:nseg)
         w_d_msfc_mxen(0:mkx,:nseg,iter)          =          w_d_msfc(0:mkx,:nseg)
         ql_d_msfc_mxen(0:mkx,:nseg,iter)         =         ql_d_msfc(0:mkx,:nseg)
         qi_d_msfc_mxen(0:mkx,:nseg,iter)         =         qi_d_msfc(0:mkx,:nseg)
         do mt = 1, ncnst
            tr_d_msfc_mxen(0:mkx,:nseg,mt,iter)   =      tr_d_msfc(0:mkx,:nseg,mt) 
         enddo
         cmf_d_msfc_mxen(0:mkx,:nseg,iter)        =        cmf_d_msfc(0:mkx,:nseg)
         a_d_msfc_mxen(0:mkx,:nseg,iter)          =          a_d_msfc(0:mkx,:nseg)
         wa_d_msfc_mxen(0:mkx,:nseg,iter)         =         wa_d_msfc(0:mkx,:nseg)
         qla_d_msfc_mxen(0:mkx,:nseg,iter)        =        qla_d_msfc(0:mkx,:nseg)
         qia_d_msfc_mxen(0:mkx,:nseg,iter)        =        qia_d_msfc(0:mkx,:nseg)

         ktop_msfc_mxen(:nseg,iter)               =               ktop_msfc(:nseg) 
         ptop_msfc_mxen(:nseg,iter)               =               ptop_msfc(:nseg)
         ztop_msfc_mxen(:nseg,iter)               =               ztop_msfc(:nseg)

         !d   orgforce1_mxen(iter)                     =                      orgforce1
         !d   orgforce2_mxen(iter)                     =                      orgforce2
         !d   orgforce3_mxen(iter)                     =                      orgforce3

         ! ----------------------------------------------------------------------------------- !
         ! End of saving '_mxen' variables associated with multiple mixing environmental airs. !
         ! ----------------------------------------------------------------------------------- !

      enddo ! End of iter = 1, niter. This is an iteration loop of whole vertical layer

      ! -------------------------------------------------------------------------------- !
      !                                                                                  !
      !          Print-Out Formal Output Variables other than 'inout' Variables          !
      !                                                                                  ! 
      ! Aug.01.2011. Brian Juwon Park's 10th Birthday.                                   !
      !              The average of explicit ensemble mixing process                     !
      !              are treated here.                                                   !
      !              Below formula only considers two-types of mixing                    !
      !              with iter = 1, 2 but multi-types of mixing can                      !
      !              be treated in future.                                               !
      !                 (1) iter = 1 : with mean environmental airs at the current time  !
      !                 (2) iter = 2 : with cumulus updraft + detrained airs at the      !
      !                                previous time step.                               !  
      !              Note that I should use 'cuorg' not 'cuorg_mxen' in the below lines. !
      !                                                                                  !  
      ! -------------------------------------------------------------------------------- !

      ! ------------------------- !
      ! 1. Flux at the Interfaces !
      ! ------------------------- !

      do ki = 0, max( ktop_mxen(ixi) - 1, ktop_mxen(ixf) - 1 )
         kvi = mkx - ki
         cmf_u_out(i,ki) = (1._r8 - cuorg)*   cmf_u_mxen(ki,ixi)                         + cuorg*cmf_u_mxen(ki,ixf)   
         slflx_out(i,ki) = (1._r8 - cuorg)*(slflx_u_mxen(ki,ixi) + slflx_d_mxen(ki,ixi)) + cuorg*(slflx_u_mxen(ki,ixf) + &
                           slflx_d_mxen(ki,ixf) ) 
         qtflx_out(i,ki) = (1._r8 - cuorg)*(qtflx_u_mxen(ki,ixi) + qtflx_d_mxen(ki,ixi)) + cuorg*(qtflx_u_mxen(ki,ixf) + &
                           qtflx_d_mxen(ki,ixf) ) 
      enddo
 
      ! ------------------------ !
      ! 2. Layer-Mean Tendencies !
      ! ------------------------ !

      do k = 1, max( ktop_mxen(ixi), ktop_mxen(ixf) )
         kv = mkx + 1 - k
         qvten_out(i,k)          = ( 1._r8 - cuorg ) *     qvten_mxen(k,ixi) + cuorg *     qvten_mxen(k,ixf)
         qlten_out(i,k)          = ( 1._r8 - cuorg ) *     qlten_mxen(k,ixi) + cuorg *     qlten_mxen(k,ixf)
         qiten_out(i,k)          = ( 1._r8 - cuorg ) *     qiten_mxen(k,ixi) + cuorg *     qiten_mxen(k,ixf)
         do mt = 1, ncnst
            trten_out(i,k,mt)    = ( 1._r8 - cuorg ) *  trten_mxen(k,mt,ixi) + cuorg *  trten_mxen(k,mt,ixf)
         enddo
         sten_out(i,k)           = ( 1._r8 - cuorg ) *      sten_mxen(k,ixi) + cuorg *      sten_mxen(k,ixf)
         uten_out(i,k)           = ( 1._r8 - cuorg ) *      uten_mxen(k,ixi) + cuorg *      uten_mxen(k,ixf)  
         vten_out(i,k)           = ( 1._r8 - cuorg ) *      vten_mxen(k,ixi) + cuorg *      vten_mxen(k,ixf)
         qrten_out(i,k)          = ( 1._r8 - cuorg ) *     qrten_mxen(k,ixi) + cuorg *     qrten_mxen(k,ixf)
         qsten_out(i,k)          = ( 1._r8 - cuorg ) *     qsten_mxen(k,ixi) + cuorg *     qsten_mxen(k,ixf)
      enddo

      ! --------------------------------------------------------------------------------------------------- !
      ! SPECIAL : Compute Dissipation Heating - This must be done here to prevent energy conservation error !
      ! --------------------------------------------------------------------------------------------------- !

      ! --------------------------------------------------------------------------- !
      ! Compute diabatic tendency associated with KE dissipative heating            !
      ! In contrast to local symmetric turbulence scheme, KE dissipative heating by !
      ! nonlocal asymmetric turbulence (i.e., convection scheme)                    !
      ! can be either positive or negative.                                         !
      ! In order to suppress energy conservation error, this should be done here at !
      ! the end after choosing 'NUM' or 'ANA'.                                      ! 
      ! --------------------------------------------------------------------------- !
      do k = 1, max( ktop_mxen(ixi), ktop_mxen(ixf) )
         uf(k) = u0(k) + uten_out(i,k) * dt
         vf(k) = v0(k) + vten_out(i,k) * dt
      enddo
      ! ------------------------------------------------------------------------- !
      ! Reconstruct momemtum flux from the reconstructed uten_u(k) and uten_d(k)  !
      ! and vten_u(k) and vten_d(k) associated with ipartition = 1.               !
      ! Sep.12.2011. I should re-check whether below formula corretly incorporate !
      !              the 'ipartition = 1' effect. However, probably below is      !
      !              correct since it seems that now I can trust myself with      !
      !              reasonable amount of confidence.                             !  
      ! ------------------------------------------------------------------------- !
      do k = 1, max( ktop_mxen(ixi), ktop_mxen(ixf) )
         km = k - 1
         uflx(k) = uflx(km) - uten_out(i,k) * ( dp0(k) / g )
         vflx(k) = vflx(km) - vten_out(i,k) * ( dp0(k) / g )
      end do
      ! ----------------------------------------------------- !
      ! Add dissipation heating to the final heating tendency !
      ! ----------------------------------------------------- !
      do k = 1, max( ktop_mxen(ixi), ktop_mxen(ixf) )
         kp = k + 1
         km = k - 1 
         if( k .eq. 1 ) then
            sten_dis(k) = - g / 4._r8 * ( &
                            uflx(k)   * ( uf(kp) - uf(k) + u0(kp) - u0(k) ) / dps0(k) + & 
                            vflx(k)   * ( vf(kp) - vf(k) + v0(kp) - v0(k) ) / dps0(k) )
         elseif( k .ge. 2 .and. k .le. max( ktop_mxen(ixi), ktop_mxen(ixf) ) - 1 ) then
            sten_dis(k) = - g / 4._r8 * ( &
                            uflx(k)   * ( uf(kp) -  uf(k) + u0(kp) -  u0(k) ) /  dps0(k) + &
                            uflx(km)  * (  uf(k) - uf(km) +  u0(k) - u0(km) ) / dps0(km) + &
                            vflx(k)   * ( vf(kp) -  vf(k) + v0(kp) -  v0(k) ) /  dps0(k) + &
                            vflx(km)  * (  vf(k) - vf(km) +  v0(k) - v0(km) ) / dps0(km) )
         elseif( k .eq. max( ktop_mxen(ixi), ktop_mxen(ixf) ) ) then
            sten_dis(k) = - g / 4._r8 * ( &
                            uflx(km)  * ( uf(k) - uf(km) + u0(k) - u0(km) ) / dps0(km) + &
                            vflx(km)  * ( vf(k) - vf(km) + v0(k) - v0(km) ) / dps0(km) )
         endif
         slten_dis(k) = sten_dis(k)
         qtten_dis(k) = 0._r8 
         uten_dis(k)  = 0._r8
         vten_dis(k)  = 0._r8
         qvten_dis(k) = 0._r8
         qlten_dis(k) = 0._r8
         qiten_dis(k) = 0._r8
         do mt = 1, ncnst
            trten_dis(k,mt) = 0._r8 
         enddo
         ! Adding of dissipation heating to slten_out(i,k) will be done further below
         ! after computing ensemble-mean slten_out(i,k). However, my code does not 
         ! print out 'slten', but print individual component of 'slten'. Thus,
         ! I don't need to do anything here.
         ! slten_out(i,k) = slten_out(i,k) + slten_dis(k)
         sten_out(i,k)  = sten_out(i,k)  +  sten_dis(k)
      enddo

      ! -------------------------- !
      ! 3. Other Layer-Mean Values !
      ! -------------------------- !

      do k = 1, max( ktop_mxen(ixi), ktop_mxen(ixf) )
         kv = mkx + 1 - k
         ! ----------------------------------------------- !
         ! rqc_l, rqc_i, rqc are set to zero in the UNICON !
         ! ----------------------------------------------- !
         rqc_l_out(i,k)          = ( 1._r8 - cuorg ) *     rqc_l_mxen(k,ixi) + cuorg *     rqc_l_mxen(k,ixf) 
         rqc_i_out(i,k)          = ( 1._r8 - cuorg ) *     rqc_i_mxen(k,ixi) + cuorg *     rqc_i_mxen(k,ixf)
         rqc_out(i,k)            = ( 1._r8 - cuorg ) *       rqc_mxen(k,ixi) + cuorg *       rqc_mxen(k,ixf)
         rnc_l_out(i,k)          = ( 1._r8 - cuorg ) *     rnc_l_mxen(k,ixi) + cuorg *     rnc_l_mxen(k,ixf) 
         rnc_i_out(i,k)          = ( 1._r8 - cuorg ) *     rnc_i_mxen(k,ixi) + cuorg *     rnc_i_mxen(k,ixf)
         ! -------------------------------------------------------------------------------------------------------------- !
         ! Detrained mass flux and condensate: consistent between 'flux-convergence' and 'subsidence-detrainment' formula ! 
         ! -------------------------------------------------------------------------------------------------------------- !
         cmf_det_out(i,k)        = ( 1._r8 - cuorg ) *   cmf_det_mxen(k,ixi) + cuorg *   cmf_det_mxen(k,ixf) 
         ql_det_out(i,k)         = ( 1._r8 - cuorg ) *    ql_det_mxen(k,ixi) + cuorg *    ql_det_mxen(k,ixf) 
         qi_det_out(i,k)         = ( 1._r8 - cuorg ) *    qi_det_mxen(k,ixi) + cuorg *    qi_det_mxen(k,ixf) 
         ! ----------------------------------------------------------------------- !
         ! evapc : Evaporation rate of convective precipitation within environment !
         ! ----------------------------------------------------------------------- !
         evapc_out(i,k)          = ( 1._r8 - cuorg ) *     evapc_mxen(k,ixi) + cuorg *     evapc_mxen(k,ixf)
         ! ------------------------------------------------------------------------ !
         ! am_u(d)  : Updraft ( Downdraft ) fractional area at the layer mid-point. !
         ! qlm_u(d) : In-Updraft ( Downdraft ) LWC obtained by area weighting       !
         ! ------------------------------------------------------------------------ !
         am_u_out(i,k)  = ( 1._r8 - cuorg )* am_u_mxen(k,ixi)                    + cuorg* am_u_mxen(k,ixf)
         qlm_u_out(i,k) = ( 1._r8 - cuorg )*qlm_u_mxen(k,ixi) * am_u_mxen(k,ixi) + cuorg*qlm_u_mxen(k,ixf) * am_u_mxen(k,ixf)
         qim_u_out(i,k) = ( 1._r8 - cuorg )*qim_u_mxen(k,ixi) * am_u_mxen(k,ixi) + cuorg*qim_u_mxen(k,ixf) * am_u_mxen(k,ixf)
         am_d_out(i,k)  = ( 1._r8 - cuorg )* am_d_mxen(k,ixi)                    + cuorg* am_d_mxen(k,ixf)
         qlm_d_out(i,k) = ( 1._r8 - cuorg )*qlm_d_mxen(k,ixi) * am_d_mxen(k,ixi) + cuorg*qlm_d_mxen(k,ixf) * am_d_mxen(k,ixf)
         qim_d_out(i,k) = ( 1._r8 - cuorg )*qim_d_mxen(k,ixi) * am_d_mxen(k,ixi) + cuorg*qim_d_mxen(k,ixf) * am_d_mxen(k,ixf)
         if( am_u_out(i,k) .gt. nonzero ) then
            qlm_u_out(i,k)      = qlm_u_out(i,k) / am_u_out(i,k)
            qim_u_out(i,k)      = qim_u_out(i,k) / am_u_out(i,k)
         else
            am_u_out(i,k)       = 0._r8
            qlm_u_out(i,k)      = 0._r8
            qim_u_out(i,k)      = 0._r8
         endif
         if( am_d_out(i,k) .gt. nonzero ) then
            qlm_d_out(i,k)      = qlm_d_out(i,k) / am_d_out(i,k)
            qim_d_out(i,k)      = qim_d_out(i,k) / am_d_out(i,k)
         else
            am_d_out(i,k)       = 0._r8
            qlm_d_out(i,k)      = 0._r8
            qim_d_out(i,k)      = 0._r8
         endif
      enddo

      ! ------------------------------- !
      ! 4. Single-Value for Each Column !
      ! ------------------------------- !

      ! --------------- !
      ! rliq, rice >= 0 !
      ! --------------- !
      rliq_out(i)                = ( 1._r8 - cuorg ) *        rliq_mxen(ixi) + cuorg *        rliq_mxen(ixf)
      rice_out(i)                = ( 1._r8 - cuorg ) *        rice_mxen(ixi) + cuorg *        rice_mxen(ixf)
      precip_out(i)              = ( 1._r8 - cuorg ) *      precip_mxen(ixi) + cuorg *      precip_mxen(ixf)
      snow_out(i)                = ( 1._r8 - cuorg ) *        snow_mxen(ixi) + cuorg *        snow_mxen(ixf) 
      ! --------------------------------------------------------------------------------------------- !
      ! cnt, cnb : Updraft 'top' and 'base' interface index. It is reasonable to take the maximum and !
      !            minimum respectively for final output instead of cuorg weighting average.          !
      ! --------------------------------------------------------------------------------------------- !
      cnt_out(i)                 = max( cnt_mxen(ixi), cnt_mxen(ixf) )
      cnb_out(i)                 = min( cnb_mxen(ixi), cnb_mxen(ixf) )

      ! --------------------------------------------------------------------- !
      !                                                                       !
      !                  Print-Out Internal Output Variables                  !
      !                                                                       !
      ! Vertical index should be reversed for these internal output variables ! 
      !                                                                       !
      ! --------------------------------------------------------------------- !

      ! ------------------------ !
      ! 1. Flux Interface Values !
      ! ------------------------ !

      do ki = 0, max( ktop_mxen(ixi) - 1, ktop_mxen(ixf) - 1 )
         kvi = mkx - ki
         cmf_out(i,kvi)      = (1._r8 - cuorg)*(  cmf_u_mxen(ki,ixi) -  cmf_d_mxen(ki,ixi)) + cuorg*( cmf_u_mxen(ki,ixf) - &
                                                                                                     cmf_d_mxen(ki,ixf) )   
         uflx_out(i,kvi)     = (1._r8 - cuorg)*( uflx_u_mxen(ki,ixi) + uflx_d_mxen(ki,ixi)) + cuorg*(uflx_u_mxen(ki,ixf) + &
                                                                                                     uflx_d_mxen(ki,ixf) )
         vflx_out(i,kvi)     = (1._r8 - cuorg)*( vflx_u_mxen(ki,ixi) + vflx_d_mxen(ki,ixi)) + cuorg*(vflx_u_mxen(ki,ixf) + &
                                                                                                     vflx_d_mxen(ki,ixf) ) 
         slflx_u_out(i,kvi)  = (1._r8 - cuorg)* slflx_u_mxen(ki,ixi)                         + cuorg *  slflx_u_mxen(ki,ixf) 
         qtflx_u_out(i,kvi)  = (1._r8 - cuorg)* qtflx_u_mxen(ki,ixi)                         + cuorg *  qtflx_u_mxen(ki,ixf)
         uflx_u_out(i,kvi)   = (1._r8 - cuorg)*  uflx_u_mxen(ki,ixi)                         + cuorg *   uflx_u_mxen(ki,ixf)
         vflx_u_out(i,kvi)   = (1._r8 - cuorg)*  vflx_u_mxen(ki,ixi)                         + cuorg *   vflx_u_mxen(ki,ixf)
         cmf_d_out(i,kvi)    = (1._r8 - cuorg)*   cmf_d_mxen(ki,ixi)                         + cuorg *    cmf_d_mxen(ki,ixf) 
         slflx_d_out(i,kvi)  = (1._r8 - cuorg)* slflx_d_mxen(ki,ixi)                         + cuorg *  slflx_d_mxen(ki,ixf)
         qtflx_d_out(i,kvi)  = (1._r8 - cuorg)* qtflx_d_mxen(ki,ixi)                         + cuorg *  qtflx_d_mxen(ki,ixf)
         uflx_d_out(i,kvi)   = (1._r8 - cuorg)*  uflx_d_mxen(ki,ixi)                         + cuorg *   uflx_d_mxen(ki,ixf)
         vflx_d_out(i,kvi)   = (1._r8 - cuorg)*  vflx_d_mxen(ki,ixi)                         + cuorg *   vflx_d_mxen(ki,ixf)

         ! Aug.15.2011. Add downdraft flux associated with convective organization. 

         !d      slflx_d_org_out(i,kvi)     = ( 1._r8 - cuorg ) *  slflx_d_org_mxen(ki,ixi)                     + cuorg *  slflx_d_org_mxen(ki,ixf)
         !d      qtflx_d_org_out(i,kvi)     = ( 1._r8 - cuorg ) *  qtflx_d_org_mxen(ki,ixi)                     + cuorg *  qtflx_d_org_mxen(ki,ixf)

         flxrain_out(i,kvi)         = ( 1._r8 - cuorg ) *  flxrain_u_mxen(ki,ixi) + &
                                      cuorg *  flxrain_u_mxen(ki,ixf)
         flxsnow_out(i,kvi)         = ( 1._r8 - cuorg ) *  flxsnow_u_mxen(ki,ixi) + &
                                      cuorg *  flxsnow_u_mxen(ki,ixf)

      enddo

      ! ----------------------------- !
      ! 2. Layer-Mean Tendency Values !
      ! ----------------------------- !

      do k = 1, max( ktop_mxen(ixi), ktop_mxen(ixf) )
         kv = mkx + 1 - k
         slten_u_out(i,kv)          = ( 1._r8 - cuorg ) *      slten_u_mxen(k,ixi) + cuorg *      slten_u_mxen(k,ixf)
         qtten_u_out(i,kv)          = ( 1._r8 - cuorg ) *      qtten_u_mxen(k,ixi) + cuorg *      qtten_u_mxen(k,ixf)
         uten_u_out(i,kv)           = ( 1._r8 - cuorg ) *       uten_u_mxen(k,ixi) + cuorg *       uten_u_mxen(k,ixf) 
         vten_u_out(i,kv)           = ( 1._r8 - cuorg ) *       vten_u_mxen(k,ixi) + cuorg *       vten_u_mxen(k,ixf)
         sten_u_out(i,kv)           = ( 1._r8 - cuorg ) *       sten_u_mxen(k,ixi) + cuorg *       sten_u_mxen(k,ixf)
         qvten_u_out(i,kv)          = ( 1._r8 - cuorg ) *      qvten_u_mxen(k,ixi) + cuorg *      qvten_u_mxen(k,ixf)
         qlten_u_out(i,kv)          = ( 1._r8 - cuorg ) *      qlten_u_mxen(k,ixi) + cuorg *      qlten_u_mxen(k,ixf)
         qiten_u_out(i,kv)          = ( 1._r8 - cuorg ) *      qiten_u_mxen(k,ixi) + cuorg *      qiten_u_mxen(k,ixf)
         do mt = 1, ncnst
            trten_u_out(i,kv,mt)    = ( 1._r8 - cuorg ) *   trten_u_mxen(k,mt,ixi) + cuorg *   trten_u_mxen(k,mt,ixf)
         enddo
         slten_d_out(i,kv)          = ( 1._r8 - cuorg ) *      slten_d_mxen(k,ixi) + cuorg *      slten_d_mxen(k,ixf)
         qtten_d_out(i,kv)          = ( 1._r8 - cuorg ) *      qtten_d_mxen(k,ixi) + cuorg *      qtten_d_mxen(k,ixf)
         uten_d_out(i,kv)           = ( 1._r8 - cuorg ) *       uten_d_mxen(k,ixi) + cuorg *       uten_d_mxen(k,ixf)
         vten_d_out(i,kv)           = ( 1._r8 - cuorg ) *       vten_d_mxen(k,ixi) + cuorg *       vten_d_mxen(k,ixf)
         sten_d_out(i,kv)           = ( 1._r8 - cuorg ) *       sten_d_mxen(k,ixi) + cuorg *       sten_d_mxen(k,ixf)
         qvten_d_out(i,kv)          = ( 1._r8 - cuorg ) *      qvten_d_mxen(k,ixi) + cuorg *      qvten_d_mxen(k,ixf)
         qlten_d_out(i,kv)          = ( 1._r8 - cuorg ) *      qlten_d_mxen(k,ixi) + cuorg *      qlten_d_mxen(k,ixf)
         qiten_d_out(i,kv)          = ( 1._r8 - cuorg ) *      qiten_d_mxen(k,ixi) + cuorg *      qiten_d_mxen(k,ixf)
         do mt = 1, ncnst
            trten_d_out(i,kv,mt)    = ( 1._r8 - cuorg ) *   trten_d_mxen(k,mt,ixi) + cuorg *   trten_d_mxen(k,mt,ixf) 
         enddo
         slten_evp_out(i,kv)        = ( 1._r8 - cuorg ) *    slten_evp_mxen(k,ixi) + cuorg *    slten_evp_mxen(k,ixf)
         qtten_evp_out(i,kv)        = ( 1._r8 - cuorg ) *    qtten_evp_mxen(k,ixi) + cuorg *    qtten_evp_mxen(k,ixf)
         uten_evp_out(i,kv)         = ( 1._r8 - cuorg ) *     uten_evp_mxen(k,ixi) + cuorg *     uten_evp_mxen(k,ixf)
         vten_evp_out(i,kv)         = ( 1._r8 - cuorg ) *     vten_evp_mxen(k,ixi) + cuorg *     vten_evp_mxen(k,ixf)
         sten_evp_out(i,kv)         = ( 1._r8 - cuorg ) *     sten_evp_mxen(k,ixi) + cuorg *     sten_evp_mxen(k,ixf)
         qvten_evp_out(i,kv)        = ( 1._r8 - cuorg ) *    qvten_evp_mxen(k,ixi) + cuorg *    qvten_evp_mxen(k,ixf)
         qlten_evp_out(i,kv)        = ( 1._r8 - cuorg ) *    qlten_evp_mxen(k,ixi) + cuorg *    qlten_evp_mxen(k,ixf)
         qiten_evp_out(i,kv)        = ( 1._r8 - cuorg ) *    qiten_evp_mxen(k,ixi) + cuorg *    qiten_evp_mxen(k,ixf)
         ! Dec.13.2012. Wet deposition term is added.
         do mt = 1, ncnst
            trten_evp_out(i,kv,mt)  = ( 1._r8 - cuorg ) *  trten_evp_mxen(k,mt,ixi) + cuorg *  trten_evp_mxen(k,mt,ixf)
            trten_wdep_out(i,kv,mt) = ( 1._r8 - cuorg ) * trten_wdep_mxen(k,mt,ixi) + cuorg * trten_wdep_mxen(k,mt,ixf)
         enddo
         ! Mar.27.2012. Dissipation heating is computed after performing the ensemble average.
         !              So, I modified below block.
         ! Below is new correct on Mar.27.2012.
         slten_dis_out(i,kv)        =     slten_dis(k)
         qtten_dis_out(i,kv)        =     qtten_dis(k)
         uten_dis_out(i,kv)         =      uten_dis(k)
         vten_dis_out(i,kv)         =      vten_dis(k)
         sten_dis_out(i,kv)         =      sten_dis(k)
         qvten_dis_out(i,kv)        =     qvten_dis(k)
         qlten_dis_out(i,kv)        =     qlten_dis(k)
         qiten_dis_out(i,kv)        =     qiten_dis(k)
         do mt = 1, ncnst
            trten_dis_out(i,kv,mt)  =  trten_dis(k,mt) 
         enddo
         ! Below is previous old.
         ! slten_dis_out(i,kv)        = ( 1._r8 - cuorg ) *    slten_dis_mxen(k,ixi) + cuorg *    slten_dis_mxen(k,ixf)
         ! qtten_dis_out(i,kv)        = ( 1._r8 - cuorg ) *    qtten_dis_mxen(k,ixi) + cuorg *    qtten_dis_mxen(k,ixf)
         ! uten_dis_out(i,kv)         = ( 1._r8 - cuorg ) *     uten_dis_mxen(k,ixi) + cuorg *     uten_dis_mxen(k,ixf)
         ! vten_dis_out(i,kv)         = ( 1._r8 - cuorg ) *     vten_dis_mxen(k,ixi) + cuorg *     vten_dis_mxen(k,ixf)
         ! sten_dis_out(i,kv)         = ( 1._r8 - cuorg ) *     sten_dis_mxen(k,ixi) + cuorg *     sten_dis_mxen(k,ixf)
         ! qvten_dis_out(i,kv)        = ( 1._r8 - cuorg ) *    qvten_dis_mxen(k,ixi) + cuorg *    qvten_dis_mxen(k,ixf)
         ! qlten_dis_out(i,kv)        = ( 1._r8 - cuorg ) *    qlten_dis_mxen(k,ixi) + cuorg *    qlten_dis_mxen(k,ixf)
         ! qiten_dis_out(i,kv)        = ( 1._r8 - cuorg ) *    qiten_dis_mxen(k,ixi) + cuorg *    qiten_dis_mxen(k,ixf)
         ! do mt = 1, ncnst
         !    trten_dis_out(i,kv,mt)  = ( 1._r8 - cuorg ) * trten_dis_mxen(k,mt,ixi) + cuorg * trten_dis_mxen(k,mt,ixf)
         ! enddo
         qlten_sub_out(i,kv)        = ( 1._r8 - cuorg ) *    qlten_sub_mxen(k,ixi) + cuorg *    qlten_sub_mxen(k,ixf)
         qiten_sub_out(i,kv)        = ( 1._r8 - cuorg ) *    qiten_sub_mxen(k,ixi) + cuorg *    qiten_sub_mxen(k,ixf)
         qlten_det_out(i,kv)        = ( 1._r8 - cuorg ) *    qlten_det_mxen(k,ixi) + cuorg *    qlten_det_mxen(k,ixf)
         qiten_det_out(i,kv)        = ( 1._r8 - cuorg ) *    qiten_det_mxen(k,ixi) + cuorg *    qiten_det_mxen(k,ixf)

       ! Diagnostic output for UNICON paper
         am_evp_out(i,kv)           = ( 1._r8 - cuorg ) *       am_evp_mxen(k,ixi) + cuorg *       am_evp_mxen(k,ixf)
         am_pu_out(i,kv)            = ( 1._r8 - cuorg ) *        am_pu_mxen(k,ixi) + cuorg *        am_pu_mxen(k,ixf) 
         x_um_out(i,kv)             = ( 1._r8 - cuorg ) *         x_um_mxen(k,ixi) + cuorg *         x_um_mxen(k,ixf) 
         y_um_out(i,kv)             = ( 1._r8 - cuorg ) *         y_um_mxen(k,ixi) + cuorg *         y_um_mxen(k,ixf) 
       ! Diagnostic output for UNICON paper

      enddo

      ! --------------------------------------------------------------- !
      ! 3. Convective Updraft and Downdraft Properties at Interfaces    !
      !    Appropriate mass-flux, area, number weightings are required. !
      ! --------------------------------------------------------------- !

      do ki = 0, max( ktop_mxen(ixi) - 1, ktop_mxen(ixf) - 1 )
         kvi = mkx - ki
         ! ----------------------------- !
         ! Convective Updraft Properties !
         ! ----------------------------- !
         thl_u_out(i,kvi)= (1._r8 - cuorg)*thl_u_mxen(ki,ixi)*cmf_u_mxen(ki,ixi) + cuorg*thl_u_mxen(ki,ixf) * cmf_u_mxen(ki,ixf) 
         qt_u_out(i,kvi) = (1._r8 - cuorg)* qt_u_mxen(ki,ixi)*cmf_u_mxen(ki,ixi) + cuorg* qt_u_mxen(ki,ixf) * cmf_u_mxen(ki,ixf) 
         u_u_out(i,kvi)  = (1._r8 - cuorg)*  u_u_mxen(ki,ixi)*cmf_u_mxen(ki,ixi) + cuorg*  u_u_mxen(ki,ixf) * cmf_u_mxen(ki,ixf)
         v_u_out(i,kvi)  = (1._r8 - cuorg)*  v_u_mxen(ki,ixi)*cmf_u_mxen(ki,ixi) + cuorg*  v_u_mxen(ki,ixf) * cmf_u_mxen(ki,ixf)
         w_u_out(i,kvi)  = (1._r8 - cuorg)*  w_u_mxen(ki,ixi)*cmf_u_mxen(ki,ixi) + cuorg*  w_u_mxen(ki,ixf) * cmf_u_mxen(ki,ixf)
         ql_u_out(i,kvi) = (1._r8 - cuorg)* ql_u_mxen(ki,ixi)*cmf_u_mxen(ki,ixi) + cuorg* ql_u_mxen(ki,ixf) * cmf_u_mxen(ki,ixf)
         qi_u_out(i,kvi) = (1._r8 - cuorg)* qi_u_mxen(ki,ixi)*cmf_u_mxen(ki,ixi) + cuorg* qi_u_mxen(ki,ixf) * cmf_u_mxen(ki,ixf)
         do mt = 1, ncnst
            tr_u_out(i,kvi,mt) = (1._r8 - cuorg)*tr_u_mxen(ki,mt,ixi)*cmf_u_mxen(ki,ixi) + &
                                          cuorg*tr_u_mxen(ki,mt,ixf)*cmf_u_mxen(ki,ixf)
         enddo
         ! ------------------------------------------------------------------------------------------------------- ! 
         ! Note that 'cmf_u_out(i,ki)' has already been computed above with OPPOSITE layer array index ki not kvi. !
         ! The way how 'rad_u_out' is computed is the same as the one in the main code with number weighting.      !
         ! ------------------------------------------------------------------------------------------------------- !
         a_u_out(i,kvi)    = (1._r8 - cuorg)*   a_u_mxen(ki,ixi)                    + cuorg * a_u_mxen(ki,ixf) 
         num_u_out(i,kvi)  = (1._r8 - cuorg)* num_u_mxen(ki,ixi)                    + cuorg * num_u_mxen(ki,ixf) 
         wa_u_out(i,kvi)   = (1._r8 - cuorg)*  wa_u_mxen(ki,ixi) * a_u_mxen(ki,ixi) + cuorg * wa_u_mxen(ki,ixf)*a_u_mxen(ki,ixf)
         qla_u_out(i,kvi)  = (1._r8 - cuorg)* qla_u_mxen(ki,ixi) * a_u_mxen(ki,ixi) + cuorg * qla_u_mxen(ki,ixf)*a_u_mxen(ki,ixf) 
         qia_u_out(i,kvi)  = (1._r8 - cuorg)* qia_u_mxen(ki,ixi) * a_u_mxen(ki,ixi) + cuorg * qia_u_mxen(ki,ixf)*a_u_mxen(ki,ixf)
         rad_u_out(i,kvi)  = (1._r8 - cuorg)* rad_u_mxen(ki,ixi)**2._r8 * num_u_mxen(ki,ixi) + cuorg*rad_u_mxen(ki,ixf)**2._r8 * &
                                                                                                    num_u_mxen(ki,ixf) 
         thva_u_out(i,kvi) = (1._r8 - cuorg)*thva_u_mxen(ki,ixi) * a_u_mxen(ki,ixi) + cuorg *thva_u_mxen(ki,ixf)*a_u_mxen(ki,ixf) 

        ! Diagnostic output for UNICON paper
          a_p_out(i,kvi)                     = ( 1._r8 - cuorg ) * &
          a_p_mxen(ki,ixi)                             + cuorg *     a_p_mxen(ki,ixf) 
          x_p_out(i,kvi)                     = ( 1._r8 - cuorg ) * &
          x_p_mxen(ki,ixi)                             + cuorg *     x_p_mxen(ki,ixf) 
          y_p_out(i,kvi)                     = ( 1._r8 - cuorg ) * &
          y_p_mxen(ki,ixi)                             + cuorg *     y_p_mxen(ki,ixf) 
        ! Diagnostic output for UNICON paper

         ! ------------------------------------------------------------------------------- !
         ! Final normalization and averaging                                               !
         ! Be careful of the different index ki ( not kvi ) only in the mass flux.         !
         ! Note also that nonzero net mass flux, area, number concentration are guaranteed !
         ! at all the interfaces we are considering in this do block.                      !
         ! However, if cuorg = 0 or 1, ero value may come out due to cuorg weighting.      !
         ! Thus, we should carefully treat below using if block.                           !
         ! For full consistency, I use all the mass-flux, area, and number concentration   !
         ! consistencies at the same time.                                                 ! 
         ! ------------------------------------------------------------------------------- !
         if( cmf_u_out(i,ki) .gt. nonzero .and. a_u_out(i,kvi) .gt. nonzero .and. num_u_out(i,kvi) .gt. nonzero ) then
            thl_u_out(i,kvi)                 =       thl_u_out(i,kvi) /  cmf_u_out(i,ki)
            qt_u_out(i,kvi)                  =        qt_u_out(i,kvi) /  cmf_u_out(i,ki)
            u_u_out(i,kvi)                   =         u_u_out(i,kvi) /  cmf_u_out(i,ki)
            v_u_out(i,kvi)                   =         v_u_out(i,kvi) /  cmf_u_out(i,ki)
            w_u_out(i,kvi)                   =         w_u_out(i,kvi) /  cmf_u_out(i,ki)
            ql_u_out(i,kvi)                  =        ql_u_out(i,kvi) /  cmf_u_out(i,ki)
            qi_u_out(i,kvi)                  =        qi_u_out(i,kvi) /  cmf_u_out(i,ki)
            do mt = 1, ncnst
               tr_u_out(i,kvi,mt)            =     tr_u_out(i,kvi,mt) /  cmf_u_out(i,ki) 
            enddo
            wa_u_out(i,kvi)                  =        wa_u_out(i,kvi) /   a_u_out(i,kvi)
            qla_u_out(i,kvi)                 =       qla_u_out(i,kvi) /   a_u_out(i,kvi)
            qia_u_out(i,kvi)                 =       qia_u_out(i,kvi) /   a_u_out(i,kvi)
            rad_u_out(i,kvi)                 = sqrt( rad_u_out(i,kvi) / num_u_out(i,kvi) )
            thva_u_out(i,kvi)                =      thva_u_out(i,kvi) /   a_u_out(i,kvi)
         else
            cmf_u_out(i,ki)                  = 0._r8
            a_u_out(i,kvi)                   = 0._r8
            num_u_out(i,kvi)                 = 0._r8
            thl_u_out(i,kvi)                 = 0._r8
            qt_u_out(i,kvi)                  = 0._r8
            u_u_out(i,kvi)                   = 0._r8
            v_u_out(i,kvi)                   = 0._r8
            w_u_out(i,kvi)                   = 0._r8
            ql_u_out(i,kvi)                  = 0._r8
            qi_u_out(i,kvi)                  = 0._r8
            do mt = 1, ncnst
               tr_u_out(i,kvi,mt)            = 0._r8
            enddo
            wa_u_out(i,kvi)                  = 0._r8
            qla_u_out(i,kvi)                 = 0._r8
            qia_u_out(i,kvi)                 = 0._r8
            rad_u_out(i,kvi)                 = 0._r8
            thva_u_out(i,kvi)                = 0._r8
         endif
         gamw_u_out(i,kvi)                    = w_u_out(i,kvi) /  max( wa_u_out(i,kvi), nonzero )
         ! ------------------------------- !
         ! Convective Downdraft Properties !
         ! ------------------------------- !
         thl_d_out(i,kvi) = (1._r8 - cuorg)*thl_d_mxen(ki,ixi)*cmf_d_mxen(ki,ixi) + cuorg*thl_d_mxen(ki,ixf)*cmf_d_mxen(ki,ixf)
         qt_d_out(i,kvi)  = (1._r8 - cuorg)* qt_d_mxen(ki,ixi)*cmf_d_mxen(ki,ixi) + cuorg* qt_d_mxen(ki,ixf)*cmf_d_mxen(ki,ixf)
         u_d_out(i,kvi)   = (1._r8 - cuorg)*  u_d_mxen(ki,ixi)*cmf_d_mxen(ki,ixi) + cuorg*  u_d_mxen(ki,ixf)*cmf_d_mxen(ki,ixf)
         v_d_out(i,kvi)   = (1._r8 - cuorg)*  v_d_mxen(ki,ixi)*cmf_d_mxen(ki,ixi) + cuorg*  v_d_mxen(ki,ixf)*cmf_d_mxen(ki,ixf)
         w_d_out(i,kvi)   = (1._r8 - cuorg)*  w_d_mxen(ki,ixi)*cmf_d_mxen(ki,ixi) + cuorg*  w_d_mxen(ki,ixf)*cmf_d_mxen(ki,ixf)
         ql_d_out(i,kvi)  = (1._r8 - cuorg)* ql_d_mxen(ki,ixi)*cmf_d_mxen(ki,ixi) + cuorg* ql_d_mxen(ki,ixf)*cmf_d_mxen(ki,ixf)
         qi_d_out(i,kvi)  = (1._r8 - cuorg)* qi_d_mxen(ki,ixi)*cmf_d_mxen(ki,ixi) + cuorg* qi_d_mxen(ki,ixf)*cmf_d_mxen(ki,ixf)
         do mt = 1, ncnst
            tr_d_out(i,kvi,mt) = (1._r8 - cuorg)*tr_d_mxen(ki,mt,ixi)*cmf_d_mxen(ki,ixi) + &
                                          cuorg*tr_d_mxen(ki,mt,ixf)*cmf_d_mxen(ki,ixf)
         enddo
         ! ------------------------------------------------------------------------------------------------- ! 
         ! Note that 'cmf_d_out(i,kvi)' has already been computed above with the SAME layer array index kvi, !
         ! in contrast to 'cmf_u_out(i,ki)'                                                                  !
         ! ------------------------------------------------------------------------------------------------- !
         a_d_out(i,kvi)   = (1._r8 - cuorg)*  a_d_mxen(ki,ixi)                  + cuorg*  a_d_mxen(ki,ixf)
         wa_d_out(i,kvi)  = (1._r8 - cuorg)* wa_d_mxen(ki,ixi)*a_d_mxen(ki,ixi) + cuorg* wa_d_mxen(ki,ixf)*a_d_mxen(ki,ixf)
         qla_d_out(i,kvi) = (1._r8 - cuorg)*qla_d_mxen(ki,ixi)*a_d_mxen(ki,ixi) + cuorg*qla_d_mxen(ki,ixf)*a_d_mxen(ki,ixf) 
         qia_d_out(i,kvi) = (1._r8 - cuorg)*qia_d_mxen(ki,ixi)*a_d_mxen(ki,ixi) + cuorg*qia_d_mxen(ki,ixf)*a_d_mxen(ki,ixf)
         ! ------------------------------------------------------------------------------- !
         ! Final normalization and averaging                                               !
         ! Be careful of the same index ki ( not kvi ) for the mass flux too in contrast   !
         ! to convective updraft.                                                          !
         ! ------------------------------------------------------------------------------- !
         if( cmf_d_out(i,kvi) .gt. nonzero .and. a_d_out(i,kvi) .gt. nonzero ) then
            thl_d_out(i,kvi)                 =       thl_d_out(i,kvi) / cmf_d_out(i,kvi)
            qt_d_out(i,kvi)                  =        qt_d_out(i,kvi) / cmf_d_out(i,kvi)
            u_d_out(i,kvi)                   =         u_d_out(i,kvi) / cmf_d_out(i,kvi)
            v_d_out(i,kvi)                   =         v_d_out(i,kvi) / cmf_d_out(i,kvi)
            w_d_out(i,kvi)                   =         w_d_out(i,kvi) / cmf_d_out(i,kvi)
            ql_d_out(i,kvi)                  =        ql_d_out(i,kvi) / cmf_d_out(i,kvi)
            qi_d_out(i,kvi)                  =        qi_d_out(i,kvi) / cmf_d_out(i,kvi)
            do mt = 1, ncnst
               tr_d_out(i,kvi,mt)            =     tr_d_out(i,kvi,mt) / cmf_d_out(i,kvi) 
            enddo
            wa_d_out(i,kvi)                  =        wa_d_out(i,kvi) /   a_d_out(i,kvi)
            qla_d_out(i,kvi)                 =       qla_d_out(i,kvi) /   a_d_out(i,kvi)
            qia_d_out(i,kvi)                 =       qia_d_out(i,kvi) /   a_d_out(i,kvi)
         else
            cmf_d_out(i,kvi)                 =   0._r8 
            a_d_out(i,kvi)                   =   0._r8
            thl_d_out(i,kvi)                 =   0._r8
            qt_d_out(i,kvi)                  =   0._r8
            u_d_out(i,kvi)                   =   0._r8
            v_d_out(i,kvi)                   =   0._r8
            w_d_out(i,kvi)                   =   0._r8
            ql_d_out(i,kvi)                  =   0._r8
            qi_d_out(i,kvi)                  =   0._r8
            do mt = 1, ncnst
               tr_d_out(i,kvi,mt)            =   0._r8
            enddo
            wa_d_out(i,kvi)                  =   0._r8
            qla_d_out(i,kvi)                 =   0._r8
            qia_d_out(i,kvi)                 =   0._r8
         endif
      enddo

      ! ---------------------------------------------------------------------------------- !
      ! 4. Individual Segment Properties of Convective Updraft and Downdraft at Interfaces !
      !    In this case, instead of doing 'cuorg' average, just print out individual       ! 
      !    mixing air properties.                                                          ! 
      ! ---------------------------------------------------------------------------------- !

      do iter = 1, niter
         do msfc = 1, nseg
            do ki = 0, max( ktop_mxen(ixi) - 1, ktop_mxen(ixf) - 1 )

               kvi = mkx - ki
               thl_u_msfc_out(i,kvi,msfc,iter)        =         thl_u_msfc_mxen(ki,msfc,iter)
               qt_u_msfc_out(i,kvi,msfc,iter)         =          qt_u_msfc_mxen(ki,msfc,iter)
               u_u_msfc_out(i,kvi,msfc,iter)          =           u_u_msfc_mxen(ki,msfc,iter)
               v_u_msfc_out(i,kvi,msfc,iter)          =           v_u_msfc_mxen(ki,msfc,iter)
               w_u_msfc_out(i,kvi,msfc,iter)          =           w_u_msfc_mxen(ki,msfc,iter)
               ql_u_msfc_out(i,kvi,msfc,iter)         =          ql_u_msfc_mxen(ki,msfc,iter)
               qi_u_msfc_out(i,kvi,msfc,iter)         =          qi_u_msfc_mxen(ki,msfc,iter)
               do mt = 1, ncnst
                  tr_u_msfc_out(i,kvi,msfc,mt,iter)   =       tr_u_msfc_mxen(ki,msfc,mt,iter)
               enddo
               cmf_u_msfc_out(i,kvi,msfc,iter)        =         cmf_u_msfc_mxen(ki,msfc,iter)
               a_u_msfc_out(i,kvi,msfc,iter)          =           a_u_msfc_mxen(ki,msfc,iter)
               num_u_msfc_out(i,kvi,msfc,iter)        =         num_u_msfc_mxen(ki,msfc,iter)
               rad_u_msfc_out(i,kvi,msfc,iter)        =         rad_u_msfc_mxen(ki,msfc,iter) 

               eps0_u_msfc_out(i,kvi,msfc,iter)       =        eps0_u_msfc_mxen(ki,msfc,iter)
               eps_u_msfc_out(i,kvi,msfc,iter)        =         eps_u_msfc_mxen(ki,msfc,iter)
               del_u_msfc_out(i,kvi,msfc,iter)        =         del_u_msfc_mxen(ki,msfc,iter)
               eeps_u_msfc_out(i,kvi,msfc,iter)       =        eeps_u_msfc_mxen(ki,msfc,iter)
               ddel_u_msfc_out(i,kvi,msfc,iter)       =        ddel_u_msfc_mxen(ki,msfc,iter)
               xc_u_msfc_out(i,kvi,msfc,iter)         =          xc_u_msfc_mxen(ki,msfc,iter)
               xs_u_msfc_out(i,kvi,msfc,iter)         =          xs_u_msfc_mxen(ki,msfc,iter)
               xemin_u_msfc_out(i,kvi,msfc,iter)      =       xemin_u_msfc_mxen(ki,msfc,iter)
               xemax_u_msfc_out(i,kvi,msfc,iter)      =       xemax_u_msfc_mxen(ki,msfc,iter)
               cridis_u_msfc_out(i,kvi,msfc,iter)     =      cridis_u_msfc_mxen(ki,msfc,iter)
               thvcuenv_u_msfc_out(i,kvi,msfc,iter)   =    thvcuenv_u_msfc_mxen(ki,msfc,iter) 
               thvegenv_u_msfc_out(i,kvi,msfc,iter)   =    thvegenv_u_msfc_mxen(ki,msfc,iter)
               thvxsenv_u_msfc_out(i,kvi,msfc,iter)   =    thvxsenv_u_msfc_mxen(ki,msfc,iter) 
               fmix_u_msfc_out(i,kvi,msfc,iter)       =        fmix_u_msfc_mxen(ki,msfc,iter)
               cmfumix_u_msfc_out(i,kvi,msfc,iter)    =     cmfumix_u_msfc_mxen(ki,msfc,iter)
  
               thl_d_msfc_out(i,kvi,msfc,iter)        =         thl_d_msfc_mxen(ki,msfc,iter) 
               qt_d_msfc_out(i,kvi,msfc,iter)         =          qt_d_msfc_mxen(ki,msfc,iter)
               u_d_msfc_out(i,kvi,msfc,iter)          =           u_d_msfc_mxen(ki,msfc,iter)
               v_d_msfc_out(i,kvi,msfc,iter)          =           v_d_msfc_mxen(ki,msfc,iter)
               w_d_msfc_out(i,kvi,msfc,iter)          =           w_d_msfc_mxen(ki,msfc,iter)
               ql_d_msfc_out(i,kvi,msfc,iter)         =          ql_d_msfc_mxen(ki,msfc,iter)
               qi_d_msfc_out(i,kvi,msfc,iter)         =          qi_d_msfc_mxen(ki,msfc,iter)
               do mt = 1, ncnst
                  tr_d_msfc_out(i,kvi,msfc,mt,iter)   =       tr_d_msfc_mxen(ki,msfc,mt,iter)
               enddo
               cmf_d_msfc_out(i,kvi,msfc,iter)        =         cmf_d_msfc_mxen(ki,msfc,iter) 
               a_d_msfc_out(i,kvi,msfc,iter)          =           a_d_msfc_mxen(ki,msfc,iter)
               wa_d_msfc_out(i,kvi,msfc,iter)         =          wa_d_msfc_mxen(ki,msfc,iter)
               qla_d_msfc_out(i,kvi,msfc,iter)        =         qla_d_msfc_mxen(ki,msfc,iter)
               qia_d_msfc_out(i,kvi,msfc,iter)        =         qia_d_msfc_mxen(ki,msfc,iter)

            enddo

            ktop_msfc_out(i,msfc,iter)             =             ktop_msfc_mxen(msfc,iter) 
            ptop_msfc_out(i,msfc,iter)             =             ptop_msfc_mxen(msfc,iter) 
            ztop_msfc_out(i,msfc,iter)             =             ztop_msfc_mxen(msfc,iter) 

         enddo
      enddo

      ! ------------------------------------------------------------- !
      !                                                               !
      ! Save the 'inout' variables related to convective organization ! 
      !                                                               !  
      ! ------------------------------------------------------------- ! 

      ! ------------------------------------------------------------------------------------------ ! 
      ! 1. Top height and average height of convective updraft at the single previous time step.   !
      !    Similar to previous treatment, take the maximum value for 'cush' while perform          !
      !    surface mass-flux weighted average for cush_avg. Note that both mxen = 1 and 2 have     !
      !    identical surface mass flux.                                                            !
      !    Thus, it is more reasonable to use cushavg instead of cush for computation of           !
      !    critical distance ( rlc ) for convective updraft mixing as is done in the current code. !
      ! ------------------------------------------------------------------------------------------ !
   
      cush_inout(i)    = max( cush_mxen(ixi), cush_mxen(ixf) )
      cushavg_inout(i) = ( 1._r8 - cuorg ) * cushavg_mxen(ixi) + cuorg * cushavg_mxen(ixf) 

     ! TEST. Apr.15.2014.
     ! if( get_nstep() .eq. 786 .or. get_nstep() .eq. 787 ) then  
     !     write(6,*)
     !     write(6,*) 'SPARKCONV: cushavg, nstep = ', get_nstep()
     !     write(6,*) 'Updated cushavg_inout, pblh, pblhz, pblhp =', cushavg_inout(i), pblh, pblhz, pblhp
     !     write(6,*) 'kpblh, kpblhm, kpblh_in(i) = ', kpblh, kpblhm, kpblh_in(i)
     !     write(6,*) 'zs0_in(i,0), zs0_in(i,1) = ', zs0_in(i,0), zs0_in(i,1)
     !     write(6,*) 'zs0_in(i,kpblhm-1), zs0_in(i,kpblhm), zs0_in(i,kpblh) = ', zs0_in(i,kpblhm-1), zs0_in(i,kpblhm), zs0_in(i,kpblh)
     !     write(6,*) 'ps0_in(i,0), ps0_in(i,kpblhm) = ', ps0_in(i,0), ps0_in(i,kpblhm)
     !     write(6,*) 'eps_u_msfc_out(i,19,1,1), eps_u_msfc_out(i,20,1,1) = ', & 
     !                 eps_u_msfc_out(i,19,1,1), eps_u_msfc_out(i,20,1,1)
     !     write(6,*) 'ktop_mxen(ixi), ktop_mxen(ixf) = ', ktop_mxen(ixi), ktop_mxen(ixf)
     !     write(6,*) 'zs0_in(i,ktop_mxen-1), zs0_in(i,ktop_mxen), zs0_in(i,ktop_mxen+1) = ', &
     !                 zs0_in(i,ktop_mxen-1), zs0_in(i,ktop_mxen), zs0_in(i,ktop_mxen+1)
     !     write(6,*)  
     ! endif 
     ! TEST. Apr.15.2014.

      ! ------------------------------------------------------------------------------------------ !
      ! 2. Convective precipitation flux at surface at several previous ( nstep_org ) time steps.  !
      !    it = 1         : the most recent time step                                              !
      !    it = nstep_org : the oldest time step                                                   !
      !    Jun.28.2011. Precipitation flux at the PBL top interface is added.                      !  
      !    Jun.30.2011. Also add organization-induced perturbations within PBL.                    !
      !    For consistency with previous treatment, I should perform mass-flux ( cmfPBLorg )       !
      !    weighting average for thlPBLorg, qtPBLorg, uPBLorg, vPBLorg in the below block.         !
      ! ------------------------------------------------------------------------------------------ !

      !d     do it = mit, 1, -1
      !d        if( it .ne. 1 ) then
      !d            cu_prep_inout(i,it)          =      cu_prep_inout(i,it-1)
      !d            cu_tkePBLorg_inout(i,it)     = cu_tkePBLorg_inout(i,it-1)
      !d            cu_cmfPBLorg_inout(i,it)     = cu_cmfPBLorg_inout(i,it-1)
      !d            cu_thlPBLorg_inout(i,it)     = cu_thlPBLorg_inout(i,it-1)
      !d            cu_qtPBLorg_inout(i,it)      =  cu_qtPBLorg_inout(i,it-1)
      !d            cu_uPBLorg_inout(i,it)       =   cu_uPBLorg_inout(i,it-1)
      !d            cu_vPBLorg_inout(i,it)       =   cu_vPBLorg_inout(i,it-1)
      !d        else
      !d            cu_prep_inout(i,it)          = ( 1._r8 - cuorg ) *      cu_prep_mxen(ixi)                          + cuorg *      cu_prep_mxen(ixf) 
      !d            cu_tkePBLorg_inout(i,it)     = ( 1._r8 - cuorg ) * cu_tkePBLorg_mxen(ixi)                          + cuorg * cu_tkePBLorg_mxen(ixf)
      !d            cu_cmfPBLorg_inout(i,it)     = ( 1._r8 - cuorg ) * cu_cmfPBLorg_mxen(ixi)                          + cuorg * cu_cmfPBLorg_mxen(ixf)
      !d            cu_thlPBLorg_inout(i,it)     = ( 1._r8 - cuorg ) * cu_thlPBLorg_mxen(ixi) * cu_cmfPBLorg_mxen(ixi) + cuorg * cu_thlPBLorg_mxen(ixf) * cu_cmfPBLorg_mxen(ixf)
      !d            cu_qtPBLorg_inout(i,it)      = ( 1._r8 - cuorg ) *  cu_qtPBLorg_mxen(ixi) * cu_cmfPBLorg_mxen(ixi) + cuorg *  cu_qtPBLorg_mxen(ixf) * cu_cmfPBLorg_mxen(ixf)
      !d            cu_uPBLorg_inout(i,it)       = ( 1._r8 - cuorg ) *   cu_uPBLorg_mxen(ixi) * cu_cmfPBLorg_mxen(ixi) + cuorg *   cu_uPBLorg_mxen(ixf) * cu_cmfPBLorg_mxen(ixf) 
      !d            cu_vPBLorg_inout(i,it)       = ( 1._r8 - cuorg ) *   cu_vPBLorg_mxen(ixi) * cu_cmfPBLorg_mxen(ixi) + cuorg *   cu_vPBLorg_mxen(ixf) * cu_cmfPBLorg_mxen(ixf)
      !d            if( cu_cmfPBLorg_inout(i,it) .gt. nonzero ) then
      !d                cu_thlPBLorg_inout(i,it) = cu_thlPBLorg_inout(i,it) / cu_cmfPBLorg_inout(i,it)  
      !d                cu_qtPBLorg_inout(i,it)  =  cu_qtPBLorg_inout(i,it) / cu_cmfPBLorg_inout(i,it)
      !d                cu_uPBLorg_inout(i,it)   =   cu_uPBLorg_inout(i,it) / cu_cmfPBLorg_inout(i,it)
      !d                cu_vPBLorg_inout(i,it)   =   cu_vPBLorg_inout(i,it) / cu_cmfPBLorg_inout(i,it)
      !d            else
      !d                cu_cmfPBLorg_inout(i,it) = 0._r8
      !d                cu_thlPBLorg_inout(i,it) = 0._r8  
      !d                cu_qtPBLorg_inout(i,it)  = 0._r8
      !d                cu_uPBLorg_inout(i,it)   = 0._r8
      !d                cu_vPBLorg_inout(i,it)   = 0._r8
      !d            endif
      !d            ! --------------------------------------------------------------------------------------- !
      !d            ! Aug.15.2011. Re-compute 'cu_tkePBLorg_inout(i,it)' using prognostic TKE budget equation !
      !d            !              similar to the computation of convective organization.                     !
      !d            ! . tmp3 : TKE forcing averaged over the PBL [ m2/s2/s ]                                  ! 
      !d            ! Aug.30.2011. I should recheck whether the unit of computed buoyancy flux is correct -   !
      !d            !              it seems than density is missing in the computed buoyancy flux.            !                                      
      !d            ! --------------------------------------------------------------------------------------- !
      !d          ! tmp3 = 0._r8
      !d          ! tmp4 = 0._r8
      !d          ! tmp5 = 0._r8
      !d          ! if( kpblh .gt. 2 ) then 
      !d          !     do km = 1, kpblhm - 1
      !d          !        k = km + 1
      !d          !        tmp1 = zvir * 0.5_r8 * ( thvl0(km) + thvl0(k) )
      !d          !        tmp2 = ( 1._r8 + zvir * 0.5_r8 * ( qt0(km) + qt0(k) ) ) / ( cp * exns0(km) )
      !d          !        tmp3 = tmp3 + ( tmp1 * qtflx_d_org_out(i,mkx-km) + tmp2 * slflx_d_org_out(i,mkx-km) ) * ( p0(km) - p0(k) ) / ( 0.5_r8 * ( rho0(km) + rho0(k) ) * thv0(k) )
      !d          !        tmp4 = tmp4 +          qtflx_d_org_out(i,mkx-km) * ( z0(k) - zs0(km) )
      !d          !        tmp5 = tmp5 +          slflx_d_org_out(i,mkx-km) * ( z0(k) - zs0(km) ) / ( cp * exns0(km) )
      !d          !     end do
      !d          !     tmp3 = tmp3 / ( z0(kpblhm) - z0(1) )
      !d          !     tmp4 = tmp4 / ( z0(kpblhm) - z0(1) )
      !d          !     tmp5 = tmp5 / ( z0(kpblhm) - z0(1) )
      !d          ! endif
      !d          ! tau_TKE  = b1 * pblhz / max( sqrt( cu_tkePBLorg_inout(i,2) ), nonzero )  
      !d          ! tau_TKE  = max( 1800._r8, min( 18000._r8, tau_TKE ) )
      !d          ! cu_tkePBLorg_inout(i,1) = cu_tkePBLorg_inout(i,2) * exp( - dt / tau_TKE ) + tmp3 * tau_TKE * ( 1._r8 - exp( - dt / tau_TKE ) )
      !d          ! cu_tkePBLorg_inout(i,1) = max( 0._r8, min( 3._r8, cu_tkePBLorg_inout(i,1) ) )
      !d          ! cu_qtPBLorg_inout(i,1)  = tmp4 / max( sqrt( cu_tkePBLorg_inout(i,1) ), nonzero ) 
      !d          ! cu_thlPBLorg_inout(i,1) = tmp5 / max( sqrt( cu_tkePBLorg_inout(i,1) ), nonzero )
      !d          ! cu_qtPBLorg_inout(i,1)  = max( -2.e-3_r8, min( 2.e-3_r8,  cu_qtPBLorg_inout(i,1) ) )
      !d          ! cu_thlPBLorg_inout(i,1) = max( -2._r8   , min( 2._r8   , cu_thlPBLorg_inout(i,1) ) )
      !d          ! tau_TKE_out(i)          = tau_TKE
      !d        endif
      !d     enddo

      ! ------------------------------------------------------------------------------------------------------- !
      ! 3. Convective updraft and downdraft mass fluxes at surface at several previous ( nstep_org ) time step. !
      !    it = 1         : the most recent time step                                                           !
      !    it = nstep_org : the oldest time step                                                                !
      ! ------------------------------------------------------------------------------------------------------- !

      !d     do it = mit, 1, -1
      !d        if( it .ne. 1 ) then
      !d            cu_cmfu_inout(i,it) = cu_cmfu_inout(i,it-1)
      !d            cu_cmfd_inout(i,it) = cu_cmfd_inout(i,it-1)
      !d        else
      !d            cu_cmfu_inout(i,it) = ( 1._r8 - cuorg ) * cu_cmfu_mxen(ixi) + cuorg * cu_cmfu_mxen(ixf)
      !d            cu_cmfd_inout(i,it) = ( 1._r8 - cuorg ) * cu_cmfd_mxen(ixi) + cuorg * cu_cmfd_mxen(ixf) 
      !d        endif
      !d     enddo

      ! --------------------------------------------------------------------------------------------- !
      ! 4. The mass and scalar properties of detrained airs into each layer from                      !  
      !    individual convective updraft and downdraft at the previous time step.                     !
      !    Due to the tracer array, I cannot save multi-time step informations.                       !
      !    Aug.01.2011. Brian Juwon Park's 9th Birthday. I modified below part to correctly compute   !
      !                 mass-flux weighted average for mixing with multiple mixing environmental air. !
      !                 Below bloak is a new code on this day.                                        !
      !                 Note that for this 'inout' variables, we must use 'do k = 1, mkx' not         !
      !                'k = 1, max( ktop_mxen(1), ktop_mxen(2) )' to correctly put zero values in the !
      !                 layers above 'max( ktop_mxen(1), ktop_mxen(2) )'.                             !
      ! --------------------------------------------------------------------------------------------- !

      do k = 1, mkx
         cu_cmfum_inout(i,k)          = ( 1._r8 - cuorg ) * cu_cmfum_mxen(k,ixi) + cuorg * cu_cmfum_mxen(k,ixf)
         ! ---------------------------- !
         ! Total average detrained airs ! 
         ! ---------------------------- ! ------------------------------------------------------------------------------------------------- !
         ! Aug.12.2011. For more geographically organized mixing, it might be better to include only                                        !
         !              cu_thlr_mxen(k,2). But may not.                                                                                     !
         ! Sep.15.2011. In order to reduce the numerical sensitivity due to on-and-off behavior of convection, define below 'cu_thlr_inout' !
         !              variables as the average of previous two time steps, not just at the previous time step.                            !  
         !              In defining individual cu_thlr_mxen, I used 'am_u' instead of 'cu_cmfr_mxen' for nonzero constraint above.          !
         !              However, below block indicates that the use of 'cu_cmfr_mxen' instead of 'am_u' is much more easy to use.           !
         !              Thus, I modified previous computation using the 'cu_cmfr_mxen'. Since 'cu_thlr_inout' is anomaly values,            !
         !              this use of 'cu_cmfr_mxen' seems to perfectly OK even though 'cu_thlr_mxen' were defined using 'am_u'.              !
         !              In fact, exact two time step average is impossible unless we save multi-time step fields, which is very hard due to !
         !              large number of tracers. Thus, I simply do mass weighting average by using the newly generated 'cu_thlr' at         !
         !              the current time step and the passed 'cu_thlr' from previous time steps. This seems to be most reasonable.          !
         !              However, due to the uncertainty on how the treat the amount of mass itself ( clearly, we cannot add them all !!! ), !
         !              we cannot easily apply this method. Thus, I am leaving as a future work.                                            !
         !              However, current one-time step saving seems to be perfectly OK, which is actually very well mimicking what is       ! 
         !              happening in real nature.                                                                                           !
         !              also, when consideing cumulus updraft trailing previous cumulus updraft, current one time step methods seems to be  !
         !              most perfectly conceptually reasonable. So, let's keep the current one-time-step method which is perfect.           !
         ! -------------------------------------------------------------------------------------------------------------------------------- !  
         cu_cmfr_inout(i,k) =(1._r8 - cuorg)*cu_cmfr_mxen(k,ixi)                     + cuorg*                    cu_cmfr_mxen(k,ixf)
         cu_thlr_inout(i,k) =(1._r8 - cuorg)*cu_thlr_mxen(k,ixi)*cu_cmfr_mxen(k,ixi) + cuorg*cu_thlr_mxen(k,ixf)*cu_cmfr_mxen(k,ixf)
         cu_qtr_inout(i,k)  =(1._r8 - cuorg)* cu_qtr_mxen(k,ixi)*cu_cmfr_mxen(k,ixi) + cuorg* cu_qtr_mxen(k,ixf)*cu_cmfr_mxen(k,ixf)
         cu_ur_inout(i,k)   =(1._r8 - cuorg)*  cu_ur_mxen(k,ixi)*cu_cmfr_mxen(k,ixi) + cuorg*  cu_ur_mxen(k,ixf)*cu_cmfr_mxen(k,ixf)
         cu_vr_inout(i,k)   =(1._r8 - cuorg)*  cu_vr_mxen(k,ixi)*cu_cmfr_mxen(k,ixi) + cuorg*  cu_vr_mxen(k,ixf)*cu_cmfr_mxen(k,ixf)
         cu_qlr_inout(i,k)  =(1._r8 - cuorg)* cu_qlr_mxen(k,ixi)*cu_cmfr_mxen(k,ixi) + cuorg* cu_qlr_mxen(k,ixf)*cu_cmfr_mxen(k,ixf)
         cu_qir_inout(i,k)  =(1._r8 - cuorg)* cu_qir_mxen(k,ixi)*cu_cmfr_mxen(k,ixi) + cuorg* cu_qir_mxen(k,ixf)*cu_cmfr_mxen(k,ixf)
         do mt = 1, ncnst
            cu_trr_inout(i,k,mt) = (1._r8 - cuorg)*cu_trr_mxen(k,mt,ixi)*cu_cmfr_mxen(k,ixi) + &
                                            cuorg*cu_trr_mxen(k,mt,ixf)*cu_cmfr_mxen(k,ixf)
         enddo
         if( cu_cmfr_inout(i,k) .gt. nonzero ) then
            cu_thlr_inout(i,k)       =   cu_thlr_inout(i,k) / cu_cmfr_inout(i,k)
            cu_qtr_inout(i,k)        =    cu_qtr_inout(i,k) / cu_cmfr_inout(i,k)
            cu_ur_inout(i,k)         =     cu_ur_inout(i,k) / cu_cmfr_inout(i,k)
            cu_vr_inout(i,k)         =     cu_vr_inout(i,k) / cu_cmfr_inout(i,k)
            cu_qlr_inout(i,k)        =    cu_qlr_inout(i,k) / cu_cmfr_inout(i,k)
            cu_qir_inout(i,k)        =    cu_qir_inout(i,k) / cu_cmfr_inout(i,k)
            do mt = 1, ncnst
               cu_trr_inout(i,k,mt)  = cu_trr_inout(i,k,mt) / cu_cmfr_inout(i,k)
            enddo
         else
            cu_cmfr_inout(i,k)       = 0._r8
            cu_thlr_inout(i,k)       = 0._r8
            cu_qtr_inout(i,k)        = 0._r8
            cu_ur_inout(i,k)         = 0._r8
            cu_vr_inout(i,k)         = 0._r8
            cu_qlr_inout(i,k)        = 0._r8
            cu_qir_inout(i,k)        = 0._r8
            do mt = 1, ncnst
               cu_trr_inout(i,k,mt)  = 0._r8
            enddo
         endif
         ! ------------------------------------------------------------------------------------------------------------------ !
         ! Aug.2.2011. For diagnostic purpose, print-out 'cu_thvr_inout' and 'cu_rhr_inout'. Note that condensate is computed !
         !             from 'thlr' and 'qtr' by direct variable conversion.                                                   !
         ! ------------------------------------------------------------------------------------------------------------------ !
         call conden( p0(k), cu_thlr_inout(i,k) + thl0(k), cu_qtr_inout(i,k) + qt0(k), th, qv, ql, qi, qse, id_check )
         !f        if( id_check .eq. 1 ) then
         !f            id_exit = .true.
         !f            go to 333
         !f        endif
         cu_thvr_inout(i,k) = th * ( 1._r8 + zvir * qv - ql - qi ) - thv0(k)
         cu_rhr_inout(i,k)  = max( 0._r8, min( 1._r8, qv / max( nonzero, qse ) ) ) - rh0(k)
         ! --------------------------------------------- !
         ! Detrained airs only from convective downdraft ! 
         ! --------------------------------------------- !
         cu_cmfrd_inout(i,k) = (1._r8 - cuorg)*cu_cmfrd_mxen(k,ixi)                      + &
                                        cuorg*cu_cmfrd_mxen(k,ixf)
         cu_thlrd_inout(i,k) = (1._r8 - cuorg)*cu_thlrd_mxen(k,ixi)*cu_cmfrd_mxen(k,ixi) + &
                                        cuorg*cu_thlrd_mxen(k,ixf)*cu_cmfrd_mxen(k,ixf)
         cu_qtrd_inout(i,k)  = (1._r8 - cuorg)* cu_qtrd_mxen(k,ixi)*cu_cmfrd_mxen(k,ixi) + &
                                        cuorg* cu_qtrd_mxen(k,ixf)*cu_cmfrd_mxen(k,ixf)
         cu_urd_inout(i,k)   = (1._r8 - cuorg)*  cu_urd_mxen(k,ixi)*cu_cmfrd_mxen(k,ixi) + &
                                        cuorg*  cu_urd_mxen(k,ixf)*cu_cmfrd_mxen(k,ixf)
         cu_vrd_inout(i,k)   = (1._r8 - cuorg)*  cu_vrd_mxen(k,ixi)*cu_cmfrd_mxen(k,ixi) + &
                                        cuorg*  cu_vrd_mxen(k,ixf)*cu_cmfrd_mxen(k,ixf)
         cu_qlrd_inout(i,k)  = (1._r8 - cuorg)* cu_qlrd_mxen(k,ixi)*cu_cmfrd_mxen(k,ixi) + &
                                        cuorg* cu_qlrd_mxen(k,ixf)*cu_cmfrd_mxen(k,ixf)
         cu_qird_inout(i,k)  = (1._r8 - cuorg)* cu_qird_mxen(k,ixi)*cu_cmfrd_mxen(k,ixi) + &
                                        cuorg* cu_qird_mxen(k,ixf)*cu_cmfrd_mxen(k,ixf)
         do mt = 1, ncnst
            cu_trrd_inout(i,k,mt) = ( 1._r8 - cuorg ) * cu_trrd_mxen(k,mt,ixi) * cu_cmfrd_mxen(k,ixi) + &
                                               cuorg * cu_trrd_mxen(k,mt,ixf) * cu_cmfrd_mxen(k,ixf)
         enddo
         if( cu_cmfrd_inout(i,k) .gt. nonzero ) then
            cu_thlrd_inout(i,k)      =   cu_thlrd_inout(i,k) / cu_cmfrd_inout(i,k)
            cu_qtrd_inout(i,k)       =    cu_qtrd_inout(i,k) / cu_cmfrd_inout(i,k)
            cu_urd_inout(i,k)        =     cu_urd_inout(i,k) / cu_cmfrd_inout(i,k)
            cu_vrd_inout(i,k)        =     cu_vrd_inout(i,k) / cu_cmfrd_inout(i,k)
            cu_qlrd_inout(i,k)       =    cu_qlrd_inout(i,k) / cu_cmfrd_inout(i,k)
            cu_qird_inout(i,k)       =    cu_qird_inout(i,k) / cu_cmfrd_inout(i,k)
            do mt = 1, ncnst
               cu_trrd_inout(i,k,mt) = cu_trrd_inout(i,k,mt) / cu_cmfrd_inout(i,k)
            enddo
         else
            cu_cmfrd_inout(i,k)      = 0._r8
            cu_thlrd_inout(i,k)      = 0._r8
            cu_qtrd_inout(i,k)       = 0._r8
            cu_urd_inout(i,k)        = 0._r8
            cu_vrd_inout(i,k)        = 0._r8
            cu_qlrd_inout(i,k)       = 0._r8
            cu_qird_inout(i,k)       = 0._r8
            do mt = 1, ncnst
               cu_trrd_inout(i,k,mt) = 0._r8
            enddo
         endif
      enddo

      ! -------------------------------------------------------------------------------------------------------- ! 
      ! 5. Convective Organization Parameter                                                                     !
      !    Compute updated convective organization for use at the next time step's ( t + dt ) convection scheme. !
      !    Impose lower and upper limits of [ 0, 1 ].                                                            !
      !    Note that cuorg at the next time step ( cuorg_out ) is updated using grid-mean organization forcing.  !
      !    Since 'tau_org' is and should be defined over the grid-mean, it is not a 'mxen-arrayed' variable but  !
      !    a single value for the entire column.                                                                 !
      ! -------------------------------------------------------------------------------------------------------- !

      !d     orgforce1_out(i)  = ( 1._r8 - cuorg ) * orgforce1_mxen(ixi) + cuorg * orgforce1_mxen(ixf)
      !d     orgforce2_out(i)  = ( 1._r8 - cuorg ) * orgforce2_mxen(ixi) + cuorg * orgforce2_mxen(ixf)
      !d     orgforce3_out(i)  = ( 1._r8 - cuorg ) * orgforce3_mxen(ixi) + cuorg * orgforce3_mxen(ixf)
      !d     orgforce_out(i)   = cc1_org * orgforce1_out(i) + cc2_org * orgforce2_out(i) + cc3_org * orgforce3_out(i)
      !d     tau_org_out(i)    = tau_org
      !d     cuorg_inout(i)    = cuorg * exp( - dt / tau_org_out(i) ) + orgforce_out(i) * tau_org_out(i) * ( 1._r8 - exp( - dt / tau_org_out(i) ) )
      !d     cuorg_inout(i)    = max( 0._r8, min( 1._r8, cuorg_inout(i) ) )

      ! Jun.30.2011. Insert diagnostically-computed organization parameter.
      ! Feb.06.2013. As of today, always choose i_diagorg = 1 and remove this option.

      !c     if( i_diagorg .eq. 1 ) cuorg_inout(i) = cuorg
      cuorg_inout(i) = cuorg

      ! -------------------------------------------------------------------------------------------------------- ! 
      ! 6. Convective Organization Parameter - Time evolution of the difference of PBL-mean conservative scalars !
      !    between off-wake region and grid-mean. At the beginning of next time time, convective organization    !
      !    parameter ( cuorg ) will be diagnostically computed using the PBL-mean vertial potential difference   !
      !    between the off-wake area and the grid-mean.                                                          !
      !    The reason to compute cuorg at the next time step diagnostically is to impose consistency in the      !
      !    computed cuorg at the right time step for correct diagnostic output.                                  ! 
      !    The lower and upper limits of [ 0, 1 ] on the cuorg is also imposed.                                  !
      !    Note that cuorg at the next time step ( cuorg_out ) is updated using grid-mean organization forcing.  !
      !    Since 'tau_org' is and should be defined over the grid-mean, it is not a 'mxen-arrayed' variable but  !
      !    a single value for the entire column.                                                                 !
      !    Note also that we are using the same damping time scale for all scalars since physically, damping of  !
      !    the difference between off-wake and grid-mean value occurs due to lateral mixing along the wall of    !
      !    of the wake from surface to the PBL top interface.                                                    !
      !    CAUTION : We may want to impose a certain on the prognosed 'delta_' variables in order to prevent     !
      !              the disruption by unreasonable values.                                                      !
      !                                                                                                          !
      !    Sep.03.2011. As a forcing of 'delta_thl_PBL' variables in the below, I should also include diabatic   !
      !                 forcing within wake area ( aw * Qw ) as well as adiabatic flux at the PBL top interface  !
      !                 from the several selected downdraft components. Since diabatic forcing ( evaporation of  !
      !                 convective precipitation ) is larger over the land than over the ocean, this will        !
      !                 help to increase convective organization over the land, if I define 'cuorg' as the       !
      !                 normalized 'delta_thv_PBL' as in the current code.                                       !     
      !    Sep.07.2011. Redefine total forcings including both adiabatic forcing and two diabatic forcings both  !
      !                 within convective downdraft and environment.                                             ! 
      !                 Also rename the variables.                                                               !
      !    Sep.07.2011. Also includes prognostic equation for the wake area.                                     !
      !                 I should be very careful when I define 'tau' for 'niter' ensemble.                       !
      !                 In addition, I should define 'tau' differently for individual conservative scalars and   !
      !                 wake area. This is because adjustment of wake by surface flux can generate diffferent    !
      !                 relaxation time scale for each conservative scalar.                                      !
      !                 Note that 'tau' for conservative scalar for iter = 1 is the same as the value for        !
      !                 iter = 2 even though we include surface flux adjustment. However, 'tau' for wake area    !
      !                 are different for iter = 1 and iter = 2. Regardless of whether it is conservative scalar !
      !                 of wak area, we should perform 'cuorg' weighted average using '1/tau(iter)' and then     !
      !                 the resulting '1/tau(avg)' should be inversed to obtain the final 'tau(avg)'. This is    !
      !                 because the prognostic organization equations below are 1st order LINEAR equation.       !
      !                 By doing this, we can compuetely remove the ambiguity on the treatment of 'tau' in the   !
      !                 ensemble mean both for conservative scalar and wake area.                                !           
      !                 In the below block, 'taui' denotes '1/tau', i.e., inverse tau.                           ! 
      !                 Note that 'tau' for 'awk' can be negative, which is completely OK.                       !
      !    Sep.09.2011. I don't prognose 'thv' any more - it will be computed diagnostically at the beginning of !
      !                 the next time step for full model consistency.                                           !     
      ! -------------------------------------------------------------------------------------------------------- !

      ! -------------------------------- !
      ! Inverse of Adjustment Time Scale !
      ! -------------------------------- ! 

      taui_thl_out(i)              = ( 1._r8 - cuorg ) *            taui_thl_mxen(ixi) + &
                                     cuorg *            taui_thl_mxen(ixf)
      taui_qt_out(i)               = ( 1._r8 - cuorg ) *             taui_qt_mxen(ixi) + &
                                     cuorg *             taui_qt_mxen(ixf)
      taui_u_out(i)                = ( 1._r8 - cuorg ) *              taui_u_mxen(ixi) + &
                                     cuorg *              taui_u_mxen(ixf)
      taui_v_out(i)                = ( 1._r8 - cuorg ) *              taui_v_mxen(ixi) + &
                                     cuorg *              taui_v_mxen(ixf)
      ! taui_thv_out(i)              = ( 1._r8 - cuorg ) *            taui_thv_mxen(ixi) + cuorg *            taui_thv_mxen(ixf)
      do mt = 1, ncnst
         taui_tr_out(i,mt)         = ( 1._r8 - cuorg ) *          taui_tr_mxen(mt,ixi) + &
                                     cuorg *          taui_tr_mxen(mt,ixf)      
      enddo
      taui_awk_out(i)              = ( 1._r8 - cuorg ) *            taui_awk_mxen(ixi) + &
                                     cuorg *            taui_awk_mxen(ixf)

      !ogg   Temporary diagnostic output
 
      del_org_out(i)               = ( 1._r8 - cuorg ) *              del_org_mxen(ixi) + &
                                     cuorg *             del_org_mxen(ixf)
      del0_org_out(i)              = ( 1._r8 - cuorg ) *             del0_org_mxen(ixi) + &
                                     cuorg *            del0_org_mxen(ixf)
 
      !ogg   Temporary diagnostic output
       
      ! -------------------------- !
      ! Total Organization Forcing ! 
      ! -------------------------- !

      thl_orgforce_out(i)          = ( 1._r8 - cuorg ) *        thl_orgforce_mxen(ixi) + &
                                     cuorg *        thl_orgforce_mxen(ixf)
      qt_orgforce_out(i)           = ( 1._r8 - cuorg ) *         qt_orgforce_mxen(ixi) + &
                                     cuorg *         qt_orgforce_mxen(ixf)
      u_orgforce_out(i)            = ( 1._r8 - cuorg ) *          u_orgforce_mxen(ixi) + &
                                     cuorg *          u_orgforce_mxen(ixf)
      v_orgforce_out(i)            = ( 1._r8 - cuorg ) *          v_orgforce_mxen(ixi) + &
                                     cuorg *          v_orgforce_mxen(ixf)
      ! thv_orgforce_out(i)          = ( 1._r8 - cuorg ) *        thv_orgforce_mxen(ixi) + cuorg *        thv_orgforce_mxen(ixf)
      do mt = 1, ncnst
         tr_orgforce_out(i,mt)     = ( 1._r8 - cuorg ) *      tr_orgforce_mxen(mt,ixi) + &
                                     cuorg *      tr_orgforce_mxen(mt,ixf)
      enddo
      awk_orgforce_out(i)          = ( 1._r8 - cuorg ) *        awk_orgforce_mxen(ixi) + &
                                     cuorg *        awk_orgforce_mxen(ixf)

      ! ----------------------------------------------------- !
      ! Individual Organization Forcing for Diagnostic Output ! 
      ! ----------------------------------------------------- !

      thl_orgforce_flx_out(i)      = ( 1._r8 - cuorg ) *    thl_orgforce_flx_mxen(ixi) + &
                                     cuorg *    thl_orgforce_flx_mxen(ixf)
      thl_orgforce_und_out(i)      = ( 1._r8 - cuorg ) *    thl_orgforce_und_mxen(ixi) + &
                                     cuorg *    thl_orgforce_und_mxen(ixf)
      thl_orgforce_env_out(i)      = ( 1._r8 - cuorg ) *    thl_orgforce_env_mxen(ixi) + &
                                     cuorg *    thl_orgforce_env_mxen(ixf)

      qt_orgforce_flx_out(i)       = ( 1._r8 - cuorg ) *     qt_orgforce_flx_mxen(ixi) + &
                                     cuorg *     qt_orgforce_flx_mxen(ixf)
      qt_orgforce_und_out(i)       = ( 1._r8 - cuorg ) *     qt_orgforce_und_mxen(ixi) + &
                                     cuorg *     qt_orgforce_und_mxen(ixf)
      qt_orgforce_env_out(i)       = ( 1._r8 - cuorg ) *     qt_orgforce_env_mxen(ixi) + &
                                     cuorg *     qt_orgforce_env_mxen(ixf)

      u_orgforce_flx_out(i)        = ( 1._r8 - cuorg ) *      u_orgforce_flx_mxen(ixi) + &
                                     cuorg *      u_orgforce_flx_mxen(ixf)
      u_orgforce_und_out(i)        = ( 1._r8 - cuorg ) *      u_orgforce_und_mxen(ixi) + &
                                     cuorg *      u_orgforce_und_mxen(ixf)
      u_orgforce_env_out(i)        = ( 1._r8 - cuorg ) *      u_orgforce_env_mxen(ixi) + &
                                     cuorg *      u_orgforce_env_mxen(ixf)

      v_orgforce_flx_out(i)        = ( 1._r8 - cuorg ) *      v_orgforce_flx_mxen(ixi) + &
                                     cuorg *      v_orgforce_flx_mxen(ixf)
      v_orgforce_und_out(i)        = ( 1._r8 - cuorg ) *      v_orgforce_und_mxen(ixi) + &
                                     cuorg *      v_orgforce_und_mxen(ixf)
      v_orgforce_env_out(i)        = ( 1._r8 - cuorg ) *      v_orgforce_env_mxen(ixi) + &
                                     cuorg *      v_orgforce_env_mxen(ixf)

      do mt = 1, ncnst
         tr_orgforce_flx_out(i,mt) = ( 1._r8 - cuorg ) *  tr_orgforce_flx_mxen(mt,ixi) + &
                                     cuorg *  tr_orgforce_flx_mxen(mt,ixf)
         tr_orgforce_und_out(i,mt) = ( 1._r8 - cuorg ) *  tr_orgforce_und_mxen(mt,ixi) + &
                                     cuorg *  tr_orgforce_und_mxen(mt,ixf)
         tr_orgforce_env_out(i,mt) = ( 1._r8 - cuorg ) *  tr_orgforce_env_mxen(mt,ixi) + &
                                     cuorg *  tr_orgforce_env_mxen(mt,ixf)
      enddo

      awk_orgforce_flx_out(i)      = ( 1._r8 - cuorg ) *    awk_orgforce_flx_mxen(ixi) + &
                                     cuorg *    awk_orgforce_flx_mxen(ixf)
      awk_orgforce_mix_out(i)      = ( 1._r8 - cuorg ) *    awk_orgforce_mix_mxen(ixi) + &
                                     cuorg *    awk_orgforce_mix_mxen(ixf)

      cmf_d_org_pblh_out(i)        = ( 1._r8 - cuorg ) *      cmf_d_org_pblh_mxen(ixi) + &
                                     cuorg *      cmf_d_org_pblh_mxen(ixf)

      ! -------------------------------------------------------------------------------------------------------------- !
      ! Sep.07.2011. If the prognosed wake area becomes larger than the available maximum value ( awk_PBL_max ),       !
      !              increae the detrainment rate of the wake 'del_wk', such that the prognozed wake area becomes      !
      !              identical to awk_PBL_max. Also correspondingly modify 'awk_orgforce_out(i)' and 'taui_thl_out(i)' ! 
      !              etc. which are explicit function of 'del_wk'.                                                     !
      !              Note that this 'awk_PBL_max' constraint is applied to the prognozed 'awk_PBL' but BEFORE applying !
      !              non-homogeneous distribution assumption of wake properties. When we apply non-homogeneous distr.  !
      !              assumption of wake properties at the next time step, we an further decrease the wake area. So,    !
      !              we have double safety which is good. Note also that due to the coding structure, it is very hard  !
      !              to apply the awk_PBL_max constraint after applying non-homogeneous distribution assumption of     !
      !              wake properties. Current UNICON code is reasonable good and perfect.                              !                                          
      ! Sep.09.2011. I don't prognose 'thv' anymore.                                                                   !
      !              I should re-check whether below formula is exactly correct or not - should re-derive for check.   !             
      ! Sep.11.2011. In the below block, 'tmp1' is an adjusted new 'del_wk'.                                           !
      !              Note that the initial 'del_wk' specified from the parameter sentence can be zero. So, in order to !
      !              prevent division by zero, I used max( del_wk, nonzero ) in the below block.                       !
      ! REQUIREMENT: I must re-check whether below formula is not correct or not.                                      !
      !              I have not done re-checking yet as of Sep.11.2011.                                                !
      ! Sep.11.2011. In case of 'awk_PBL', I should adjust 'awk_orgforce' which is a function of del_wk, while         !
      !              in case of 'thl,qt' , I should adjust 'taui'         which is a function of del_wk.               !
      !              In the below block, 'tmp1' is a newly adjusted 'del_wk'.                                          !
      !              I performed correct re-checking and corrected the previously wrong code.                          ! 
      ! -------------------------------------------------------------------------------------------------------------- !

      if( abs(taui_awk_out(i)) .gt. nonzero ) then
         awk_PBL_inout(i)         =  awk_PBL *    exp( - dt * taui_awk_out(i) ) + &
                                     awk_orgforce_out(i) / taui_awk_out(i) * &
                                    ( 1._r8 - exp( - dt * taui_awk_out(i) ) )
      else
         awk_PBL_inout(i)         =  awk_PBL * ( 1._r8 - dt * taui_awk_out(i) ) + &
                                     awk_orgforce_out(i) * dt
      endif

      if( awk_PBL_inout(i) .gt. awk_PBL_max ) then
         awk_PBL_inout(i) = awk_PBL_max
         tmp2 = awk_orgforce_out(i)
         if( abs(taui_awk_out(i)) .gt. nonzero ) then
            awk_orgforce_out(i) = ( awk_PBL_max - awk_PBL * exp( - dt * taui_awk_out(i) ) ) * &
            taui_awk_out(i) / ( 1._r8 - exp( - dt * taui_awk_out(i) ) ) 
         else
            awk_orgforce_out(i) = ( awk_PBL_max - awk_PBL * ( 1._r8 - dt * taui_awk_out(i) ) ) / dt
         endif
         tmp1 = del_wk_eff + tmp2 - awk_orgforce_out(i)
         tmp3 = 1._r8 / max( nonzero, awk_PBL * ( 1._r8 - awk_PBL ) )
         ! Below is correctly, re-checked code on Sep.11.2011.
         taui_thl_out(i)      =  taui_thl_out(i)   + tmp3 * ( tmp1 - del_wk_eff )
         taui_qt_out(i)       =  taui_qt_out(i)    + tmp3 * ( tmp1 - del_wk_eff )
         taui_u_out(i)        =  taui_u_out(i)     + tmp3 * ( tmp1 - del_wk_eff )
         taui_v_out(i)        =  taui_v_out(i)     + tmp3 * ( tmp1 - del_wk_eff )
         ! taui_thv_out(i)      =  taui_thv_out(i)   + tmp3 * ( tmp1 - del_wk_eff )
         do mt = 1, ncnst
            taui_tr_out(i,mt) =  taui_tr_out(i,mt) + tmp3 * ( tmp1 - del_wk_eff )
         enddo
         ! Below is previously wrong code.
         ! tmp3 = tmp1 / max( del_wk_eff, nonzero )
         ! tmp4 = ws1 / pblhz
         ! taui_thl_out(i)      = tmp3 *   taui_thl_out(i) + ( 1._r8 - tmp3 ) * (    cd_thl * tmp4 )
         ! taui_qt_out(i)       = tmp3 *    taui_qt_out(i) + ( 1._r8 - tmp3 ) * (     cd_qt * tmp4 )
         ! taui_u_out(i)        = tmp3 *     taui_u_out(i) + ( 1._r8 - tmp3 ) * (      cd_u * tmp4 )
         ! taui_v_out(i)        = tmp3 *     taui_v_out(i) + ( 1._r8 - tmp3 ) * (      cd_v * tmp4 )
         !! taui_thv_out(i)      = tmp3 *   taui_thv_out(i) + ( 1._r8 - tmp3 ) * (    cd_thv * tmp4 )
         ! do mt = 1, ncnst
         !    taui_tr_out(i,mt) = tmp3 * taui_tr_out(i,mt) + ( 1._r8 - tmp3 ) * ( cd_tr(mt) * tmp4 )
         ! enddo
      endif

      !og
      !og When a new energy-consistent cold pool formula is used, the above corrective detrainment part 
      !og should be modified as below.    
      !og It seems that I don't need to do here anything since the above block seems to be perfectly
      !og valid for this energy-consistent cold pool case.
      !og I checked that the above formula is also exactly valid for this energy-consistent cold pool case.
      !og So, I don't need to do anything new here.
      !og    if( i_energy_coldpool .eq. 1 ) then
      !og        .....   
      !og    endif
      !og
 
      ! ------------------------------------------------------ !
      ! Compute final prognosed state                          !
      ! I may need to impose a bound on the prognosed results. !
      ! Sep.09.2011. I don't prognose 'thv' anymore.           !  
      ! ------------------------------------------------------ !

      if( abs(taui_thl_out(i)) .gt. nonzero ) then
         delta_thl_PBL_inout(i)      =    delta_thl_PBL *    exp( - dt * taui_thl_out(i) ) + thl_orgforce_out(i) / &
                                          taui_thl_out(i) * ( 1._r8 - exp( - dt * taui_thl_out(i) ) )
      else
         delta_thl_PBL_inout(i)      =    delta_thl_PBL * ( 1._r8 - dt * taui_thl_out(i) ) + thl_orgforce_out(i) * dt
      endif
      if( abs(taui_qt_out(i)) .gt. nonzero ) then
         delta_qt_PBL_inout(i)       =     delta_qt_PBL *    exp( - dt * taui_qt_out(i) ) + qt_orgforce_out(i) / &
                                           taui_qt_out(i) * ( 1._r8 - exp( - dt * taui_qt_out(i) ) )
      else
         delta_qt_PBL_inout(i)       =     delta_qt_PBL * ( 1._r8 - dt * taui_qt_out(i) ) + qt_orgforce_out(i) * dt
      endif
      if( abs(taui_u_out(i)) .gt. nonzero ) then
         delta_u_PBL_inout(i)        =      delta_u_PBL *    exp( - dt * taui_u_out(i) ) + u_orgforce_out(i) / &
                                            taui_u_out(i) * ( 1._r8 - exp( - dt * taui_u_out(i) ) )
      else
         delta_u_PBL_inout(i)        =      delta_u_PBL * ( 1._r8 - dt * taui_u_out(i) ) + u_orgforce_out(i) * dt
      endif
      if( abs(taui_v_out(i)) .gt. nonzero ) then
         delta_v_PBL_inout(i)        =      delta_v_PBL *    exp( - dt * taui_v_out(i) ) + v_orgforce_out(i) / &
                                            taui_v_out(i) * ( 1._r8 - exp( - dt * taui_v_out(i) ) )
      else
         delta_v_PBL_inout(i)        =      delta_v_PBL * ( 1._r8 - dt * taui_v_out(i) ) + v_orgforce_out(i) * dt
      endif
      ! if( abs(taui_thv_out(i)) .gt. nonzero ) then
      !     delta_thv_PBL_inout(i)      =    delta_thv_PBL *    exp( - dt * taui_thv_out(i) ) + thv_orgforce_out(i) / taui_thv_out(i) * ( 1._r8 - exp( - dt * taui_thv_out(i) ) )
      ! else
      !     delta_thv_PBL_inout(i)      =    delta_thv_PBL * ( 1._r8 - dt * taui_thv_out(i) ) + thv_orgforce_out(i) * dt
      ! endif
      do mt = 1, ncnst
         if ( abs(taui_tr_out(i,mt)) .gt. nonzero) then
            delta_tr_PBL_inout(i,mt) = delta_tr_PBL(mt) *    exp( - dt * taui_tr_out(i,mt) ) + tr_orgforce_out(i,mt) / &
              taui_tr_out(i,mt) * ( 1._r8 - exp( - dt * taui_tr_out(i,mt) ) )
         else
            delta_tr_PBL_inout(i,mt) = delta_tr_PBL(mt) * ( 1._r8 - dt * taui_tr_out(i,mt) ) + tr_orgforce_out(i,mt) * dt
         endif
      enddo

      !333 continue
     
      !f   if( id_exit ) then 

      !f       exit_Cu(i)                                    = 1._r8

      !f     ! Aug.02.2011. I really don't need below block for initializing below non-out variables.
      !f     !              Thus, I commented out below block.

      !f     ! slten(:mkx)                                   = 0._r8
      !f     ! qtten(:mkx)                                   = 0._r8
      !f     ! qlten(:mkx)                                   = 0._r8
      !f     ! qiten(:mkx)                                   = 0._r8
      !f     ! qvten(:mkx)                                   = 0._r8
      !f     ! do mt = 1, ncnst
      !f     !    trten(:mkx,mt)                             = 0._r8
      !f     ! enddo        
      !f     ! sten(:mkx)                                    = 0._r8
      !f     ! uten(:mkx)                                    = 0._r8
      !f     ! vten(:mkx)                                    = 0._r8

      !f       cmf_u_out(i,0:mkx)                            = 0._r8
      !f       slflx_out(i,0:mkx)                            = 0._r8
      !f       qtflx_out(i,0:mkx)                            = 0._r8
      !f       qvten_out(i,:mkx)                             = 0._r8
      !f       qlten_out(i,:mkx)                             = 0._r8
      !f       qiten_out(i,:mkx)                             = 0._r8
      !f       do mt = 1, ncnst
      !f          trten_out(i,:mkx,mt)                       = 0._r8
      !f       enddo
      !f       sten_out(i,:mkx)                              = 0._r8
      !f       uten_out(i,:mkx)                              = 0._r8
      !f       vten_out(i,:mkx)                              = 0._r8
      !f       qrten_out(i,:mkx)                             = 0._r8
      !f       qsten_out(i,:mkx)                             = 0._r8

      !f       rqc_l_out(i,:mkx)                             = 0._r8
      !f       rqc_i_out(i,:mkx)                             = 0._r8
      !f       rqc_out(i,:mkx)                               = 0._r8
      !f       rnc_l_out(i,:mkx)                             = 0._r8
      !f       rnc_i_out(i,:mkx)                             = 0._r8
      !f       evapc_out(i,:mkx)                             = 0._r8
      !f       am_u_out(i,:mkx)                              = 0._r8
      !f       qlm_u_out(i,:mkx)                             = 0._r8
      !f       qim_u_out(i,:mkx)                             = 0._r8
      !f       am_d_out(i,:mkx)                              = 0._r8
      !f       qlm_d_out(i,:mkx)                             = 0._r8
      !f       qim_d_out(i,:mkx)                             = 0._r8

      !f       rliq_out(i)                                   = 0._r8
      !f       rice_out(i)                                   = 0._r8
      !f       precip_out(i)                                 = 0._r8
      !f       snow_out(i)                                   = 0._r8
      !f       cnt_out(i)                                    = 1._r8
      !f       cnb_out(i)                                    = real(mkx, r8)

      !f       cmf_out(i,mkx:0:-1)                           = 0._r8
      !f       uflx_out(i,mkx:0:-1)                          = 0._r8
      !f       vflx_out(i,mkx:0:-1)                          = 0._r8
      !f       slflx_u_out(i,mkx:0:-1)                       = 0._r8
      !f       qtflx_u_out(i,mkx:0:-1)                       = 0._r8
      !f       uflx_u_out(i,mkx:0:-1)                        = 0._r8
      !f       vflx_u_out(i,mkx:0:-1)                        = 0._r8
      !f       cmf_d_out(i,mkx:0:-1)                         = 0._r8
      !f       slflx_d_out(i,mkx:0:-1)                       = 0._r8
      !f       qtflx_d_out(i,mkx:0:-1)                       = 0._r8
      !f       uflx_d_out(i,mkx:0:-1)                        = 0._r8
      !f       vflx_d_out(i,mkx:0:-1)                        = 0._r8

      !f       slflx_d_org_out(i,mkx:0:-1)                   = 0._r8
      !f       qtflx_d_org_out(i,mkx:0:-1)                   = 0._r8

      !f     ! Sep.07.2011. Change the variable names. Also add 'taui' variables.
      !f     ! Sep.09.2011. The 'thv' is not prognosed anymore.

      !f       thl_orgforce_out(i)                           = 0._r8
      !f       qt_orgforce_out(i)                            = 0._r8
      !f       u_orgforce_out(i)                             = 0._r8
      !f       v_orgforce_out(i)                             = 0._r8
      !f     ! thv_orgforce_out(i)                           = 0._r8
      !f       do mt = 1, ncnst
      !f          tr_orgforce_out(i,mt)                      = 0._r8
      !f       enddo
      !f       awk_orgforce_out(i)                           = 0._r8

      !f     ! Below block is for detailed diagnostic output

      !f       thl_orgforce_flx_out(i)                       = 0._r8 
      !f       qt_orgforce_flx_out(i)                        = 0._r8 
      !f       u_orgforce_flx_out(i)                         = 0._r8 
      !f       v_orgforce_flx_out(i)                         = 0._r8 
      !f       do mt = 1, ncnst
      !f          tr_orgforce_flx_out(i,mt)                  = 0._r8 
      !f       enddo
      !f       awk_orgforce_flx_out(i)                       = 0._r8 

      !f       thl_orgforce_und_out(i)                       = 0._r8 
      !f       qt_orgforce_und_out(i)                        = 0._r8 
      !f       u_orgforce_und_out(i)                         = 0._r8 
      !f       v_orgforce_und_out(i)                         = 0._r8 
      !f       do mt = 1, ncnst
      !f          tr_orgforce_und_out(i,mt)                  = 0._r8 
      !f       enddo 
      !f       awk_orgforce_mix_out(i)                       = 0._r8 
      
      !f       thl_orgforce_env_out(i)                       = 0._r8 
      !f       qt_orgforce_env_out(i)                        = 0._r8 
      !f       u_orgforce_env_out(i)                         = 0._r8 
      !f       v_orgforce_env_out(i)                         = 0._r8 
      !f       do mt = 1, ncnst
      !f          tr_orgforce_env_out(i,mt)                  = 0._r8 
      !f       enddo
      !f       cmf_d_org_pblh_out(i)                         = 0._r8 

      !f     ! Above block is for detailed diagnostic output

      !f       taui_thl_out(i)                               = 0._r8
      !f       taui_qt_out(i)                                = 0._r8
      !f       taui_u_out(i)                                 = 0._r8
      !f       taui_v_out(i)                                 = 0._r8
      !f     ! taui_thv_out(i)                               = 0._r8
      !f       do mt = 1, ncnst
      !f          taui_tr_out(i,mt)                          = 0._r8
      !f       enddo
      !f       taui_awk_out(i)                               = 0._r8

      !f       slten_u_out(i,mkx:1:-1)                       = 0._r8
      !f       qtten_u_out(i,mkx:1:-1)                       = 0._r8
      !f       uten_u_out(i,mkx:1:-1)                        = 0._r8
      !f       vten_u_out(i,mkx:1:-1)                        = 0._r8
      !f       sten_u_out(i,mkx:1:-1)                        = 0._r8
      !f       qvten_u_out(i,mkx:1:-1)                       = 0._r8
      !f       qlten_u_out(i,mkx:1:-1)                       = 0._r8
      !f       qiten_u_out(i,mkx:1:-1)                       = 0._r8
      !f       do mt = 1, ncnst
      !f          trten_u_out(i,mkx:1:-1,mt)                 = 0._r8
      !f       enddo

      !f       slten_d_out(i,mkx:1:-1)                       = 0._r8
      !f       qtten_d_out(i,mkx:1:-1)                       = 0._r8
      !f       uten_d_out(i,mkx:1:-1)                        = 0._r8
      !f       vten_d_out(i,mkx:1:-1)                        = 0._r8
      !f       sten_d_out(i,mkx:1:-1)                        = 0._r8
      !f       qvten_d_out(i,mkx:1:-1)                       = 0._r8
      !f       qlten_d_out(i,mkx:1:-1)                       = 0._r8
      !f       qiten_d_out(i,mkx:1:-1)                       = 0._r8
      !f       do mt = 1, ncnst
      !f          trten_d_out(i,mkx:1:-1,mt)                 = 0._r8
      !f       enddo

      !f       slten_evp_out(i,mkx:1:-1)                     = 0._r8
      !f       qtten_evp_out(i,mkx:1:-1)                     = 0._r8
      !f       uten_evp_out(i,mkx:1:-1)                      = 0._r8
      !f       vten_evp_out(i,mkx:1:-1)                      = 0._r8
      !f       sten_evp_out(i,mkx:1:-1)                      = 0._r8
      !f       qvten_evp_out(i,mkx:1:-1)                     = 0._r8
      !f       qlten_evp_out(i,mkx:1:-1)                     = 0._r8
      !f       qiten_evp_out(i,mkx:1:-1)                     = 0._r8
      !f     ! Dec.13.2012. Wet deposition term is added.
      !f       do mt = 1, ncnst
      !f          trten_evp_out(i,mkx:1:-1,mt)               = 0._r8
      !f          trten_wdep_out(i,mkx:1:-1,mt)              = 0._r8
      !f       enddo

      !f       slten_dis_out(i,mkx:1:-1)                     = 0._r8
      !f       qtten_dis_out(i,mkx:1:-1)                     = 0._r8
      !f       uten_dis_out(i,mkx:1:-1)                      = 0._r8
      !f       vten_dis_out(i,mkx:1:-1)                      = 0._r8
      !f       sten_dis_out(i,mkx:1:-1)                      = 0._r8
      !f       qvten_dis_out(i,mkx:1:-1)                     = 0._r8
      !f       qlten_dis_out(i,mkx:1:-1)                     = 0._r8
      !f       qiten_dis_out(i,mkx:1:-1)                     = 0._r8
      !f       do mt = 1, ncnst
      !f          trten_dis_out(i,mkx:1:-1,mt)               = 0._r8
      !f       enddo

      !f       qlten_sub_out(i,mkx:1:-1)                     = 0._r8
      !f       qiten_sub_out(i,mkx:1:-1)                     = 0._r8
      !f       qlten_det_out(i,mkx:1:-1)                     = 0._r8
      !f       qiten_det_out(i,mkx:1:-1)                     = 0._r8

      !f       thl_u_out(i,mkx:0:-1)                         = 0._r8
      !f       qt_u_out(i,mkx:0:-1)                          = 0._r8
      !f       u_u_out(i,mkx:0:-1)                           = 0._r8
      !f       v_u_out(i,mkx:0:-1)                           = 0._r8
      !f       w_u_out(i,mkx:0:-1)                           = 0._r8
      !f       ql_u_out(i,mkx:0:-1)                          = 0._r8
      !f       qi_u_out(i,mkx:0:-1)                          = 0._r8
      !f       do mt = 1, ncnst
      !f          tr_u_out(i,mkx:0:-1,mt)                    = 0._r8
      !f       enddo
      !f       a_u_out(i,mkx:0:-1)                           = 0._r8
      !f       num_u_out(i,mkx:0:-1)                         = 0._r8
      !f       wa_u_out(i,mkx:0:-1)                          = 0._r8
      !f       qla_u_out(i,mkx:0:-1)                         = 0._r8
      !f       qia_u_out(i,mkx:0:-1)                         = 0._r8
      !f       rad_u_out(i,mkx:0:-1)                         = 0._r8
      !f       gamw_u_out(i,mkx:0:-1)                        = 0._r8
      !f       thva_u_out(i,mkx:0:-1)                        = 0._r8

      !f       thl_d_out(i,mkx:0:-1)                         = 0._r8
      !f       qt_d_out(i,mkx:0:-1)                          = 0._r8
      !f       u_d_out(i,mkx:0:-1)                           = 0._r8
      !f       v_d_out(i,mkx:0:-1)                           = 0._r8
      !f       w_d_out(i,mkx:0:-1)                           = 0._r8
      !f       ql_d_out(i,mkx:0:-1)                          = 0._r8
      !f       qi_d_out(i,mkx:0:-1)                          = 0._r8
      !f       do mt = 1, ncnst
      !f          tr_d_out(i,mkx:0:-1,mt)                    = 0._r8
      !f       enddo
      !f       a_d_out(i,mkx:0:-1)                           = 0._r8
      !f       wa_d_out(i,mkx:0:-1)                          = 0._r8
      !f       qla_d_out(i,mkx:0:-1)                         = 0._r8
      !f       qia_d_out(i,mkx:0:-1)                         = 0._r8

      !f    do msfc = 1, nseg
      
      !f       thl_u_msfc_out(i,mkx:0:-1,msfc,1:niter)       = 0._r8
      !f       qt_u_msfc_out(i,mkx:0:-1,msfc,1:niter)        = 0._r8
      !f       u_u_msfc_out(i,mkx:0:-1,msfc,1:niter)         = 0._r8
      !f       v_u_msfc_out(i,mkx:0:-1,msfc,1:niter)         = 0._r8
      !f       w_u_msfc_out(i,mkx:0:-1,msfc,1:niter)         = 0._r8
      !f       ql_u_msfc_out(i,mkx:0:-1,msfc,1:niter)        = 0._r8
      !f       qi_u_msfc_out(i,mkx:0:-1,msfc,1:niter)        = 0._r8
      !f       do mt = 1, ncnst
      !f          tr_u_msfc_out(i,mkx:0:-1,msfc,mt,1:niter)  = 0._r8
      !f       enddo
      !f       cmf_u_msfc_out(i,mkx:0:-1,msfc,1:niter)       = 0._r8
      !f       a_u_msfc_out(i,mkx:0:-1,msfc,1:niter)         = 0._r8
      !f       num_u_msfc_out(i,mkx:0:-1,msfc,1:niter)       = 0._r8
      !f       rad_u_msfc_out(i,mkx:0:-1,msfc,1:niter)       = 0._r8

      !f       eps0_u_msfc_out(i,mkx:0:-1,msfc,1:niter)      = 0._r8
      !f       eps_u_msfc_out(i,mkx:0:-1,msfc,1:niter)       = 0._r8
      !f       del_u_msfc_out(i,mkx:0:-1,msfc,1:niter)       = 0._r8
      !f       eeps_u_msfc_out(i,mkx:0:-1,msfc,1:niter)      = 0._r8
      !f       ddel_u_msfc_out(i,mkx:0:-1,msfc,1:niter)      = 0._r8
      !f       xc_u_msfc_out(i,mkx:0:-1,msfc,1:niter)        = 0._r8
      !f       xs_u_msfc_out(i,mkx:0:-1,msfc,1:niter)        = 0._r8
      !f       xemin_u_msfc_out(i,mkx:0:-1,msfc,1:niter)     = 0._r8
      !f       xemax_u_msfc_out(i,mkx:0:-1,msfc,1:niter)     = 0._r8
      !f       cridis_u_msfc_out(i,mkx:0:-1,msfc,1:niter)    = 0._r8
      !f       thvcuenv_u_msfc_out(i,mkx:0:-1,msfc,1:niter)  = 0._r8
      !f       thvegenv_u_msfc_out(i,mkx:0:-1,msfc,1:niter)  = 0._r8
      !f       thvxsenv_u_msfc_out(i,mkx:0:-1,msfc,1:niter)  = 0._r8
      !f       fmix_u_msfc_out(i,mkx:0:-1,msfc,1:niter)      = 0._r8
      !f       cmfumix_u_msfc_out(i,mkx:0:-1,msfc,1:niter)   = 0._r8
  
      !f       thl_d_msfc_out(i,mkx:0:-1,msfc,1:niter)       = 0._r8
      !f       qt_d_msfc_out(i,mkx:0:-1,msfc,1:niter)        = 0._r8
      !f       u_d_msfc_out(i,mkx:0:-1,msfc,1:niter)         = 0._r8
      !f       v_d_msfc_out(i,mkx:0:-1,msfc,1:niter)         = 0._r8
      !f       w_d_msfc_out(i,mkx:0:-1,msfc,1:niter)         = 0._r8
      !f       ql_d_msfc_out(i,mkx:0:-1,msfc,1:niter)        = 0._r8
      !f       qi_d_msfc_out(i,mkx:0:-1,msfc,1:niter)        = 0._r8
      !f       do mt = 1, ncnst
      !f          tr_d_msfc_out(i,mkx:0:-1,msfc,mt,1:niter)  = 0._r8
      !f       enddo
      !f       cmf_d_msfc_out(i,mkx:0:-1,msfc,1:niter)       = 0._r8
      !f       a_d_msfc_out(i,mkx:0:-1,msfc,1:niter)         = 0._r8
      !f       wa_d_msfc_out(i,mkx:0:-1,msfc,1:niter)        = 0._r8
      !f       qla_d_msfc_out(i,mkx:0:-1,msfc,1:niter)       = 0._r8
      !f       qia_d_msfc_out(i,mkx:0:-1,msfc,1:niter)       = 0._r8
     
      !f       ktop_msfc_out(i,msfc,1:niter)                 = 0
      !f       ptop_msfc_out(i,msfc,1:niter)                 = 0._r8
      !f       ztop_msfc_out(i,msfc,1:niter)                 = 0._r8
      
      !f    enddo

      !f    cush_inout(i)                                    =  pblhz 
      !f    cushavg_inout(i)                                 =  pblhz 
     
      !d    do it = mit, 1, -1
      !d       if( it .ne. 1 ) then
      !d           cu_prep_inout(i,it)                       =      cu_prep_inout(i,it-1)
      !d           cu_tkePBLorg_inout(i,it)                  = cu_tkePBLorg_inout(i,it-1)
      !d           cu_cmfPBLorg_inout(i,it)                  = cu_cmfPBLorg_inout(i,it-1)
      !d           cu_thlPBLorg_inout(i,it)                  = cu_thlPBLorg_inout(i,it-1)
      !d           cu_qtPBLorg_inout(i,it)                   =  cu_qtPBLorg_inout(i,it-1)
      !d           cu_uPBLorg_inout(i,it)                    =   cu_uPBLorg_inout(i,it-1)
      !d           cu_vPBLorg_inout(i,it)                    =   cu_vPBLorg_inout(i,it-1)
      !d       else
      !d           cu_prep_inout(i,it)                       = 0._r8
      !d           cu_tkePBLorg_inout(i,it)                  = 0._r8
      !d           cu_cmfPBLorg_inout(i,it)                  = 0._r8
      !d           cu_thlPBLorg_inout(i,it)                  = 0._r8
      !d           cu_qtPBLorg_inout(i,it)                   = 0._r8
      !d           cu_uPBLorg_inout(i,it)                    = 0._r8
      !d           cu_vPBLorg_inout(i,it)                    = 0._r8
      !d           ! --------------------------------------------------------------------------------------- !
      !d           ! Aug.15.2011. Re-compute 'cu_tkePBLorg_inout(i,it)' using prognostic TKE budget equation !
      !d           !              similar to the computation of convective organization.                     !
      !d           ! --------------------------------------------------------------------------------------- !
      !d         ! tau_TKE  = b1 * pblhz / max( sqrt( cu_tkePBLorg_inout(i,2) ), nonzero )  
      !d         ! tau_TKE  = max( 1800._r8, min( 18000._r8, tau_TKE ) )
      !d         ! cu_tkePBLorg_inout(i,1) = cu_tkePBLorg_inout(i,2) * exp( - dt / tau_TKE )
      !d         ! cu_tkePBLorg_inout(i,1) = max( 0._r8, min( 3._r8, cu_tkePBLorg_inout(i,1) ) ) 
      !d         ! tau_TKE_out(i) = tau_TKE
      !d       endif
      !d    enddo

      !d    do it = mit, 1, -1
      !d       if( it .ne. 1 ) then
      !d           cu_cmfu_inout(i,it)                       = cu_cmfu_inout(i,it-1)
      !d           cu_cmfd_inout(i,it)                       = cu_cmfd_inout(i,it-1)
      !d       else
      !d           cu_cmfu_inout(i,it)                       = 0._r8
      !d           cu_cmfd_inout(i,it)                       = 0._r8
      !d       endif
      !d    enddo

      !f    cu_cmfum_inout(i,:mkx)                           = 0._r8
      !f    cu_cmfr_inout(i,:mkx)                            = 0._r8
      !f    cu_thlr_inout(i,:mkx)                            = 0._r8
      !f    cu_qtr_inout(i,:mkx)                             = 0._r8
      !f    cu_ur_inout(i,:mkx)                              = 0._r8
      !f    cu_vr_inout(i,:mkx)                              = 0._r8
      !f    cu_qlr_inout(i,:mkx)                             = 0._r8
      !f    cu_qir_inout(i,:mkx)                             = 0._r8
      !f    do mt = 1, ncnst
      !f       cu_trr_inout(i,:mkx,mt)                       = 0._r8
      !f    enddo

      !f    cu_thvr_inout(i,:mkx)                            = 0._r8
      !f    cu_rhr_inout(i,:mkx)                             = 0._r8

      !f    cu_cmfrd_inout(i,:mkx)                           = 0._r8
      !f    cu_thlrd_inout(i,:mkx)                           = 0._r8
      !f    cu_qtrd_inout(i,:mkx)                            = 0._r8
      !f    cu_urd_inout(i,:mkx)                             = 0._r8
      !f    cu_vrd_inout(i,:mkx)                             = 0._r8
      !f    cu_qlrd_inout(i,:mkx)                            = 0._r8
      !f    cu_qird_inout(i,:mkx)                            = 0._r8
      !f    do mt = 1, ncnst
      !f       cu_trrd_inout(i,:mkx,mt)                      = 0._r8
      !f    enddo

      !d    orgforce1_out(i)                                 = 0._r8 
      !d    orgforce2_out(i)                                 = 0._r8
      !d    orgforce3_out(i)                                 = 0._r8
      !d    orgforce_out(i)                                  = 0._r8
      !d    tau_org_out(i)                                   = tau_org

      !d    cuorg_inout(i)                                   = cuorg * exp( - dt / tau_org_out(i) )
      !d    cuorg_inout(i)                                   = max( 0._r8, min( 1._r8, cuorg_inout(i) ) )

      !f  ! Jun.30.2011. Insert diagnostically-computed organization parameter.
      !f  ! Feb.06.2013. As of today, always choose i_diagorg = 1 and remove this option.
      !c    if( i_diagorg .eq. 1 ) cuorg_inout(i)            = 0._r8
      !f    cuorg_inout(i)                                   = 0._r8
     
     
      !f  ! Aug.31.2011. Include the treatment of excess of conservative scalar in the off-wave areas relative to the grid-mean
      !f  !              averaged vertically over the PBL.  
      !f  ! Sep.07.2011. In this case, simply use the user-specified 'tau_org' since the scheme may have not computed 'taui'
      !f  !              for some quantities, such as awk_PBL.
      !f  !              This process can be understood as the one dominated by 'del_wk', i.e., detrainment occurs.
      !f  !              While the change of awk_PBL does not follow below formulation, it is likely to be roughly OK
      !f  !              since (1) this goto 333 never happens ( I checked this ), and (2) we want to keep positive awk_PBL at the
      !f  !              next time step.  
      !f  ! Sep.09.2011. I don't prognose 'thv' anymore.

      !f    delta_thl_PBL_inout(i)                           =    delta_thl_PBL * exp( - dt / tau_org_out(i) )
      !f    delta_qt_PBL_inout(i)                            =     delta_qt_PBL * exp( - dt / tau_org_out(i) )
      !f    delta_u_PBL_inout(i)                             =      delta_u_PBL * exp( - dt / tau_org_out(i) )
      !f    delta_v_PBL_inout(i)                             =      delta_v_PBL * exp( - dt / tau_org_out(i) )
      !f  ! delta_thv_PBL_inout(i)                           =    delta_thv_PBL * exp( - dt / tau_org_out(i) )
      !f    do mt = 1, ncnst
      !f       delta_tr_PBL_inout(i,mt)                      = delta_tr_PBL(mt) * exp( - dt / tau_org_out(i) )
      !f    enddo
      !f    awk_PBL_inout(i)                                 =          awk_PBL * exp( - dt / tau_org_out(i) )

      !f   end if

      ! ------------------------------------------------------------------------------------------------- !
      ! Substitute organization tendency to the tracer array in all layers when organization is advected. !
      ! In future, I can include the heterogeneity of individual 25 tracer components for completeness    !
      ! which however will increase computation time.                                                     ! 
      ! Add an offset to make the output tracer to be positive, so that advection scheme can handle.      !
      ! Note that the same amount of offset should be subtracted when 'delta_xxx' is extracted from the   !
      ! input tr0_in at the beginning of this program.                                                    !
      ! Note that to ensure that 'delta_xxx' are not modified by wet or dry deposition and other physical !
      ! processes other than UNICON and horizontal advection, a guaranteed update of tracer arrays        !
      ! just before advection scheme is done within tphysac.F90, which in fact makes below block          !
      ! unnecessary. However, for clarify, let's keep below block. It is not a harm at all.               !
      ! ------------------------------------------------------------------------------------------------- !

      if( iorg_adv ) then
! JHYoon (was commented out before) now uncommented to be sure
           call cnst_get_ind( 'ORGawk', i_awk )
           call cnst_get_ind( 'ORGthl', i_thl )
           call cnst_get_ind( 'ORGqto',  i_qt )
           call cnst_get_ind( 'ORGuoo',   i_u )
           call cnst_get_ind( 'ORGvoo',   i_v )
         do k = 1, mkx
            trten_out(i,k,i_awk) = (                   awk_PBL_inout(i)             - tr0_in(i,k,i_awk) ) / dt    
!           trten_out(i,k,i_thl) = ( max( 0._r8, delta_thl_PBL_inout(i) + 100._r8 ) - tr0_in(i,k,i_thl) ) / dt    
!           trten_out(i,k,i_qt)  = ( max( 0._r8,  delta_qt_PBL_inout(i) + 100._r8 ) - tr0_in(i,k,i_qt)  ) / dt    
!           trten_out(i,k,i_u)   = ( max( 0._r8,   delta_u_PBL_inout(i) + 100._r8 ) - tr0_in(i,k,i_u)   ) / dt    
!           trten_out(i,k,i_v)   = ( max( 0._r8,   delta_v_PBL_inout(i) + 100._r8 ) - tr0_in(i,k,i_v)   ) / dt    
            trten_out(i,k,i_thl) = ( max( 0._r8, delta_thl_PBL_inout(i) + 10._r8 ) - tr0_in(i,k,i_thl) ) / dt    
            trten_out(i,k,i_qt)  = ( max( 0._r8,  delta_qt_PBL_inout(i) + 0.01_r8 ) - tr0_in(i,k,i_qt)  ) / dt    
            trten_out(i,k,i_u)   = ( max( 0._r8,   delta_u_PBL_inout(i) + 10._r8 ) - tr0_in(i,k,i_u)   ) / dt    
            trten_out(i,k,i_v)   = ( max( 0._r8,   delta_v_PBL_inout(i) + 10._r8 ) - tr0_in(i,k,i_v)   ) / dt    
! JHYoon
         enddo
      endif

   enddo ! End of do i = 1, iend.  This is a column loop.
         
   ! TEST
   ! write(6,*)
   ! write(6,*) 'UNICON : ncnst, i_awk, i_thl, i_qt, i_u, i_v = ', ncnst, i_awk, i_thl, i_qt, i_u, i_v 
   ! write(6,*)
   ! TEST
                         
   ! ----------------------- !
   ! End of Main Computation !
   ! ----------------------- !

   ! ---------------------------------------- !
   ! Writing main diagnostic output variables !
   ! ---------------------------------------- !

   call outfld('cmf_SP'  ,                             cmf_out, mix, lchnk) 
   tmpi_array(:,0:mkx) = slflx_out(:,mkx:0:-1) 
   call outfld('slflx_SP',                          tmpi_array, mix, lchnk) 
   tmpi_array(:,0:mkx) = qtflx_out(:,mkx:0:-1)
   call outfld('qtflx_SP',                          tmpi_array, mix, lchnk) 
   call outfld('uflx_SP' ,                            uflx_out, mix, lchnk) 
   call outfld('vflx_SP' ,                            vflx_out, mix, lchnk) 

   call outfld('flxrain_SP' ,                      flxrain_out, mix, lchnk) 
   call outfld('flxsnow_SP' ,                      flxsnow_out, mix, lchnk) 

   tmpi_array(:,0:mkx) = cmf_u_out(:,mkx:0:-1)
   call outfld('cmf_u_SP'  ,                        tmpi_array, mix, lchnk) 
   call outfld('slflx_u_SP',                       slflx_u_out, mix, lchnk) 
   call outfld('qtflx_u_SP',                       qtflx_u_out, mix, lchnk) 
   call outfld('uflx_u_SP' ,                        uflx_u_out, mix, lchnk) 
   call outfld('vflx_u_SP' ,                        vflx_u_out, mix, lchnk) 

   call outfld('cmf_d_SP'  ,                         cmf_d_out, mix, lchnk) 
   call outfld('slflx_d_SP',                       slflx_d_out, mix, lchnk) 
   call outfld('qtflx_d_SP',                       qtflx_d_out, mix, lchnk) 
   call outfld('uflx_d_SP' ,                        uflx_d_out, mix, lchnk) 
   call outfld('vflx_d_SP' ,                        vflx_d_out, mix, lchnk) 

   !d   call outfld('exit_Cu_SP',                           exit_Cu, mix, lchnk) 
   call outfld('cush_SP',                           cush_inout, mix, lchnk) 
   call outfld('cushavg_SP',                     cushavg_inout, mix, lchnk) 
   call outfld('cuorg_SP',                         cuorg_inout, mix, lchnk) 
   call outfld('Radius_SP',                   rad_u_out(:,mkx), mix, lchnk) 
   !d   call outfld('orgforce_SP',                     orgforce_out, mix, lchnk) 
   !d   call outfld('tau_org_SP',                       tau_org_out, mix, lchnk) 
   !d   call outfld('tau_TKE_SP',                       tau_TKE_out, mix, lchnk) 
   call outfld('sgh_SP',                                sgh_in, mix, lchnk) 
   call outfld('sgh30_SP',                            sgh30_in, mix, lchnk) 

   call outfld('kw_SP',                                 kw_out, mix, lchnk)

   call outfld('sigma_w_SP',                       sigma_w_out, mix, lchnk)
   call outfld('sigma_thl_SP',                   sigma_thl_out, mix, lchnk)
   call outfld('sigma_qt_SP',                     sigma_qt_out, mix, lchnk) 
   call outfld('sigma_u_SP',                       sigma_u_out, mix, lchnk) 
   call outfld('sigma_v_SP',                       sigma_v_out, mix, lchnk) 

   call outfld('w_org_SP',                           w_org_out, mix, lchnk)
   call outfld('thl_org_SP',                       thl_org_out, mix, lchnk)
   call outfld('qt_org_SP',                         qt_org_out, mix, lchnk)
   call outfld('u_org_SP',                           u_org_out, mix, lchnk)
   call outfld('v_org_SP',                           v_org_out, mix, lchnk)

   call outfld('tkes_SP',                             tkes_out, mix, lchnk)
   call outfld('went_SP',                             went_out, mix, lchnk)
   call outfld('went_eff_SP',                     went_eff_out, mix, lchnk)

   tmpm_array(:,1:mkx) = am_u_out(:,mkx:1:-1)
   call outfld('am_u_SP',                           tmpm_array, mix, lchnk) 
   tmpm_array(:,1:mkx) = qlm_u_out(:,mkx:1:-1)
   call outfld('qlm_u_SP',                          tmpm_array, mix, lchnk) 
   tmpm_array(:,1:mkx) = qim_u_out(:,mkx:1:-1)
   call outfld('qim_u_SP',                          tmpm_array, mix, lchnk) 
   tmpm_array(:,1:mkx) = am_d_out(:,mkx:1:-1)
   call outfld('am_d_SP',                           tmpm_array, mix, lchnk) 
   tmpm_array(:,1:mkx) = qlm_d_out(:,mkx:1:-1)
   call outfld('qlm_d_SP',                          tmpm_array, mix, lchnk) 
   tmpm_array(:,1:mkx) = qim_d_out(:,mkx:1:-1)
   call outfld('qim_d_SP',                          tmpm_array, mix, lchnk) 

   call outfld('slten_u_SP' ,                      slten_u_out, mix, lchnk) 
   call outfld('qtten_u_SP' ,                      qtten_u_out, mix, lchnk) 
   call outfld('uten_u_SP'  ,                       uten_u_out, mix, lchnk) 
   call outfld('vten_u_SP'  ,                       vten_u_out, mix, lchnk)
   call outfld('sten_u_SP'  ,                       sten_u_out, mix, lchnk) 
   call outfld('qvten_u_SP' ,                      qvten_u_out, mix, lchnk) 
   call outfld('qlten_u_SP' ,                      qlten_u_out, mix, lchnk) 
   call outfld('qiten_u_SP' ,                      qiten_u_out, mix, lchnk) 
   call outfld('nlten_u_SP' ,        trten_u_out(:,:,ixnumliq), mix, lchnk) 
   call outfld('niten_u_SP' ,        trten_u_out(:,:,ixnumice), mix, lchnk) 
#ifdef MODAL_AERO
   do m = 1, ntot_amode
      l = numptr_amode(m)
      varname = trim(cnst_name(l))//'_u_SP'
      call outfld( trim(varname),        trten_u_out(:,:,l),    mix, lchnk )
      do lspec = 1, nspec_amode(m)
         l = lmassptr_amode(lspec,m)
         varname = trim(cnst_name(l))//'_u_SP'
         call outfld( trim(varname),        trten_u_out(:,:,l), mix, lchnk )
      enddo
   enddo
#endif

   call outfld('slten_d_SP' , slten_d_out, mix, lchnk) 
   call outfld('qtten_d_SP' , qtten_d_out, mix, lchnk) 
   call outfld('uten_d_SP'  ,  uten_d_out, mix, lchnk) 
   call outfld('vten_d_SP'  ,  vten_d_out, mix, lchnk)
   call outfld('sten_d_SP'  ,  sten_d_out, mix, lchnk) 
   call outfld('qvten_d_SP' , qvten_d_out, mix, lchnk) 
   call outfld('qlten_d_SP' , qlten_d_out, mix, lchnk) 
   call outfld('qiten_d_SP' , qiten_d_out, mix, lchnk) 
   call outfld('nlten_d_SP' , trten_d_out(:,:,ixnumliq), mix, lchnk) 
   call outfld('niten_d_SP' , trten_d_out(:,:,ixnumice), mix, lchnk) 
#ifdef MODAL_AERO
   do m = 1, ntot_amode
      l = numptr_amode(m)
      varname = trim(cnst_name(l))//'_d_SP'
      call outfld( trim(varname),  trten_d_out(:,:,l),    mix, lchnk )
      do lspec = 1, nspec_amode(m)
         l = lmassptr_amode(lspec,m)
         varname = trim(cnst_name(l))//'_d_SP'
         call outfld( trim(varname),  trten_d_out(:,:,l), mix, lchnk )
      enddo
   enddo
#endif
   
   call outfld('slten_evp_SP' , slten_evp_out, mix, lchnk) 
   call outfld('qtten_evp_SP' , qtten_evp_out, mix, lchnk) 
   call outfld('uten_evp_SP'  ,  uten_evp_out, mix, lchnk) 
   call outfld('vten_evp_SP'  ,  vten_evp_out, mix, lchnk)
   call outfld('sten_evp_SP'  ,  sten_evp_out, mix, lchnk) 
   call outfld('qvten_evp_SP' , qvten_evp_out, mix, lchnk) 
   call outfld('qlten_evp_SP' , qlten_evp_out, mix, lchnk) 
   call outfld('qiten_evp_SP' , qiten_evp_out, mix, lchnk) 
   call outfld('nlten_evp_SP' , trten_evp_out(:,:,ixnumliq), mix, lchnk) 
   call outfld('niten_evp_SP' , trten_evp_out(:,:,ixnumice), mix, lchnk) 
#ifdef MODAL_AERO
   do m = 1, ntot_amode
      l = numptr_amode(m)
      varname = trim(cnst_name(l))//'_evp_SP'
      call outfld( trim(varname),  trten_evp_out(:,:,l),    mix, lchnk )
      do lspec = 1, nspec_amode(m)
         l = lmassptr_amode(lspec,m)
         varname = trim(cnst_name(l))//'_evp_SP'
         call outfld( trim(varname),  trten_evp_out(:,:,l), mix, lchnk )
      enddo
   enddo
#endif
   ! Dec.13.2012. Wet deposition term is added.
   ! Due to unknown reason, below did not correctly printed-out the results 
   ! with error messages. So, I commented out below block temporarily.
   ! #ifdef MODAL_AERO
   !     do m = 1, ntot_amode
   !        l = numptr_amode(m)
   !        varname = trim(cnst_name(l))//'_wdep_SP'
   !        call outfld( trim(varname),  trten_wdep_out(:iend,:mkx,l),    mix, lchnk )
   !        do lspec = 1, nspec_amode(m)
   !           l = lmassptr_amode(lspec,m)
   !           varname = trim(cnst_name(l))//'_wdep_SP'
   !           call outfld( trim(varname),  trten_wdep_out(:iend,:mkx,l), mix, lchnk )
   !        enddo
   !     enddo
   ! #endif

   call outfld('slten_dis_SP' , slten_dis_out, mix, lchnk) 
   call outfld('qtten_dis_SP' , qtten_dis_out, mix, lchnk) 
   call outfld('uten_dis_SP'  ,  uten_dis_out, mix, lchnk) 
   call outfld('vten_dis_SP'  ,  vten_dis_out, mix, lchnk)
   call outfld('sten_dis_SP'  ,  sten_dis_out, mix, lchnk) 
   call outfld('qvten_dis_SP' , qvten_dis_out, mix, lchnk) 
   call outfld('qlten_dis_SP' , qlten_dis_out, mix, lchnk) 
   call outfld('qiten_dis_SP' , qiten_dis_out, mix, lchnk) 
   call outfld('nlten_dis_SP' , trten_dis_out(:,:,ixnumliq), mix, lchnk) 
   call outfld('niten_dis_SP' , trten_dis_out(:,:,ixnumice), mix, lchnk) 
#ifdef MODAL_AERO
   do m = 1, ntot_amode
      l = numptr_amode(m)
      varname = trim(cnst_name(l))//'_dis_SP'
      call outfld( trim(varname),  trten_dis_out(:,:,l),    mix, lchnk )
      do lspec = 1, nspec_amode(m)
         l = lmassptr_amode(lspec,m)
         varname = trim(cnst_name(l))//'_dis_SP'
         call outfld( trim(varname),  trten_dis_out(:,:,l), mix, lchnk )
      enddo
   enddo
#endif
   
   call outfld('qlten_sub_SP'   , qlten_sub_out,   mix, lchnk) 
   call outfld('qiten_sub_SP'   , qiten_sub_out,   mix, lchnk) 
  
   call outfld('qlten_det_SP'   , qlten_det_out,   mix, lchnk) 
   call outfld('qiten_det_SP'   , qiten_det_out,   mix, lchnk) 

   call outfld('thl_u_SP'       ,     thl_u_out,   mix, lchnk)
   call outfld('qt_u_SP'        ,      qt_u_out,   mix, lchnk)
   call outfld('u_u_SP'         ,       u_u_out,   mix, lchnk)
   call outfld('v_u_SP'         ,       v_u_out,   mix, lchnk)
   call outfld('w_u_SP'         ,       w_u_out,   mix, lchnk)
   call outfld('ql_u_SP'        ,      ql_u_out,   mix, lchnk)
   call outfld('qi_u_SP'        ,      qi_u_out,   mix, lchnk)
   call outfld('wa_u_SP'        ,      wa_u_out,   mix, lchnk)
   call outfld('qla_u_SP'       ,     qla_u_out,   mix, lchnk)
   call outfld('qia_u_SP'       ,     qia_u_out,   mix, lchnk)
   call outfld('a_u_SP'         ,       a_u_out,   mix, lchnk)
   call outfld('rad_u_SP'       ,     rad_u_out,   mix, lchnk)
   call outfld('num_u_SP'       ,     num_u_out,   mix, lchnk)
   call outfld('gamw_u_SP'      ,    gamw_u_out,   mix, lchnk)
   call outfld('nl_u_SP'        ,      tr_u_out(:,:,ixnumliq),   mix, lchnk)
   call outfld('ni_u_SP'        ,      tr_u_out(:,:,ixnumice),   mix, lchnk)
   call outfld('thva_u_SP'      ,    thva_u_out,   mix, lchnk)

   call outfld('a_p_SP'         ,       a_p_out,   mix, lchnk)
   call outfld('am_evp_SP'      ,    am_evp_out,   mix, lchnk)
   call outfld('am_pu_SP'       ,     am_pu_out,   mix, lchnk)
   call outfld('x_p_SP'         ,       x_p_out,   mix, lchnk)
   call outfld('y_p_SP'         ,       y_p_out,   mix, lchnk)
   call outfld('x_um_SP'        ,      x_um_out,   mix, lchnk)
   call outfld('y_um_SP'        ,      y_um_out,   mix, lchnk)

   call outfld('thl_d_SP'       ,     thl_d_out,   mix, lchnk)
   call outfld('qt_d_SP'        ,      qt_d_out,   mix, lchnk)
   call outfld('u_d_SP'         ,       u_d_out,   mix, lchnk)
   call outfld('v_d_SP'         ,       v_d_out,   mix, lchnk)
   call outfld('w_d_SP'         ,       w_d_out,   mix, lchnk)
   call outfld('ql_d_SP'        ,      ql_d_out,   mix, lchnk)
   call outfld('qi_d_SP'        ,      qi_d_out,   mix, lchnk)
   call outfld('wa_d_SP'        ,      wa_d_out,   mix, lchnk)
   call outfld('qla_d_SP'       ,     qla_d_out,   mix, lchnk)
   call outfld('qia_d_SP'       ,     qia_d_out,   mix, lchnk)
   call outfld('a_d_SP'         ,       a_d_out,   mix, lchnk)
   call outfld('nl_d_SP'        ,      tr_d_out(:,:,ixnumliq),   mix, lchnk)
   call outfld('ni_d_SP'        ,      tr_d_out(:,:,ixnumice),   mix, lchnk)

   tmpi_array(:,0:mkx) = thv_b_out(:,mkx:0:-1)
   call outfld('thv_b_SP',         tmpi_array,     mix, lchnk)
   tmpi_array(:,0:mkx) = thv_t_out(:,mkx:0:-1)
   call outfld('thv_t_SP',         tmpi_array,     mix, lchnk)
   tmpi_array(:,0:mkx) = thv_mt_out(:,mkx:0:-1)
   call outfld('thv_mt_SP',        tmpi_array,     mix, lchnk)
   tmpi_array(:,0:mkx) = thv_min_out(:,mkx:0:-1)
   call outfld('thv_min_SP',       tmpi_array,     mix, lchnk)
   !a   tmpm_array(:,1:mkx) = CFL_out(:,mkx:1:-1)
   !a   call outfld('CFL_SP',           tmpm_array,     mix, lchnk)

   tmpm_array(:,1:mkx) = cu_cmfr_inout(:,mkx:1:-1)
   call outfld('cu_cmfr_SP',                       tmpm_array, mix, lchnk) 
   tmpm_array(:,1:mkx) = cu_thlr_inout(:,mkx:1:-1)
   call outfld('cu_thlr_SP',                       tmpm_array, mix, lchnk) 
   tmpm_array(:,1:mkx) = cu_qtr_inout(:,mkx:1:-1)
   call outfld('cu_qtr_SP',                        tmpm_array, mix, lchnk) 
   tmpm_array(:,1:mkx) = cu_qlr_inout(:,mkx:1:-1)
   call outfld('cu_qlr_SP',                        tmpm_array, mix, lchnk) 
   tmpm_array(:,1:mkx) = cu_qir_inout(:,mkx:1:-1)
   call outfld('cu_qir_SP',                        tmpm_array, mix, lchnk) 
   tmpm_array(:,1:mkx) = cu_ur_inout(:,mkx:1:-1)
   call outfld('cu_ur_SP',                         tmpm_array, mix, lchnk) 
   tmpm_array(:,1:mkx) = cu_vr_inout(:,mkx:1:-1)
   call outfld('cu_vr_SP',                         tmpm_array, mix, lchnk) 
   tmpm_array(:,1:mkx) = cu_thvr_inout(:,mkx:1:-1)
   call outfld('cu_thvr_SP',                       tmpm_array, mix, lchnk) 
   tmpm_array(:,1:mkx) = cu_rhr_inout(:,mkx:1:-1)
   call outfld('cu_rhr_SP',                        tmpm_array, mix, lchnk) 
   tmpm_array(:,1:mkx) = cu_trr_inout(:,mkx:1:-1,ixnumliq)
   call outfld('cu_nlr_SP',                        tmpm_array, mix, lchnk) 
   tmpm_array(:,1:mkx) = cu_trr_inout(:,mkx:1:-1,ixnumice)
   call outfld('cu_nir_SP',                        tmpm_array, mix, lchnk) 

   ! Nov.15.2012. Below output corresponding to individual updraft segment is designed to write out individual 
   !              segment values for writing UNICON_II paper.
   !              Note that the vertical array index is already switched similar to 'thl_u_out'. 
   !              Thus, we don't need to switch vertical array index here.

   do msfc = 1, nseg        
      write(numcha,'(i2.2)') msfc        

      ! The properties of individual updraft segment       

      call outfld( 'thl_u'//numcha//'_SP',              thl_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'qt_u'//numcha//'_SP',                qt_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'u_u'//numcha//'_SP',                  u_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'v_u'//numcha//'_SP',                  v_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'w_u'//numcha//'_SP',                  w_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'ql_u'//numcha//'_SP',                ql_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'qi_u'//numcha//'_SP',                qi_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'cmf_u'//numcha//'_SP',              cmf_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'a_u'//numcha//'_SP',                  a_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'num_u'//numcha//'_SP',              num_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'rad_u'//numcha//'_SP',              rad_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'nl_u'//numcha//'_SP',       tr_u_msfc_out(:,:,msfc,ixnumliq,1), mix, lchnk) 
      call outfld( 'ni_u'//numcha//'_SP',       tr_u_msfc_out(:,:,msfc,ixnumice,1), mix, lchnk) 

      call outfld( 'eps0_u'//numcha//'_SP',            eps0_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'eps_u'//numcha//'_SP',              eps_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'del_u'//numcha//'_SP',              del_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'eeps_u'//numcha//'_SP',            eeps_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'ddel_u'//numcha//'_SP',            ddel_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'xc_u'//numcha//'_SP',                xc_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'xs_u'//numcha//'_SP',                xs_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'xemin_u'//numcha//'_SP',          xemin_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'xemax_u'//numcha//'_SP',          xemax_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'cridis_u'//numcha//'_SP',        cridis_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'thvcuenv_u'//numcha//'_SP',    thvcuenv_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'thvegenv_u'//numcha//'_SP',    thvegenv_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'thvxsenv_u'//numcha//'_SP',    thvxsenv_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'fmix_u'//numcha//'_SP',            fmix_u_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'cmfumix_u'//numcha//'_SP',      cmfumix_u_msfc_out(:,:,msfc,1), mix, lchnk) 

      ! call outfld( 'ktop'//numcha//'_SP',                ktop_msfc_out(:,msfc,1),       mix, lchnk) 
      call outfld( 'ptop'//numcha//'_SP',                ptop_msfc_out(:,msfc,1),       mix, lchnk) 
      call outfld( 'ztop'//numcha//'_SP',                ztop_msfc_out(:,msfc,1),       mix, lchnk) 

      ! The properties of mass flux weighted ( or area-weighted or net=sum ) downdraft properties for individual updraft segment       

      call outfld( 'thl_d'//numcha//'_SP',              thl_d_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'qt_d'//numcha//'_SP',                qt_d_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'u_d'//numcha//'_SP',                  u_d_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'v_d'//numcha//'_SP',                  v_d_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'w_d'//numcha//'_SP',                  w_d_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'ql_d'//numcha//'_SP',                ql_d_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'qi_d'//numcha//'_SP',                qi_d_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'wa_d'//numcha//'_SP',                wa_d_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'qla_d'//numcha//'_SP',              qla_d_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'qia_d'//numcha//'_SP',              qia_d_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'cmf_d'//numcha//'_SP',              cmf_d_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'a_d'//numcha//'_SP',                  a_d_msfc_out(:,:,msfc,1), mix, lchnk) 
      call outfld( 'nl_d'//numcha//'_SP',       tr_d_msfc_out(:,:,msfc,ixnumliq,1), mix, lchnk) 
      call outfld( 'ni_d'//numcha//'_SP',       tr_d_msfc_out(:,:,msfc,ixnumice,1), mix, lchnk) 

   enddo

   ! Nov.16.2012. Additional detailed diagnostic output

   call outfld('thl_orgfce_SP',                                             thl_orgforce_out, mix, lchnk)
   call outfld('qt_orgfce_SP',                                               qt_orgforce_out, mix, lchnk)
   call outfld('u_orgfce_SP',                                                 u_orgforce_out, mix, lchnk)
   call outfld('v_orgfce_SP',                                                 v_orgforce_out, mix, lchnk)
   call outfld('awk_orgfce_SP',                                             awk_orgforce_out, mix, lchnk)

   call outfld('thl_orgfce_f_SP',                                       thl_orgforce_flx_out, mix, lchnk)
   call outfld('qt_orgfce_f_SP',                                         qt_orgforce_flx_out, mix, lchnk)
   call outfld('u_orgfce_f_SP',                                           u_orgforce_flx_out, mix, lchnk)
   call outfld('v_orgfce_f_SP',                                           v_orgforce_flx_out, mix, lchnk)
   call outfld('awk_orgfce_f_SP',                                       awk_orgforce_flx_out, mix, lchnk)

   call outfld('thl_orgfce_u_SP',                                       thl_orgforce_und_out, mix, lchnk)
   call outfld('qt_orgfce_u_SP',                                         qt_orgforce_und_out, mix, lchnk)
   call outfld('u_orgfce_u_SP',                                           u_orgforce_und_out, mix, lchnk)
   call outfld('v_orgfce_u_SP',                                           v_orgforce_und_out, mix, lchnk)
   call outfld('awk_orgfce_m_SP',                                       awk_orgforce_mix_out, mix, lchnk)

   call outfld('thl_orgfce_e_SP',                                       thl_orgforce_env_out, mix, lchnk)
   call outfld('qt_orgfce_e_SP',                                         qt_orgforce_env_out, mix, lchnk)
   call outfld('u_orgfce_e_SP',                                           u_orgforce_env_out, mix, lchnk)
   call outfld('v_orgfce_e_SP',                                           v_orgforce_env_out, mix, lchnk)
   call outfld('cmf_d_orgh_SP',                                           cmf_d_org_pblh_out, mix, lchnk)

   call outfld('taui_thl_SP',                                                   taui_thl_out, mix, lchnk)
   call outfld('taui_qt_SP',                                                     taui_qt_out, mix, lchnk)
   call outfld('taui_u_SP',                                                       taui_u_out, mix, lchnk)
   call outfld('taui_v_SP',                                                       taui_v_out, mix, lchnk)
   call outfld('taui_awk_SP',                                                   taui_awk_out, mix, lchnk)

   !og
   call outfld('del_org_SP',                                                     del_org_out, mix, lchnk)
   call outfld('del0_org_SP',                                                   del0_org_out, mix, lchnk)
   !og
  
   ! Nov.16.2012. Additional detailed diagnostic output

   return

end subroutine compute_unicon

  ! ------------------------------ !
  ! End of SPARK convection scheme !
  ! ------------------------------ !

  ! ------------------------------ !
  !                                ! 
  ! Beginning of subroutine blocks !
  !                                !
  ! ------------------------------ !

 
  real(r8) function exnf(pressure)
           real(r8), intent(in)  :: pressure
           exnf = (pressure/p00)**rovcp
           return
  end function exnf


  real(r8) function quad(a,b,c,x)
           real(r8), intent(in)  :: a, b, c, x
           quad = a*(x**2) + b*x + c
           return
  end function quad


  subroutine conden(p,thl,qt,th,qv,ql,qi,rvls,id_check)
  ! --------------------------------------------------------------------- !
  ! Calculate thermodynamic properties from a given set of ( p, thl, qt ) !
  ! Note that this subroutine assumes horizontal homogeneity in the grid. ! 
  ! --------------------------------------------------------------------- !
    implicit none
    real(r8), intent(in)  :: p, thl, qt
    real(r8), intent(out) :: th, qv, ql, qi, rvls
    integer,  intent(out) :: id_check
!icereal(r8), optional, intent(in) :: frac_ice            
    real(r8)              :: es, qs, gam
    integer   i 
    real(r8)  qc, t, fice, ficeg, ficeg0, leff, leffg 
    real(r8)  f, fg

    ! ---------------------------------------------------------- !
    ! Main Computation Loop : Find Final Equilibrium Temperature !
    ! ---------------------------------------------------------- !

    id_check =  1
    ficeg0   = -1._r8/(tmax_fice-tmin_fice)
    t        =  thl*exnf(p)
    call qsat(t, p, es, qs)

    if( qs .ge. qt ) then  

        qv = qt
        qc = 0._r8
        ql = 0._r8
        qi = 0._r8
        th = t/exnf(p)
        rvls = qs
        id_check = 0
        return

    else 

        do i = 1, 10

      !ice if( present(frac_ice) ) then
      !ice     fice  = frac_ice
      !ice     ficeg = 0._r8
      !ice else 
               fice = max( 0._r8, min( 1._r8, (tmax_fice-t)/(tmax_fice-tmin_fice) ) )
               if( t .lt. tmin_fice-1._r8 ) then
                   ficeg = 0._r8
               elseif( t .ge. tmin_fice-1._r8 .and. t .lt. tmin_fice+1._r8 ) then
                   ficeg =  ficeg0 * ( t - tmin_fice + 1._r8 )/2._r8
               elseif( t .ge. tmin_fice+1._r8 .and. t .lt. tmax_fice-1._r8 ) then
                   ficeg =  ficeg0
               elseif( t .ge. tmax_fice-1._r8 .and. t .lt. tmax_fice+1._r8 ) then
                   ficeg = -ficeg0 * ( t - tmax_fice - 1._r8 )/2._r8
               elseif( t .ge. tmax_fice+1._r8 ) then
                   ficeg = 0._r8
               endif 
      !ice endif

           leff   = fice *xls + (1._r8 - fice)*xlv
           leffg  = ficeg*(xls-xlv)
           call qsat(t, p, es, qs, gam=gam)
           f      = qt - (cp/leff)*(t-exnf(p)*thl)-qs
           fg     = (cp/leff)*((leffg/leff)*(t-exnf(p)*thl)-1._r8-gam)

         ! WRITE-SPARK
         ! write(6,*)
         ! write(6,*) 'i, t, f/fg, tmax_fice, tmin_fice in conden'
         ! write(6,*)  i, t, f/fg, tmax_fice, tmin_fice

           if( abs(fg) .lt. 1.e-12_r8 ) then
               t = t + 0.1_r8
           else 
               t = t - f/fg
           endif
           if( abs(f/fg) .lt. 1.e-3_r8 ) then
               qc = max(qt - qs,0._r8)
               qv = qt - qc
               ql = qc*(1._r8 - fice)
               qi = fice*qc
               th = t/exnf(p)             
               rvls = qs
               id_check = 0
               return
           endif 

        enddo 

    end if

    write(6,*) 'Warning : Convergence in conden is not achived and final value is used in unicon.F90'
    qc = max(qt - qs,0._r8)
    qv = qt - qc
    ql = qc*(1._r8 - fice)
    qi = fice*qc
    th = t/exnf(p)             
    rvls = qs
    id_check = 0

    return
  end subroutine conden


  subroutine conden_org(p,thl,qt,th,qv,ql,qi,rvls,id_check)
  ! --------------------------------------------------------------------- !
  ! Calculate thermodynamic properties from a given set of ( p, thl, qt ) !
  ! Note that this subroutine assumes horizontal homogeneity in the grid. ! 
  ! --------------------------------------------------------------------- !
    implicit none
    real(r8), intent(in)  :: p, thl, qt
    real(r8), intent(out) :: th, qv, ql, qi, rvls
    integer,  intent(out) :: id_check
    real(r8)              :: es, qs
    integer   iteration 
    real(r8)  tc, temps, t
    real(r8)  leff, nu, qc

    ! --------------------------------------------------------------------------- !
    ! Below "temps" and "rvls" are just initial guesses for iteration loop below. !
    ! Note that the output "temps" from the below iteration loop is "temperature" !
    ! NOT "liquid temperature".                                                   !
    ! --------------------------------------------------------------------------- !

    tc     = thl*exnf(p)
    nu     = max(min((263.15_r8 - tc)/30._r8,1._r8),0._r8) 
    leff   = (1._r8 - nu)*xlv + nu*xls 
    call qsat(tc, p, es, qs)
    rvls   = qs
    temps  = tc

    if( qs .ge. qt ) then  

        id_check = 0
        qv = qt
        qc = 0._r8
        ql = 0._r8
        qi = 0._r8
        th = tc/exnf(p)

    else 

        do iteration = 1, 10
           temps  = temps + (( tc - temps )*cp/leff + qt - rvls)/               & 
                            (cp/leff + ep2*leff*rvls/r/temps/temps)
           call qsat(temps, p, es, qs)
           rvls   = qs
           nu     = max(min((263.15_r8 - temps)/30._r8,1._r8),0._r8)
           leff   = (1._r8 - nu)*xlv + nu*xls
        end do
         
        qc = max(qt - qs,0._r8)
        qv = qt - qc
        ql = qc*(1._r8 - nu)
        qi = nu*qc
        th = temps/exnf(p)

        if( abs((temps-(leff/cp)*qc)-tc) .ge. 1._r8 ) then
            id_check = 1
        else
            id_check = 0
        end if

    end if

    return
  end subroutine conden_org


  subroutine roots(a,b,c,r1,r2,status)
  ! --------------------------------------------------------- !
  ! Subroutine to solve the second order polynomial equation. !
  ! I should check this subroutine later.                     !
  ! Done.                                                     !
  ! --------------------------------------------------------- !
    implicit none
    real(r8), intent(in)  :: a
    real(r8), intent(in)  :: b
    real(r8), intent(in)  :: c
    real(r8), intent(out) :: r1
    real(r8), intent(out) :: r2
    integer , intent(out) :: status
    real(r8)              :: q, rmin, rmax

    r1 = 0._r8
    r2 = 0._r8
    status = 0
    if(a .eq. 0) then                              ! Form b*x + c = 0
       if(b .eq. 0) then                           ! Failure: c = 0
          status = 1
       else                                        ! b*x + c = 0
          r1 = -c/b
          r2 = r1
       endif
    else
       if(b .eq. 0._r8) then                       ! Form a*x**2 + c = 0
          if(a*c .gt. 0._r8) then                  ! Failure: x**2 = -c/a < 0
             status = 2  
          else                                     ! x**2 = -c/a 
             r1 = sqrt(-c/a)
             r2 = -r1
          endif
       else                                        ! Form a*x**2 + b*x + c = 0
          if((b**2 - 4._r8*a*c) .lt. 0._r8) then   ! Failure, no real roots
             status = 3
          else
             q  = -0.5_r8*(b + sign(1.0_r8,b)*sqrt(b**2 - 4._r8*a*c))
             r1 =  q/a
             r2 =  c/q
          endif
       endif
    endif

    rmin = min(r1,r2)
    rmax = max(r1,r2)
    r1 = rmin
    r2 = rmax

    return
  end subroutine roots

  
  function slope(mkx,field,p0)
  ! ------------------------------------------------------------------ !
  ! Function performing profile reconstruction of conservative scalars !
  ! in each layer. This is identical to profile reconstruction used in !
  ! UW-PBL scheme but from bottom to top layer here.     At the lowest !
  ! layer near to surface, slope is defined using the two lowest layer !
  ! mid-point values. I checked this subroutine and it is correct.     !
  ! ------------------------------------------------------------------ !
    implicit none
    integer,  intent(in) :: mkx
    real(r8), intent(in) :: field(mkx)
    real(r8), intent(in) :: p0(mkx)
    
    real(r8)             :: slope(mkx)
    real(r8)             :: below
    real(r8)             :: above
    integer              :: k

    below = (field(2) - field(1))/(p0(2) - p0(1))
    do k = 2, mkx
       above = (field(k) - field(k-1))/(p0(k) - p0(k-1))
       if (above .gt. 0._r8) then
          slope(k-1) = max(0._r8,min(above,below))
       else 
          slope(k-1) = min(0._r8,max(above,below))
       end if
       below = above
    end do
    slope(mkx) = slope(mkx-1)

  ! Sep.22.2011. Set the slope in the lowest model layer to be zero to reduce the
  !              sensitivity of the diurnal cycle to the surface heating.
  ! slope(1) = 0._r8 

    return
  end function slope


  function qsinvert(qt,thl,psfc)
  ! ----------------------------------------------------------------- !
  ! Function calculating saturation pressure ps (or pLCL) from qt and !
  ! thl ( liquid potential temperature,  NOT liquid virtual potential !
  ! temperature) by inverting Bolton formula. I should check later if !
  ! current use of 'leff' instead of 'xlv' here is reasonable or not. !
  ! ----------------------------------------------------------------- !
    real(r8)          :: qsinvert
    real(r8)             qt, thl, psfc
    real(r8)             ps, Pis, Ts, err, dlnqsdT, dTdPis
    real(r8)             dPisdps, dlnqsdps, derrdps, dps
    real(r8)             Ti, rhi, TLCL, PiLCL, psmin, dpsmax
    integer              i
    real(r8)          :: es                     ! saturation vapor pressure
    real(r8)          :: qs                     ! saturation spec. humidity
    real(r8)          :: gam                    ! (L/cp)*dqs/dT
    real(r8)          :: leff, nu

    psmin  = 100._r8*100._r8 ! Default saturation pressure [Pa] if iteration does not converge
    dpsmax = 1._r8           ! Tolerance [Pa] for convergence of iteration

    ! ------------------------------------ !
    ! Calculate best initial guess of pLCL !
    ! ------------------------------------ !

    Ti       =  thl*(psfc/p00)**rovcp
    call qsat(Ti, psfc, es, qs)
    rhi      =  qt/qs
    if( rhi .le. 0.01_r8 ) then
        write(6,*) 'UNICON : Source air is too dry and pLCL is set to psmin in uwshcu.F90'
        qsinvert = psmin
        return
    end if
    TLCL     =  55._r8 + 1._r8/(1._r8/(Ti-55._r8)-log(rhi)/2840._r8); ! Bolton's formula. MWR.1980.Eq.(22)
    PiLCL    =  TLCL/thl
    ps       =  p00*(PiLCL)**(1._r8/rovcp)

    do i = 1, 10
       Pis      =  (ps/p00)**rovcp
       Ts       =  thl*Pis
       call qsat(Ts, ps, es, qs, gam=gam)
       err      =  qt - qs
       nu       =  max(min((268._r8 - Ts)/20._r8,1.0_r8),0.0_r8)
       leff     =  (1._r8 - nu)*xlv + nu*xls
       dlnqsdT  =  gam*(cp/leff)/qs
       dTdPis   =  thl
       dPisdps  =  rovcp*Pis/ps
       dlnqsdps = -1._r8/(ps - (1._r8 - ep2)*es)
       derrdps  = -qs*(dlnqsdT * dTdPis * dPisdps + dlnqsdps)
       dps      = -err/derrdps
       ps       =  ps + dps
       if( ps .lt. 0._r8 ) then
           write(6,*) 'UNICON : pLCL iteration is negative and set to psmin in uwshcu.F90', qt, thl, psfc
           qsinvert = psmin
           return
       end if
       if( abs(dps) .le. dpsmax ) then
           qsinvert = ps
           return
       end if
    end do
    write(6,*) 'UNICON : pLCL does not converge and is set to psmin in unicon.F90', qt, thl, psfc
    qsinvert = psmin
    return
  end function qsinvert


  function area_overlap(x1,y1,a1,x2,y2,a2,cn)
  ! ----------------------------------------------------------------- !
  ! Function to compute overlapping area between two disks located at !
  ! (x1,y1) in unit of [m] with fractional area a1, and               !
  ! (x2,y2) in unit of [m] with fractional area a2, both of which has !
  ! the same number concentration of 'cn' [ # / m^2 ].                !
  ! The resulting overlapping area has no unit : fractional area.     ! 
  ! ----------------------------------------------------------------- !
    implicit none
    real(r8)             :: area_overlap
    real(r8), intent(in) :: x1, y1, a1, x2, y2, a2, cn
    real(r8)             :: r1, r2
    real(r8)             :: rmin, rmax, d
    real(r8)             :: arg1, arg2, arg3

    r1 = sqrt(max(0._r8,a1/cn/3.141592_r8))
    r2 = sqrt(max(0._r8,a2/cn/3.141592_r8))
    d = sqrt( (x2-x1)**2._r8 + (y2-y1)**2._r8 )
    rmin = min( r1, r2 )
    rmax = max( r1, r2 )

    if( rmin .eq. 0._r8 .or. rmax .eq. 0._r8 ) then
        area_overlap = 0._r8
        return
    else
        if( d .le. ( rmax - rmin ) ) then
            area_overlap = min( a1, a2 )
            return
        elseif( d .ge. ( rmax + rmin ) ) then
            area_overlap = 0._r8
            return
        else
            arg1 = (d**2._r8+rmin**2._r8-rmax**2._r8)/(2._r8*d*rmin)    
            arg2 = (d**2._r8+rmax**2._r8-rmin**2._r8)/(2._r8*d*rmax)    
            arg3 = (-d+rmin+rmax)*(d+rmin-rmax)*(d-rmin+rmax)*(d+rmin+rmax)
            arg1 = max(-1._r8,min(1._r8,arg1))
            arg2 = max(-1._r8,min(1._r8,arg2))
            arg3 = max(0._r8,arg3)
            area_overlap = cn * &
                          (rmin**2._r8*acos(arg1) + rmax**2._r8*acos(arg2) - 0.5_r8*sqrt(arg3))
          ! Apr.25.2012. I checked that below is always satisfied with round-off error.
          ! So, I safely added below safety constraint.
            area_overlap = min( a1, min( a2, area_overlap ) )
            return 
        end if
    end if
  ! Apr.25.2012. I checked that below is always satisfied with round-off error.
  ! So, I removed below checking block with final safety constraint as above inside the if block.
  ! if( area_overlap .gt. a1 .or. area_overlap .gt. a2 .or. &
  !     area_overlap .lt. 0._r8 )  then
  !     write(6,*) 'UNICON : Unreasonable overlapping area in unicon.F90'
  !     write(6,*) 'a1, a2, area_overlap, cn = ', a1, a2, area_overlap, cn
  !     stop
  ! end if
  ! return
  end function area_overlap


  subroutine envcon_flux(ki,mkx,umi,dmi,a0,ssa0,ps0,au,ad)
  ! --------------------------------------------------------------------------- !
  ! Compute mean-environmental values of conservative scalar for computation of !
  ! convective fluxes by considering the displacement of flux interface induced !
  ! by convective updraft and downdraft mass fluxes and associated compensating !
  ! downwelling and upwelling.                                                  !
  ! ki  : interface index that is considered                                    !
  ! umi : updraft   mass flux in unit of [Pa] during dt ( umi >= 0 )            !
  ! dmi : downdraft mass flux in unit of [Pa] during dt ( dmi >= 0 )            !
  ! a   : environmental conservative scalar that is considered                  !
  ! Done.                                                                       !
  ! --------------------------------------------------------------------------- ! 
    implicit none
    integer,  intent(in)   :: ki, mkx 
    real(r8), intent(in)   :: umi, dmi
    real(r8), intent(in)   :: a0(mkx), ssa0(mkx)
    real(r8), intent(in)   :: ps0(0:mkx)
    real(r8), intent(out)  :: au, ad
    integer   k, ku, kd 
    real(r8)  um, dm
    real(r8)  dp, dpu, dpd, pbot, ptop, dptop, a_dptop, dpbot, a_dpbot

  ! Impose a limiting on the updraft (um) and downdraft mass flux (dm) such that
  ! it cannot be larger than the available mass above the interface (um) and 
  ! below the displaced interface (dm) by updraft mass flux. Note that ps0(0) is
  ! surface interface while ps0(mkx) is top-most interface. Note umi, dmi > 0.

    um = max( 0._r8, min( umi, ps0(ki) - ps0(mkx) ) )
    dm = max( 0._r8, min( dmi, ps0(0)  - ps0(ki) + um ) ) 

  ! Treatment of updraft
 
  ! if( um .eq. 0._r8 ) then
    if( um .lt. 1.e-5_r8 ) then ! To avoid dividing by zero ( dpu = 0 ) by round-off error.
        if( ki .eq. mkx ) then
            au = a0(ki)
        else
            au = a0(ki+1) + 0.5_r8 * ssa0(ki+1) * ( ps0(ki) - ps0(ki+1) ) 
        endif
        goto 50
    endif

    ku = ki + 1
    do k = ki, mkx
       if( ps0(k) .lt. ( ps0(ki) - um ) ) then  
           ku = k 
           goto 10
       endif
    enddo   
 10 continue

    au = 0._r8
    dpu = 0._r8
    if( ( ku - 1 ) .ge. ( ki + 1 ) ) then
          do k = ki + 1, ku - 1 
             dp = ps0(k-1) - ps0(k)
             au = au + a0(k) * dp
             dpu = dpu + dp
          enddo
    endif

    ptop = ps0(ki) - um
    dptop = ps0(ku-1) - ptop
    a_dptop = a0(ku) + 0.5_r8 * ssa0(ku) * ( ptop - ps0(ku) )
    au = au + a_dptop * dptop
    dpu = dpu + dptop
    ! I checked that dpu = 0 happans when umi is very small, 1.e-15.
    if( dpu .eq. 0._r8 ) then
        write(6,*) 'ki, ku, um, umi, dmi = ', ki, ku, um, umi, dmi
        write(6,*) 'ptop, dptop, a_dptop, au, dpu = ', ptop, dptop, a_dptop, au, dpu
        do k = 1, mkx 
           write(6,*) 'ps0(k), a0(k) =', ps0(k), a0(k)
        enddo
        call endrun('UNICON : Zero dpu within envcon_flux')  
    endif
    au = au / dpu

 50 continue

  ! Treatment of downdraft
    
  ! if( dm .eq. 0._r8 ) then
    if( dm .lt. 1.e-5_r8 ) then ! To avoid dividing by zero ( dpd = 0 ) by round-off error.
        ad = a0(ku) + ssa0(ku) * ( ptop - 0.5_r8 * ( ps0(ku-1) - ps0(ku ) ) )
        return
    endif   

    pbot = ps0(ki) - um + dm
    kd = ku
    do k = ku, 1, -1
       if( ps0(k) .ge. pbot ) then
           kd = k + 1
           goto 20
       endif
    enddo
 20 continue

    ad = 0._r8
    dpd = 0._r8
    if( ( ku - 1 ) .ge. ( kd + 1 ) ) then
          do k =  kd + 1, ku - 1
             dp = ps0(k-1) - ps0(k)
             ad = ad + a0(k) * dp
             dpd = dpd + dp
          enddo 
    endif

    if( pbot .le. ps0(ku-1) ) then
        dpbot = dm
        a_dpbot = a0(ku) + 0.5_r8 * ssa0(ku) * ( pbot + ptop - ps0(ku-1) - ps0(ku) )
        ad = ad + a_dpbot * dpbot
        dpd = dpd + dpbot
        ad = ad / dpd   
        return
    else
        dpbot = pbot - ps0(kd)
        a_dpbot = a0(kd) + 0.5_r8 * ssa0(kd) * ( pbot + ps0(kd) - ps0(kd-1) - ps0(kd) )
        ad = ad + a_dpbot * dpbot + a_dptop * dptop
        dpd = dpd + dpbot + dptop
        ad = ad / dpd
        return
    endif   

    return
  end subroutine envcon_flux


  subroutine prod_prep_up( z_b, z_t, p_b, p_t, exn_t, exn_m, w_b, w_t,                   & 
                           thl_in, qt_in, ql_in, qi_in, tr_in,                           &
                           S_b_ql_in, S_b_qi_in, iprd_prep,                              &
                           ql_b, qi_b, epsb,                                             &
                           thl_m, ssthl_m, thl_b, qt_m, ssqt_m, qt_b,                    & 
                           ncnst, ixcldliq, ixcldice, ixnumliq, ixnumice, ii, kk, lchnk, &
                           flxrain, flxsnow, a_p, a_u, a_pu,                             &
                           caer, criqc, c0_ac, droprad_liq, droprad_ice,                 &
                           exql, exqi, extr, S_t_ql, S_t_qi, evpR, evpS, evpRStr )
  ! ------------------------------------------------------------------------------------------------------- ! 
  ! Compute 'exql, exqi >= 0' [kg/kg] and 'S_t_ql, S_t_qi >= 0' [kg/kg/Pa].                                 !
  ! ------------------------------------------------------------------------------------------------------- !
    implicit none
    integer,  intent(in)     :: ncnst, ixcldliq, ixcldice, ixnumliq, ixnumice, ii, kk, lchnk, iprd_prep 
    real(r8), intent(in)     :: z_b, z_t, p_b, p_t, exn_t, exn_m
    real(r8), intent(in)     :: w_b, w_t
    real(r8), intent(in)     :: thl_in, qt_in, ql_in, qi_in, tr_in(ncnst)
    real(r8), intent(in)     :: S_b_ql_in, S_b_qi_in
    real(r8), intent(in)     :: ql_b, qi_b, epsb
    real(r8), intent(in)     :: thl_m, ssthl_m, thl_b, qt_m, ssqt_m, qt_b
    real(r8), intent(in)     :: flxrain, flxsnow
    real(r8), intent(in)     :: a_p, a_u, a_pu
    real(r8), intent(in)     :: caer, criqc, c0_ac, droprad_liq, droprad_ice 
    real(r8), intent(out)    :: exql, exqi, extr(ncnst)
    real(r8), intent(out)    :: evpR, evpS, evpRStr(ncnst)
    real(r8), intent(out)    :: S_t_ql, S_t_qi
    integer   mt, iter, id_exit, id_check, niter
    real(r8)  lambda
    real(r8)  tmp1, tmp2
    real(r8)  tmp_thl, tmp_qt, tmp_th, tmp_qv, tmp_ql, tmp_qi, tmp_qs
    real(r8)  dp, dz, wm, delta_t
    real(r8)  flxrain_in, flxsnow_in
    real(r8)  ql, qi
    real(r8)  S_b_ql, S_b_qi 
    real(r8)  S_ql, S_qi 
    real(r8)  S_t_ql_pre, S_t_qi_pre
    real(r8)  exql_pre, exqi_pre
    real(r8)  dia_thl, dia_qt
    ! ----------------------- !
    ! Compute basic variables !
    ! ----------------------- !

    niter = 1
    if( iprd_prep .eq. -1 .or. iprd_prep .eq. -5 ) niter = 0   ! Forward Method
    lambda     = 0.5_r8 
    dp         = p_b - p_t              ! [  Pa ] >= 0.
    dz         = z_t - z_b              ! [  z  ] >= 0.
    wm         = 0.5_r8 * ( w_b + w_t ) ! [ m/s ] >  0.
    delta_t    = dz / wm                ! [  s  ] >= 0.
    flxrain_in = flxrain / max( nonzero, a_p )
    flxsnow_in = flxsnow / max( nonzero, a_p )

    ! ------------------------------------------------------------------------------------------------------------------- !
    ! Current formulation only contains a simple auto-conversion process as a unique function of in-cloud LWC/IWC.        !
    ! In future, I should add more advanced formula as a function of droplet radius, vertical velocity, and               !
    ! precipitation flux falling into the current layer.                                                                  !
    ! IMPORTANT :                                                                                                         !
    !    (1) Current precipitation formula conserve 'the fraction (f(T)) of in-cumulus liquid / ice as a function         !
    !        of T' as is assumed in the subroutine 'conden'. Thus, without using 'conden', I can construct this iteration !
    !        loop associated with precipitation production (i.e., temperature T does not change during precipitation      !
    !        production process ), which saves computation time a lot.                                                    !
    !    (2) With future double-moment microphysics, this f(T) assumed within 'conden' does not hold after precipitation  !
    !        production. Thus, I should not use 'conden' subroutine with future microphysics, which will also save        !
    !        computation time in future.                                                                                  !
    ! ------------------------------------------------------------------------------------------------------------------- !

    if( iprd_prep .eq. -5 ) then

        if( ( ql_b + qi_b ) .gt. criqc ) then
            S_ql = c0_ac * ( ( ql_b + qi_b ) - criqc ) * ( ql_b / ( ql_b + qi_b ) )
            S_qi = c0_ac * ( ( ql_b + qi_b ) - criqc ) * ( qi_b / ( ql_b + qi_b ) )
        else
            S_ql = 0._r8
            S_qi = 0._r8
        endif      
        dia_qt  =   S_ql + S_qi 
        dia_thl = - ( ( xlv / cp / exn_m ) * S_ql + ( xls / cp / exn_m ) * S_qi )
        call progup_thlqt( epsb, 0._r8, dia_thl, p_b, p_t, thl_m, ssthl_m, thl_b, tmp_thl )
        call progup_thlqt( epsb, 0._r8, dia_qt,  p_b, p_t, qt_m,  ssqt_m,  qt_b,  tmp_qt  )
        call conden( p_t, tmp_thl, tmp_qt, tmp_th, tmp_qv, tmp_ql, tmp_qi, tmp_qs, id_check )
        exql = min( max( ql_in - tmp_ql, 0._r8 ), 0.99_r8 * ql_in )
        exqi = min( max( qi_in - tmp_qi, 0._r8 ), 0.99_r8 * qi_in )
        if( mclimit .eq. 1 ) then
            tmp1 = exql + exqi
            tmp2 = min( tmp1, max( ql_in + qi_in - criqc, 0._r8 ) ) ! To impose a continuous variation across ql + qi = criqc.
            exql = exql * ( tmp2 / max( tmp1, nonzero ) )
            exqi = exqi * ( tmp2 / max( tmp1, nonzero ) )
        endif
        S_ql = exql / max( dp, nonzero )
        S_qi = exqi / max( dp, nonzero )
        S_t_ql = S_ql
        S_t_qi = S_qi

    else

    ! ------------------------------------------------------------------------------------------------------ !
    ! Compute initially-precipitated updraft state variable 'ql,qi' at the top interface using precipitation !
    ! tendency at the base interface.                                                                        !
    ! ------------------------------------------------------------------------------------------------------ !

    S_ql = S_b_ql_in
    S_qi = S_b_qi_in
    exql = S_ql * dp 
    exqi = S_qi * dp
    exql = min( max( 0._r8, exql ), 0.99_r8 * ql_in )
    exqi = min( max( 0._r8, exqi ), 0.99_r8 * qi_in )
    if( mclimit .eq. 1 ) then
        tmp1 = exql + exqi
        tmp2 = min( tmp1, max( ql_in + qi_in - criqc, 0._r8 ) ) ! To impose a continuous variation across ql_in + qi_in = criqc.
        exql = exql * ( tmp2 / max( tmp1, nonzero ) )
        exqi = exqi * ( tmp2 / max( tmp1, nonzero ) )
    endif
    S_b_ql = exql / max( dp, nonzero )
    S_b_qi = exqi / max( dp, nonzero )
    ql = ql_in - exql
    qi = qi_in - exqi
    if( iprd_prep .eq. 1 ) then
        ql = ql_in
        qi = qi_in    
    elseif( iprd_prep .eq. 0 ) then
        ql = ql_in
        qi = qi_in
        S_b_ql = S_b_ql_in
        S_b_qi = S_b_qi_in
    endif    
    if( ( ql + qi ) .gt. criqc ) then
        S_t_ql = c0_ac * ( ( ql + qi ) - criqc ) * ( ql / ( ql + qi ) ) ! [ kg/kg/Pa ]
        S_t_qi = c0_ac * ( ( ql + qi ) - criqc ) * ( qi / ( ql + qi ) ) ! [ kg/kg/Pa ]
    else
        S_t_ql = 0._r8
        S_t_qi = 0._r8
    endif

    ! ---------------------------------------------------------------------------------------------------------------- !
    ! Perform implicit iteration                                                                                       !
    ! The requires output from the iteration loop :                                                                    !
    !   (1) 'exql, exqi'                                                                                               ! 
    !   (2) 'S_t_ql, S_t_qi'                                                                                           !
    ! where the above (1) and (2) are fully consistent ( exql = 0.5_r8 * ( S_b_ql + S_t_ql ) * dp, exqi = ... )        !
    ! regardless of the iteration number. However, the consistency between the 'ql = ql_in - exql' and 'S_t_ql' at the !
    ! top interface can be obtained as iteration is executed many times.                                               !
    ! By setting 'do iter = 1, 1', I can use centered difference instead of forward difference which is a default.     !
    ! ---------------------------------------------------------------------------------------------------------------- !

    id_exit = 0
    do iter = 1, niter
    
       ! ------------------------------------------------------ !
       ! Compute 'raw' precipitation rate at the top interface. !
       ! ------------------------------------------------------ !

       if( ( ql + qi ) .gt. criqc ) then
           S_t_ql = c0_ac * ( ( ql + qi ) - criqc ) * ( ql / ( ql + qi ) ) ! [ kg/kg/Pa ]
           S_t_qi = c0_ac * ( ( ql + qi ) - criqc ) * ( qi / ( ql + qi ) ) ! [ kg/kg/Pa ]
       else
           S_t_ql = 0._r8
           S_t_qi = 0._r8
       endif

       ! ------------------------------------------------------------------------------- !
       ! Impose a limiter on the computed 'raw' precipitation rate at the top interface. !
       ! Use 'ql_in, qi_in' which does not include precipitation fall-out at the top.    !
       ! At the end of this block, 'exql,exqi' is fully consistent with 'S_t_ql,S_t_qi'. ! 
       ! ------------------------------------------------------------------------------- !  

       S_ql = 0.5_r8 * ( S_b_ql + S_t_ql )
       S_qi = 0.5_r8 * ( S_b_qi + S_t_qi )
       if( iprd_prep .eq. 1 ) then
           S_ql = S_t_ql
           S_qi = S_t_qi
       endif
       exql = S_ql * dp 
       exqi = S_qi * dp 
       exql = min( max( 0._r8, exql ), 0.99_r8 * ql_in )
       exqi = min( max( 0._r8, exqi ), 0.99_r8 * qi_in )
       if( mclimit .eq. 1 ) then
           tmp1 = exql + exqi
           tmp2 = min( tmp1, max( ql_in + qi_in - criqc, 0._r8 ) ) ! To impose a continuous variation across ql_in + qi_in = criqc.
           exql = exql * ( tmp2 / max( tmp1, nonzero ) )
           exqi = exqi * ( tmp2 / max( tmp1, nonzero ) )
       endif
       S_ql = exql / max( dp, nonzero )
       S_qi = exqi / max( dp, nonzero )
       S_t_ql = 2._r8 * S_ql - S_b_ql ! IMPORTANT : This must be allowed to be negative.
       S_t_qi = 2._r8 * S_qi - S_b_qi ! IMPORTANT : This must be allowed to be negative.  	
       if( iprd_prep .eq. 1 ) then
           S_t_ql = 1._r8 * S_ql      ! IMPORTANT : This must be allowed to be negative.
           S_t_qi = 1._r8 * S_qi      ! IMPORTANT : This must be allowed to be negative.  	
       endif

       ! ------------------------------------------------------------------------------------------------------------- !
       ! Compute 'implicit' precipitation rate at the top interface by averaging the 'current' precipitation rate with !
       ! the 'previous' precipitation rate computed at the previous iteration loop.                                    !
       ! Since both 'current' and 'previous' precipitation rates satisfies the limiters,                               !
       ! the average 'implicit' precipitation rate also satisfies the limiter automatically.                           !
       ! Within if block, the implicit 'exql,exqi' is fully consistent with 'S_t_ql,S_t_qi'.                           ! 
       ! ------------------------------------------------------------------------------------------------------------- !

       if( iter .gt. 1 ) then
           S_t_ql = lambda * S_t_ql + ( 1._r8 - lambda ) * S_t_ql_pre
           S_t_qi = lambda * S_t_qi + ( 1._r8 - lambda ) * S_t_qi_pre
           S_ql   = 0.5_r8 * ( S_b_ql + S_t_ql )
           S_qi   = 0.5_r8 * ( S_b_qi + S_t_qi )
           if( iprd_prep .eq. 1 ) then
               S_ql   = S_t_ql
               S_qi   = S_t_qi
           endif
           exql   = S_ql * dp
           exqi   = S_qi * dp
         ! if( kk .ge. 10 .and. kk .le. 12 ) then
         !     write(6,*)
         !     write(6,*) 'UNICON : Convergence test within the subroutine prod_prep_up'
         !     write(6,*) 'kk, iter, abs( exql + exqi - exql_pre - exqi_pre ) = ', kk, iter, abs( exql + exqi - exql_pre - exqi_pre )
         !     write(6,*) 'kk, iter, exql, exqi, S_t_ql, S_t_qi, dp           = ', kk, iter, exql, exqi, S_t_ql, S_t_qi, dp  
         !     write(6,*)
         ! endif  
           if( abs( exql + exqi - exql_pre - exqi_pre ) .lt. 1.e-6_r8 ) then
               id_exit = 1
           endif 
       endif

       S_t_ql_pre = S_t_ql 
       S_t_qi_pre = S_t_qi 
       exql_pre   = exql 
       exqi_pre   = exqi 

       ! ----------------------------------------------------------------------------------------------------------------- !
       ! Update state variable at the top interface.                                                                       ! 
       ! At this stage, 'exql = 0.5_r8 * ( S_b_ql + S_t_ql ) * dp' is exactly satisfied.                                   !
       ! However, our 'S_t_ql' becomes inconsistent with the below updated 'ql = ql_in - exql' since 'S_t_ql' was computed !
       ! using 'ql = ql_in - exql(old)' where 'exql(old)' differs from 'exql'.                                             ! 
       ! This inconsistency will be removed as iteration goes on.                                                          !
       ! ----------------------------------------------------------------------------------------------------------------- !

       ql = ql_in - exql
       qi = qi_in - exqi
       if( id_exit .eq. 1 ) goto 10

    enddo
 10 S_t_ql = max( 0._r8, S_t_ql ) ! Reset to non-negative value before sending to output.
    S_t_qi = max( 0._r8, S_t_qi ) ! Reset to non-negative value before sending to output.

    endif ! End of 'iprd_prep = -5' choice

    ! ------------------------------- !
    ! Treatment of In-Cumulus Tracers !
    ! ------------------------------- !

    do mt = 1, ncnst
       if( mt .eq. 1 ) then
           extr(mt) = 0._r8
       elseif( mt .eq. ixcldliq ) then
           extr(mt) = exql
       elseif( mt .eq. ixcldice ) then
           extr(mt) = exqi
       elseif( mt .eq. ixnumliq ) then
           extr(mt) = exql * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_liq**3 * density_liq )
       elseif( mt .eq. ixnumice ) then
           extr(mt) = exqi * 3._r8 / ( 4._r8 * 3.141592_r8 * droprad_ice**3 * density_ice )
       else
           ! ----------------------------------------------------------------------------------------- !
           ! Wet deposition of aerosols (both interstitial and cloud-borne) within convective updarft. !
           ! Below is a very simple treatment which should be refined in future.                       !
           ! Note that I should use 'qt_in, tr_in' (i.e., input values) within below block.            !
           ! ----------------------------------------------------------------------------------------- !
           extr(mt) = tr_in(mt) * ( ( exql + exqi ) / max( qt_in, nonzero ) )
         ! Nov.26.2013. Following the reviewer's comments, set 'extr(mt) = 0' since current formulation of
         !              extr(mt) only treats auto-conversion not accretion.
         ! extr(mt) = 0._r8 
         ! Nov.29.2013. Following the reviewer's comments, use 'ql_in + qi_in' instead of 'qt_in' 
         !              in computing 'extr(mt)' above.
           extr(mt) = caer * tr_in(mt) * min( 1._r8, ( ( exql + exqi ) / max( ql_in + qi_in, nonzero ) ) )
       endif
    enddo

    ! ------------------------------------------------------------ !
    ! Evaporation.                                                 !
    ! Temporary set it to be zero, but should be refined in future !
    ! ------------------------------------------------------------ !

    evpR = 0._r8
    evpS = 0._r8
    do mt = 1, ncnst
       evpRStr(mt) = 0._r8
    enddo

    return

  end subroutine prod_prep_up


  subroutine evap_prep_dn( z_b, z_t, p_b, p_t, w_dt, bogtop,                                                     &  
                           th_in, qv_in, ql_in, qi_in, qs_in, tr_in, qmin,                                       &
                           i_downloading, qrain_in, qsnow_in,                                                    &
                           S_t_qvR_in, S_t_qvS_in, ievp_prep,                                                    & 
                           flxrain_bot_upeesm, flxsnow_bot_upeesm, flxtrrs_bot_upeesm, a_p_msfc,                 &
                           ncnst, ixcldliq, ixcldice, ixnumliq, ixnumice, ndb_evp, cmfdb_evp, ii, kk, ks, lchnk, & 
                           rho, thv_mean_b, cmf_db, eps_dn, del_dn,                                              &
                           kevp_rain_dn, kevp_snow_dn, eta2, rbuoy_dn, rdrag, rjet, nonzero, wdmin,              &
                           evp_qvR, evp_qvS, evp_tr, S_b_qvR, S_b_qvS, w_db )
  ! ------------------------------------------------------------------------------------------------------- ! 
  ! Compute 'evp_qvR, evp_qvS >= 0' [kg/kg] and 'S_b_qvR, S_b_qvS >= 0' [kg/kg/Pa], 'w_db >= wdmin [m/s]'   !
  ! ------------------------------------------------------------------------------------------------------- !
    implicit none
    integer,  intent(in)     :: ncnst, ixcldliq, ixcldice, ixnumliq, ixnumice
    integer,  intent(in)     :: i_downloading, ndb_evp, ii, kk, ks, lchnk, ievp_prep
    real(r8), intent(in)     :: cmfdb_evp
    real(r8), intent(in)     :: z_b, z_t, p_b, p_t
    real(r8), intent(in)     :: w_dt, bogtop
    real(r8), intent(in)     :: th_in, qv_in, ql_in, qi_in, qs_in, tr_in(ncnst), qmin(ncnst)
    real(r8), intent(in)     :: qrain_in, qsnow_in
    real(r8), intent(in)     :: S_t_qvR_in, S_t_qvS_in
    real(r8), intent(in)     :: flxrain_bot_upeesm, flxsnow_bot_upeesm, flxtrrs_bot_upeesm(ncnst), a_p_msfc
    real(r8), intent(in)     :: rho, thv_mean_b, cmf_db, eps_dn, del_dn 
    real(r8), intent(in)     :: kevp_rain_dn, kevp_snow_dn, eta2 
    real(r8), intent(in)     :: rbuoy_dn, rdrag, rjet
    real(r8), intent(in)     :: nonzero, wdmin
    real(r8), intent(out)    :: evp_qvR, evp_qvS, evp_tr(ncnst)
    real(r8), intent(out)    :: S_b_qvR, S_b_qvS
    real(r8), intent(out)    :: w_db
    real(r8)                 :: es, qs
    integer   mt, iter, id_exit, niter
    real(r8)  tmp1, tmp2
    real(r8)  evp_max
    real(r8)  S_t_qvR, S_t_qvS
    real(r8)  S_qvR, S_qvS
    real(r8)  evp_qvR_pre, evp_qvS_pre
    real(r8)  S_b_qvR_pre, S_b_qvS_pre
    real(r8)  t_in, thv_in, tw_in, qw_in
    real(r8)  t, qv, th, thv, bogbot, wd2  
    real(r8)  subsat_db
    real(r8)  dp, dz
    real(r8)  lambda
    real(r8)  rndb_evp

    ! ----------------------- !
    ! Compute basic variables !
    ! ----------------------- !

    niter = 1
    if( ievp_prep .eq. -1 .or. ievp_prep .eq. -5 ) niter = 0   ! Forward Method
    lambda   = 0.5_r8 
    rndb_evp = real(ndb_evp,r8)
    dp       = p_b - p_t              ! [  Pa ] >= 0.
    dz       = z_t - z_b              ! [  z  ] >= 0.
    t_in     = th_in*exnf(p_b)
    call findsp_single( qv_in, t_in, p_b, tw_in, qw_in, ii, kk, lchnk )

    ! -------------------------------------------------------------------------------------------------------------- !
    ! Two sufficient-necessary downdraft state variables used for computing evaporation rate at the base interface : !
    !   (1) subsat_db                                                                                                !
    !   (2) w_db                                                                                                     !
    ! which should continuously updated within the iteration loop.                                                   !
    ! -------------------------------------------------------------------------------------------------------------- !

    S_qvR      = S_t_qvR_in
    S_qvS      = S_t_qvS_in
    evp_qvR    = S_qvR * dp
    evp_qvS    = S_qvS * dp
  ! evp_qvR = max( 0._r8, min( evp_qvR, eta2 * flxrain_bot_upeesm / max( nonzero, cmf_db ) / max( 1._r8, rndb_evp ) ) )
  ! evp_qvS = max( 0._r8, min( evp_qvS, eta2 * flxsnow_bot_upeesm / max( nonzero, cmf_db ) / max( 1._r8, rndb_evp ) ) )
    evp_qvR = max( 0._r8, min( evp_qvR, eta2 * flxrain_bot_upeesm / max( nonzero, cmfdb_evp ) ) )
    evp_qvS = max( 0._r8, min( evp_qvS, eta2 * flxsnow_bot_upeesm / max( nonzero, cmfdb_evp ) ) )
    evp_max = max( qw_in - qv_in, 0._r8 )
    if( ( evp_qvR + evp_qvS ) .gt. evp_max ) then
        tmp1 = evp_qvR * evp_max / ( evp_qvR + evp_qvS )
        tmp2 = evp_qvS * evp_max / ( evp_qvR + evp_qvS )
        evp_qvR = tmp1
        evp_qvS = tmp2
    endif
    S_t_qvR    = evp_qvR / max( dp, nonzero )
    S_t_qvS    = evp_qvS / max( dp, nonzero )
    t          = t_in - ( xlv / cp ) * evp_qvR - ( xls / cp ) * evp_qvS
    qv         = qv_in + evp_qvR + evp_qvS 

  ! Mar.15.2015. Below block is moved from below. 

    th         = t / exnf(p_b)
    thv        = th * ( 1._r8 + zvir * qv - ql_in - qi_in )
    if( i_downloading .eq. 1 ) thv = th * ( 1._r8 + zvir * qv - ql_in - qi_in - qrain_in - qsnow_in )
    bogbot     = rbuoy_dn * ( 1._r8 - thv / thv_mean_b )
    call progup_wu2( -( rdrag*eps_dn - rjet*del_dn ), rho, p_t, p_b, -bogtop, -bogbot, w_dt**2._r8, 0._r8, wd2 )
    w_db       = max( wdmin, sqrt( max( wd2, nonzero ) ) )

    if( ievp_prep .eq. 1 ) then
        t      = t_in
        qv     = qv_in
    elseif( ievp_prep .eq. 0 ) then
        t      = t_in
        qv     = qv_in
        S_t_qvR = S_t_qvR_in 
        S_t_qvS = S_t_qvS_in 
    endif

    call qsat(t,p_b,es,qs)
    subsat_db  = min( 1._r8, max( 0._r8, 1._r8 - qv / max( qs, nonzero ) ) )

  ! May.15.2015. Potentially, for 'ievp_prep = 0' option, I can use 't = t_in - ( xlv / cp ) * evp_qvR - ( xls / cp ) * evp_qvS' and
  !              'qv = qv_in + evp_qvR + evp_qvS' for computing 'w_db', in order to prevent too small 'w_db' due to the neglect of
  !              evaporation of precipitation at the base interface in computing 'w_db' in the below block. This should be tested in
  !              future. However, regardless of 'w_db', I should use 't = t_in' and 'qv = qv_in' in computing 'subsat_db' above. 

  ! th         = t / exnf(p_b)
  ! thv        = th * ( 1._r8 + zvir * qv - ql_in - qi_in )
  ! if( i_downloading .eq. 1 ) thv = th * ( 1._r8 + zvir * qv - ql_in - qi_in - qrain_in - qsnow_in )
  ! bogbot     = rbuoy_dn * ( 1._r8 - thv / thv_mean_b )
  ! call progup_wu2( -( rdrag*eps_dn - rjet*del_dn ), rho, p_t, p_b, -bogtop, -bogbot, w_dt**2._r8, 0._r8, wd2 )
  ! w_db       = max( wdmin, sqrt( max( wd2, nonzero ) ) )

    S_b_qvR    = ( 1._r8 / ( rho * g ) / max( w_db, wdmin ) ) * kevp_rain_dn * subsat_db * & 
                 sqrt( max( 0._r8, flxrain_bot_upeesm / max( a_p_msfc, nonzero ) ) )
    S_b_qvS    = ( 1._r8 / ( rho * g ) / max( w_db, wdmin ) ) * kevp_snow_dn * subsat_db * & 
                 sqrt( max( 0._r8, flxsnow_bot_upeesm / max( a_p_msfc, nonzero ) ) )

  ! if( qv_in .gt. qw_in .or. qw_in .gt. qs .or. qv_in .gt. qs ) then
  !     write(6,*)
  !     write(6,*) 'UNICON : Error in qv_in, qw_in, qs_in within evap_prep_dn'
  !     write(6,*) 'qv_in, qw_in, qs_in = ', 1000._r8 * qv_in, 1000._r8 * qw_in, 1000._r8 * qs 
  !     write(6,*)
  ! endif

    ! ---------------------------------------------------------------------------------------------------------------- !
    ! Perform implicit iteration                                                                                       !
    ! The requires output from the iteration loop :                                                                    !
    !   (1) 'evp_qvR, evp_qvS [kg/kg]    >= 0'                                                                         ! 
    !   (2) 'S_b_qvR, S_b_qvS [kg/kg/Pa] >= 0'                                                                         !
    ! where the above (1) and (2) are fully consistent ( evp_qvR = 0.5_r8 * ( S_t_qvR + S_b_qvR ) * dp, evp_qvS = .. ) !
    ! regardless of the iteration number. However, consistency between 't = t_in-(xlv/cp)*evp_qvR-(xls/cp)*evp_qvS,    !
    ! qv = qv_in + evp_qvR + evp_qvS' and 'S_b_qvR, S_b_qvS' at the base interface can be obtained as iteration is     !
    ! executed many times.                                                                                             !
    ! By setting 'do iter = 1, 1', I can use centered difference instead of forward difference which is a default.     !
    ! ---------------------------------------------------------------------------------------------------------------- !

    id_exit = 0
    do iter = 1, niter

       ! ----------------------------------------------------- !
       ! Compute 'raw' evaporation rate at the base interface. !
       ! ----------------------------------------------------- !

       S_b_qvR = ( 1._r8 / ( rho * g ) / max( w_db, wdmin ) ) * kevp_rain_dn * subsat_db * & 
                 sqrt( max( 0._r8, flxrain_bot_upeesm / max( a_p_msfc, nonzero ) ) )
       S_b_qvS = ( 1._r8 / ( rho * g ) / max( w_db, wdmin ) ) * kevp_snow_dn * subsat_db * & 
                 sqrt( max( 0._r8, flxsnow_bot_upeesm / max( a_p_msfc, nonzero ) ) )

       ! --------------------------------------------------------------------------------------- !
       ! Impose a limiter on the computed 'raw' evaporation rate at the base interface.          !
       ! Use 'evp_max = qw_in - qv_in' and 'eta2 * flxrain_bot_upeesm...' which do not include   ! 
       ! evaporation of precipitation yet.                                                       !
       ! --------------------------------------------------------------------------------------- !  

       S_qvR   = 0.5_r8 * ( S_t_qvR + S_b_qvR )
       S_qvS   = 0.5_r8 * ( S_t_qvS + S_b_qvS )
       if( ievp_prep .eq. 1 ) then
           S_qvR   = S_b_qvR
           S_qvS   = S_b_qvS
       endif
       evp_qvR = S_qvR * dp
       evp_qvS = S_qvS * dp
     ! evp_qvR = max( 0._r8, min( evp_qvR, eta2 * flxrain_bot_upeesm / max( nonzero, cmf_db ) / max( 1._r8, rndb_evp ) ) )
     ! evp_qvS = max( 0._r8, min( evp_qvS, eta2 * flxsnow_bot_upeesm / max( nonzero, cmf_db ) / max( 1._r8, rndb_evp ) ) )
       evp_qvR = max( 0._r8, min( evp_qvR, eta2 * flxrain_bot_upeesm / max( nonzero, cmfdb_evp ) ) )
       evp_qvS = max( 0._r8, min( evp_qvS, eta2 * flxsnow_bot_upeesm / max( nonzero, cmfdb_evp ) ) )
       evp_max = max( qw_in - qv_in, 0._r8 )
       if( ( evp_qvR + evp_qvS ) .gt. evp_max ) then
           tmp1 = evp_qvR * evp_max / ( evp_qvR + evp_qvS )
           tmp2 = evp_qvS * evp_max / ( evp_qvR + evp_qvS )
           evp_qvR = tmp1
           evp_qvS = tmp2
       endif
     ! Mar.15.2014. By commenting in (activating) below 'if' block, compute 'non-zero' 'S_b_qvR,S_b_qvS'
     !              for mixing downdraft generated in the current layer. This is important to obtain reasonably
     !              strong downdraft vertical velocity. 
!?     if( ks .ne. kk .and. dp .gt. 0._r8 ) then
       if( ks .ne. kk ) then
       S_qvR = evp_qvR / max( dp, nonzero )
       S_qvS = evp_qvS / max( dp, nonzero )
       S_b_qvR = 2._r8 * S_qvR - S_t_qvR    ! IMPORTANT : This must be allowed to be negative to prevent negative precipitation flux.   
       S_b_qvS = 2._r8 * S_qvS - S_t_qvS    ! IMPORTANT : This must be allowed to be negative to prevent negative precipitation flux.
       if( ievp_prep .eq. 1 ) then
           S_b_qvR = 1._r8 * S_qvR          ! IMPORTANT : This must be allowed to be negative to prevent negative precipitation flux.   
           S_b_qvS = 1._r8 * S_qvS          ! IMPORTANT : This must be allowed to be negative to prevent negative precipitation flux.
       endif
       endif

       ! ------------------------------------------------------------------------------------------------------------- !
       ! Compute 'implicit' precipitation rate at the top interface by averaging the 'current' precipitation rate with !
       ! the 'previous' precipitation rate computed at the previous iteration loop.                                    !
       ! Since both 'current' and 'previous' precipitation rates satisfies the limiters,                               !
       ! the average 'implicit' precipitation rate also satisfies the limiter automatically.                           !
       ! ------------------------------------------------------------------------------------------------------------- !

       if( iter .gt. 1 ) then
           S_b_qvR = lambda * S_b_qvR + ( 1._r8 - lambda ) * S_b_qvR_pre
           S_b_qvS = lambda * S_b_qvS + ( 1._r8 - lambda ) * S_b_qvS_pre
           S_qvR   = 0.5_r8 * ( S_t_qvR + S_b_qvR )
           S_qvS   = 0.5_r8 * ( S_t_qvS + S_b_qvS )
           if( ievp_prep .eq. 1 ) then
               S_qvR   = S_b_qvR
               S_qvS   = S_b_qvS
           endif
           evp_qvR = S_qvR * dp
           evp_qvS = S_qvS * dp
         ! if( kk .ge. 10 .and. kk .le. 12 ) then
         !     write(6,*)
         !     write(6,*) 'UNICON : Convergence test within the subroutine evap_prep_up'
         !     write(6,*) 'kk, iter, abs( evp_qvR + evp_qvS - evp_qvR_pre - evp_qvS_pre )    = ', kk, iter, abs( evp_qvR + evp_qvS - evp_qvR_pre - evp_qvS_pre ) 
         !     write(6,*) 'kk, iter, evp_qvR, evp_qvS, S_b_qvR, S_b_qvS, w_db, subsat_db, dp = ', kk, iter, evp_qvR, evp_qvS, S_b_qvR, S_b_qvS, w_db, subsat_db, dp  
         !     write(6,*)
         ! endif
           if( abs( evp_qvR + evp_qvS - evp_qvR_pre - evp_qvS_pre ) .lt. 1.e-6_r8 ) then
               id_exit = 1 
           endif 
       endif

       S_b_qvR_pre = S_b_qvR 
       S_b_qvS_pre = S_b_qvS
       evp_qvR_pre = evp_qvR
       evp_qvS_pre = evp_qvS

       ! ----------------------------------------------------------------------------------------------------------------- !
       ! Update state variable at the top interface.                                                                       ! 
       ! At this stage, 'exql = 0.5_r8 * ( S_b_ql + S_t_ql ) * dp' is exactly satisfied.                                   !
       ! However, our 'S_t_ql' becomes inconsistent with the below updated 'ql = ql_in - exql' since 'S_t_ql' was computed !
       ! using 'ql = ql_in - exql(old)' where 'exql(old)' differs from 'exql'.                                             ! 
       ! This inconsistency will be removed as iteration goes on.                                                          !
       ! ----------------------------------------------------------------------------------------------------------------- !
     
       t         = t_in - ( xlv / cp ) * evp_qvR - ( xls / cp ) * evp_qvS
       qv        = qv_in + evp_qvR + evp_qvS 
       call qsat(t,p_b,es,qs)
       subsat_db = min( 1._r8, max( 0._r8, 1._r8 - qv / max( qs, nonzero ) ) )
       th        = t / exnf(p_b)
       thv       = th * ( 1._r8 + zvir * qv - ql_in - qi_in )
       if( i_downloading .eq. 1 ) thv = th * ( 1._r8 + zvir * qv - ql_in - qi_in - qrain_in - qsnow_in )
       bogbot    = rbuoy_dn * ( 1._r8 - thv / thv_mean_b )
       call progup_wu2( -( rdrag*eps_dn - rjet*del_dn ), rho, p_t, p_b, -bogtop, -bogbot, w_dt**2._r8, 0._r8, wd2 )
       w_db      = max( wdmin, sqrt( max( wd2, nonzero ) ) )
       if( id_exit .eq. 1 ) goto 10

    enddo
 10 S_b_qvR = max( 0._r8, S_b_qvR ) ! Reset to non-negative value before sending to output.
    S_b_qvS = max( 0._r8, S_b_qvS ) ! Reset to non-negative value before sending to output.

    ! ------------------------------- !
    ! Treatment of In-Cumulus Tracers !
    ! ------------------------------- !

    do mt = 1, ncnst
       if( mt .eq. 1 ) then
           evp_tr(mt) = evp_qvR + evp_qvS
       elseif( mt .eq. ixcldliq .or. mt .eq. ixcldice .or. mt .eq. ixnumliq .or. mt .eq. ixnumice ) then
           evp_tr(mt) = 0._r8
       else
           evp_tr(mt) = flxtrrs_bot_upeesm(mt) * ( evp_qvR + evp_qvS ) / & 
                        max( ( flxrain_bot_upeesm + flxsnow_bot_upeesm ) , nonzero )
       endif
       evp_tr(mt) = max( evp_tr(mt), qmin(mt) - tr_in(mt) )
    enddo

    return

  end subroutine evap_prep_dn


! subroutine progup_thlqt(eps,pb,pt,qmid,gamq,qub,qut)
! ! ---------------------------------------------------------------------- !
! ! Compute cumulus updraft properties at the top interface for 'thl,qt'   !
! ! for individual updraft plume. This subroutine is directly from the     !
! ! progupeff_thlqt but edge computation is removed for multiple plume     !
! ! approach.                                                              !
! ! Done.                                                                  !                                         
! ! ---------------------------------------------------------------------- ! 
!   implicit none
!   real(r8), intent(in)                     :: eps
!   real(r8), intent(in)                     :: pb, pt
!   real(r8), intent(in)                     :: qub
!   real(r8), intent(in)                     :: qmid, gamq
!   real(r8), intent(out)                    :: qut
!   real(r8)  qb, a, b, c, dp

! ! Environmental conservative scalar at the base interface 

!   dp = pb - pt
!   qb = qmid + 0.5_r8 * dp * gamq 

! ! Ensemble-mean updraft value at the top interface
! ! Aug.18.2010. I chekced that below 'qut' exactly reproduce the UW 
! ! in a raw form, but not the Taylor-extended form. I verified that
! ! my Taylor extended form is wrong but the UW has the correct 
! ! Taylor-expanded form. Thus, I am using the UW-Taylor extended form.
! ! As a result, my nelow formula produced the exactly same results as UW in
! ! all cases.

!   a = -eps  
!   b = -eps * gamq
!   c = -eps * ( qb - gamq * pb )

!   if(abs(a*dp).gt.1.e-3_r8) then
!    ! I checked that below exactly reproduced the UW.
!      qut = ( qub - ( b * pb + c ) / a + ( b / a / a ) ) * exp( a * dp ) + ( b * pt + c ) / a - ( b / a / a ) 
!   else   
!    ! Aug.18.2010. Below original form is wrong. Thus, I am using the
!    ! UW Taylor extended form.
!    ! Jul.12.2011. I may need to correct below Taylor-expansion formula using both 'q_b' and 'q_t'
!    !              similar to the modification in progup_wu2. 
!    ! qut = qub - dp * ( 0.5_r8 * b * ( pt + pb ) + c )  ! Original, Wrong. 
!      qut = qub + dp * a * ( qub - qb )                  ! New = UW. Correct.
!   endif

! ! Below is from UW shallow convection
! ! Produced similar result as above.
! ! On Jul.21.2010., change to the UW formula for consistency with
! ! the description paper. Also change 1.e-4 to 1.e-3 for Taylor expansion.   
 
! ! if( eps*dp .gt. 1.e-3_r8 ) then
! !     qut = ( qmid + gamq / eps - gamq * dp / 2._r8 ) - &
! !           ( qmid + gamq * dp / 2._r8 - qub + gamq / eps ) * exp( -eps * dp )
! ! else
! !     qut = qub + ( qmid + gamq * dp / 2._r8 - qub ) * eps * dp
! ! endif

!   return
! end subroutine progup_thlqt


  subroutine progup_thlqt(eps_mix,eps_dia,qsrcg,pb,pt,qmid,gamq,qub,qut)
  ! -------------------------------------------------------------------------------------------------------------------------- !
  ! Compute cumulus updraft properties at the top interface for 'thl,qt'                                                       !
  ! for individual updraft plume. This subroutine is directly from the                                                         !
  ! progupeff_thlqt but edge computation is removed for multiple plume                                                         !
  ! approach.                                                                                                                  !
  !                                                                                                                            !
  !  (1) qsrcg = ['q'/Pa]                                                                                                      !
  !                                                                                                                            !
  !      Both in case that 'q' decreases as   updraft rises (i.e., precipitation production  process with q = ql, qi)          ! 
  !      and 'q' increases as downdraft sinks (i.e., precipitation evaporation process with q = qv),                           !
  !      the specified 'qsrcg' should be positive.                                                                             !
  !      That is, we should specify 'qsrcg' in pressure-coordinate system by considering dp = -dz.                             !
  !                                                                                                                            !
  !  (2) eps_mix, eps_dia = [1/Pa]                                                                                             !
  !                                                                                                                            !
  !      Here, 'eps_mix' is an inverse of damping length scale by 'entrainment mixing' while                                   !
  !      the 'eps_dia' is an inverse of damping length scale by 'diabatic forcing'                                             ! 
  !      ('eps_dia = +  cat * max( (qc_cu - qcrit) / qc_cu, 0._r8 ) [1/Pa]' which is auto-conversion efficiency for updraft or ! 
  !      ('eps_dia = - (kevp / (rho*g*wd)) * sqrt( Fp / ap ) / qsd' [1/Pa]' which is evaporation efficiency for downdraft ).   !
  !      Be careful that for convective updraft, both the specified 'eps_mix, eps_dia > 0' while                               !
  !      for downdraft process, both 'eps_mix, eps_dia < 0' as is shown in the calling routine in the main body.               !
  !                                                                                                                            !
  ! Done.                                                                                                                      !                                         
  ! -------------------------------------------------------------------------------------------------------------------------- ! 
    implicit none
    real(r8), intent(in)                     :: eps_mix, eps_dia, qsrcg
    real(r8), intent(in)                     :: pb, pt
    real(r8), intent(in)                     :: qub
    real(r8), intent(in)                     :: qmid, gamq
    real(r8), intent(out)                    :: qut
    real(r8)  eps, qb, a, b, c, fp, dp

  ! Environmental conservative scalar at the base interface 

    dp = pb - pt
    qb = qmid + 0.5_r8 * dp * gamq 

  ! Ensemble-mean updraft value at the top interface
  ! Aug.18.2010. I chekced that below 'qut' exactly reproduce the UW 
  ! in a raw form, but not the Taylor-extended form. I verified that
  ! my Taylor extended form is wrong but the UW has the correct 
  ! Taylor-expanded form. Thus, I am using the UW-Taylor extended form.
  ! As a result, my nelow formula produced the exactly same results as UW in
  ! all cases.

    eps =   eps_mix + eps_dia
    a   = - eps    
    b   = - eps * gamq
    c   = - eps * ( qb - gamq * pb )

    if(abs(a*dp).gt.1.e-3_r8) then
     ! I checked that below exactly reproduced the UW.
!prp   qut = ( qub - ( b * pb + c ) / a + ( b / a / a ) ) * exp( a * dp ) + ( b * pt + c ) / a - ( b / a / a ) 
       fp  = 1._r8 - eps_dia / eps
       qut = ( qub - ( ( b * pb + c ) / a - ( b / a / a ) ) * fp - qsrcg / a ) * exp( a * dp ) + &
             ( ( b * pt + c ) / a - ( b / a / a ) ) * fp + qsrcg / a
    else   
     ! Aug.18.2010. Below original form is wrong. Thus, I am using the
     ! UW Taylor extended form.
     ! Jul.12.2011. I may need to correct below Taylor-expansion formula using both 'q_b' and 'q_t'
     !              similar to the modification in progup_wu2. 
     ! Apr.18.2012. I realized that 'dp * a * ( qub - qb )' produces results non-trivially different from
     !              the 'dp * ( a * ( qub - qb ) )'. This was the reason why '057a' produces different
     !              results from '057' in bluefire. 
     !              To be consistent with the treatment in progup_uv, I should use the UW.Correct.1.
     !              But in order to reproduce the '056' simulation, let's use UW.Correct.2. for the
     !              time being.  This should be carefully chosen in future to be consistent with the
     !              progup_uv.
     !              I checked that below UW.Correct.2. exactly reproduces '056'.
     ! qut = qub - dp * ( 0.5_r8 * b * ( pt + pb ) + c )            ! Original, Wrong. 
!prp   qut = qub + dp * ( a * ( qub - qb ) - qsrcg )                ! New = UW. Correct.1.
       qut = qub + dp * ( a * ( qub - qb ) - qsrcg - eps_dia * qb ) ! New = UW. Correct.1.
     ! qut = qub + dp *   a * ( qub - qb ) - dp * qsrcg             ! New = UW. Correct.2.
    endif

  ! Below is from UW shallow convection
  ! Produced similar result as above.
  ! On Jul.21.2010., change to the UW formula for consistency with
  ! the description paper. Also change 1.e-4 to 1.e-3 for Taylor expansion.   
 
  ! if( eps*dp .gt. 1.e-3_r8 ) then
  !     qut = ( qmid + gamq / eps - gamq * dp / 2._r8 ) - &
  !           ( qmid + gamq * dp / 2._r8 - qub + gamq / eps ) * exp( -eps * dp )
  ! else
  !     qut = qub + ( qmid + gamq * dp / 2._r8 - qub ) * eps * dp
  ! endif

    return
  end subroutine progup_thlqt


  subroutine progup_uv(eps,PGFuv,pb,pt,qmid,gamq,gamqPGF,qub,qut)
  ! ---------------------------------------------------------------------- !
  ! Compute cumulus updraft properties at the top interface for 'u,v'      !
  ! for individual updraft plume. This subroutine is directly from the     !
  ! progupeff_thlqt but edge computation is removed for multiple plume     !
  ! approach.                                                              !
  ! This is same as 'progupeff_thlqt_single' except that coef. c is        !
  ! re-defined by including PGFc effect.                                   !
  ! Done.                                                                  !
  ! ---------------------------------------------------------------------- ! 
    implicit none
    real(r8), intent(in)                     :: eps, PGFuv
    real(r8), intent(in)                     :: pb, pt
    real(r8), intent(in)                     :: qub
    real(r8), intent(in)                     :: qmid, gamq, gamqPGF 
    real(r8), intent(out)                    :: qut
    real(r8)  qb, a, b, c, dp

  ! Environmental conservative scalar at the base interface 
  ! Aug.18.2010. I checked that below 'qut' exactly reproduce the UW 
  ! in a raw form, but not the Taylor-extended form. I verified that
  ! my Taylor extended form is wrong but the UW has the correct 
  ! Taylor-expanded form. Thus, I am using the UW-Taylor extended form.
  ! As a result, my nelow formula produced the exactly same results as UW in
  ! all cases.

  ! Apr.5.2011. The 'gamq' multiplied to 'PGFuv' may need to be the one 
  ! using the inter-layer slope, not the within the layer slope. Thus,
  ! I am using gamqPGF for PGFc effect.

    dp = pb - pt
    qb = qmid + 0.5_r8 * dp * gamq 

  ! Ensemble-mean updraft value at the top interface

    a = - eps  
    b = - eps * gamq
    c = - eps * ( qb - gamq * pb ) + PGFuv * gamqPGF

    if( abs( a * dp ) .gt. 1.e-3_r8 ) then
        qut = ( qub - ( b * pb + c ) / a + ( b / a / a ) ) * exp( a * dp ) + ( b * pt + c ) / a - ( b / a / a ) 
    else   
      ! Aug.18.2010. Below original form is wrong. Thus, I am using the
      ! UW Taylor extended form.
      ! Apr.18.2012. For consistency with progup_thlqt, I use UW.Correct.2. below.
      !              The diffrence between UW.Correct.1. and UW.Correct.2. is from numerical truncation error.
      ! qut = qub - dp * ( 0.5_r8 * b * ( pt + pb ) + c )          ! Original, Wrong.
        qut = qub + dp * ( a * ( qub - qb ) - PGFuv * gamqPGF )    ! New = UW. Correct.1.
      ! qut = qub + dp *   a * ( qub - qb ) - dp * gamqPGF * PGFuv ! New = UW. Correct.2.
    endif

  ! Below is from UW shallow convection
  ! Produced similar result as above.
  ! On Jul.21.2010., change to the UW formula for consistency with
  ! the description paper. Also change 1.e-4 to 1.e-3 for Taylor expansion.   
    
  ! if( eps * dp .gt. 1.e-3_r8 ) then
  !     qut = ( qmid + ( 1._r8 - PGFuv ) * gamq / eps - gamq * dp / 2._r8 ) - &
  !           ( qmid + gamq * dp / 2._r8 - qub + ( 1._r8 - PGFuv ) * gamq / eps ) * exp( -eps * dp )
  ! else
  !     qut = qub + ( qmid + gamq * dp / 2._r8 - qub ) * eps * dp - PGFuv * gamq * dp
  ! endif

    return
  end subroutine progup_uv


  subroutine progup_wu2(eps,rho,pb,pt,bogbot,bogtop,wwub,wwe,wwut)
  ! ----------------------------------------------------------------- !
  ! Compute squared ensemble-mean cumulus updraft vertical at the top ! 
  ! interface. Note that 'bogbot,bogtop' ( which are non-dimensional  !
  ! variables ) already contains buoyancy coefficient, rbuoy in it.   ! 
  ! Eqn: dw2/dp + a*w2 = c                                            !
  ! Note that even the case of 'wwub=0.' is reasonably treated within !
  ! this subroutine.                                                  ! 
  ! Note that following 'compute_dp' should be chosen in a consistent !
  ! way as the one in this subroutine.                                !
  ! Mar.11.2013. Add 'wwe [m2/s2]' which is the square of vertical    !
  !              velocity of mixing environmental airs that is        !
  !              assumed to be a height-independent constant in the   !
  !              layer considered.                                    !   
  ! worg, bogbot, bogtop : Have no unit.                              !
  ! Done.                                                             !
  ! ----------------------------------------------------------------- !
    implicit none
    real(r8), intent(in)                     :: eps, rho
    real(r8), intent(in)                     :: pb, pt 
    real(r8), intent(in)                     :: bogbot, bogtop
    real(r8), intent(in)                     :: wwub
    real(r8), intent(in)                     :: wwe
    real(r8), intent(out)                    :: wwut
    real(r8)  a, b, c
    real(r8)  dp, delbog, drage, expfac, gammaB, worg

  ! Coefficients

    dp = pb - pt
    a  = - 2._r8 * eps  
    c  = - ( bogbot + bogtop ) / rho
    worg = rho * eps * wwe

  ! Option 1. Ensemble-mean updraft value at the top interface without
  ! considering buoyancy slope in each layer.
  ! For consistency with compute_dp, good to use this. 
  ! Aug.18.2010. I chekced that below 'qut' exactly reproduce the UW 
  ! if 'bogbot = bogtop' in the UW form.

  ! if( abs( a * dp ) .gt. 1.e-3_r8 ) then
  !    wwut = ( wwub - c / a ) * exp( a * dp ) + c / a 
  ! else   
  !  ! Aug.18.2010. Below original form is wrong. Thus, I am using the
  !  ! correct UW Taylor extended form.
  !  ! wwut = wwub - c * dp                                ! Original Wrong
  !    wwut = wwub * ( 1._r8 - 2._r8 * eps * dp ) - c * dp ! New Correct.
  ! endif

  ! Option 2. Ensemble-mean updraft value at the top interface
  !           with consideration of buoyancy slope in each layer.
  !           Below is the most perfect formula I should use.
  !           My below formula produced the exactly same results as UW in
  !           all cases.
  ! Jul.9.2011. Below is not correct for downdraft momentum equation.
  !             I should correct this. Probably, I should correct ( add (-) sign )
  !             to the input argument of bogbot and bogtop.
  ! Jul.10.2011. I modified below Taylor expansion formula by using 'eps .gt. 1.e-5' and
  !              by changing 'bogbot' to '0.5_r8 * ( bogbot + bogtop )' for full consistency.
  ! Below is old before Jul.10.2011.
  ! if( eps * dp .gt. 1.e-3_r8 ) then
  !     expfac = exp( -2._r8 * eps * dp )
  !     gammaB = ( bogtop - bogbot ) / dp
  !     wwut = wwub * expfac + ( gammaB * dp + (1._r8-expfac)*(bogbot + gammaB/(-2._r8*eps)) )/(rho*eps)
  !  else
  !     wwut = wwub * ( 1._r8 - 2._r8 * eps * dp ) + 2._r8 * bogbot * dp / rho 
  ! endif
  ! Below is new after Jul.10.2011.
  ! Mar.11.2013. Add 'worg' only in the below block of formula.
  !              Thus, I should only use below block. 

    if( abs(dp) .lt. 1.e-10_r8 ) then
        wwut = wwub
    else
        if( abs(eps) .gt. 1.e-6_r8 ) then
            expfac = exp( -2._r8 * eps * dp )
            gammaB = ( bogtop - bogbot ) / dp
            wwut = wwub * expfac + ( gammaB * dp + (1._r8-expfac)*(bogbot + gammaB/(-2._r8*eps) + worg) )/(rho*eps)
        else
            wwut = wwub * ( 1._r8 - 2._r8 * eps * dp ) + ( bogbot + bogtop + 2._r8 * worg ) * dp / rho 
        endif
    endif

  ! Below is from UW shallow convection
  ! Produced similar result as above.
  ! On Jul.21.2010., change to the UW formula for consistency with the description paper.
  ! However, Taylor-expanded formula is correctly revised.   

  ! delbog = bogtop - bogbot
  ! expfac = exp( -2._r8 * eps * dp )
  ! if( eps * dp .gt. 1.e-3_r8 ) then
  !     wwut = wwub * expfac + ( delbog + (1._r8-expfac)*(bogbot + delbog/(-2._r8*eps*dp)))/(rho*eps)
  ! else
  !   ! Below is original Taylor formula.
  !   ! wwut = wwub + dp * ( bogbot + bogtop ) / rho
  !   ! Below is corrected Taylor formula on Jul.21.2010.
  !     wwut = wwub * ( 1._r8 - 2._r8 * eps * dp ) + 2._r8 * bogbot * dp / rho 
  ! endif

    return
  end subroutine progup_wu2



  real(r8) function compute_dp(eps,rho,pb,pt,bogbot,bogtop,wwub,wwe)
  ! ---------------------------------------------------------------------- !
  ! Compute vertical distance that convective updraft with non-zero        ! 
  ! entrainment can move.                                                  !
  ! For simplicity, use the height-independent average buoyancy.           !
  ! Note 'compute_dp = [Pa] > 0'. eps = [1/Pa]. bogbot,bgtop = [ no unit ] !
  ! Note that above 'progup_wu2' should be chosen in a consistent way      !
  ! as the one in this subroutine.                                         !
  ! Mar.11.2013. Add 'wwe [m2/s2]' which is the square of vertical         !
  !              velocity of mixing environmental airs that is             !
  !              assumed to be a height-independent constant in the        !
  !              layer considered.                                         !   
  ! worg, bogbot, bogtop : Have no unit.                                   !
  ! Done.                                                                  !
  ! ---------------------------------------------------------------------- !
    implicit none
    real(r8), intent(in)                     :: eps, rho
    real(r8), intent(in)                     :: pb, pt 
    real(r8), intent(in)                     :: bogbot, bogtop
    real(r8), intent(in)                     :: wwub
    real(r8), intent(in)                     :: wwe
    real(r8)  a, c, dp, dpen, gammaB, worg
    real(r8)  x0, x1, f, fs, s00
    integer   iteration

    a = 2._r8 * eps  
    c = ( bogbot + bogtop ) / rho
    dpen = pb - pt
    gammaB = ( bogtop - bogbot ) / dpen
    worg = rho * eps * wwe

  ! Option 1. Without considering buoyancy slope in each layer.  

  ! if( c .ge. 0._r8 ) then
  !     dp = dpen 
  ! else
  !     if( a .lt. 1.e-12_r8 ) then
  !         dp = - wwub / c
  !     else
  !         dp = - ( 1._r8 / a ) * log( c / ( c - a * wwub ) )
  !     endif
  ! endif 

  ! Option 2. With considering buoyancy slope in each layer.  
  !           Below is from the UW code.
  !           Below is the most perfect choice.

  ! Jul.10.2011. Rigorously speaking, below Taylor expansion should also be modified following
  !              the same day's modification in progup_wu2 above, using 'eps' not the 
  !              product of 'eps * dpen', although this modification is likely to have
  !              a very minor effect. 
  ! Mar.11.2013. Add 'worg' in the below block. However, I have not added 'worg' in the
  !              Taylor-expended block, which should be done in future. 
  !              Probably, I should redefine s00 = ( bogbot + worg ) / rho - eps * wwub.
  !              Since this seems to be quite straightforwatd, I also modified this Taylor block. 

  ! s00 = bogbot / rho - eps * wwub
    s00 = ( bogbot + worg ) / rho - eps * wwub
    if( eps * dpen .le. 1.e-8_r8 ) then
        if( s00 .ge. 0._r8 ) then
            x0 = dpen
        else
            x0 = max( 0._r8, min( dpen , -0.5_r8 * wwub / s00 ) )
        endif
    else
        if( s00 .ge. 0._r8 ) then
            x0 = dpen
        else
            x0 = 0._r8
        endif
        do iteration = 1, 5
           f  = exp(-2._r8*eps*x0)*(wwub-(bogbot-gammaB/(2._r8*eps)+worg)/(eps*rho)) + &
                                   (gammaB*x0+bogbot-gammaB/(2._r8*eps)+worg)/(eps*rho)
           fs = -2._r8*eps*exp(-2._r8*eps*x0)*(wwub-(bogbot-gammaB/(2._r8*eps)+worg)/(eps*rho)) + &
                                   (gammaB)/(eps*rho)
         ! Sep.28.2010. Very rarely, fs = 0 happens. So, I added below fixer.
           if( fs .ge. 0._r8 ) fs = max(fs, nonzero)
           if( fs .lt. 0._r8 ) fs = min(fs,-nonzero)
           x1 = x0 - f/fs
           x0 = x1
           x0 = min( dpen, max( 0._r8, x0 ) )
      end do
    endif
    dp = x0

    compute_dp = min( dpen, max( 0._r8, dp ) )
    return

  end function compute_dp


                            
  real(r8) function compute_dp_zeroeps(rho,pb,pt,bogbot,bogtop,wwub)
  ! ---------------------------------------------------------------------- !
  ! Compute vertical distance that convective updraft with zero            ! 
  ! entrainment can move.                                                  !
  ! This subroutine only valid when 'bogbot < 0', 'wwub > 0', and we       ! 
  ! already know that one single solution is guaranteedly exists.          !
  ! Note 'compute_dp = [Pa] > 0'. eps = [1/Pa]. bogbot,bgtop = [ no unit ] !
  ! Done.                                                                  !
  ! ---------------------------------------------------------------------- !
    implicit none
    real(r8), intent(in)                     :: rho
    real(r8), intent(in)                     :: pb, pt 
    real(r8), intent(in)                     :: bogbot, bogtop
    real(r8), intent(in)                     :: wwub
    real(r8)  a, b, c, det, dp, dpen

    dpen = pb - pt
    a = ( bogtop - bogbot ) / dpen / rho
    b = 2._r8 * bogbot / rho 
    c = wwub

    det = b**2._r8 - 4._r8 * a * c
    if( det .lt. -1.e-12_r8 ) then
        write(6,*)
        write(6,*) 'UNICON: det is negative smaller than -1.e-12 and set to be zero'
        write(6,*) 'det = b**2 - 4*a*c  = ', det
        write(6,*) 
    endif
    det = max( 0._r8, det )

    if( a .eq. 0._r8 ) then
        dp = - c / b
    else
        dp = ( - b - sqrt( det ) ) / ( 2._r8 * a )
    endif

    compute_dp_zeroeps = min( dpen , max( 0._r8, dp ) )
    return

  end function compute_dp_zeroeps


  subroutine getbuoy(pbot,thv0bot,ptop,thv0top,thvubot,thvutop,rho,plfc,cin)
  ! ----------------------------------------------------------- !
  ! Subroutine to calculate integrated CIN [ J/kg = m2/s2 ] and !
  ! 'cinlcl, plfc' if any. Assume 'thv' is linear in each layer !
  ! both for cumulus and environment. Note that this subroutine !
  ! only include positive CIN in calculation - if there are any !
  ! negative CIN, it is assumed to be zero.    This is slightly !
  ! different from 'single_cin' below, where both positive  and !
  ! negative CIN are included.                                  !
  ! ----------------------------------------------------------- !
    real(r8) pbot,thv0bot,ptop,thv0top,thvubot,thvutop,rho,plfc,cin,frc

    if( thvubot .gt. thv0bot .and. thvutop .gt. thv0top ) then
        plfc = pbot
        return
    elseif( thvubot .le. thv0bot .and. thvutop .le. thv0top ) then
        cin  = cin - ( (thvubot/thv0bot - 1._r8) + (thvutop/thv0top - 1._r8)) * (pbot - ptop) /        &
                     ( 2._r8 * rho )
    elseif( thvubot .gt. thv0bot .and. thvutop .le. thv0top ) then
        frc  = ( thvutop/thv0top - 1._r8 ) / ( (thvutop/thv0top - 1._r8) - (thvubot/thv0bot - 1._r8) )
        cin  = cin - ( thvutop/thv0top - 1._r8 ) * ( (ptop + frc*(pbot - ptop)) - ptop ) /             &
                     ( 2._r8 * rho )
    else
        frc  = ( thvubot/thv0bot - 1._r8 ) / ( (thvubot/thv0bot - 1._r8) - (thvutop/thv0top - 1._r8) )
        plfc = pbot - frc * ( pbot - ptop )
        cin  = cin - ( thvubot/thv0bot - 1._r8)*(pbot - plfc)/                                         &
                     ( 2._r8 * rho )
    endif

    return
  end subroutine getbuoy


  subroutine buosort_downdraft( cuL, cuU, enL, xdown_min, xdown_max )
  ! -------------------------------------------------------------- !
  ! Perform buoyancy sorting of downdrafts and find the ranges of  ! 
  ! mixing fraction, (xdown_min, xdown_max), where mixtures within !
  ! this range will move down into the base interface.             !
  ! It must be and is that x = 0 is corresponding to cuL, while    !
  !                        x = 1 is corresponding to cuU.          !
  ! Done.                                                          !
  ! -------------------------------------------------------------- !
    implicit none
    real(r8), intent(in)   :: cuL, cuU, enL 
    real(r8), intent(out)  :: xdown_min, xdown_max
    real(r8)  x

    if( cuU.gt.cuL ) then
        xdown_min = 0._r8
        xdown_max = min(1._r8,max(0._r8,(enL-cuL)/(cuU-cuL)))
        return
    elseif( cuU.lt.cuL ) then
        xdown_min = min(1._r8,max(0._r8,(enL-cuL)/(cuU-cuL)))
        xdown_max = 1._r8
        return
    elseif( cuU.eq.cuL ) then
        if( cuU.lt.enL ) then
            xdown_min = 0._r8
            xdown_max = 1._r8
            return
        elseif( cuU.gt.enL ) then
            xdown_min = 0._r8
            xdown_max = 0._r8
            return
        else
          ! Below can be any values between 0 <= x <= 1
          ! Apr.21.2011. xdown_min is changed to 0 instead of 0.5 as described in the text.
          ! xdown_min = 0.5_r8
            xdown_min = 0.0_r8
            xdown_max = 0.5_r8
            return
        endif
        return
    endif

    return
  end subroutine buosort_downdraft



  subroutine compute_PDF( PDFtype, zLL, zUU, zbar, zmass, zmass_L )
  ! ---------------------------------------------------------------------------------------- !
  ! Compute mass-flux weighted (or equally, probability weighted) mean z                     !
  ! (zbar) and corrresponding mass fraction (zmass) within a given single                    !
  ! interval between (zL,zU).                                                                !
  ! The PDFtype is as follows:                                                               ! 
  !    'PDFupG' : Updraft PDF with Gamma distribution   ( 0 < z = alpha < alpha_max = 3 )    !
  !    'PDFupW' : Updraft PDF with Weibull distri.      ( 0 < z = alpha < alpha_max = 3 )    !
  !    'PDFdnU' : Downdraft PDF with Uniform distri.    ( 0 < z = alpha < 2 )                !     
  !    'PDFdnT' : Downdraft PDF with Triangular distri. ( 0 < z = alpha < 2 )                ! 
  !    'PDFbsU' : Microscopic buoyancy sorting PDF with Uniform distri.    ( 0 < z = x < 1 ) !
  !    'PDFbsT' : Microscopic buoyancy sorting PDF with Triangular distri. ( 0 < z = x < 1 ) !
  !    'PDFbsQ' : Microscopic buoyancy sorting PDF with Quadratic distri.  ( 0 < z = x < 1 ) !
  !    'PDFbsN' : Microscopic buoyancy sorting PDF with p=0.5 in symmetric beta distri.      !
  !               ( 0 < z = x < 1 )                                                          !
  ! Note that                                                                                ! 
  !     x = 0 : cumulus core,                                                                !
  !     x = 1 : environmental mean                                                           !
  !     alpha = 0 : cumulus edge toward environment                                          !
  !     alpha = 2 or 3 : cumulus core-edge away from the environment                         !
  ! As the most general application, I should use the following                              !
  ! symmetric beta distribution for microscopic buoyancy sorting                             !
  !        P(x) = (x*(1-x))**(p-1) / B(p,p)   , p > 0, 0 <= x <= 1                           !          
  !        B(p,p) = Gamma(p)*Gamma(p)/Gamma(2*p)                                             !
  !        B(0.1,0.1) = 19.7146, B(0.5,0.5) = 3.1416                                         !
  !        B(1,1) = 1, B(2,2) = 1/6                                                          !
  ! This shows how much time the system has for mixing for a given                           !
  ! model time step dt. If 'p' increases, it means that the system has                       !
  ! more time for buoyancy sorting mixing. This 'p' can parameterized                        !  
  ! as a function of timeres/dt.                                                             !
  ! Nov.04.2014.                                                                             !
  ! Currently, only 'PDFbsU' and 'PDFbsQ' computes 'zmass_L'. So, only choose these two      !
  ! options. Computation of 'zmass_L' for the other cases should be done later.              !            
  ! Done.                                                                                    !
  ! ---------------------------------------------------------------------------------------- !
    implicit none
    character(len=6), intent(in)   :: PDFtype 
    real(r8),  intent(in)   :: zLL, zUU
    real(r8),  intent(out)  :: zbar, zmass, zmass_L
    real(r8)   zmin, zmax, gma, Pn, zL, zU

  ! Take such that zU is always equal or larger than zL.

    zL = min(zLL,zUU) 
    zU = max(zLL,zUU) 
  
  ! Main computation.
  ! 'zmass' is fractional area (mass) surrounded by [zL,zU]
  ! 'zbar'  is PDF-weighted mean z in [zL,zU]
  ! 'zmass_L' is fractional mass of the convective updraft (on the zL side) 

    select case (PDFtype)
    case ('PDFupG')
           zmin = 0._r8
           zmax = alpha_max
           gma  = 2._r8
           Pn   = 1._r8 - exp(-2._r8*zmax)*(1._r8+2._r8*zmax)
         ! Currently, below analytical formula is obtained only when gma = 2._r8
           zmass = (exp(-2._r8*zL)*(1._r8+2._r8*zL)-exp(-2._r8*zU)*(1._r8+2._r8*zU))/Pn
           if( abs(zL-zU) .le. 1.e-10 ) then
               zbar = zL
               zmass = 0._r8
               return
           else
               zbar = exp(-2._r8*zL)*(zL**2+zL+0.5_r8)-exp(-2._r8*zU)*(zU**2+zU+0.5_r8)
               zbar = 2._r8*zbar/Pn/zmass
               return
           endif
    case ('PDFdnU')
           zmin = 0._r8
           zmax = 2._r8
           zmass = 0.5_r8*(zU-zL)
           zbar  = 0.5_r8*(zU+zL)
           return
    case ('PDFbsU')
           zmin = 0._r8
           zmax = 1._r8
           zmass = 1.0_r8*(zU-zL)
           zbar  = 0.5_r8*(zU+zL)
           zmass_L = zU-0.5_r8*zU**2-(zL-0.5_r8*zL**2)
           return
    case ('PDFbsQ')
           zmin = 0._r8
           zmax = 1._r8
           zmass = (3._r8*zU**2-2._r8*zU**3)-(3._r8*zL**2-2._r8*zL**3)
           if( zmass .gt. 0._r8 ) then
               zbar = 0.5_r8*((4._r8*zU**3-3._r8*zU**4)-(4._r8*zL**3-3._r8*zL**4))/zmass
           else
               zbar = 0.5*(zL+zU)
           endif
           zmass_L = 3._r8*zU**2-4._r8*zU**3+1.5_r8*zU**4-(3._r8*zL**2-4._r8*zL**3+1.5_r8*zL**4)
           return
    case ('PDFbsN')
           zmin = 0._r8
           zmax = 1._r8
           zmass = 0.3183_r8*( asin(2._r8*zU-1._r8) - asin(2._r8*zL-1._r8) )
           if( zL .eq. 0._r8 .and. zU .eq. 1._r8 ) zmass = 1._r8
           zmass = max(0._r8,min(1._r8,zmass)) 
           if( zmass .gt. 0._r8 ) then
               zbar = ( 0.5_r8*asin(2._r8*zU-1._r8) - sqrt(zU*(1._r8-zU)) - 0.5_r8*asin(2._r8*zL-1._r8) + sqrt(zL*(1._r8-zL)) ) / &
                      ( asin(2._r8*zU-1._r8) - asin(2._r8*zL-1._r8) )
           else
               zbar = 0.5*(zL+zU)
           endif
           return

    end select

    return
  end subroutine compute_PDF



  subroutine compute_epsdelnod( PDFtype, xc, epsnod, delnod )
  ! ------------------------------------------------------------------ !
  ! Compute non-dimensional fraction entrainment and detrainment rate  !
  ! for a given 'xc' and normalized symmetric PDF(x) within 0 < x < 1. !
  ! This is for microscopic buoyancy sorting.                          ! 
  ! The PDFtype is as follows:                                         !
  !  'PDFbsU' : PDF with Uniform    distri. ( 0 < x < 1 )              !
  !  'PDFbsT' : PDF with Triangular distri. ( 0 < x < 1 )              !
  !  'PDFbsQ' : PDF with Quadratic  distri. ( 0 < x < 1 )              !
  !  'PDFbsN' : PDF with p=0.5 in symmetric beta distri. ( 0 < x < 1 ) !
  ! Note that                                                          ! 
  !     x = 0 : cumulus core,                                          !
  !     x = 1 : environmental mean                                     !
  ! In order to avoid infinite area at x = 1, either triangular or     !
  ! quadratic distribution is better than the uniform distribution.    !
  ! As the most general application, I should use the following        !
  ! symmetric beta distribution:                                       !
  !        P(x) = (x*(1-x))**(p-1) / B(p,p)   , p > 0, 0 <= x <= 1     !          
  !        B(p,p) = Gamma(p)*Gamma(p)/Gamma(2*p)                       !
  !        B(0.1,0.1) = 19.7146, B(0.5,0.5) = 3.1416                   !
  !        B(1,1) = 1, B(2,2) = 1/6                                    !
  ! This shows how much time the system has for mixing for a given     !
  ! model time step dt. If 'p' increases, it means that the system has !
  ! more time for buoyancy sorting mixing. This 'p' can parameterized  ! 
  ! as a function of timeres/dt.                                       !          
  ! Done.                                                              !
  ! ------------------------------------------------------------------ !
    implicit none
    character(len=6), intent(in)  :: PDFtype 
    real(r8), intent(in)   :: xc
    real(r8), intent(out)  :: epsnod, delnod
  
  ! Main computation.
  ! 'epsnod' is non-dimensional fractional entrainment rate
  ! 'delnod' is non-dimensional fractional detrainment rate

    select case (PDFtype)
    case ('PDFbsU')
           epsnod = xc**2
           delnod = (1._r8-xc)**2 
           return
    case ('PDFbsT')
           if( xc .le. 0.5_r8 ) then
               epsnod = (8._r8/3._r8)*xc**3 
               delnod =  1._r8-4._r8*xc**2+(8._r8/3._r8)*xc**3
               return
           else
               epsnod = -1._r8/3._r8 + 4._r8*xc**2-(8._r8/3._r8)*xc**3 
               delnod = (8._r8/3._r8)*(1._r8-xc)**3
               return
           endif
           return
    case ('PDFbsQ')
           epsnod = xc**3*(4._r8-3._r8*xc)
           delnod = (1._r8-6._r8*xc**2+8._r8*xc**3-3._r8*xc**4)
           return
    case ('PDFbsN')
           epsnod =         2._r8*0.3183_r8*(0.5_r8*asin(2._r8*xc-1._r8)-sqrt(xc*(1._r8-xc))-0.5_r8*asin(-1._r8)) 
           delnod = 1._r8 - 2._r8*0.3183_r8*(0.5_r8*asin(2._r8*xc-1._r8)+sqrt(xc*(1._r8-xc))-0.5_r8*asin(-1._r8))
           if( xc .eq. 0._r8 ) then
               epsnod = 0._r8
               delnod = 1._r8
           elseif( xc .eq. 1._r8 ) then                                            
               epsnod = 1._r8
               delnod = 0._r8
           endif
           epsnod = max(0._r8,min(1._r8,epsnod))
           delnod = max(0._r8,min(1._r8,delnod)) 
           return
    end select

    return
  end subroutine compute_epsdelnod



  subroutine buosorts_UW(rbuoy,p,w_cu,thl_cu,qt_cu,w_eg,thl_eg,qt_eg,&
                         thv_en,cridis,xc,xs,thv_cu,thv_eg,thvxs)
  ! ---------------------------------------------------------------------- !
  ! Buoyancy Sorting Algorithm from UWShCu but can treat the case of       !
  ! different 'thv_eg' and 'thv_en' for handling organized non-uniform     ! 
  ! environmental airs being entrained.                                    !
  ! This codes assumes that gamv_en = gamv_cu = 0                          !
  ! Except this, this code is quite general and correct for any 'cridis',  !
  ! and computationally efficient. So, I should use this code in my GCM.   !
  ! For microscopic buoyancy sorting,                                      !
  !     x = 0 : cumulsu ensemble-mean                                      !
  !     x = 1 : non-uniform environmental value                            !
  ! Done.                                                                  !
  ! May.03.2011. In order to save computation time, I changed the variable !
  !              names: thvxsat -> thvxs, thlxsat -> thlxs, qtxsat -> qtxs !
  !              xsat -> xs which does not change the answer.              !
  ! Mar.11.2013. I added 'w_eg' to treat the effect of organized flow      !
  !              within PBL.                                               !
  ! ---------------------------------------------------------------------- ! 
    implicit none
    real(r8), intent(in)          :: rbuoy    
    real(r8), intent(in)          :: w_cu, w_eg
    real(r8), intent(in)          :: thl_cu, thl_eg
    real(r8), intent(in)          :: qt_cu, qt_eg
    real(r8), intent(in)          :: cridis
    real(r8), intent(in)          :: p, thv_en
    real(r8), intent(out)         :: xc, xs, thv_cu, thv_eg, thvxs
!icereal(r8), optional, intent(in) :: frac_ice            
    integer   id_check, status, kk
    real(r8)  thlxs, qtxs, x_cu, x_en, thv_x0, thv_x1
    real(r8)  th, qv, ql, qi, qse
    real(r8)  aquad, bquad, cquad, xc1, xc2, excess_cu, excess_eg, xs1, xs2
    real(r8)  es
    real(r8)  qs
    real(r8)  qsat_arg
    real(r8)  exn

    ! ---------------------------------------------------------------- !
    ! Calculate environmental and cumulus saturation.                  !
    ! Note that in order to calculate saturation excess, we should use !
    ! liquid water temperature instead of temperature  as the argument !
    ! of "qsat". But note normal argument of "qsat" is temperature.    !
    ! ---------------------------------------------------------------- !

    exn        = (p/p00)**rovcp
    call conden(p,thl_eg,qt_eg,th,qv,ql,qi,qse,id_check)
    thv_eg     = th * ( 1._r8 + zvir*qv - ql - qi )
    qsat_arg   = thl_eg*exn
    call qsat(qsat_arg, p, es, qs)
    excess_eg  = qt_eg - qs

!icecall conden(p,thl_cu,qt_cu,th,qv,ql,qi,qse,id_check,frac_ice=frac_ice)
    call conden(p,thl_cu,qt_cu,th,qv,ql,qi,qse,id_check)
    thv_cu     = th * ( 1._r8 + zvir * qv - ql - qi )
    qsat_arg   = thl_cu*exn
    call qsat(qsat_arg, p, es, qs)
    excess_cu  = qt_cu - qs

    if( (excess_cu*excess_eg).lt.0._r8 ) then
      ! May.03.2011. Regardless of the relative magnitude of 'excess_cu,excess_eg', it should be
      !              xs = excess_cu / ( excess_cu - excess_eg ). In the mother code, this 'xs'
      !              is also directly used to compute 'xe_min, xe_max'. So, below mistake can 
      !              influence actual model computation. I fixed this bug by commenting out
      !              4 lines in the below if block.  
      ! if( excess_cu .gt. excess_eg ) then 
            xs = excess_cu / ( excess_cu - excess_eg );
      ! else
      !     xs = excess_eg / ( excess_eg - excess_cu );
      ! endif
      ! May.03.2011. In order to be fully compatible with the mother routine that computes
      !              'xe_min, xe_max', I should set 'xs = 0' for all these cases. This also
      !              removes the distinuity when excess_cu=excess_eg=0. Thus, I removed
      !              below 5 lines and reset xs = 0.
  ! else
  !     xs = 0._r8
  ! endif
  ! Below block is old code before May.03.2011.  
  ! May.16.2011. I restored to the 'old code, since 'xs = 1._r8' is also fully compatible with the
  !              mother subroutine and correct even within this subroutine.
    elseif( excess_cu.le.0._r8 .and. excess_eg.le.0._r8 ) then
        xs = 0._r8
    elseif( excess_cu.ge.0._r8 .and. excess_eg.ge.0._r8 ) then
        xs = 1._r8
    endif

    ! ----------------------------------------------------------------- !
    ! Case 1 : When both cumulus and env. are unsaturated or saturated. !
    ! ----------------------------------------------------------------- !
  
    thvxs = thv_cu
    ! May.03.2011. In order to save computation time, I re-write below if line using the above newly computed 'xs',
    !              which should produce identical results. 
    if( xs .eq. 0._r8 .or. xs .eq. 1._r8 ) then
  ! if( ( excess_cu .le. 0._r8 .and. excess_eg .le. 0._r8 ) .or. ( excess_cu .ge. 0._r8 .and. excess_eg .ge. 0._r8 ) ) then
        ! Below is the original UW code assuming 'thv_eg=thv_en'
        ! xc = min(1._r8,max(0._r8,1._r8-2._r8*rbuoy*g*cridis/w_cu**2._r8*(1._r8-thv_cu/thv_en)))
        ! Below is the revised code considering the difference between 'thv_eg' and 'thv_en'
          thv_x0 = thv_cu;
          thv_x1 = thv_eg;
        ! aquad =  w_cu**2;
        ! bquad =  2._r8*rbuoy*g*cridis*(thv_x1 - thv_x0)/thv_en - 2._r8*w_cu**2;
          aquad =  (w_cu-w_eg)**2;
          bquad =  2._r8*rbuoy*g*cridis*(thv_x1 - thv_x0)/thv_en - 2._r8*w_cu*(w_cu-w_eg);
          cquad =  2._r8*rbuoy*g*cridis*(thv_x0 - thv_en)/thv_en +       w_cu**2;
          if( ( bquad**2-4._r8*aquad*cquad ) .ge. 0._r8 ) then
                call roots(aquad,bquad,cquad,xs1,xs2,status)
                xc = min(1._r8,max(0._r8,min(1._r8,min(xs1,xs2))))
          else
                xc = 1._r8;
          endif
    else
    ! -------------------------------------------------- !
    ! Case 2 : When either cumulus or env. is saturated. !
    ! -------------------------------------------------- !
      ! May.03.2011. I commented out below 'xs' since it is already computed above.
      !              This will save computation time.
      ! xs  = excess_cu / ( excess_cu - excess_eg );
        thlxs = thl_cu + xs * ( thl_eg - thl_cu );
        qtxs  = qt_cu  + xs * ( qt_eg - qt_cu );
        call conden(p,thlxs,qtxs,th,qv,ql,qi,qse,id_check)
        thvxs = th * ( 1._r8 + zvir * qv - ql - qi )
        ! -------------------------------------------------- !
        ! kk=1 : Cumulus Segment, kk=2 : Environment Segment !
        ! -------------------------------------------------- !
        do kk = 1, 2
             if( kk .eq. 1 ) then
                 thv_x0 = thv_cu;
                 thv_x1 = ( 1._r8 - 1._r8 / xs ) * thv_cu + ( 1._r8 / xs ) * thvxs;
             else
                 thv_x1 = thv_eg;
                 thv_x0 = ( xs / ( xs - 1._r8 ) ) * thv_eg + ( 1._r8/( 1._r8 - xs ) ) * thvxs;
             endif
           ! aquad =  w_cu**2._r8;
           ! bquad =  2._r8*rbuoy*g*cridis*(thv_x1 - thv_x0)/thv_en - 2._r8*w_cu**2._r8;
             aquad =  (w_cu-w_eg)**2._r8;
             bquad =  2._r8*rbuoy*g*cridis*(thv_x1 - thv_x0)/thv_en - 2._r8*w_cu*(w_cu-w_eg);
           ! Below is the original UW code assuming 'thv_eg=thv_en'
           ! cquad =  2._r8*rbuoy*g*cridis*(thv_x0 - thv_eg)/thv_en +       w_cu**2._r8;
           ! Below is the revised code considering the difference between 'thv_eg' and 'thv_en'
             cquad =  2._r8*rbuoy*g*cridis*(thv_x0 - thv_en)/thv_en +       w_cu**2._r8;
             if( kk .eq. 1 ) then
                 if( ( bquad**2._r8-4._r8*aquad*cquad ) .ge. 0._r8 ) then
                       call roots(aquad,bquad,cquad,xs1,xs2,status)
                       x_cu = min(1._r8,max(0._r8,min(xs,min(xs1,xs2))))
                 else
                       x_cu = xs;
                 endif
             else
                 if( ( bquad**2._r8-4._r8*aquad*cquad) .ge. 0._r8 ) then
                       call roots(aquad,bquad,cquad,xs1,xs2,status)
                       x_en = min(1._r8,max(0._r8,max(xs,min(xs1,xs2))))
                 else
                       x_en = 1._r8;
                 endif
             endif
        enddo
        if( x_cu .eq. xs ) then
            xc = max(x_cu, x_en);
        else
            xc = x_cu;
        endif
    endif

    return
  end subroutine buosorts_UW



  subroutine buosorts(rbuoy,p,w_cu,thl_cu,qt_cu,thl_eg,qt_eg,thv_en,gamv_en,gamv_cu,cridis,xc,xs)
  ! ------------------------------------------------------------------------ !
  ! Compute critical mixing fraction, xc ( parcels with '0 < x < xc' are     !
  ! entrained or non-detached, while 'xc < x < 1' are detrained or detached. !
  ! Also find saturation mixing fraction, xs.                                !
  ! For macroscopic buoyancy sorting,                                        !
  !     x = 0 : cumulus core ( alpha = 3 )                                   !
  !     x = 1 : cumulus edge value ( alpha = 0 )                             !
  ! For microscopic buoyancy sorting,                                        !
  !     x = 0 : cumulsu ensemble-mean ( alpha = 1 )                          !
  !     x = 1 : environmental value ( thv_env )                              !
  ! Done.                                                                    !
  ! This code is questionable when gamv_en is non-zero : xc = 0 or 1 always. !
  ! May.03.2011. Bug fix on this day may solve the 'questionable' issue.     !
  !              I should check this later.                                  !
  ! ------------------------------------------------------------------------ ! 
    implicit none
    real(r8), intent(in)          :: rbuoy
    real(r8), intent(in)          :: w_cu
    real(r8), intent(in)          :: thl_cu, thl_eg
    real(r8), intent(in)          :: qt_cu, qt_eg
    real(r8), intent(in)          :: gamv_en, gamv_cu, cridis
    real(r8), intent(in)          :: p, thv_en
    real(r8), intent(out)         :: xc, xs
    real(r8)  buof, gamd, exn, qsat_arg, xc_sat, xc_dry
    real(r8)  th_cu,qv_cu,ql_cu,qi_cu,qs_cu,thv_cu,rho_cu,excess_cu
    real(r8)  th_eg,qv_eg,ql_eg,qi_eg,qs_eg,thv_eg,rho_eg,excess_eg
    real(r8)  th_sa,qv_sa,ql_sa,qi_sa,qs_sa,thv_sa,thl_sa,qt_sa,w_sa
    real(r8)  x0, w0, thv0, x1, w1, thv1 
    real(r8)  esl, qsl
    integer   id_check

  ! Internally-defined variables

    buof = rbuoy*g/thv_en
    gamd = gamv_cu - gamv_en

  ! Compute saturation excesses of cumulus and edge (or env) values. 
  ! As the argument of 'qsat', we must use liquid water temperature
  ! instead of temperature, although normal argument is temperature. 
  ! Also compute mixing fraction of saturation point (xs) and 
  ! corresponding thermodynamic variables.

    exn       = (p/p00)**rovcp
    call conden(p,thl_cu,qt_cu,th_cu,qv_cu,ql_cu,qi_cu,qs_cu,id_check)
    thv_cu    = th_cu * ( 1._r8 + zvir*qv_cu - ql_cu - qi_cu )
    rho_cu    = p / ( r * thv_cu * exn )
    qsat_arg  = thl_cu*exn     
    call qsat(qsat_arg, p, esl, qsl)
    excess_cu = qt_cu - qsl

    call conden(p,thl_eg,qt_eg,th_eg,qv_eg,ql_eg,qi_eg,qs_eg,id_check)
    thv_eg    = th_eg * ( 1._r8 + zvir * qv_eg - ql_eg - qi_eg )
    qsat_arg  = thl_eg * exn
    call qsat(qsat_arg, p, esl, qsl)
    excess_eg = qt_eg - qsl

    if( (excess_cu*excess_eg).lt.0._r8 ) then
      ! May.03.2011. Regardless of the relative magnitude of 'excess_cu,excess_eg', it should be
      !              xs = excess_cu / ( excess_cu - excess_eg ). In the mother code, this 'xs'
      !              is also directly used to compute 'xe_min, xe_max'. So, below mistake can 
      !              influence actual model computation. I fixed this bug by commenting out
      !              4 lines in the below if block.  
      ! if( excess_cu .gt. excess_eg ) then 
           xs = excess_cu / ( excess_cu - excess_eg );
      ! else
      !    xs = excess_eg / ( excess_eg - excess_cu );
      ! endif
        thl_sa = thl_cu + xs * ( thl_eg - thl_cu );
        qt_sa  = qt_cu + xs * ( qt_eg - qt_cu );
        call conden(p,thl_sa,qt_sa,th_sa,qv_sa,ql_sa,qi_sa,qs_sa,id_check)
        thv_sa = th_sa * ( 1._r8 + zvir * qv_sa - ql_sa - qi_sa )
        w_sa   = w_cu * ( 1._r8 - xs )                              
      ! May.03.2011. In order to be fully compatible with the mother routine that computes
      !              'xe_min, xe_max', I should set 'xs = 0' for all these cases. This also
      !              removes the distinuity when excess_cu=excess_eg=0. Thus, I removed
      !              below 5 lines and reset xs = 0.
  ! else
  !     xs = 0._r8
  ! endif
  ! Below block is old code before May.03.2011.  
  ! May.16.2011. I restored to the 'old code, since 'xs = 1._r8' is also fully compatible with the
  !              mother subroutine and correct even within this subroutine.
    elseif( excess_cu.le.0._r8 .and. excess_eg.le.0._r8 ) then
        xs = 0._r8
    elseif( excess_cu.ge.0._r8 .and. excess_eg.ge.0._r8 ) then
        xs = 1._r8
    endif

  ! ------------------------------------------------------------------- !
  ! Case 1 : Both cumulus and edge values are unsaturated or saturated. !
  !          Here, we should use '.le.' instead of '.lt.'               !
  !          Only single-segment analysis is necessary.                 !
  ! ------------------------------------------------------------------- !

  ! May.03.2011. In order to save computation time, I re-write below if line using the above newly computed 'xs',
  !              which should produce identical results. 
    if( xs .eq. 0._r8 .or. xs .eq. 1._r8 ) then
  ! if( (excess_cu.le.0._r8 .and. excess_eg.le.0._r8) .or. &
  !     (excess_cu.ge.0._r8 .and. excess_eg.ge.0._r8) ) then

        x0   = 0._r8
        w0   = w_cu
        thv0 = thv_cu

        x1   = 1._r8
        w1   = 0._r8
        thv1 = thv_eg

        xc   = xc_seg_numeric(x0,w0,thv0,x1,w1,thv1,thv_en,buof,gamd,cridis)

        return

    else

  ! ---------------------------------------------------- !
  ! Case 2 : Either cumulus or edge values are saturated !
  !          Anslysis of two segments are necessary.     ! 
  ! ---------------------------------------------------- !

      ! A. Saturated segment or Cumulus-oriented segment

        x0   = 0._r8
        w0   = w_cu
        thv0 = thv_cu

        x1   = xs
        w1   = w_sa
        thv1 = thv_sa

        xc_sat = xc_seg_numeric(x0,w0,thv0,x1,w1,thv1,thv_en,buof,gamd,cridis)

      ! B. Dry segment or edge-oriented segment 

        x0   = xs
        w0   = w_sa
        thv0 = thv_sa

        x1   = 1._r8
        w1   = 0._r8
        thv1 = thv_eg

        xc_dry = xc_seg_numeric(x0,w0,thv0,x1,w1,thv1,thv_en,buof,gamd,cridis)

      ! Final Solution

        xc = xc_sat
        if( abs(xc-xs) .le. 1.e-8_r8 ) xc = xc_dry
        return

    endif

    return
  end subroutine buosorts



  real(r8) function xc_seg(x0,w0,thv0,x1,w1,thv1,thv_en,buof,gamd,cridis)
  ! --------------------------------------------------------------- !
  ! Compute critical mixing fraction, xc for one single segment     !
  ! Parcels with 'x0 < x < xc' are entrained or non-detached, while !
  !         with 'xc < x < x1' are detrained or detached.           !
  ! Done.                                                           !
  ! --------------------------------------------------------------- ! 
    implicit none
    real(r8), intent(in)          :: x0, x1
    real(r8), intent(in)          :: w0, w1
    real(r8), intent(in)          :: thv0, thv1
    real(r8), intent(in)          :: thv_en, buof, gamd, cridis
    real(r8)  wgrd,thvgrd
    real(r8)  az,bz,cz, xz1,xz2
    real(r8)  al,bl,cl, xl1,xl2 
    real(r8)  xn,xp 
    integer   statusz, statusl

  ! Sanity check

    if( x0 .ge. x1 ) then
        call endrun('UNICON : x0 >= x1 in the subroutine xc_seg ')  
    endif

  ! Gradient or slope of 'w' and 'thv' in terms of mixing fraction. 

    wgrd   = (w1-w0)/(x1-x0)
    thvgrd = (thv1-thv0)/(x1-x0)

  ! Quadratic solution integrated upto the 'cridis' [m]
  ! Note that positive 'az' is guaranteed for this case. 
  ! In roots.m, it is guaranteed that 'xz1<xz2'.

    az = wgrd**2
    bz = 2._r8*wgrd*(w0-x0*wgrd)+2._r8*buof*thvgrd*cridis
    cz = (w0-x0*wgrd)**2+buof*cridis*(gamd*cridis-2._r8*(x0*thvgrd+thv_en-thv0))
    if((bz**2-4._r8*az*cz).ge.0._r8) then
        call roots(az,bz,cz,xz1,xz2,statusz)
    else
        xz1 = x1
        xz2 = x1
    endif 

  ! Quadratic solution integrated upto 'Lz(x)'
  ! Numerically, the case of 'al=0.' will never happen.  However, for 
  ! conceptual clarity of qudaratic solutions,  I can impose non-zero
  ! constraint to 'al' before calling 'roots' in future.
  ! Since below will be used only when 'gamd>0', multiplying 'gamd'
  ! to the quadratic inequality equation without sign change is OK. 

    al = gamd*wgrd**2-buof*thvgrd**2
    bl = gamd*2._r8*wgrd*(w0-x0*wgrd)+2._r8*buof*thvgrd*(x0*thvgrd+thv_en-thv0)
    cl = gamd*(w0-x0*wgrd)**2-buof*(x0*thvgrd+thv_en-thv0)**2
    if((bl**2-4._r8*al*cl).ge.0._r8) then
        call roots(al,bl,cl,xl1,xl2,statusl)
    else
        if( al.ge.0._r8 ) then
            xl1 = x1
            xl2 = x1
        else
            xl1 = x0
            xl2 = x0
        endif 
    endif 

  ! Final root finding for each case-by-case. 
  ! Separately treat the cases when 'gamd > 0' and 'gamd <= 0'. 
  ! Also separately consider when 'thv0.lt.thv1' and 'thv0.gt.thv1'.
  ! Note that the case of 'thv0 = thv1' should never happen here. 

    if( gamd .le. 0._r8 ) then

        xc_seg = min(x1,max(x0,min(xz1,xz2)))
        return

    else

        if( thv0 .eq. thv1 ) then

            xc_seg = x1
            return       

        elseif( thv0 .lt. thv1 ) then

            xn = x0 + (thv_en-thv0-gamd*cridis)/thvgrd 
            xp = x0 + (thv_en-thv0)/thvgrd            

            if( xn .lt. x0 ) then                
                if( xp .lt. x0 ) then
                    xc_seg = x1
                    return
                elseif( xp.ge.x0 .and. xp.lt.x1 ) then 
                    xc_seg = min(xp,max(x0,min(xl1,xl2)))
                    if(al.lt.0._r8) then
                       if(xl1.gt.x0) then
                          xc_seg = x0
                       else
                          xc_seg = min(xp,max(x0,xl2))
                       endif
                    endif
                    if(xc_seg.eq.xp) xc_seg = x1
                    return
                elseif( xp.ge.x1 ) then 
                    xc_seg = min(x1,max(x0,min(xl1,xl2)))
                    if(al.lt.0._r8) then
                       if(xl1.gt.x0) then
                          xc_seg = x0
                       else
                          xc_seg = min(x1,max(x0,xl2))
                       endif
                    endif
                    return
                endif
            elseif( xn.ge.x0 .and. xn.lt.x1 ) then                
                if( xp .lt. x1 ) then
                    xc_seg = min(xn,max(x0,min(xz1,xz2)))
                    if(xc_seg.eq.xn) then
                       xc_seg = min(xp,max(xn,min(xl1,xl2)))
                       if(al.lt.0._r8) then
                          if(xl1.gt.xn) then
                             xc_seg = xn
                          else
                             xc_seg = min(xp,max(xn,xl2))
                          endif
                       endif
                    endif
                    if(xc_seg.eq.xp) xc_seg = x1
                    return
                elseif( xp .ge. x1 ) then
                    xc_seg = min(xn,max(x0,min(xz1,xz2)))
                    if(xc_seg.eq.xn) then
                       xc_seg = min(x1,max(xn,min(xl1,xl2)))
                       if(al.lt.0._r8) then
                          if(xl1.gt.xn) then
                             xc_seg = xn
                          else
                             xc_seg = min(x1,max(xn,xl2))
                          endif
                       endif
                    endif
                    return
                endif
            elseif( xn .ge. x1 ) then                
                xc_seg = min(x1,max(x0,min(xz1,xz2)))
                return
            endif

        elseif( thv0 .gt. thv1 ) then

            xn = x0 + (thv_en-thv0-gamd*cridis)/thvgrd 
            xp = x0 + (thv_en-thv0)/thvgrd            

            if( xp .lt. x0 ) then                
                if( xn .lt. x0 ) then
                    xc_seg = min(x1,max(x0,min(xz1,xz2)))
                    return
                elseif( xn.ge.x0 .and. xn.lt.x1 ) then 
                    xc_seg = min(xn,max(x0,min(xl1,xl2)))
                    if(al.lt.0._r8) then
                       if(xl1.gt.x0) then
                          xc_seg = x0
                       else
                          xc_seg = min(xn,max(x0,xl2))
                       endif
                    endif
                    if(xc_seg.eq.xn) xc_seg = min(x1,max(xn,min(xz1,xz2)))
                    return
                elseif( xn.ge.x1 ) then 
                    xc_seg = min(x1,max(x0,min(xl1,xl2)))
                    if(al.lt.0._r8) then
                       if(xl1.gt.x0) then
                          xc_seg = x0
                       else
                          xc_seg = min(x1,max(x0,xl2))
                       endif
                    endif
                    return
                endif
            elseif( xp.ge.x0 .and. xp.lt.x1 ) then                
                if( xn.lt.x1 ) then 
                    xc_seg = min(xn,max(xp,min(xl1,xl2)))
                    if(al.lt.0._r8) then
                       if(xl1.gt.xp) then
                          xc_seg = xp
                       else
                          xc_seg = min(xn,max(xp,xl2))
                       endif
                    endif
                    if(xc_seg.eq.xn) xc_seg = min(x1,max(xn,min(xz1,xz2)))
                    return
                elseif( xn.ge.x1 ) then 
                    xc_seg = min(x1,max(xp,min(xl1,xl2)))
                    if(al.lt.0._r8) then
                       if(xl1.gt.xp) then
                          xc_seg = xp
                       else
                          xc_seg = min(x1,max(xp,xl2))
                       endif
                    endif
                    return
                endif
            elseif( xp.ge.x1 ) then                
                xc_seg = x1
                return
            endif

        endif

    endif

  end function xc_seg



  real(r8) function xc_seg_numeric(x0,w0,thv0,x1,w1,thv1,thv_en,buof,gamd,cridis)
  ! --------------------------------------------------------------- !
  ! Compute critical mixing fraction, xc for one single segment     !
  ! Parcels with 'x0 < x < xc' are entrained or non-detached, while !
  !         with 'xc < x < x1' are detrained or detached.           !
  ! This is same as 'xc_seg' but find solution from direct numerical!
  ! computation not by tracking quadraic inequality eqation.        !
  ! I checked that this numerical solution produced almost identical!
  ! results to the analytical solution 'xc_seg' without any bug.    !
  ! --------------------------------------------------------------- ! 
    implicit none
    real(r8), intent(in)          :: x0, x1
    real(r8), intent(in)          :: w0, w1
    real(r8), intent(in)          :: thv0, thv1
    real(r8), intent(in)          :: thv_en, buof, gamd, cridis
    real(r8)  wgrd,thvgrd
    real(r8)  az,bz,cz
    real(r8)  al,bl,cl 
    real(r8)  xn,xp,x2 
    logical   succes

  ! Sanity check

    if( x0 .ge. x1 ) then
        call endrun('UNICON : x0 >= x1 in the subroutine xc_seg_numeric ')  
    endif

  ! Gradient or slope of 'w' and 'thv' in terms of mixing fraction. 

    wgrd   = (w1-w0)/(x1-x0)
    thvgrd = (thv1-thv0)/(x1-x0)

  ! ---------------------------------------------------- ! 
  ! Quadratic solution integrated upto the 'cridis' [m]  !
  ! Note that positive 'az' is guaranteed for this case. !
  ! ---------------------------------------------------- ! 

    az = wgrd**2
    bz = 2._r8*wgrd*(w0-x0*wgrd)+2._r8*buof*thvgrd*cridis
    cz = (w0-x0*wgrd)**2+buof*cridis*(gamd*cridis-2._r8*(x0*thvgrd+thv_en-thv0))

  ! --------------------------------------------------------------- !
  ! Quadratic solution integrated upto 'Lz(x)'                      ! 
  ! Be careful the case of gamd < 0: since I multiplied gamd to the !
  ! original quadratic equation, I should find the solution of f(x) !
  ! to be negative if gamd < 0. However, since (az,bz,cz) are       !
  ! always used when gamd < 0, I don't need to be careful at all.   !
  ! Note that even the case of negative 'al' is generally handled.  !
  ! --------------------------------------------------------------- !

    al = gamd*wgrd**2-buof*thvgrd**2
    bl = gamd*2._r8*wgrd*(w0-x0*wgrd)+2._r8*buof*thvgrd*(x0*thvgrd+thv_en-thv0)
    cl = gamd*(w0-x0*wgrd)**2-buof*(x0*thvgrd+thv_en-thv0)**2

  ! --------------------------------------------------------------- !
  ! Final root finding for each case-by-case.                       !
  ! Separately treat the cases when 'gamd > 0' and 'gamd <= 0'.     !
  ! Also separately consider when 'thv0.lt.thv1' and 'thv0.gt.thv1' !
  ! and 'thv0 = thv1', in order to prevent 'xn, xp -> infinite'     !
  ! --------------------------------------------------------------- !

    if( gamd .le. 0._r8 ) then
        if( quad(az,bz,cz,x0) .le. 0._r8 ) then
            xc_seg_numeric = x0
            return 
        else
            call zbrac(az,bz,cz,x0,x1,x2,succes)
            if( .not. succes ) then
                xc_seg_numeric = x1
                return
            else
                xc_seg_numeric = zbrent(az,bz,cz,x0,x2,1.e-2_r8)
                return
            endif
        endif
    else
        if( thv0 .eq. thv1 ) then
            xc_seg_numeric = x1
            return
        elseif( thv0 .lt. thv1 ) then
            xn = x0 + (thv_en-thv0-gamd*cridis)/thvgrd 
            xp = x0 + (thv_en-thv0)/thvgrd            
            if( xn .lt. x0 ) then                
                if( xp .lt. x0 ) then
                    xc_seg_numeric = x1
                    return
                elseif( xp.ge.x0 .and. xp.lt.x1 ) then 
                    if( quad(al,bl,cl,x0) .le. 0._r8 ) then
                        xc_seg_numeric = x0
                        return 
                    else
                        call zbrac(al,bl,cl,x0,xp,x2,succes)
                        if( .not. succes ) then
                            xc_seg_numeric = x1
                            return
                        else
                            xc_seg_numeric = zbrent(al,bl,cl,x0,x2,1.e-2_r8)
                            return
                        endif
                    endif
                elseif( xp.ge.x1 ) then 
                    if( quad(al,bl,cl,x0) .le. 0._r8 ) then
                        xc_seg_numeric = x0
                        return 
                    else
                        call zbrac(al,bl,cl,x0,x1,x2,succes)
                        if( .not. succes ) then
                            xc_seg_numeric = x1
                            return
                        else
                            xc_seg_numeric = zbrent(al,bl,cl,x0,x2,1.e-2_r8)
                            return
                        endif
                    endif
                endif
            elseif( xn.ge.x0 .and. xn.lt.x1 ) then                
                if( xp .lt. x1 ) then
                    if( quad(az,bz,cz,x0) .le. 0._r8 ) then
                        xc_seg_numeric = x0
                        return 
                    else
                        call zbrac(az,bz,cz,x0,xn,x2,succes)
                        if( .not. succes ) then
                            call zbrac(al,bl,cl,xn,xp,x2,succes)
                            if( .not. succes ) then
                                xc_seg_numeric = x1
                                return
                            else
                                xc_seg_numeric = zbrent(al,bl,cl,xn,x2,1.e-2_r8)
                                return
                            endif
                        else
                            xc_seg_numeric = zbrent(az,bz,cz,x0,x2,1.e-2_r8)
                            return
                        endif
                    endif
                elseif( xp .ge. x1 ) then
                    if( quad(az,bz,cz,x0) .le. 0._r8 ) then
                        xc_seg_numeric = x0
                        return 
                    else
                        call zbrac(az,bz,cz,x0,xn,x2,succes)
                        if( .not. succes ) then
                            call zbrac(al,bl,cl,xn,x1,x2,succes)
                            if( .not. succes ) then
                                xc_seg_numeric = x1
                                return
                            else
                                xc_seg_numeric = zbrent(al,bl,cl,xn,x2,1.e-2_r8)
                                return
                            endif
                        else
                            xc_seg_numeric = zbrent(az,bz,cz,x0,x2,1.e-2_r8)
                            return
                        endif
                    endif
                endif
            elseif( xn .ge. x1 ) then                
                if( quad(az,bz,cz,x0) .le. 0._r8 ) then
                    xc_seg_numeric = x0
                    return 
                else
                    call zbrac(az,bz,cz,x0,x1,x2,succes)
                    if( .not. succes ) then
                        xc_seg_numeric = x1
                        return
                    else
                        xc_seg_numeric = zbrent(az,bz,cz,x0,x2,1.e-2_r8)
                        return
                    endif
                endif
            endif
        elseif( thv0 .gt. thv1 ) then
            xn = x0 + (thv_en-thv0-gamd*cridis)/thvgrd 
            xp = x0 + (thv_en-thv0)/thvgrd            
            if( xp .lt. x0 ) then                
                if( xn .lt. x0 ) then
                    if( quad(az,bz,cz,x0) .le. 0._r8 ) then
                        xc_seg_numeric = x0
                        return 
                    else
                        call zbrac(az,bz,cz,x0,x1,x2,succes)
                        if( .not. succes ) then
                            xc_seg_numeric = x1
                            return
                        else
                            xc_seg_numeric = zbrent(az,bz,cz,x0,x2,1.e-2_r8)
                            return
                        endif
                    endif
                elseif( xn.ge.x0 .and. xn.lt.x1 ) then 
                    if( quad(al,bl,cl,x0) .le. 0._r8 ) then
                        xc_seg_numeric = x0
                        return 
                    else
                        call zbrac(al,bl,cl,x0,xn,x2,succes)
                        if( .not. succes ) then
                            call zbrac(az,bz,cz,xn,x1,x2,succes)
                            if( .not. succes ) then
                                xc_seg_numeric = x1
                                return
                            else
                                xc_seg_numeric = zbrent(az,bz,cz,xn,x2,1.e-2_r8)
                                return
                            endif
                        else
                            xc_seg_numeric = zbrent(al,bl,cl,x0,x2,1.e-2_r8)
                            return
                        endif
                    endif
                elseif( xn.ge.x1 ) then 
                    if( quad(al,bl,cl,x0) .le. 0._r8 ) then
                        xc_seg_numeric = x0
                        return 
                    else
                        call zbrac(al,bl,cl,x0,x1,x2,succes)
                        if( .not. succes ) then
                            xc_seg_numeric = x1
                            return
                        else
                            xc_seg_numeric = zbrent(al,bl,cl,x0,x2,1.e-2_r8)
                            return
                        endif
                    endif
                endif
            elseif( xp.ge.x0 .and. xp.lt.x1 ) then                
                if( xn.lt.x1 ) then 
                    if( quad(al,bl,cl,xp) .le. 0._r8 ) then
                        xc_seg_numeric = xp
                        return
                    endif
                    call zbrac(al,bl,cl,xp,xn,x2,succes)
                    if( .not. succes ) then
                        call zbrac(az,bz,cz,xn,x1,x2,succes)
                        if( .not. succes ) then
                            xc_seg_numeric = x1
                            return
                        else
                            xc_seg_numeric = zbrent(az,bz,cz,xn,x2,1.e-2_r8)
                            return
                        endif
                    else
                        xc_seg_numeric = zbrent(al,bl,cl,xp,x2,1.e-2_r8)
                        return
                    endif
                elseif( xn.ge.x1 ) then 
                    if( quad(al,bl,cl,xp) .le. 0._r8 ) then
                        xc_seg_numeric = xp
                        return
                    endif
                    call zbrac(al,bl,cl,xp,x1,x2,succes)
                    if( .not. succes ) then
                        xc_seg_numeric = x1
                        return
                    else
                        xc_seg_numeric = zbrent(al,bl,cl,xp,x2,1.e-2_r8)
                        return
                    endif
                endif
            elseif( xp.ge.x1 ) then                
                xc_seg_numeric = x1
                return
            endif
        endif
    endif
    return

  end function xc_seg_numeric



  subroutine zbrac(a1,b1,c1,x0,x1,x2,succes)
  ! -------------------------------------------------- !
  ! Find 'x2' where function 'quad' changes signs from !
  ! 'x0' within (x0,x1). If such 'x2' does not exist,  !
  ! set 'succes = .false.                              !
  ! -------------------------------------------------- !
    implicit none
    real(r8), intent(in)    :: a1, b1, c1, x0, x1
    real(r8), intent(out)   :: x2
    logical,  intent(out)   :: succes
    integer,  parameter     :: nx = 10
    integer  :: j
    real(r8) :: f1, f2, dx

    dx = (x1-x0)/nx 
    x2 = x0 + dx

    f1 = quad(a1,b1,c1,x0)
    f2 = quad(a1,b1,c1,x2)
    succes = .true.
    do j = 1, nx
       if ((f1 > 0._r8 .and. f2 < 0._r8) .or. (f1 < 0._r8 .and. f2 > 0._r8)) return
       x2 = x2 + dx
       f2 = quad(a1,b1,c1,x2)
    end do
    succes = .false.

  end subroutine zbrac



  real(r8) function zbrent(a1,b1,c1,x1,x2,tol)
  ! ---------------------------------------------- !
  ! Find root within (x1,x2) with accuracy tol for !
  ! quadratic function 'quad' with coefficients    !
  ! (a1,b1,c1)                                     !
  ! ---------------------------------------------- !
    implicit none
    real(r8), intent(in) :: a1, b1, c1, x1, x2, tol
    integer,  parameter  :: itmax = 100
    real(r8), parameter  :: eps = epsilon(x1)
    integer :: iter
    real(r8) :: a,b,c,d,e,fa,fb,fc,p,q,r,s,tol1,xm

    a = x1
    b = x2
    fa = quad(a1,b1,c1,a)
    fb = quad(a1,b1,c1,b)
    if ( (fa > 0._r8 .and. fb > 0._r8) .or. (fa < 0._r8 .and. fb < 0._r8) ) then
          write(6,*) a, b, fa, fb
          call endrun('UNICON : Error in zbrent : root must be bracketed')  
    endif
    c = b
    fc = fb
    do iter = 1, itmax
       if ((fb > 0._r8 .and. fc > 0._r8) .or. (fb < 0._r8 .and. fc < 0._r8)) then
            c = a
            fc = fa
            d = b-a
            e = d
       end if
       if ( abs(fc) < abs(fb) ) then
            a = b
            b = c
            c = a
            fa = fb
            fb = fc
            fc = fa
       end if
       tol1 = 2.0_r8*eps*abs(b)+0.5_r8*tol
       xm = 0.5_r8*(c-b)
       if ( abs(xm) <= tol1 .or. fb == 0.0) then
            zbrent = b
            return
       end if
       if ( abs(e) >= tol1 .and. abs(fa) > abs(fb) ) then
            s = fb/fa
            if (a == c) then
                p = 2.0_r8*xm*s
                q = 1.0_r8-s
            else
                q = fa/fc
                r = fb/fc
                p = s*(2.0_r8*xm*q*(q-r)-(b-a)*(r-1.0_r8))
                q = (q-1.0_r8)*(r-1.0_r8)*(s-1.0_r8)
            end if
                if (p > 0.0) q=-q
                p = abs(p)
                if ( 2.0_r8*p  <  min(3.0_r8*xm*q-abs(tol1*q),abs(e*q))) then
                     e = d
                     d = p/q
               else
                     d = xm
                     e = d
               end if
       else
               d = xm
               e = d
       end if
       a = b
       fa = fb
       b = b + merge(d,sign(tol1,xm), abs(d) > tol1 )
       fb = quad(a1,b1,c1,b)
    end do
    write(6,*) 'Warning in zbrent in unicon.F90 : exceeded maximum iterations'
    zbrent = b

  end function zbrent



  subroutine positive_moisture( cp, xlv, xls, pcols, ncol, mkx, dt, qvmin, qlmin, qimin, dp, qv, ql, qi, t, s, qvten, &
                                qlten, qiten, sten )
  ! ------------------------------------------------------------------------------- !
  ! Author : Sungsu Park. AMP/CGD/NCAR.                                             !
  ! If any 'ql < qlmin, qi < qimin, qv < qvmin' are developed in any layer,         !
  ! force them to be larger than minimum value by (1) condensating water vapor      !
  ! into liquid or ice, and (2) by transporting water vapor from the very lower     !
  ! layer. '2._r8' is multiplied to the minimum values for safety.                  !
  ! Update final state variables and tendencies associated with this correction.    !
  ! If any condensation happens, update (s,t) too.                                  !
  ! Note that (qv,ql,qi,t,s) are final state variables after applying corresponding !
  ! input tendencies.                                                               !
  ! Be careful the order of k : '1': near-surface layer, 'mkx' : top layer          ! 
  ! May.03.2011. Additional refinement is added in the lowest model layer for       !
  !              complete treatment.                                                !
  ! ------------------------------------------------------------------------------- !
    implicit none
    integer,  intent(in)     :: pcols, ncol, mkx
    real(r8), intent(in)     :: cp, xlv, xls
    real(r8), intent(in)     :: dt, qvmin, qlmin, qimin
    real(r8), intent(in)     :: dp(pcols,mkx)
    real(r8), intent(inout)  :: qv(pcols,mkx), ql(pcols,mkx), qi(pcols,mkx), t(pcols,mkx), s(pcols,mkx)
    real(r8), intent(inout)  :: qvten(pcols,mkx), qlten(pcols,mkx), qiten(pcols,mkx), sten(pcols,mkx)
    integer   i, k
    real(r8)  dql, dqi, dqv, sum, aa, dum 

    do i = 1, ncol
    do k = mkx, 1, -1    ! From the top to the 1st (lowest) layer from the surface
       dql        = max(0._r8,1._r8*qlmin-ql(i,k))
       dqi        = max(0._r8,1._r8*qimin-qi(i,k))
       qlten(i,k) = qlten(i,k) +  dql/dt
       qiten(i,k) = qiten(i,k) +  dqi/dt
       qvten(i,k) = qvten(i,k) - (dql+dqi)/dt
       sten(i,k)  = sten(i,k)  + xlv * (dql/dt) + xls * (dqi/dt)
       ql(i,k)    = ql(i,k) +  dql
       qi(i,k)    = qi(i,k) +  dqi
       qv(i,k)    = qv(i,k) -  dql - dqi
       s(i,k)     = s(i,k)  +  xlv * dql + xls * dqi
       t(i,k)     = t(i,k)  + (xlv * dql + xls * dqi)/cp
       dqv        = max(0._r8,1._r8*qvmin-qv(i,k))
       qvten(i,k) = qvten(i,k) + dqv/dt
       qv(i,k)    = qv(i,k)    + dqv
       if( k .ne. 1 ) then 
           qv(i,k-1)    = qv(i,k-1)    - dqv*dp(i,k)/dp(i,k-1)
           qvten(i,k-1) = qvten(i,k-1) - dqv*dp(i,k)/dp(i,k-1)/dt
       endif
       qv(i,k) = max(qv(i,k),qvmin)
       ql(i,k) = max(ql(i,k),qlmin)
       qi(i,k) = max(qi(i,k),qimin)
    end do
    ! May.03.2011. Below block is additionally added for completeness.
    ! Extra moisture used to satisfy 'qv(i,1)=qvmin' is proportionally
    ! extracted from all the layers that has 'qv > 2*qvmin'. This fully
    ! preserves column moisture.
    if( dqv .gt. 0._r8 ) then
        sum = 0._r8
        do k = 1, mkx
           if( qv(i,k) .gt. 2._r8*qvmin ) sum = sum + qv(i,k)*dp(i,k)
        enddo
        aa = dqv*dp(i,1)/max(1.e-20_r8,sum)
        if( aa .lt. 0.5_r8 ) then
            do k = 1, mkx
               if( qv(i,k) .gt. 2._r8*qvmin ) then
                   dum        = aa*qv(i,k)
                   qv(i,k)    = qv(i,k) - dum
                   qvten(i,k) = qvten(i,k) - dum/dt
               endif
            enddo
        else
            write(6,*) 'Full positive_moisture is impossible in UNICON'
        endif
    endif
    end do
    return

  end subroutine positive_moisture


  subroutine positive_tracer( pcols, ncol, mkx, dt, trmin, dp, tr, trten )
  ! ------------------------------------------------------------------------------- !
  ! If any 'tr < trmin' are developed in any layer, force them to be larger than    !
  ! minimum value by transporting water vapor from the very lower layer.            !
  ! Update final state variables and tendencies associated with this correction.    !
  ! Note that 'tr' is the final state variables after applying corresponding        !
  ! input tendencies.                                                               !
  ! Be careful the order of k : '1': near-surface layer, 'mkx' : top layer          !
  ! May.03.2011. Additional refinement is added in the lowest model layer for       !
  !              complete treatment.                                                ! 
  ! ------------------------------------------------------------------------------- !
    implicit none
    integer,  intent(in)     :: pcols, ncol, mkx
    real(r8), intent(in)     :: dt, trmin
    real(r8), intent(in)     :: dp(pcols,mkx)
    real(r8), intent(inout)  :: tr(pcols,mkx)
    real(r8), intent(inout)  :: trten(pcols,mkx)
    integer   i, k
    real(r8)  dtr, sum, aa, dum 

    do i = 1, ncol
    do k = mkx, 1, -1    ! From the top to the 1st (lowest) layer from the surface
       dtr = max(0._r8,1._r8*trmin-tr(i,k))
       trten(i,k) = trten(i,k) + dtr/dt
       tr(i,k)    = tr(i,k)    + dtr
       if( k .ne. 1 ) then 
           tr(i,k-1)    = tr(i,k-1)    - dtr*dp(i,k)/dp(i,k-1)
           trten(i,k-1) = trten(i,k-1) - dtr*dp(i,k)/dp(i,k-1)/dt
       endif
       tr(i,k) = max(tr(i,k),trmin)
    end do
    ! May.03.2011. Below block is additionally added for completeness.
    ! Extra moisture used to satisfy 'qv(i,1)=qvmin' is proportionally
    ! extracted from all the layers that has 'qv > 2*qvmin'. This fully
    ! preserves column moisture.
    if( dtr .gt. 0._r8 ) then
        sum = 0._r8
        do k = 1, mkx
           if( tr(i,k) .gt. 2._r8*trmin ) sum = sum + tr(i,k)*dp(i,k)
        enddo
        aa = dtr*dp(i,1)/max(1.e-20_r8,sum)
        if( aa .lt. 0.5_r8 ) then
            do k = 1, mkx
               if( tr(i,k) .gt. 2._r8*trmin ) then
                   dum        = aa*tr(i,k)
                   tr(i,k)    = tr(i,k) - dum
                   trten(i,k) = trten(i,k) - dum/dt
               endif
            enddo
        else
          ! write(6,*) 'Full positive_tracer is impossible in UNICON'
        endif
    endif
    end do
    return

  end subroutine positive_tracer



  subroutine findsp_single ( q, t, p, tsp, qsp, i_in, k_in, lchnk )

     ! Wrapper for the findsp subroutine in wv_saturation.

     integer , intent(in) :: lchnk     
     integer , intent(in) :: i_in, k_in      
     real(r8), intent(in) :: q      ! Water vapor [kg/kg]
     real(r8), intent(in) :: t      ! Temperature [K]
     real(r8), intent(in) :: p      ! Pressure    [Pa]

     real(r8), intent(out) :: tsp   ! Saturation temp [K]
     real(r8), intent(out) :: qsp   ! Saturation mixing ratio [kg/kg]

     logical :: use_ice = .true.
     integer :: status
     !------------------------------------------------------------------------------

     call findsp(q, t, p, use_ice, tsp, qsp, status)

     ! Currently, only 2 and 8 seem to be treated as fatal errors.
     if (status == 2) then
        write(iulog,*) ' findsp not converging at i,k,lchnk = ', i_in, k_in, lchnk
        write(iulog,*) ' t, q, p ', t, q, p
        write(iulog,*) ' tsp, qsp ', tsp, qsp
        call endrun ('UNICON::FINDSP -- not converging')
     else if (status == 8) then
        write(iulog,*) ' the enthalpy is not conserved at i,k,lchnk = ', i_in, k_in, lchnk
        write(iulog,*) ' t, q, p ', t, q, p
        write(iulog,*) ' tsp, qsp ', tsp, qsp
        call endrun ('UNICON::FINDSP -- enthalpy is not conserved')
     endif
      
  end subroutine findsp_single

  ! ------------------------ !
  !                          ! 
  ! End of subroutine blocks !
  !                          !
  ! ------------------------ !

  end module unicon
